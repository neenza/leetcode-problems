{
  "title": "Longest ZigZag Path in a Binary Tree",
  "problem_id": "1474",
  "frontend_id": "1372",
  "difficulty": "Medium",
  "problem_slug": "longest-zigzag-path-in-a-binary-tree",
  "topics": [
    "Dynamic Programming",
    "Tree",
    "Depth-First Search",
    "Binary Tree"
  ],
  "description": "You are given the root of a binary tree.\nA ZigZag path for a binary tree is defined as follow:\nZigzag length is defined as the number of nodes visited - 1. (A single node has a length of 0).\nReturn the longest ZigZag path contained in that tree.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: root = [1,null,1,1,1,null,null,1,1,null,1,null,null,null,1]\nOutput: 3\nExplanation: Longest ZigZag path in blue nodes (right -> left -> right).",
      "images": [
        "https://assets.leetcode.com/uploads/2020/01/22/sample_1_1702.png"
      ]
    },
    {
      "example_num": 2,
      "example_text": "Input: root = [1,1,1,null,1,null,null,1,1,null,1]\nOutput: 4\nExplanation: Longest ZigZag path in blue nodes (left -> right -> left -> right).",
      "images": [
        "https://assets.leetcode.com/uploads/2020/01/22/sample_2_1702.png"
      ]
    },
    {
      "example_num": 3,
      "example_text": "Input: root = [1]\nOutput: 0",
      "images": [
        "https://assets.leetcode.com/uploads/2020/01/22/sample_2_1702.png"
      ]
    }
  ],
  "constraints": [
    "The number of nodes in the tree is in the range [1, 5 * 104].",
    "1 <= Node.val <= 100"
  ],
  "follow_ups": [],
  "hints": [
    "Create this function maxZigZag(node, direction) maximum zigzag given a node and direction (right or left)."
  ],
  "code_snippets": {
    "cpp": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    int longestZigZag(TreeNode* root) {\n        \n    }\n};",
    "java": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public int longestZigZag(TreeNode root) {\n        \n    }\n}",
    "python": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def longestZigZag(self, root):\n        \"\"\"\n        :type root: Optional[TreeNode]\n        :rtype: int\n        \"\"\"\n        ",
    "python3": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def longestZigZag(self, root: Optional[TreeNode]) -> int:\n        ",
    "c": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     struct TreeNode *left;\n *     struct TreeNode *right;\n * };\n */\nint longestZigZag(struct TreeNode* root) {\n    \n}",
    "csharp": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public int val;\n *     public TreeNode left;\n *     public TreeNode right;\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\npublic class Solution {\n    public int LongestZigZag(TreeNode root) {\n        \n    }\n}",
    "javascript": "/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nvar longestZigZag = function(root) {\n    \n};",
    "typescript": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nfunction longestZigZag(root: TreeNode | null): number {\n    \n};",
    "php": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     public $val = null;\n *     public $left = null;\n *     public $right = null;\n *     function __construct($val = 0, $left = null, $right = null) {\n *         $this->val = $val;\n *         $this->left = $left;\n *         $this->right = $right;\n *     }\n * }\n */\nclass Solution {\n\n    /**\n     * @param TreeNode $root\n     * @return Integer\n     */\n    function longestZigZag($root) {\n        \n    }\n}",
    "swift": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public var val: Int\n *     public var left: TreeNode?\n *     public var right: TreeNode?\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\n *         self.val = val\n *         self.left = left\n *         self.right = right\n *     }\n * }\n */\nclass Solution {\n    func longestZigZag(_ root: TreeNode?) -> Int {\n        \n    }\n}",
    "kotlin": "/**\n * Example:\n * var ti = TreeNode(5)\n * var v = ti.`val`\n * Definition for a binary tree node.\n * class TreeNode(var `val`: Int) {\n *     var left: TreeNode? = null\n *     var right: TreeNode? = null\n * }\n */\nclass Solution {\n    fun longestZigZag(root: TreeNode?): Int {\n        \n    }\n}",
    "dart": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *   int val;\n *   TreeNode? left;\n *   TreeNode? right;\n *   TreeNode([this.val = 0, this.left, this.right]);\n * }\n */\nclass Solution {\n  int longestZigZag(TreeNode? root) {\n    \n  }\n}",
    "golang": "/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\nfunc longestZigZag(root *TreeNode) int {\n    \n}",
    "ruby": "# Definition for a binary tree node.\n# class TreeNode\n#     attr_accessor :val, :left, :right\n#     def initialize(val = 0, left = nil, right = nil)\n#         @val = val\n#         @left = left\n#         @right = right\n#     end\n# end\n# @param {TreeNode} root\n# @return {Integer}\ndef longest_zig_zag(root)\n    \nend",
    "scala": "/**\n * Definition for a binary tree node.\n * class TreeNode(_value: Int = 0, _left: TreeNode = null, _right: TreeNode = null) {\n *   var value: Int = _value\n *   var left: TreeNode = _left\n *   var right: TreeNode = _right\n * }\n */\nobject Solution {\n    def longestZigZag(root: TreeNode): Int = {\n        \n    }\n}",
    "rust": "// Definition for a binary tree node.\n// #[derive(Debug, PartialEq, Eq)]\n// pub struct TreeNode {\n//   pub val: i32,\n//   pub left: Option<Rc<RefCell<TreeNode>>>,\n//   pub right: Option<Rc<RefCell<TreeNode>>>,\n// }\n// \n// impl TreeNode {\n//   #[inline]\n//   pub fn new(val: i32) -> Self {\n//     TreeNode {\n//       val,\n//       left: None,\n//       right: None\n//     }\n//   }\n// }\nuse std::rc::Rc;\nuse std::cell::RefCell;\nimpl Solution {\n    pub fn longest_zig_zag(root: Option<Rc<RefCell<TreeNode>>>) -> i32 {\n        \n    }\n}",
    "racket": "; Definition for a binary tree node.\n#|\n\n; val : integer?\n; left : (or/c tree-node? #f)\n; right : (or/c tree-node? #f)\n(struct tree-node\n  (val left right) #:mutable #:transparent)\n\n; constructor\n(define (make-tree-node [val 0])\n  (tree-node val #f #f))\n\n|#\n\n(define/contract (longest-zig-zag root)\n  (-> (or/c tree-node? #f) exact-integer?)\n  )",
    "erlang": "%% Definition for a binary tree node.\n%%\n%% -record(tree_node, {val = 0 :: integer(),\n%%                     left = null  :: 'null' | #tree_node{},\n%%                     right = null :: 'null' | #tree_node{}}).\n\n-spec longest_zig_zag(Root :: #tree_node{} | null) -> integer().\nlongest_zig_zag(Root) ->\n  .",
    "elixir": "# Definition for a binary tree node.\n#\n# defmodule TreeNode do\n#   @type t :: %__MODULE__{\n#           val: integer,\n#           left: TreeNode.t() | nil,\n#           right: TreeNode.t() | nil\n#         }\n#   defstruct val: 0, left: nil, right: nil\n# end\n\ndefmodule Solution do\n  @spec longest_zig_zag(root :: TreeNode.t | nil) :: integer\n  def longest_zig_zag(root) do\n    \n  end\nend"
  },
  "solution": "[TOC]\n\n## Solution\n\n---\n\n### Overview\n\nWe are given the `root` node of a binary tree.\n\nOur task is to find the longest zigzag path contained in the tree.\n\n---\n\n### Approach: Depth First Search\n\n#### Intuition\n\nWe can see that there are only two options available from each parent node. We either go to its left or right child (if they exist).\n\nLet us observe some situations in which we move from a parent node to its children.\n\nConsider a parent node `p`, which itself is a left child. If `p` has a left child, `l`, we cannot combine the edges going into `p` and `l`, because they have the same direction and do not form a zigzag path. We can only begin a new zigzag path of length `1` by including the edge between `p` and `l`.\n\nIf `p` has a right child, `r`, we can include the edges going into `p` and `r` together because their directions are opposite and form a zigzag path. If we know the length of the zigzag path until node `p`, including `r` increases the length of the path by `1`.\n\nNow assume, that node `p` itself is a right child. If it has a left child `l`, we can combine the edges going into `p` and `l`. The length of the zigzag path until `l` is equal to the length of the zigzag path until `p` plus `1`. If `p` has a right child, `r`, we must start over with only the edge between `p` and `r` forming a zigzag path of length `1`.\n\nThis provides us with a solution to the problem. All we have to do now is keep track of which way we should go to continue forming a zigzag path. Depending on the current direction, we either include the edge of the child in the zigzag path that includes the edge going into the parent node, or we start a new zigzag path with the edge going into the child if the current direction does not match the direction of the child node.\n\nWe can use a graph traversal algorithm like depth-first search (DFS) to traverse in the tree. In DFS, we use a recursive function to explore nodes as far as possible along each branch. Upon reaching the end of a branch, we backtrack to the previous node and continue exploring the next branches.\n\n![img](../Figures/1372/1372-1.png)\n\nIf you are new to Depth First Search, please see our [Leetcode Explore Card](https://leetcode.com/explore/featured/card/graph/619/depth-first-search-in-graph/3882/) for more information on it!\n\nTo store the longest zigzag path found thus far, we define an answer variable `pathLength = 0`. We implement a `dfs` method that accepts a `TreeNode node`, a boolean `goLeft` to indicate whether we should go left for the continuation of the zigzag path, and `steps` which stores the length of the zigzag path so far.\n\nIt's worth noting that we can substitute any other indication for `goLeft`. We can use whether the parent node is a left or right child, or we can choose whether to continue the zigzag path to the right (similar to left).\n\nIn the `dfs` method, we first determine whether `node` is `null` or not. If `node` is `null`, we exit the method. If it is a valid node, we update our answer variable `pathLength = max(pathLength, steps)`.\n\nIf `goLeft` is `true`, the zigzag path will continue to the left. We can't go left in the next step to continue this zigzag path because we're already going left in this step. As a result, we call `dfs(node.left, false, steps + 1)`. We passed `steps + 1` because we kept going in a zigzag pattern.\n\nIt should be noted that if the left does not exit, this call will be returned while we check if `node` is `null` at the beginning. After the `null` node check, we update `pathLength`, so it should only update `pathLength` for valid nodes.\n\nWe use `dfs(node.right, true, 1)` for the right child. Because we must visit the left child the next time, we passed `true` for `goLeft`. We pass `1` for`steps` to begin a new zigzag path including only the parent to the right child edge as it cannot be merged with ongoing path.\n\nIf `goLeft` is set to `false`, the zigzag path will continue to the right. We use `dfs(node.left, false, 1)` for the left child because we need to start a new zigzag path from the parent to the left child edge and we can't take left again in the next step. For the right child, we call `dfs(node.right, true, steps + 1)` because we keep continuing in the zigzag pattern.\n\n#### Algorithm\n\n- Initialize a class-level variable `pathLength` to `0` to keep track of the longest ZigZag path found.\n\n- Define the `dfs` function to traverse the tree:\n  - If `node` is null, return immediately (base case).\n  - Update `pathLength` to be the maximum of its current value and `steps` (tracks the current ZigZag path length).\n  - If `goLeft` is `true` (current direction is left):\n    - Call `dfs` on the left child with `goLeft` set to `false` and `steps + 1` (continuing the ZigZag path).\n    - Call `dfs` on the right child with `goLeft` set to `true` and `steps` reset to `1` (starting a new path in the opposite direction).\n  - If `goLeft` is `false` (current direction is right):\n    - Call `dfs` on the left child with `goLeft` set to `false` and `steps` reset to `1` (starting a new path in the opposite direction).\n    - Call `dfs` on the right child with `goLeft` set to `true` and `steps + 1` (continuing the ZigZag path).\n\n- Define the `longestZigZag` function:\n  - Call `dfs` starting at the `root` with `goLeft` set to `true` and `steps` set to `0`.\n  - Return the value of `pathLength` as the longest ZigZag path in the tree.\n\n#### Implementation#### Complexity Analysis\n\nHere, $n$ is the number of nodes in the given binary tree.\n\n* Time complexity: $O(n)$\n\n    - Using the `dfs` function, we recursively visit both the childrens of every node once. As a result, it takes $O(n)$ time because there are $n$ nodes in total. We iterate over each edge once to visit all the all nodes, which again takes $O(n)$ operations as there are $n - 1$ edges in the tree.\n\n* Space complexity: $O(n)$\n\n    - The recursion stack used by `dfs` can have no more than $n$ elements in the worst-case scenario where each node is added to it. It would take up $O(n)$ space in that case.\n\n---"
}