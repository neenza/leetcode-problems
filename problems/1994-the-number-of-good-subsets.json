{
  "title": "The Number of Good Subsets",
  "problem_id": "2105",
  "frontend_id": "1994",
  "difficulty": "Hard",
  "problem_slug": "the-number-of-good-subsets",
  "topics": [
    "Array",
    "Hash Table",
    "Math",
    "Dynamic Programming",
    "Bit Manipulation",
    "Counting",
    "Number Theory",
    "Bitmask"
  ],
  "description": "You are given an integer array nums. We call a subset of nums good if its product can be represented as a product of one or more distinct prime numbers.\nReturn the number of different good subsets in nums modulo 109 + 7.\nA subset of nums is any array that can be obtained by deleting some (possibly none or all) elements from nums. Two subsets are different if and only if the chosen indices to delete are different.\nExample 1:\nExample 2:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: nums = [1,2,3,4]\nOutput: 6\nExplanation: The good subsets are:\n- [1,2]: product is 2, which is the product of distinct prime 2.\n- [1,2,3]: product is 6, which is the product of distinct primes 2 and 3.\n- [1,3]: product is 3, which is the product of distinct prime 3.\n- [2]: product is 2, which is the product of distinct prime 2.\n- [2,3]: product is 6, which is the product of distinct primes 2 and 3.\n- [3]: product is 3, which is the product of distinct prime 3.",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input: nums = [4,2,3,15]\nOutput: 5\nExplanation: The good subsets are:\n- [2]: product is 2, which is the product of distinct prime 2.\n- [2,3]: product is 6, which is the product of distinct primes 2 and 3.\n- [2,15]: product is 30, which is the product of distinct primes 2, 3, and 5.\n- [3]: product is 3, which is the product of distinct prime 3.\n- [15]: product is 15, which is the product of distinct primes 3 and 5.",
      "images": []
    }
  ],
  "constraints": [
    "1 <= nums.length <= 105",
    "1 <= nums[i] <= 30"
  ],
  "follow_ups": [],
  "hints": [
    "Consider only the numbers which have a good prime factorization.",
    "Use brute force to find all possible good subsets and then calculate its frequency in nums."
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    int numberOfGoodSubsets(vector<int>& nums) {\n        \n    }\n};",
    "java": "class Solution {\n    public int numberOfGoodSubsets(int[] nums) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def numberOfGoodSubsets(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def numberOfGoodSubsets(self, nums: List[int]) -> int:\n        ",
    "c": "int numberOfGoodSubsets(int* nums, int numsSize) {\n    \n}",
    "csharp": "public class Solution {\n    public int NumberOfGoodSubsets(int[] nums) {\n        \n    }\n}",
    "javascript": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar numberOfGoodSubsets = function(nums) {\n    \n};",
    "typescript": "function numberOfGoodSubsets(nums: number[]): number {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @return Integer\n     */\n    function numberOfGoodSubsets($nums) {\n        \n    }\n}",
    "swift": "class Solution {\n    func numberOfGoodSubsets(_ nums: [Int]) -> Int {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun numberOfGoodSubsets(nums: IntArray): Int {\n        \n    }\n}",
    "dart": "class Solution {\n  int numberOfGoodSubsets(List<int> nums) {\n    \n  }\n}",
    "golang": "func numberOfGoodSubsets(nums []int) int {\n    \n}",
    "ruby": "# @param {Integer[]} nums\n# @return {Integer}\ndef number_of_good_subsets(nums)\n    \nend",
    "scala": "object Solution {\n    def numberOfGoodSubsets(nums: Array[Int]): Int = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn number_of_good_subsets(nums: Vec<i32>) -> i32 {\n        \n    }\n}",
    "racket": "(define/contract (number-of-good-subsets nums)\n  (-> (listof exact-integer?) exact-integer?)\n  )",
    "erlang": "-spec number_of_good_subsets(Nums :: [integer()]) -> integer().\nnumber_of_good_subsets(Nums) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec number_of_good_subsets(nums :: [integer]) :: integer\n  def number_of_good_subsets(nums) do\n    \n  end\nend"
  }
}