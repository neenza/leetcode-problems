{
  "title": "Maximum Sum of 3 Non-Overlapping Subarrays",
  "problem_id": "689",
  "frontend_id": "689",
  "difficulty": "Hard",
  "problem_slug": "maximum-sum-of-3-non-overlapping-subarrays",
  "topics": [
    "Array",
    "Dynamic Programming",
    "Sliding Window",
    "Prefix Sum"
  ],
  "description": "Given an integer array nums and an integer k, find three non-overlapping subarrays of length k with maximum sum and return them.\nReturn the result as a list of indices representing the starting position of each interval (0-indexed). If there are multiple answers, return the lexicographically smallest one.\nExample 1:\nExample 2:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: nums = [1,2,1,2,6,7,5,1], k = 2\nOutput: [0,3,5]\nExplanation: Subarrays [1, 2], [2, 6], [7, 5] correspond to the starting indices [0, 3, 5].\nWe could have also taken [2, 1], but an answer of [1, 3, 5] would be lexicographically larger.",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input: nums = [1,2,1,2,1,2,1,2,1], k = 2\nOutput: [0,2,4]",
      "images": []
    }
  ],
  "constraints": [
    "1 <= nums.length <= 2 * 104",
    "1 <= nums[i] < 216",
    "1 <= k <= floor(nums.length / 3)"
  ],
  "follow_ups": [],
  "hints": [],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    vector<int> maxSumOfThreeSubarrays(vector<int>& nums, int k) {\n        \n    }\n};",
    "java": "class Solution {\n    public int[] maxSumOfThreeSubarrays(int[] nums, int k) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def maxSumOfThreeSubarrays(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def maxSumOfThreeSubarrays(self, nums: List[int], k: int) -> List[int]:\n        ",
    "c": "/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nint* maxSumOfThreeSubarrays(int* nums, int numsSize, int k, int* returnSize) {\n    \n}",
    "csharp": "public class Solution {\n    public int[] MaxSumOfThreeSubarrays(int[] nums, int k) {\n        \n    }\n}",
    "javascript": "/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number[]}\n */\nvar maxSumOfThreeSubarrays = function(nums, k) {\n    \n};",
    "typescript": "function maxSumOfThreeSubarrays(nums: number[], k: number): number[] {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @param Integer $k\n     * @return Integer[]\n     */\n    function maxSumOfThreeSubarrays($nums, $k) {\n        \n    }\n}",
    "swift": "class Solution {\n    func maxSumOfThreeSubarrays(_ nums: [Int], _ k: Int) -> [Int] {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun maxSumOfThreeSubarrays(nums: IntArray, k: Int): IntArray {\n        \n    }\n}",
    "dart": "class Solution {\n  List<int> maxSumOfThreeSubarrays(List<int> nums, int k) {\n    \n  }\n}",
    "golang": "func maxSumOfThreeSubarrays(nums []int, k int) []int {\n    \n}",
    "ruby": "# @param {Integer[]} nums\n# @param {Integer} k\n# @return {Integer[]}\ndef max_sum_of_three_subarrays(nums, k)\n    \nend",
    "scala": "object Solution {\n    def maxSumOfThreeSubarrays(nums: Array[Int], k: Int): Array[Int] = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn max_sum_of_three_subarrays(nums: Vec<i32>, k: i32) -> Vec<i32> {\n        \n    }\n}",
    "racket": "(define/contract (max-sum-of-three-subarrays nums k)\n  (-> (listof exact-integer?) exact-integer? (listof exact-integer?))\n  )",
    "erlang": "-spec max_sum_of_three_subarrays(Nums :: [integer()], K :: integer()) -> [integer()].\nmax_sum_of_three_subarrays(Nums, K) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec max_sum_of_three_subarrays(nums :: [integer], k :: integer) :: [integer]\n  def max_sum_of_three_subarrays(nums, k) do\n    \n  end\nend"
  },
  "solution": "[TOC]\n\n## Solution\n\n---\n\n### Overview\n\n### Approach 1: Memoization\n\n#### Intuition\n\nAt first, we might think of a greedy approach: since all array values are positive, we could just find the three largest `k`- length subarrays. Unfortunately, this doesn't always work because the subarrays might overlap and, even if we avoid overlaps, we might miss better combinations. For example, taking a smaller subarray sum early on could allow us to pick two much larger subarrays later. This is why a greedy approach fails - we need to balance between local (current subarray) and global (overall) optimization.\n\nTo find the optimal subarrays, we need to make a decision at each position in the array:  \n- Should we take the `k`-length subarray starting here?  \n- Or should we skip it and move to the next position?  \n\nThis \"take it or leave it\" choice is typical in dynamic programming problems, similar to the 0/1 Knapsack Problem. If you are unfamiliar with the 0/1 Knapsack Problem, take a look at this excellent [LeetCode Discuss post 🔗](https://leetcode.com/discuss/study-guide/1152328/01-Knapsack-Problem-and-Dynamic-Programming#:~:text=Statement%3A%20Given%20a%20set%20of,equal%20to%20the%20knapsack's%20capacity.).\n\nLet us try to implement a memoized recursive function which should pick three subarrays such that their total sum is as large as possible. However, it is too slow to calculate the `k`-length subarray whenever we want to pick a particular index. To optimize this, let's precalculate the sum of the `k`-length subarray starting at each index. We create an array `sums` and populate it by maintaining a window of size `k` that slides through the array, adding the new element and removing the oldest one at each step.\n\nFor our recursive function design, which returns the largest total sum after selecting the subarrays, we need to consider two base cases:\n- If we’ve already selected 3 subarrays, return the current sum immediately.\n- If we've reached the array's end, terminate naturally.\n\nAt each step, we have two choices:  \n1. Take the current subarray: Add its sum to the total and jump `k` positions forward (to avoid overlap).  \n2. Skip the current position: Move to the next position and continue looking for subarrays.  \n\nWe take the larger of these two choices, and this forms our recurrence relation.\n\nTo keep track of these decisions and avoid recalculating results, we use a 2D array (`dp`) of size `n × 3`, where `n` is the length of the array and `3` represents the number of subarrays we need to find. Each cell in `dp` stores the best sum for a specific position and the number of remaining subarrays.\n\nOnce we’ve calculated the largest total sum using this DP table, we need to find the starting indices of the subarrays that produce this sum. This is the second phase of the solution: **path reconstruction**.  \n\nTo do this, we use a Depth-First Search (DFS) to retrace the steps of the DP function. At each step, we decide whether to include the current position or skip it, and we check the `dp` table to guide our choice.  \n- If taking the current position gives the same or a better sum, we add its index to our result.  \n\nSince all DP states are precomputed, each DFS step is fast. After the DFS completes, the `indices` list contains the starting indices of the three non-overlapping subarrays. We return this list as our final answer.\n\n> If you are unfamiliar with dynamic programming, check out the [Dynamic Programming Explore Card 🔗](https://leetcode.com/explore/featured/card/dynamic-programming/). This resource provides an in-depth look at the dynamic programming paradigm, explaining its key concepts and applications with a variety of problems to solidify understanding of the pattern. \n\n#### Algorithm\n\n- Create a variable `n` to store the number of possible starting positions for subarrays, calculated as the array length minus `k` plus 1.\n- Initialize:\n  - an array `sums` of size `n` to store sums of all possible `k`-length subarrays.\n  - a variable `windowSum` to store the sum of the first `k` elements.\n- Store the first window sum in `sums[0]`.\n- Use a sliding window technique to calculate the remaining sums:\n  - Subtract the leftmost element of the previous window.\n  - Add the rightmost element of the current window.\n  - Store the result in the corresponding position of the `sums` array.\n- Initialize a 2D array `memo` of size `n x 4` to store dynamic programming states, where `memo[i][j]` represents the largest sum possible starting from index `i` with `j` subarrays remaining.\n- Initialize an empty list `indices` to store final result indices.\n- Call `dp` to find the optimal sum using dynamic programming.\n- Call `dfs` to reconstruct the path and find the starting indices.\n- Return `indices` as the required answer.\n\nIn the `dp` function:\n- Base case 1: If the remaining subarrays (`rem`) is 0, return 0 as we've found all required subarrays.\n- Base case 2: If the current index (`idx`) exceeds array bounds, return -infinity if we still need subarrays, else return 0.\n- Check if the current state is already computed by examining `memo[idx][rem]`. If the value is not -1, return the memoized result.\n- Calculate the first choice by adding the current subarray sum (`sums[idx]`) to the result of a recursive call with:\n  - Index advanced by `k` positions (`idx + k`).\n  - One less subarray remaining (`rem - 1`).\n- Calculate the second choice by making a recursive call with:\n  - Index advanced by 1 (`idx + 1`).\n  - Same number of subarrays remaining (`rem`).\n- Store the larger of two choices in `memo[idx][rem]`.\n- Return the stored largest value.\n\nIn the `dfs` function:\n- Base case 1: If the remaining subarrays (`rem`) is `0`, return as the solution is complete.\n- Base case 2: If the current index (`idx`) exceeds array bounds, return as the path is invalid.\n- Calculate the largest sum possible by including the current subarray using the same parameters as in the `dp` function.  \n- Calculate the largest sum possible by skipping the current subarray using the same parameters as in the `dp` function.\n- Compare the two possibilities:\n  - If including the current subarray gives a greater or equal sum:\n    - Add the current index to the solution list.\n    - Make a recursive call with an index advanced by `k` and one less subarray remaining.\n  - Otherwise:\n    - Make a recursive call with the next index and the same number of subarrays.\n  \n#### Implementation#### Complexity Analysis\n\nLet $n$ be the length of the input array `nums`, $k$ be the length of each subarray and $m$ be the required number of non-overlapping subarrays.\n\n- Time Complexity: $O(n \\cdot m) \\approx O(n)$\n\n    The algorithm first computes prefix sums in $O(n)$ time using a sliding window. The `dp` function fills an $n \\times (m + 1)$ memo table, where each state `(i, j)` is computed once due to memoization. The `dfs` function reconstructs the solution in $O(m)$ time by tracing the path through the `dp` table. \n    \n    Combining these, the overall time complexity is $O(n)$ for prefix sums, $O(n \\cdot m)$ for DP, and $O(m)$ for DFS, resulting in $O(n \\cdot m)$. With $m$ fixed at 3, this simplifies to $O(n)$.\n\n- Space Complexity: $O(n \\cdot m) \\approx O(n)$\n\n    The algorithm uses an array `sums` of size $n$ to store subarray sums and a `memo` table of size $n \\times (m + 1)$, which requires $O(n \\cdot m)$ space. The recursion stack depth is limited by $m$, contributing $O(m)$ to space complexity. The `indices` list stores $m$ elements. \n    \n    Thus, the space complexity is dominated by the `memo` table, resulting in $O(n \\cdot m)$. With $m$ fixed at 3, this simplifies to $O(n)$.\n\n> Note: While `m = 3` is fixed in this problem, we've kept it as a variable in the analysis to show how the complexity would scale if `m` were different. \n\n---\n\n### Approach 2: Tabulation\n\n#### Intuition\n\nOur previous top-down dynamic programming approach had two main drawbacks: recursive overhead and complex path reconstruction. Let's develop a more efficient bottom-up approach that eliminates the need for recursive path reconstruction.\n\nLet's shift our insight a bit: instead of thinking about \"What choices do we have at each position?\", we can think about \"What’s the best result we can achieve with a specific number of subarrays up to each position?\". \n\nNotice that at a particular position, if we know the best possible answer for the two subarrays occurring before it, we can easily find the biggest third subarray occurring after it and complete the problem. So, we can build our answer progressively by finding the best arrangements for one subarray first, then using that information to find the best arrangements for two subarrays, and finally for three subarrays. \n\nTo make this process faster, we optimize how we calculate subarray sums by using prefix sums. A prefix sum array holds the sum of elements from the start of the array up to each position. This lets us calculate any subarray sum quickly by subtracting two values from the prefix sum array: `prefixSum[end] - prefixSum[start]`.\n\nNow, let's build the main solution. For each index in the array, we’ll keep track of two things:  \n1. The best sum possible up to that index, called `bestSum`.\n2. The starting index that gives us this best sum, called `bestIndex`.\n\nWe’ll calculate these values for 1, 2, and 3 subarrays. To do this, we use a `bestIndex` matrix of size $4 \\times (n + 1)$, where `bestIndex[i][j]` gives the best sum achieved up to index `j` with `i` subarrays.\n\nWe'll loop over each number of subarrays starting from 1. Inside this loop, we loop over each array position and calculate the best possible sum for that position. For each index, the best sum will be one of two options:  \n- Option 1: The sum we get by including a subarray that ends at this position.\n- Option 2: The best sum we had up to the previous index (for the same number of subarrays).\n\nTo calculate **Option 2**, we simply retrieve the best sum from the previous index for the same subarray count from the `bestSum` array.\n\nTo calculate **Option 1**, we check the sum of the `k`-length subarray ending at the current position and add it to the best sum we could get with one less subarray, ending at the position `index - k`. This comes from the `bestSum[subarrayCount - 1][index - k]`.\n\nIf including the current subarray gives us a better sum, we update both `bestSum` and `bestIndex` to reflect this. If not, we keep the best values from the previous position. This approach also ensures that we find the lexicographically smallest result, because we only update when we find a strictly better sum.\n\nOnce the main loop is done, we'll have the best sum and the corresponding index for the three subarrays. Now, we need to figure out where each of these subarrays starts.\n\nStarting from the end of the array, we use the `bestIndex` table to trace back the starting index for each subarray. For the third subarray, we check the starting index stored for the best sum with three subarrays. After that, we work backward to find the starting index for the second and first subarrays. Each time we find the start of a subarray, we update `currentEnd` to be the start of the subarray we just picked. This ensures there is no overlap between subarrays.\n\nAt the end of this process, we’ll have the starting indices of the three subarrays that give the largest sum.\n\n#### Algorithm\n\n- Initialize a variable `n` to store the length of the input array `nums`.\n- Create a prefix sum array of size `n + 1`:\n  - Populate the prefix sum array by iteratively adding each element to the previous sum.\n- Create a 2D array:\n  - `bestSum` of size `4 x (n + 1)` to store the largest sums achievable with up to 3 subarrays ending at each position.\n  - `bestIndex` of size `4 x (n + 1)` to store starting indices of subarrays that give the best sums.\n- For each possible number of subarrays `subarrayCount`:\n  - For each possible ending position (`k * subarrayCount` to `n`):\n    - Calculate the current sum by adding the:\n      - Sum of the current window (using prefix sum).\n      - Best sum achievable with one less subarray ending before the current window.\n    - If the current sum is greater than the best sum ending at the previous position:\n      - Update `bestSum` at current position with current sum.\n      - Store the starting index of the current window in `bestIndex`.\n    - Otherwise:\n      - Copy `bestSum` and `bestIndex` from the previous position to the current position.\n- Create a `result` array of size 3 to store the final starting indices.\n- Initialize `currentEnd` to point to the end of the array.\n- For each subarray (counting down from `3` to `1`):\n  - Store the best starting index for the current subarray count in the `result` array.\n  - Update `currentEnd` to point to the start of the just-placed subarray.\n- Return the `result` array containing optimal starting indices.\n\n#### Implementation#### Complexity Analysis\n\nLet $n$ be the length of the input array `nums`, $k$ be the length of each subarray and $m$ be the required number of non-overlapping subarrays.\n\n- Time complexity: $O(n \\cdot m) \\approx O(n)$\n\n    The algorithm first computes prefix sums in $O(n)$ time by traversing the array once. For each $t$ from $1$ to $m$, it iterates from position $k \\cdot t$ to $n$, performing constant-time operations at each step. This results in $O(n \\cdot m)$ operations due to the nested loops - $m$ outer iterations and approximately $n$ inner iterations. The final backtracking step takes $O(m)$ time. Thus, the overall time complexity is $O(n \\cdot m)$. With $m = 3$, this simplifies to $O(n)$.\n\n- Space complexity: $O(n \\cdot m) \\approx O(n)$\n\n    The algorithm uses a prefix sum array of size $n + 1$ to store cumulative sums. It also maintains two 2D arrays `bestSum` and `bestIndex`, each of size $(m + 1) \\times (n + 1)$, resulting in $O(n \\times m)$ space. The `result` array uses $O(m)$ space. Therefore, the total space complexity is $O(n \\times m)$. Since $m = 3$ in this problem, this reduces to $O(n)$.\n\n> Note: While `m = 3` is fixed in this problem, we've kept it as a variable in the analysis to show how the complexity would scale if `m` were different. \n\n---\n\n### Approach 3: Three Pointers\n\n#### Intuition\n\nIn the previous two approaches, we focused on finding the best solution for any number of non-overlapping subarrays. However, since our problem only requires finding 3 subarrays, we can use this fact to simplify our approach.\n\nWe can break the problem into three parts by **fixing the position of the middle subarray** first. This divides the array into three regions:\n1. The left region (before the middle subarray), where we need to find the best left subarray.\n2. The middle subarray itself.\n3. The right region (after the middle subarray), where we need to find the best right subarray.\n\nFor each possible position of the middle subarray, we can then find the best subarrays in the left and right regions. The highest sum across all possible middle subarray positions will give us the final answer.\n\nHowever, we need to optimize the way we calculate each subarray on either side while also maintaining information about their starting positions. In previous approaches, we used a prefix sum to precompute subarray sums. We'll now extend that idea further to also precompute the starting positions of the best subarray sums for each index in the array.\n\nTo implement this concept, we will create two arrays, `leftMaxIndex` and `rightMaxIndex`, to help us track the best subarrays for each segment. \n\nThe `leftMaxIndex[i]` array will store the starting index of the best subarray sum that ends at index `i`. To calculate this value, we compare the sum of the `k`-length subarray ending at `i` with the best sum we've found to the left of `i`. If the sum before is equal to the sum at index `i`, we prefer the earlier subarray, as we want the lexicographically smallest index. Similarly, we will build the `rightMaxIndex` array, where `rightMaxIndex[i]` will store the starting index of the best subarray sum starting at or after index `i`.\n\nIn the main loop, we will consider `k`-length subarrays starting from each index in the `nums` array. For each subarray, we will look up the corresponding `leftMaxIndex` and `rightMaxIndex` values, calculate the sum for these subarrays, and store the starting indices of the subarrays that give us the largest sum.\n\n#### Algorithm\n\n- Initialize variables:\n  - `n` to store the length of input array nums.\n  - `maxSum` to store the largest sum possible with three non-overlapping subarrays.\n- Create a prefix sum array of size `n + 1` to enable quick calculation of subarray sums.\n- Populate the prefix sum array by iteratively adding each element to the previous sum.\n- Create arrays `leftMaxIndex` and `rightMaxIndex` to store the best starting index for the left and right subarrays. respectively at each position.\n- Create a `result` array of size 3 to store the final starting indices.\n- Iterate from position `k` to `n - 1` to find the best left subarray for each position:\n  - Calculate the current subarray sum using prefix sum array.\n  - If current subarray sum is greater than the largest sum we have seen so far:\n    - Update `leftMaxIndex` at current position with the starting index of current subarray.\n    - Update the largest sum seen so far.\n  - Otherwise:\n    - Copy the previous best index to current position.\n- Set the rightmost possible position as initial best right subarray position.\n- Iterate from position `n - k - 1` to `0` to find the best right subarray for each position:\n  - Calculate the current subarray sum using prefix sum array.\n  - If current subarray sum is greater than or equal to the largest sum seen so far:\n    - Update `rightMaxIndex` at current position with the starting index of current subarray.\n    - Update the largest sum seen so far.\n  - Otherwise:\n    - Copy the next position's best index to current position.\n- Iterate over all possible middle subarray positions from `k` to `n - 2*k`:\n  - Get the best left subarray index before current position.\n  - Get the best right subarray index after current position plus `k`.\n  - Calculate total sum of all three subarrays using prefix sum array.\n  - If total sum is greater than `maxSum`:\n    - Update `maxSum` with the new largest sum.\n    - Store the three starting indices in the `result` array.\n- Return the `result` array containing the three optimal starting indices.\n\n#### Implementation#### Complexity Analysis\n\nLet $n$ be the length of the input array `nums`.\n\n- Time complexity: $O(n)$\n\n    The algorithm performs four linear scans. The first scan builds the prefix sum array in $O(n)$ time. The second builds the `leftMaxIndex` array from left to right in $O(n)$. The third scan builds the `rightMaxIndex` array from right to left, also in $O(n)$. The final scan finds the optimal middle position in $O(n)$. Since each operation is a sequential linear scan, the overall time complexity is $O(n)$.\n\n- Space complexity: $O(n)$\n\n    The algorithm uses three arrays of size proportional to the input length: the prefix sum array of size $n+1$, a `leftMaxIndex` array of size $n$, and a `rightMaxIndex` array of size $n$. Since all auxiliary space usage grow linearly with the input size, the total space complexity is $O(n)$.\n\n---\n\n### Approach 4: Sliding Window\n\n#### Intuition\n\nIn Approach 2, we built up the solution incrementally: the best two subarrays were derived from the best single subarray, and the best three subarrays were built from the best two. We can extend this concept to create a more optimized solution that doesn’t require storing all possible sums — just the best ones at each step.\n\nImagine a train with three cars, each of length `k`, moving along a track (our array). The cars must maintain their order and can't overlap:\n\n```\nInitial position:\n[Car1][Car2][Car3]------------------\n 0    k     2k    \n\nAfter one move:\n-[Car1][Car2][Car3]-----------------\n 1    k+1   2k+1  \n\nAnd so on...\n```\nEach car calculates the sum of the numbers it covers. At each position, Car1 finds the best single-window sum seen so far, Car2 combines its current sum with the best sum from Car1, and Car3 combines its current sum with the best combined sum from Cars 1 and 2.\n\nThe main idea in this approach is that we don’t need to try every possible combination of subarrays. Instead, by keeping track of the best results so far at each level - for one subarray, two subarrays, and three subarrays - we can build the solution incrementally. When we reach the end of the `nums` array, the best result for three subarrays will be our final answer.\n\nWe'll first need to set up three sliding windows. We only need to keep track of their starting points, which will be `0`, `k`, and `2*k` respectively. This ensures that the windows never overlap. We'll calculate the sums of the subarrays within these windows and store them in three variables:\n1. `bestSingleSum` — The best sum for a single subarray.\n2. `bestDoubleSum` — The best sum for two non-overlapping subarrays.\n3. `bestTripleSum` — The best sum for three non-overlapping subarrays.\n\nAs the windows slide forward over the array, we update the current sums by subtracting the element that moves out of the window and adding the new element that enters. At each step, we update the “best seen so far” sums in sequence: first `bestSingleSum`, then `bestDoubleSum`, and finally `bestTripleSum`. \n\nAlong with updating the sums, we also track the starting indices for these best subarrays, so by the end of the loop, the indices corresponding to `bestTripleSum` will represent the solution. We return these indices as the final result.\n\nThe slideshow below demonstrates the algorithm in action (Consider `k = 3`):\n\n!?!../Documents/689_re/slideshow.json:1404,702!?!\n\n#### Algorithm\n\n- Initialize:\n  - a variable `bestSingleStart` to store the starting index of the best single subarray.\n  - an array `bestDoubleStart` to store the starting indices of the best two subarrays.\n  - an array `bestTripleStart` to store the starting indices of the best three subarrays.\n- Create a variable `currentWindowSumSingle` to store the sum of the first `k` elements.\n  - Calculate `currentWindowSumSingle` by adding the first `k` elements from the input array.\n- Create a variable `currentWindowSumDouble` to store the sum of the second window of `k` elements.\n  - Calculate `currentWindowSumDouble` by adding elements from index `k` to `2*k - 1`.\n- Create a variable `currentWindowSumTriple` to store the sum of the third window of `k` elements.\n  - Calculate `currentWindowSumTriple` by adding elements from index `2*k` to `3*k - 1`.\n- Initialize variables `bestSingleSum`, `bestDoubleSum` and `bestTripleSum` to store the largest sum achieved with one, two, and three subarrays, respectively.\n- Initialize three sliding window pointers: `singleStartIndex` at `1`, `doubleStartIndex` at `k + 1`, and `tripleStartIndex` at `2*k + 1`.\n- While `tripleStartIndex` is less than or equal to array length minus `k`:\n  - Update `currentWindowSumSingle`, `currentWindowSumDouble`, and `currentWindowSumTriple` by removing the leftmost element and adding the new rightmost element.\n  - If current `currentWindowSumSingle` is greater than `bestSingleSum`:\n    - Update `bestSingleStart` to current `singleStartIndex`.\n    - Update `bestSingleSum` to current `currentWindowSumSingle`.\n  - If the sum of current `currentWindowSumDouble` and `bestSingleSum` is greater than `bestDoubleSum`:\n    - Update `bestDoubleStart` with `bestSingleStart` and current `doubleStartIndex`.\n    - Update `bestDoubleSum` with the new largest sum.\n  - If the sum of current `currentWindowSumTriple` and `bestDoubleSum` is greater than `bestTripleSum`:\n    - Update `bestTripleStart` with `bestDoubleStart` and current `tripleStartIndex`.\n    - Update `bestTripleSum` with the new largest sum.\n  - Increment all three sliding window pointers.\n- Return `bestTripleStart` containing the optimal starting indices.\n\n#### Implementation#### Complexity Analysis\n\nLet $n$ be the length of the input array `nums`.\n\n- Time complexity: $O(n + k)$\n\n    The algorithm computes three initial window sums, each taking $O(k)$. It then processes the array with three sliding windows, requiring $O(n)$. Since all operations are constant-time during the single pass, the total time complexity is $O(n + k)$.\n\n- Space complexity: $O(1)$\n\n    The algorithm uses a constant amount of extra space regardless of input size. It maintains three arrays of fixed sizes (`bestDoubleStart` of size $2$ and `bestTripleStart` of size $3$) and several single variables. Since none of these space requirements grow with the input size, the space complexity is $O(1)$.\n\n---"
}