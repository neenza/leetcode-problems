{
  "title": "Generate Fibonacci Sequence",
  "problem_id": "2775",
  "frontend_id": "2648",
  "difficulty": "Easy",
  "problem_slug": "generate-fibonacci-sequence",
  "topics": [],
  "description": "Write a generator function that returns a generator object which yields the fibonacci sequence.\nThe fibonacci sequence is defined by the relation Xn = Xn-1 + Xn-2.\nThe first few numbers of the series are 0, 1, 1, 2, 3, 5, 8, 13.\nExample 1:\nExample 2:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: callCount = 5\nOutput: [0,1,1,2,3]\nExplanation:\nconst gen = fibGenerator();\ngen.next().value; // 0\ngen.next().value; // 1\ngen.next().value; // 1\ngen.next().value; // 2\ngen.next().value; // 3",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input: callCount = 0\nOutput: []\nExplanation: gen.next() is never called so nothing is outputted",
      "images": []
    }
  ],
  "constraints": [
    "0 <= callCount <= 50"
  ],
  "follow_ups": [],
  "hints": [
    "Javascript has the concept of generators. They are critical to this problem.",
    "First yield 0 and 1.",
    "Create an infinite \"while(true)\" loop.",
    "In that loop, continuously yield the next value which is the sum of the previous two."
  ],
  "code_snippets": {
    "javascript": "/**\n * @return {Generator<number>}\n */\nvar fibGenerator = function*() {\n    \n};\n\n/**\n * const gen = fibGenerator();\n * gen.next().value; // 0\n * gen.next().value; // 1\n */",
    "typescript": "function* fibGenerator(): Generator<number, any, number> {\n    \n};\n\n/**\n * const gen = fibGenerator();\n * gen.next().value; // 0\n * gen.next().value; // 1\n */"
  },
  "solution": "[TOC]\n\n## Solution\n\n--- \n\n### Overview\n\nThis problem presents an interesting exploration of JavaScript generator functions, with the objective of writing a generator function that yields the Fibonacci sequence. This sequence is a series of numbers in which each number is the sum of the two preceding ones, generally starting with `0` and `1`. Therefore, the sequence initiates as follows: `0, 1, 1, 2, 3, 5, 8, 13` and so forth.\n\nJavaScript generator functions are special types of functions that can control the execution flow within a function, including the ability to pause and resume at specific points. This characteristic makes them ideal for generating potentially infinite sequences like the Fibonacci sequence. By using the `yield` keyword, a generator function can produce a sequence of values over time, instead of computing them all at once. It can thus generate an infinite data stream, creating each value only when needed. This feature provides significant performance benefits and allows for the creation of infinite sequences without overloading memory resources.\n\nUnderstanding the `yield` keyword in JavaScript and the concept of maintaining state between function invocations are critical to address this problem. Also, getting acquainted with how JavaScript's `.next()` method operates with generator objects is important as it is used to retrieve the next Fibonacci number in the sequence.\n\nIf you're not yet familiar with the Fibonacci sequence, consider starting with this problem: [Fibonacci Number](https://leetcode.com/problems/fibonacci-number/). This will provide a solid understanding of the sequence, which is crucial for this problem.\n\nFinally, for a more detailed study on JavaScript functions, consider reading the [Create Hello World Function](https://leetcode.com/problems/create-hello-world-function/editorial/) Editorial. This article provides valuable insights into the behavior and usage of functions in JavaScript.\n\n\n#### JavaScript Generator Functions\nGenerator functions in JavaScript are special types of functions that can be paused and resumed, enabling them to yield multiple outputs on different invocations. They are defined using the `function*` keyword, and they return a generator object when invoked.\n\nThis generator object is special because it conforms to both the iterable and iterator protocols in JavaScript:\n- The _iterable protocol_ allows JavaScript objects to define or customize their iteration behavior. An object is iterable if it implements the `@@iterator` method, meaning it has a property with a `Symbol.iterator` key.\n- The _iterator protocol_ is a protocol that defines a standard way to produce a sequence of values. An object is an iterator when it implements a `next()` method.\n\nIn other words, the generator object returned by a generator function is an iterator and can be used directly in a `for...of` loop and other JavaScript constructs that expect an iterable.\n\nHere's an example of using a generator function with the iterator protocol:\n\n```javascript\nconst gen = [1,2,3][Symbol.iterator]();\nconsole.log(gen.next()); // { value: 1, done: false }\n```\n\nFor a deeper understanding of the iteration protocols in JavaScript, check out the [MDN reference on Iteration Protocols](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols).\n\nThe `yield` keyword is used within the generator function to specify the values to be returned during its execution. Each time `yield` is encountered, the function's execution is paused, and the yielded value is emitted. The next invocation of the generator's `next()` method resumes the execution from where it was last paused.\n\nAn example of a simple generator function in JavaScript:\n```javascript\nfunction* simpleGenerator() {\n  yield 1;\n  yield 2;\n  yield 3;\n}\n\nconst gen = simpleGenerator();\n\nconsole.log(gen.next().value); // 1\nconsole.log(gen.next().value); // 2\nconsole.log(gen.next().value); // 3\n```\n\n`simpleGenerator` is a generator function that yields the numbers `1`, `2`, and `3`. When we invoke `simpleGenerator`, it returns a generator object. We then call the `next()` method on this object to retrieve the next value yielded by the generator function.\n\n#### Maintaining State with JavaScript Generators\nOne of the key features of JavaScript generator functions is their ability to maintain state between invocations. This allows you to create functions that generate a series of related values over multiple calls, such as a sequence of numbers or a sequence of Fibonacci numbers.\n\nWhen a generator function is invoked, it returns a generator object, but it doesn't execute any of the function's code immediately. Instead, the function's code is executed on-demand, each time the generator's `next()` method is invoked. This feature allows the generator to maintain its position in the code for subsequent calls, effectively preserving state between these calls.\n\n```javascript\nfunction* countUp() {\n  let count = 0;\n  while (true) {\n    yield count++;\n  }\n}\n\nconst gen = countUp();\n\nconsole.log(gen.next().value); // 0\nconsole.log(gen.next().value); // 1\nconsole.log(gen.next().value); // 2\n\n```\n\nIn this example, the `countUp` generator function yields an infinite series of incrementing numbers. Each time `gen.next()` is called, the function resumes execution from the last `yield`, using the current value of the count variable. This demonstrates how generators can maintain state between invocations.\n\n#### The `next()` Method in JavaScript Generators\n\nThe `next()` method is a key part of the JavaScript generator function framework. When invoked on a generator object, it resumes the execution of the function until the next `yield` statement is encountered. The value yielded by the yield statement is returned as the value property of an object, which also includes a done property indicating whether the generator has completed execution.\n\nHere's an example demonstrating the use of the `next()` method:\n\n```javascript\nfunction* simpleGenerator() {\n  yield 1;\n  yield 2;\n  return 3;\n}\n\nconst gen = simpleGenerator();\n\nconsole.log(gen.next()); // { value: 1, done: false }\nconsole.log(gen.next()); // { value: 2, done: false }\nconsole.log(gen.next()); // { value: 3, done: true }\n```\n\nEach call to `gen.next()` resumes the execution of the `simpleGenerator` function, returning an object that includes the yielded value and a flag indicating whether the function has completed its execution.\n\n#### Iterators vs Generators\nThe concepts of iterators and generators are related and often used together in JavaScript, but they serve different purposes. It's important to distinguish between them to understand their respective roles in managing sequences of data.\n\nAn iterator is a design pattern used to traverse a container and access the container's elements. The iterator pattern decouples algorithms from containers; in some cases, algorithms are necessarily container-specific and thus cannot be decoupled.\n\nIn JavaScript, an iterator is an object which defines a sequence and potentially a return value upon its termination. Specifically, an object is an iterator when it implements a `next()` method with the following semantics:\n* On each call, it returns an object with two properties: `value` and `done`.\n* The `value` property is the `value` of the current item in the sequence.\n* The `done` property is a Boolean that is true if the last `value` in the sequence has already been produced and false otherwise.\n\n##### How Do They Work Together?\nWhen a generator function is called, it returns a generator object. This object is an iterator, meaning it has a `next()` method that can be called to produce a value from the generator.\n\nEach time `next()` is called, the generator function's execution is resumed from its paused state, and it continues until it reaches the next `yield` expression. The `value` of the `yield` expression is returned from the `next()` method.\n\nIn conclusion, while the terms iterator and generator are related, they are not interchangeable:\n* Iterators are a concept and a pattern that allows you to traverse sequences of values.\n* Generators are a tool in JavaScript that helps create iterators with a special syntax. Generators can be paused and resumed, making it easier to create complex sequences because the function \"remembers\" its state.\n\n#### Use Cases of Generators\n\nGenerators, with their ability to produce values on demand, can be employed effectively in various programming scenarios. Here are some of the prominent use cases:\n\n##### Cancellation of Execution\n\nGenerators open the way for two-way communication between generator code and the \"execution engine\". Not only can you pause execution, but you can also cancel it or completely alter how the generator code behaves based on the decisions of the \"engine\". This unique advantage can be particularly useful when dealing with complex control flows or when you need to manage resources effectively.\n\n```javascript\nfunction* taskRunner() {\n  let taskId = 0;\n  let cancelled = false;\n\n  while (!cancelled) {\n    cancelled = yield taskId++;\n  }\n}\n\nconst tasks = taskRunner();\ntasks.next(); // starts task 0\ntasks.next(); // starts task 1\ntasks.next(true); // cancels the tasks\n```\n\nIn this generator function `taskRunner`, we generate a sequence of task IDs. The statement `cancelled = yield taskId++;` pauses execution and returns the current task ID. The generator then waits for the next invocation of `next()` before it continues.\n\nThe single yield statement `cancelled = yield taskId++;` in the loop demonstrates a key feature of generators: the ability to send data back into the generator. When `next()` is called, the value passed as an argument to `next()` is returned by `yield`. This allows the caller to send a signal (in this case, a cancellation signal) back into the generator.\n\nBy passing `true` to `next()`, we signal the generator to cancel the tasks. As a result, cancelled becomes `true`, the while loop ends, and the generator function stops generating new tasks. This showcases the two-way communication feature of generators, allowing external control over the execution of a generator function.\n\nThis ability to pause and resume execution, coupled with the ability to send data back into the generator, provides a lot of flexibility in controlling execution flow, making generators a powerful feature in JavaScript for handling complex, stateful computations or tasks.\n\n##### Infinite Data Streams\n\nGenerators can be implemented to create infinite sequences or data streams. For instance, one might define a generator that generates an endless sequence of incrementing numbers as follows:\n\n```javascript\nfunction* infiniteSequence() {\n  let i = 0;\n  while(true) {\n    yield i++;\n  }\n}\n```\nThis generator can be iterated indefinitely to produce an endless sequence of numbers. Interestingly, this gives us the capability to employ infinite loops without the risk of the program crashing. It could also serve as a simple method to generate unique IDs. Each time you invoke the `next()` method on the generator, it yields a new number, incremented from the previous one.\n\n##### Simulation and Game State:\n\nIf you're developing a game where a player can move in four directions and want to simulate all possible moves, you could use a generator to create the sequence of moves:\n\n```javascript\nfunction* playerMoves() {\n  const directions = ['up', 'down', 'left', 'right'];\n  for(let direction of directions) {\n    yield direction;\n  }\n}\n```\nYou could certainly use a simple loop to iterate over the directions, but using a generator here provides some unique advantages, particularly in more complex game scenarios.\n\nOne key advantage of generators is their ability to maintain internal state across multiple calls, with the added benefit of pausing and resuming execution. This functionality is particularly useful in complex scenarios such as a chess game, where the ability to pause the game, store the state, and resume later can be invaluable. Unlike a simple loop, where additional logic would be necessary to manage this, generators inherently provide this functionality.\n\nConsider a chess engine, where the number of potential game states is astronomically large. Instead of generating all possible game states upfront, which is not only impractical but also resource-intensive, a generator can produce them on-demand as each move is made. This leads to a more efficient management of game states, saving memory and computing power. Generators, therefore, can greatly enhance the performance and complexity of applications like a chess engine.\n\n#### Dealing with Deeply Nested Data Structures\n\nGenerators can be used to process deeply nested data structures such as trees or arrays in a different manner compared to traditional recursion. While traditional recursive methods can result in a stack overflow for data structures with a high level of nesting, generators allow us to control the flow of data by yielding items one at a time. This characteristic doesn't inherently prevent stack overflow but provides us with a unique way of handling and processing data in complex, deeply nested structures.\n\n```javascript\nfunction* traverseTree(node) {\n  if (!node) {\n    return;\n  }\n\n  yield node.value;\n\n  if (node.left) {\n    yield* traverseTree(node.left);\n  }\n\n  if (node.right) {\n    yield* traverseTree(node.right);\n  }\n}\n\nconst tree = {\n  value: 1,\n  left: {\n    value: 2,\n    left: { value: 4 },\n    right: { value: 5 },\n  },\n  right: {\n    value: 3,\n    left: { value: 6 },\n    right: { value: 7 },\n  },\n};\n\nfor (const value of traverseTree(tree)) {\n  console.log(value); // logs: 1, 2, 4, 5, 3, 6, 7\n}\n```\n\nThe `traverseTree` generator function recursively traverses the nodes in the binary tree. It starts at the root, then it yields the root's value and recursively calls itself on the left child and right child if they exist. This process allows the function to handle binary trees of any level of depth.\n\nBoth generators and traditional functions in JavaScript interact with the engine's call stack and can lead to a stack overflow error if the recursion depth exceeds the stack size limit. It's a common misconception that generator functions prevent stack overflow. Generators are described as 'lazy' because they generate values only when explicitly asked for, rather than computing all values upfront. This can lead to more efficient memory usage, especially when dealing with large but finite data structures, as they generate values on demand.\n\nHowever, this 'lazy' computation does not affect the call stack depth. In other words, even though generators can handle memory more efficiently by generating values on demand, they do not inherently reduce the depth of the call stack or prevent stack overflow. Therefore, it's crucial to manage recursion depth carefully when using both generators and traditional recursion.\n\n---\n\n### Approach 1: Iterative Generator Function for Fibonacci Sequence\n\n#### Intuition\nGenerator functions yield a sequence of values, making them ideal for this problem. In our function, we'll use two variables to store the last two values of the Fibonacci sequence. With each `next()` call, we calculate and yield the next number in the sequence, providing an efficient way to generate the Fibonacci sequence. We not gonna run into infinite loop as generator yields just once.\n\n#### Algorithm\n1. Declare `prev1` and `prev2` variables and initialize them to `0` and `1` respectively.\n2. Start an infinite loop.\n3. In each iteration of the loop, yield the value of `prev1`.\n4. After yielding, calculate the next Fibonacci number by summing `prev1` and `prev2`, update the variables `prev1` and `prev2` accordingly.\n\n#### Implementation\n\nThis approach can be implemented in various ways.\n\n##### Implementation 1: Using a while loopThe `yield` keyword pauses the function execution and returns the value of `prev1`, then it resumes from where it left off in the next call.\n\n\n##### Implementation 2: Using Destructuring Assignment in Fibonacci Sequence UpdateIn this implementation, we utilize JavaScript's destructuring assignment to update the variables a and b simultaneously. The line `[a, b] = [b, a+b];` first evaluates the right hand side creating a temporary array `[b, a+b]`, then destructures this array to update `a` and `b`. This ensures `a` is updated to `b` and `b` is updated to `a+b` simultaneously, providing a more concise way to calculate the next term in the Fibonacci sequence.\n\n##### Implementation 3: Using Multiple Yield StatementsIn this variant of the first approach, we utilize multiple `yield` statements to separately yield the first two numbers of the Fibonacci sequence. The first two `yield` statements yield `a` and `b`, which are the first two numbers of the sequence.\n\nWe then enter an infinite loop, where we calculate the next number `c` in the sequence, yield `c`, and update `a` and `b` for the next round.\n\nThis demonstrates the flexibility of generator functions and the `yield` keyword. Unlike `return` statements, which terminate the function once encountered, `yield` statements only pause the function, allowing multiple `yield` statements to be executed over successive calls to `next()`. \n\n#### Complexity Analysis\n\nTime complexity: $O(1)$. The time complexity of the `fibGenerator` function is $O(1)$ for each `next()` call. This is because in each call to `next()`, we only perform a fixed number of operations: adding two numbers and swapping two variables. Hence, the time complexity does not grow with the number of calls to `next()`. However, if you were to consider the time complexity of generating `N` Fibonacci numbers (i.e., making `N` calls to `next()`), the overall time complexity would be $O(N)$, since you'd be making `N` constant-time operations. \n\n\nSpace complexity: $O(1)$. The space complexity of the `fibGenerator` function is also $O(1)$. This is because we only use a fixed amount of space to store the two most recent numbers in the Fibonacci sequence and one additional variable for the calculation, regardless of how many times we call `next()`.\n\n### Approach 2: Recursive Generator Function for Fibonacci Sequence\n\n#### Intuition\nInstead of using an infinite loop like in the previous approach, we can also use recursion to generate the Fibonacci sequence. This approach is slightly more complex and less recommended unlike iterative solution, but it highlights a fascinating aspect of generator functions: they can yield other generator functions. \n\n#### Algorithm\n1. In the generator function, yield the first number (`a`).\n2. Recursively call `fibGenerator` with the next pair of numbers in the Fibonacci sequence (`b` and `a+b`), and yield the entire generator function using `yield*`.\n\n\n#### ImplementationIn this recursive implementation of `fibGenerator`, we initialize the function parameters `a` and `b` to `0` and `1`, respectively, which are the first two numbers in the Fibonacci sequence.\n\nDuring each call to `fibGenerator`, we initially yield the number `a`. Subsequently, we make a recursive call to `fibGenerator`. However, instead of yielding a single value, we use `yield*` to yield the entire generator function.\n\nIt's important to note that we use the `yield*` expression, not just `yield`, to yield another generator. This process repeats recursively, thereby generating the Fibonacci sequence indefinitely.\n\n#### Complexity Analysis\n\nTime complexity: $O(1)$. Similar to the iterative approach, the time complexity of the `fibGenerator` function is $O(1)$ for each `next()` call. Although we use recursion, we still only perform a fixed number of operations in each call to `next()`.\n\nSpace complexity: $O(N)$. The space complexity of the recursive approach is $O(N)$, where `N` is the number of `next()` calls. This is because each recursive call to `fibGenerator` adds a new frame to the call stack. Therefore, if we call `next()` `N` times, there will be `N` frames on the call stack, leading to a space complexity of $O(N)$. This is the key disadvantage of the recursive approach compared to the iterative one.\n\n### Approach 3: Precomputed Array and Custom Iterator\n\n#### Intuition\nInstead of using recursion or an infinite loop to generate the Fibonacci sequence, we can compute the sequence in advance up to a certain number and then yield these precomputed values with a custom iterator.\n\n#### Algorithm\n1. Initialize an array with a specific length based on the constraints, and set all its elements to `0`. The length of this array will determine the number of Fibonacci numbers you want to generate.\n2. Set the second element of the array to `1` to align with the Fibonacci sequence rule.\n3. Use a for loop to populate the rest of the array with the Fibonacci sequence.\n4. After the array is filled, return an iterator for the array.\n\n#### ImplementationIn this implementation, we first determine the number of Fibonacci numbers we want to generate (`lengthOfSequence`). We then initialize an array (`fibonacciSequence`) of this length and set all its elements to `0`. The second element of the array is set to `1` to represent the second number in the Fibonacci sequence.\n\nWe then populate the array with the Fibonacci sequence using a for loop. Each Fibonacci number is calculated by adding the two preceding numbers in the array.\n\nOnce the array is filled with the Fibonacci sequence, we return an iterator for the array using the built-in `Symbol.iterator` method. This iterator will yield each number in the precomputed Fibonacci sequence when called.\n\n#### Complexity Analysis\n\nTime complexity: $O(N)$. This approach involves precomputing the Fibonacci sequence, where `N` is the length of the array (the number of Fibonacci numbers we want to generate). After this precomputation, each call to `next()` is $O(1)$.\n\nSpace complexity: $O(N)$.  This approach requires storing `N` numbers in the array, resulting in a space complexity of $O(N)$. However, unlike the recursive approach, this space is not used for call stack frames but for storing the sequence numbers.\n\n---"
}