{
  "title": "Minimum Time to Make Array Sum At Most x",
  "problem_id": "2952",
  "frontend_id": "2809",
  "difficulty": "Hard",
  "problem_slug": "minimum-time-to-make-array-sum-at-most-x",
  "topics": [
    "Array",
    "Dynamic Programming",
    "Sorting"
  ],
  "description": "You are given two 0-indexed integer arrays nums1 and nums2 of equal length. Every second, for all indices 0 <= i < nums1.length, value of nums1[i] is incremented by nums2[i]. After this is done, you can do the following operation:\nYou are also given an integer x.\nReturn the minimum time in which you can make the sum of all elements of nums1 to be less than or equal to x, or -1 if this is not possible.\nExample 1:\nExample 2:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: nums1 = [1,2,3], nums2 = [1,2,3], x = 4\nOutput: 3\nExplanation: \nFor the 1st second, we apply the operation on i = 0. Therefore nums1 = [0,2+2,3+3] = [0,4,6]. \nFor the 2nd second, we apply the operation on i = 1. Therefore nums1 = [0+1,0,6+3] = [1,0,9]. \nFor the 3rd second, we apply the operation on i = 2. Therefore nums1 = [1+1,0+2,0] = [2,2,0]. \nNow sum of nums1 = 4. It can be shown that these operations are optimal, so we return 3.",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input: nums1 = [1,2,3], nums2 = [3,3,3], x = 4\nOutput: -1\nExplanation: It can be shown that the sum of nums1 will always be greater than x, no matter which operations are performed.",
      "images": []
    }
  ],
  "constraints": [
    "1 <= nums1.length <= 103",
    "1 <= nums1[i] <= 103",
    "0 <= nums2[i] <= 103",
    "nums1.length == nums2.length",
    "0 <= x <= 106"
  ],
  "follow_ups": [],
  "hints": [
    "<div class=\"_1l1MA\">It can be proven that in the optimal solution, for each index <code>i</code>, we only need to set <code>nums1[i]</code> to <code>0</code> at most once. (If we have to set it twice, we can simply remove the earlier set and all the operations “shift left” by <code>1</code>.)</div>",
    "<div class=\"_1l1MA\">It can also be proven that if we select several indexes <code>i<sub>1</sub>, i<sub>2</sub>, ..., i<sub>k</sub></code> and set <code>nums1[i<sub>1</sub>], nums1[i<sub>2</sub>], ..., nums1[i<sub>k</sub>]</code> to <code>0</code>, it’s always optimal to set them in the order of <code>nums2[i<sub>1</sub>] <= nums2[i<sub>2</sub>] <= ... <= nums2[i<sub>k</sub>]</code> (the larger the increase is, the later we should set it to <code>0</code>).</div>",
    "<div class=\"_1l1MA\">Let’s sort all the values by <code>nums2</code> (in non-decreasing order). Let <code>dp[i][j]</code> represent the maximum total value that can be reduced if we do <code>j</code> operations on the first <code>i</code> elements. Then we have <code>dp[i][0] = 0</code> (for all <code>i = 0, 1, ..., n</code>) and <code>dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - 1] + nums2[i - 1] * j + nums1[i - 1])</code> (for <code>1 <= i <= n</code> and <code>1 <= j <= i</code>).</div>",
    "<div class=\"_1l1MA\">The answer is the minimum value of <code>t</code>, such that <code>0 <= t <= n</code> and <code>sum(nums1) + sum(nums2) * t - dp[n][t] <= x</code>, or <code>-1</code> if it doesn’t exist.</div>"
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    int minimumTime(vector<int>& nums1, vector<int>& nums2, int x) {\n        \n    }\n};",
    "java": "class Solution {\n    public int minimumTime(List<Integer> nums1, List<Integer> nums2, int x) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def minimumTime(self, nums1, nums2, x):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :type x: int\n        :rtype: int\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def minimumTime(self, nums1: List[int], nums2: List[int], x: int) -> int:\n        ",
    "c": "int minimumTime(int* nums1, int nums1Size, int* nums2, int nums2Size, int x) {\n    \n}",
    "csharp": "public class Solution {\n    public int MinimumTime(IList<int> nums1, IList<int> nums2, int x) {\n        \n    }\n}",
    "javascript": "/**\n * @param {number[]} nums1\n * @param {number[]} nums2\n * @param {number} x\n * @return {number}\n */\nvar minimumTime = function(nums1, nums2, x) {\n    \n};",
    "typescript": "function minimumTime(nums1: number[], nums2: number[], x: number): number {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param Integer[] $nums1\n     * @param Integer[] $nums2\n     * @param Integer $x\n     * @return Integer\n     */\n    function minimumTime($nums1, $nums2, $x) {\n        \n    }\n}",
    "swift": "class Solution {\n    func minimumTime(_ nums1: [Int], _ nums2: [Int], _ x: Int) -> Int {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun minimumTime(nums1: List<Int>, nums2: List<Int>, x: Int): Int {\n        \n    }\n}",
    "dart": "class Solution {\n  int minimumTime(List<int> nums1, List<int> nums2, int x) {\n    \n  }\n}",
    "golang": "func minimumTime(nums1 []int, nums2 []int, x int) int {\n    \n}",
    "ruby": "# @param {Integer[]} nums1\n# @param {Integer[]} nums2\n# @param {Integer} x\n# @return {Integer}\ndef minimum_time(nums1, nums2, x)\n    \nend",
    "scala": "object Solution {\n    def minimumTime(nums1: List[Int], nums2: List[Int], x: Int): Int = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn minimum_time(nums1: Vec<i32>, nums2: Vec<i32>, x: i32) -> i32 {\n        \n    }\n}",
    "racket": "(define/contract (minimum-time nums1 nums2 x)\n  (-> (listof exact-integer?) (listof exact-integer?) exact-integer? exact-integer?)\n  )",
    "erlang": "-spec minimum_time(Nums1 :: [integer()], Nums2 :: [integer()], X :: integer()) -> integer().\nminimum_time(Nums1, Nums2, X) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec minimum_time(nums1 :: [integer], nums2 :: [integer], x :: integer) :: integer\n  def minimum_time(nums1, nums2, x) do\n    \n  end\nend"
  }
}