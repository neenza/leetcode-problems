{
  "title": "Zero Array Transformation II",
  "problem_id": "3643",
  "frontend_id": "3356",
  "difficulty": "Medium",
  "problem_slug": "zero-array-transformation-ii",
  "topics": [
    "Array",
    "Binary Search",
    "Prefix Sum"
  ],
  "description": "You are given an integer array nums of length n and a 2D array queries where queries[i] = [li, ri, vali].\nEach queries[i] represents the following action on nums:\nA Zero Array is an array with all its elements equal to 0.\nReturn the minimum possible non-negative value of k, such that after processing the first k queries in sequence, nums becomes a Zero Array. If no such k exists, return -1.\nExample 1:\nExample 2:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: nums = [2,0,2], queries = [[0,2,1],[0,2,1],[1,1,3]]\nOutput: 2\nExplanation:",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input: nums = [4,3,2,1], queries = [[1,3,2],[0,2,1]]\nOutput: -1\nExplanation:",
      "images": []
    }
  ],
  "constraints": [
    "1 <= nums.length <= 105",
    "0 <= nums[i] <= 5 * 105",
    "1 <= queries.length <= 105",
    "queries[i].length == 3",
    "0 <= li <= ri < nums.length",
    "1 <= vali <= 5"
  ],
  "follow_ups": [],
  "hints": [
    "Can we apply binary search here?",
    "Utilize a difference array to optimize the processing of queries."
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {\n        \n    }\n};",
    "java": "class Solution {\n    public int minZeroArray(int[] nums, int[][] queries) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def minZeroArray(self, nums, queries):\n        \"\"\"\n        :type nums: List[int]\n        :type queries: List[List[int]]\n        :rtype: int\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        ",
    "c": "int minZeroArray(int* nums, int numsSize, int** queries, int queriesSize, int* queriesColSize) {\n    \n}",
    "csharp": "public class Solution {\n    public int MinZeroArray(int[] nums, int[][] queries) {\n        \n    }\n}",
    "javascript": "/**\n * @param {number[]} nums\n * @param {number[][]} queries\n * @return {number}\n */\nvar minZeroArray = function(nums, queries) {\n    \n};",
    "typescript": "function minZeroArray(nums: number[], queries: number[][]): number {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @param Integer[][] $queries\n     * @return Integer\n     */\n    function minZeroArray($nums, $queries) {\n        \n    }\n}",
    "swift": "class Solution {\n    func minZeroArray(_ nums: [Int], _ queries: [[Int]]) -> Int {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun minZeroArray(nums: IntArray, queries: Array<IntArray>): Int {\n        \n    }\n}",
    "dart": "class Solution {\n  int minZeroArray(List<int> nums, List<List<int>> queries) {\n    \n  }\n}",
    "golang": "func minZeroArray(nums []int, queries [][]int) int {\n    \n}",
    "ruby": "# @param {Integer[]} nums\n# @param {Integer[][]} queries\n# @return {Integer}\ndef min_zero_array(nums, queries)\n    \nend",
    "scala": "object Solution {\n    def minZeroArray(nums: Array[Int], queries: Array[Array[Int]]): Int = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn min_zero_array(nums: Vec<i32>, queries: Vec<Vec<i32>>) -> i32 {\n        \n    }\n}",
    "racket": "(define/contract (min-zero-array nums queries)\n  (-> (listof exact-integer?) (listof (listof exact-integer?)) exact-integer?)\n  )",
    "erlang": "-spec min_zero_array(Nums :: [integer()], Queries :: [[integer()]]) -> integer().\nmin_zero_array(Nums, Queries) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec min_zero_array(nums :: [integer], queries :: [[integer]]) :: integer\n  def min_zero_array(nums, queries) do\n    \n  end\nend"
  },
  "solution": "[TOC]\n\n## Solution\n\n---\n\n### Overview\n\nWe are given an integer array `nums` of length `n`, and a list of queries that are each in the form `[left, right, val]`. For a given range `[left, right]`, we can decrease each element in that range by at most `val`. Our task is to determine the earliest query that allows us to turn `nums` into an array of all zeroes. If it's not possible, we return `-1`.  \n\nWe can look at an example of the queries being processed:\n\n!?!../Documents/3356/slideshow1.json:960,540!?!\n\nFrom this example, we can see that there are two main operations that will occur:\n\n1. Iterating through each element in `queries`.\n2. Applying the range and value of each query to `nums`.\n\nWe need to assess how to optimally handle both operations to find the earliest value of `k` to reach a zero array.\n\n---\n\n### Approach 1: Binary Search\n\n#### Intuition\n\nA simple approach would be to iterate through each query, applying the updates directly to `nums` and checking whether all elements have become zero. However, given the constraints where both `nums` and `queries` can be as large as $10^5$, this approach is too slow. Each query might require traversing the entire array, leading to an impractical time complexity.  \n\nTo optimize this, we need a more efficient way to apply queries to `nums`. Instead of modifying each element individually, we can take advantage of a **difference array**. This technique allows us to apply a range update in constant time. The key idea is to store the changes at the boundaries of the range rather than updating every element inside it. For a query $[ \\text{left}, \\text{right}, \\text{val} ]$, we add `val` at index `left`, and subtract `val` at index `right + 1`. When we later compute the prefix sum of this difference array, it reconstructs the actual values efficiently. This way, instead of updating `nums` repeatedly, we can process all queries in an optimized manner and then traverse `nums` just once to check if all elements have become zero.  \n\nLet's look at how the difference array can be applied to this problem:\n\n!?!../Documents/3356/slideshow2.json:960,540!?!\n\nNow that we optimized how we apply queries, the next step is to determine how many queries we actually need. Instead of processing all queries one by one, we can use **binary search** to quickly determine the minimum number of queries required to achieve the zero array. We start by setting two pointers: `left = 0` and `right = len(queries)`, representing the search range. The middle index, `mid = (left + right) / 2`, represents the number of queries we will attempt to apply. We update `nums` using only the first `mid` queries, compute the final state using the prefix sum of the difference array, and check if `nums` is now a zero array.  \n\nIf it is possible to achieve a zero array with `mid` queries, we reduce our search range by setting `right = mid - 1`, since we might be able to do it with even fewer queries. Otherwise, we increase our search range by setting `left = mid + 1`, since we need more queries to reach the desired state. This binary search ensures that instead of checking every possible number of queries linearly $O(N)$, we find the answer in $O(\\log N)$ time.  \n\n#### Algorithm\n\n- Define a function `canFormZeroArray`, which takes the parameters `nums`, `queries`, and integer `k` and returns a boolean value:\n    - Initialize:\n        - `n` to the size of `nums`.\n        - `sum` to `0` to track the cumulative sum of updates added to a given index.\n        - `differenceArray` as a vector of integers of size `n + 1` to apply range updates\n    - Iterate through the first `k` elements of `queries`:\n        - Initialize `start`, `end`, and `val` to the respective values of the current query.\n        - Increment `differenceArray[start]` by `val` to update the start of the range.\n        - Decrement `differenceArray[end + 1]` by `val` to update the end of the range.\n    - Iterate through `nums`. For each index, `numIndex`:\n        - Increment `sum` by `differenceArray[numIndex]`;\n        - If `sum` is less than `nums[numIndex]`, return `false`, indicating that a zero array cannot be formed after the first `k` queries.\n    - Return `true`, meaning a zero array was formed after `k` queries.\n\n- Define `minZeroArray`:\n    - Initialize:\n        - `n` to the size of `nums`.\n        - `left` to `0`.\n        - `right` to the size of `queries`.\n    - If a zero array cannot be formed at `right`, return `-1`, since that means we processed all the queries without reaching a zero array.\n    - Perform binary search on `queries`. While `left` is less than or equal to `right`:\n        - Initialize `middle` to half of the current search interval (`left + (right - left) / 2`).\n        - If `canFormZeroArray` returns `false` when we pass `middle` as the `k` parameter, set `right` to `middle - 1`.\n        - Else, set `left` to `middle + 1`.\n    - Return `left`, which is the earliest query that a zero array can be formed.\n    \n#### Implementation#### Complexity Analysis\n\nLet $N$ be the size of array `nums` and $M$ be the size of array `queries`.\n\n* Time Complexity: $O(log(M) \\cdot (N + M))$\n\n    We perform a binary search on `queries`, which repeatedly divides the search space in half at each step, leading to a time complexity of $log(M)$.\n\n    In each iteration of the binary search, we first iterate through the first `k` elements in `queries`. In the worst case, we have to iterate through each element when `k` is the size of `queries`, leading to a time complexity of $O(M)$.\n\n    From there, we iterate through each element of `nums` until one of the elements exceeds the value of `sum`. In the worst case, we have to iterate through each element in `nums` when this doesn't occur, leading to a time complexity of $O(N)$.\n\n    As a result, each iteration of the binary search has a time complexity of $O(N + M)$. Combining each iteration leads to a final time complexity of $O(log(M) \\cdot (N + M))$.\n\n* Space Complexity: $O(N)$\n\n    The space complexity is based on the array `differenceArray`. Here, `differenceArray` is set to hold elements from the range `[0, N + 1]` to track all the changes in `nums`. As a result, this creates a space complexity of $O(N + 1)$, which can be simplified to $O(N)$.\n\n---\n\n### Approach 2: Line Sweep\n\n#### Intuition\n\nIn our previous approach, we used binary search to determine how many queries were needed to turn `nums` into a zero array. This allowed us to efficiently process a subset of `queries`, applying them to a **difference array**, and then checking if `nums` had become all zeros. While this was an improvement over a naive approach, there was still an inefficiency: we were iterating over `queries` twice: once for binary search and again while applying updates.  \n\nTo optimize further, we can change our perspective on how we traverse the data. Instead of iterating through `queries`, we can iterate directly through `nums`, using it as the main loop. This means that as we process each element in `nums`, we dynamically apply only the necessary queries at the right moment. The key challenge, then, is finding an efficient way to apply queries while moving through `nums`.  \n\nThis is where a line sweep approach comes into play. Line sweeping is a technique that processes an array incrementally, maintaining only the relevant updates at each step. Instead of processing all queries upfront, we maintain an **active set of queries** and update `nums` only when necessary. Here, the **difference array** helps us track how `nums` is being modified, while `queries` provide the updates at specific points.  \n\nWe start at index `0` of `nums` and check if it can be turned into `0` with the queries we have processed so far. If it cannot be zeroed out, we process additional queries to apply their effects. The key observation is that at any index `i` in `nums`, a query `[left, right, val]` can fall into three possible cases:  \n\n1. If `i < left`, the query affects a later part of `nums`, so we store it for later processing.  \n2. If `left ≤ i ≤ right`, the query is immediately relevant and should be applied.  \n3. If `right < i`, the query is no longer useful for the current index and can be ignored.  \n\nFor example, if we're at index `4` in `nums` and the current query accesses the range `[0,2]`, we do not need to process that query and can simply move on to the next query.\n\nOtherwise, we continue to the next element of `nums`. We repeat this process until we reach the end of either `nums` or `queries`, where we then return either `k` or `-1`, respectively. \n\nThrough this process, we only have to iterate through both `nums` and `queries` at most once each while skipping over unnecessary queries.\n\n#### Algorithm\n- Initialize:\n    - `n` to the size of `nums`.\n    - `sum` to `0` to track the cumulative sum of updates applied up to a given index\n    - `k` to `0` to represent the number of queries used.\n    - `differenceArray` as a vector of integers set to size `n + 1` to apply range updates.\n- Iterate through `nums`. For each `index`:\n    - If `sum + differenceArray[index]` is less than `nums[index]`, meaning more operations need to be applied at the current index:\n        - Increase `k` by `1`.\n        - If `k` is greater than the size of `queries`, return `-1`, since we processed all the queries without reaching a zero array.\n        - Initialize `left`, `right`, and `val` to the respective values of the current query.\n        - If `right` is greater than or equal to `index`:\n            - Increment `differenceArray[max(left, index)]` by `val` to update the start of the range.\n            - Decrement `differenceArray[right + 1]` by `val` to update the end of the range.\n    - Increment `sum` by `differenceArray[index]`.\n- Return `k`.\n\n#### Implementation#### Complexity Analysis\n\nLet $N$ be the size of `nums` and $M$ be the size of `queries`.\n\n* Time Complexity: $O(N + M)$\n\n    We iterate through each element of `nums` at most once. Within this loop, we loop through each element of `queries` at most once. \n    \n    The program returns a value and ends when we reach the end of either of these arrays. In the worst case, we iterate through each element in `nums` and `queries` once before returning a value. As a result, this leads to a time complexity of $O(N + M)$.\n\n* Space Complexity: $O(N)$\n\n    The space complexity is based on the array `differenceArray`. Here, `differenceArray` is set to hold elements from the range `[0, N + 1]` to track all the changes in `nums`. As a result, this creates a space complexity of $O(N + 1)$, which can be simplified to $O(N)$.\n\n---"
}