{
  "title": "Freedom Trail",
  "problem_id": "514",
  "frontend_id": "514",
  "difficulty": "Hard",
  "problem_slug": "freedom-trail",
  "topics": [
    "String",
    "Dynamic Programming",
    "Depth-First Search",
    "Breadth-First Search"
  ],
  "description": "In the video game Fallout 4, the quest \"Road to Freedom\" requires players to reach a metal dial called the \"Freedom Trail Ring\" and use the dial to spell a specific keyword to open the door.\nGiven a string ring that represents the code engraved on the outer ring and another string key that represents the keyword that needs to be spelled, return the minimum number of steps to spell all the characters in the keyword.\nInitially, the first character of the ring is aligned at the \"12:00\" direction. You should spell all the characters in key one by one by rotating ring clockwise or anticlockwise to make each character of the string key aligned at the \"12:00\" direction and then by pressing the center button.\nAt the stage of rotating the ring to spell the key character key[i]:\nExample 1:\nExample 2:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: ring = \"godding\", key = \"gd\"\nOutput: 4\nExplanation:\nFor the first key character 'g', since it is already in place, we just need 1 step to spell this character. \nFor the second key character 'd', we need to rotate the ring \"godding\" anticlockwise by two steps to make it become \"ddinggo\".\nAlso, we need 1 more step for spelling.\nSo the final output is 4.",
      "images": [
        "https://assets.leetcode.com/uploads/2018/10/22/ring.jpg"
      ]
    },
    {
      "example_num": 2,
      "example_text": "Input: ring = \"godding\", key = \"godding\"\nOutput: 13",
      "images": [
        "https://assets.leetcode.com/uploads/2018/10/22/ring.jpg"
      ]
    }
  ],
  "constraints": [
    "1 <= ring.length, key.length <= 100",
    "ring and key consist of only lower case English letters.",
    "It is guaranteed that key could always be spelled by rotating ring."
  ],
  "follow_ups": [],
  "hints": [],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    int findRotateSteps(string ring, string key) {\n        \n    }\n};",
    "java": "class Solution {\n    public int findRotateSteps(String ring, String key) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def findRotateSteps(self, ring, key):\n        \"\"\"\n        :type ring: str\n        :type key: str\n        :rtype: int\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def findRotateSteps(self, ring: str, key: str) -> int:\n        ",
    "c": "int findRotateSteps(char* ring, char* key) {\n    \n}",
    "csharp": "public class Solution {\n    public int FindRotateSteps(string ring, string key) {\n        \n    }\n}",
    "javascript": "/**\n * @param {string} ring\n * @param {string} key\n * @return {number}\n */\nvar findRotateSteps = function(ring, key) {\n    \n};",
    "typescript": "function findRotateSteps(ring: string, key: string): number {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param String $ring\n     * @param String $key\n     * @return Integer\n     */\n    function findRotateSteps($ring, $key) {\n        \n    }\n}",
    "swift": "class Solution {\n    func findRotateSteps(_ ring: String, _ key: String) -> Int {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun findRotateSteps(ring: String, key: String): Int {\n        \n    }\n}",
    "dart": "class Solution {\n  int findRotateSteps(String ring, String key) {\n    \n  }\n}",
    "golang": "func findRotateSteps(ring string, key string) int {\n    \n}",
    "ruby": "# @param {String} ring\n# @param {String} key\n# @return {Integer}\ndef find_rotate_steps(ring, key)\n    \nend",
    "scala": "object Solution {\n    def findRotateSteps(ring: String, key: String): Int = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn find_rotate_steps(ring: String, key: String) -> i32 {\n        \n    }\n}",
    "racket": "(define/contract (find-rotate-steps ring key)\n  (-> string? string? exact-integer?)\n  )",
    "erlang": "-spec find_rotate_steps(Ring :: unicode:unicode_binary(), Key :: unicode:unicode_binary()) -> integer().\nfind_rotate_steps(Ring, Key) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec find_rotate_steps(ring :: String.t, key :: String.t) :: integer\n  def find_rotate_steps(ring, key) do\n    \n  end\nend"
  },
  "solution": "[TOC]\n\n## Solution\n\n---\n\n### Overview\n\nOur objective is to find the minimum number of steps required to spell the keyword (given as `key`), using the metal dial (given as `ring`). The characters of the keyword must be spelled in order.\n\nAny one of the following operations counts as one step:\n1. Rotate the metal dial clockwise by one place. \n2. Rotate the metal dial anticlockwise by one place. \n3. Press the center button to spell a character.\n\nWhen spelling a given character `key[i]`, the number of steps it takes to spell the character will be the number of rotations made to put the character in the `\"12:00\"` position plus one, which represents pressing the center button to spell the character.\n\n---\n\n### Approach 1: Top-Down Dynamic Programming\n\n#### Intuition\n\nWe want to find the minimum number of steps required to spell the keyword, which is made up of one or more characters. Let's start by finding the minimum number of steps required to spell one character. \n\nTo spell a character, we must align the character with the `\"12:00\"` direction on the metal dial `ring`. To determine the number of steps required to do so, let's define a function called `countSteps`. The parameters for this function are:\n- `curr`: the position, or index, in the `ring` of the character currently located at the `\"12:00\"` position.\n- `next`: the index in the `ring` of the character that needs to be spelled out in `key`.\n\nThe metal dial can be turned clockwise or anticlockwise to reach the desired character in `key`.  \n\nAssuming `curr` comes before `next`, we calculate the difference between `curr` and `next`, denoted as `curr - next`. Since `next` could be either before or after `curr`, potentially resulting in a negative difference, we obtain the absolute value of the difference to represent the number of steps between the indices. Let's store this value in the variable `stepsBetween`.\n\n> An example of this process is the string `godding`, where `'o'` is at index `1` and `'n'` is at index `5`. When `curr = 1` and `next = 5`, we compute `|5 - 1| = 4`, and when `cur = 5` and `next = 1`  we compute `|1 - 5| = 4`. \n>\n> |0|1|2|3|4|5|6|\n> |-|-|-|-|-|-|-|\n> |g|o|d|d|i|n|g|\n\nTo calculate the steps required to rotate from `curr` to `next` by wrapping around the metal dial, we subtract the value of `stepsBetween` from the length of the `ring`, denoted as `ringLength - stepsBetween`. Let's store this result in the variable `stepsAround`.\n\n> Using the previous example, traversing `'o'` to `'n'`,  `ringLength` is `7` and `stepsBetween` is 4.  `7 - 4 = 3`. \n\nFinally, `countSteps` returns the minimum of the two distances, `stepsAround` and `stepsBetween`.\n\n![Possible Paths Between o and n](../Figures/514/metal_dial.png)\n\n> Steps from `'o'` to `'n'` in `godding`.\n> - The red arrow represents `stepsBetween`, where `'n'` is reached without wrapping around the end of the string.\n> - The blue arrow represents `stepsAround`, where `'n'` is reached by wrapping around the end of the string.\n\n**`countSteps` function**    \n1. Calculate `stepsBetween` by taking the absolute value of `curr - next`.\n2. Calculate `stepsAround` using `ringLength - stepsBetween`.\n3. Return `min(steps_around, steps_between)`.\n\n**Brute Force**    \n\nTo achieve our goal using a naive approach, we could calculate the minimum steps for each character in the keyword individually and then sum them to find the minimum steps needed to spell the entire keyword. This method would be considered greedy because it selects the locally optimal next character. However, what if a word has multiple occurrences of the same character? \n\nLet's understand this through example. Assume the `ring` is `repetitive` and the key is `per`. \n\n|0|1|2|3|4|5|6|7|8|9|\n|-|-|-|-|-|-|-|-|-|-|\n|r|e|p|e|t|i|t|i|v|e|\n\nThere are at least two ways to spell the keyword:\n\n1. - Let's spell the `p` at index `2`. It will take `|2 - 0| + 1 = 3` steps.\n   - Then, let's choose the `e` at index `3`. It will take `|3 - 2| + 1 = 2` steps.\n   - Going back to `r` at index `0` will take `|0 - 3| + 1 = 4` steps.\n\n   This totals `9` steps.\n\n2. - Let's spell the `p` at index `2`. It will take `|2 - 0| + 1 = 3` steps.\n   - Then, let's choose the `e` at index `1`. It will take `|1 - 2| + 1 = 2` steps.\n   - Going back to `r` at index `0` will take `|0 - 1| + 1 = 2` steps.\n\n   This totals `7` steps.\n\nTherefore, we need to consider which character we were at previously.\n\nFor this problem, the greedy method does not lead to an optimal solution. If a word has multiple occurrences of the same character, the minimum steps to the next character are affected by which character was previously at the `\"12:00\"` position.\n\nWe will define a recursive function, `tryLock`, to calculate the number of steps to spell the keyword. The parameters are: \n- `ringIndex`: the current index of `ring`. \n- `keyIndex`: the current index of `key`.\n- `minSteps`: the minimum steps to spell the keyword so far. \n\nThis function returns the minimum number of steps required to spell the whole keyword, stored in the variable `minSteps`. \n\nWhen we reach the end of the keyword, we have spelled the whole word. Therefore, our base case is `keyIndex == key.length()`. At that point, the `keyIndex` is past the end of the keyword, and no steps need to be taken, so we return zero.\n\nGiven two characters, if there is only one occurrence of each character in `ring`, then there are only two ways between those characters. Our function `countSteps` will provide the number of steps of the better way. We simply need to add one to signify pressing the center button.\n\nTo find `minSteps` for the whole word based on a given choice between characters, we can recursively call `tryLock`, calculating the steps from the character we just visited to the next character in `key`. This will tell us how visiting a given occurrence of a character affects the overall `minSteps`. Since there are multiple options for spelling when there are multiple occurrences of a character, we will loop through the keyword and calculate `bestSteps` for each duplicate occurrence.\n\nWhen we call `tryLock`, we will pass the largest integer as a parameter because a path has not been determined between the zeroth index of `ring` and the first character in `key`. This way, when we update `minSteps`, the calculation will always be less than the initial amount, so we can accurately calculate the number of steps.\n\n**Brute Force Algorithm** \n\n1. Define a function `countSteps` that gives the minimum path between two indices of `ring`.\n2. Define a function `tryLock` that returns the minimum number of steps to spell the keyword. The parameters are `ringIndex`, the current index of `ring`, `keyIndex`, the current index of `key`, and `minSteps`, the minimum steps to spell the keyword so far:\n    1. If `key_index` is equal to `key.length()`, then return `0`; `key` has been spelled.\n    2. Iterate through each character in the `ring` using `i`:\n        1. If `ring[i]` equals the current character `key[keyIndex]`:\n            - Calculate `totalSteps`, the steps it takes to spell `key` when we visit `ring[i]` by adding the following three terms: \n                - The output of `countSteps` which finds the number of steps from the `ringIndex` to `ring[i]`.\n                - `1`, signifying pressing the center button.\n                - The output of `tryLock`, which calculates how many steps to each character in `key` are required if we choose to visit `ring[i]`.\n            - Save the minimum between `totalSteps` and the best so far in `minSteps`.\n    3. Return `minSteps`.\n3. Call `tryLock(0, 0, INT_MAX)` as we start with the zeroth index of `ring` in the  `\"12:00\"` position and start spelling with the first character in `key`. The largest integer is passed as the final parameter because a path has not been determined between the zeroth index of `ring` and the first character in `key`.This solution is inefficient and is not accepted because the time limit is exceeded. We compute the output of the same argument multiple times. \n\n![repeated_subproblems](../Figures/514/repeated_subproblems.png)\n\nIs there a more efficient way to solve this problem? The problem involves finding a minimum, which is a hint that it could be solved with a greedy or dynamic programming approach. Since one decision affects others, a greedy approach is not likely to solve the problem, but dynamic programming could be an effective approach. Can we use dynamic programming to make this approach more efficient?  \n\n> Dynamic programming is a programming paradigm in which we break a problem into sub-problems, store the result of each sub-problem, and use it when required. If you are not familiar with dynamic programming, we recommend checking out [Dynamic Programming Explore Card](https://leetcode.com/explore/featured/card/dynamic-programming/).\n\nWe can optimize our calculations by storing values as we calculate them. To do this, we can utilize a map called `bestSteps`, where we store the best path we have found to reach a particular `keyIndex` of `key` when the `ringIndex` of `ring` is aligned with the `\"12:00\"` position. \n\nWe adjust our `tryLock` function in two ways:\n1. We check whether the `ringIndex` and `keyIndex` pair is already in the map. If it is, we return the stored `minSteps` value.\n2. We only calculate the optimum for new `(ringIndex, keyIndex)` pairs, and when we do, we add them to the map.\n\nThis approach saves computational time by avoiding redundant calculations and utilizing stored values whenever possible.\n\n#### Algorithm\n\n1. Define a function `countSteps` that gives the minimum path between two indices of `ring`.\n2. Create the variables `ringLen` to store the length of the `ring` and `keyLen` to store the length of the `key`.\n3. Create a map, `bestSteps`, to store the minimum number of steps to find the character at `keyIndex` when the `ringIndex` of `ring` is aligned with the `\"12:00\"` position. \n4. Define a function `tryLock` that returns the minimum number of steps to spell the keyword. The parameters are `ringIndex`, `keyIndex`, and `minSteps`, the minimum steps to spell the keyword so far:\n    1. Check whether `keyIndex` equals `keyLen`; if so return `0`; `key` has been spelled.\n    2. Check whether the `(ringIndex, keyIndex)` pair is in `bestSteps`. If it is, return `bestSteps[ringIndex][keyIndex]`; we have already calculated the best path.\n    3. Iterate through each `charIndex` in `ring`:\n        1. If `ring[charIndex]` equals the current character `key[keyIndex]`:\n           - Calculate `totalSteps`, the steps it takes to spell `key` when we visit this occurrence of `ring[charIndex]` by adding the following three terms:\n                - The output of `countSteps`, which finds the number of steps from the `ringIndex` to the `ring[charIndex]`.\n                - `1`, which signifies pressing the center button.\n                - The output of `tryLock`, which calculates the number of steps to each character in `key`, granted we chose to visit this occurrence of `ring[charIndex]`.\n            - Save the minimum between `totalSteps` and the best so far in `minSteps`.\n            - Save the `minSteps` for this `(ringIndex, keyIndex)` pair in `bestSteps`.\n    4. Return `minSteps`.\n5. Call `tryLock(0, 0, INT_MAX)` as we start with the zeroth index of `ring` in the `\"12:00\"` position and start spelling with the first character in `key`. The largest integer is passed as the final parameter because a path has not been determined between the zeroth index of `ring` and the first character in `key`.\n\n#### Implementation#### Complexity Analysis\n\nLet $R$ be the length of `ring` and $K$ be the length of `key`.\n\n* Time Complexity: $O(K \\cdot R^2)$. \n\n    When every character in `ring` is unique, $K$ recursive calls are made, one for each letter in the keyword.\n    \n    At worst, when every character of `ring` is the same, we initially call `trylock` $R$ times. For each of these $R$ recursive calls, `tryLock` is called for each occurrence of the character in `ring` for each character in the keyword. This means the `trylock` function is called a total of $R \\cdot K \\cdot R$ times.\n    \n    Therefore, the overall time complexity is $O(K \\cdot R^2)$.\n\n* Space Complexity: $O(K \\cdot R)$ \n\n    $O(K \\cdot R)$ space is used for the map. The call stack can grow as deep as $K$ since a recursive call is made for each character in `key`. This makes the overall space complexity $O(K \\cdot R)$.\n\n---\n\n### Approach 2: Bottom-Up Dynamic Programming \n\n#### Intuition\n\nThe top-down solution involves recursion, which requires a significant amount of overhead to maintain the call stack. We can convert our top-down solution to a bottom-up solution to save space. \n\nWe can utilize the previously defined `tryLock` function. Additionally, we create a variable `ringLen` to store the length of the `ring` and a variable `keyLen` to store the length of the `key`.\n\nIn our top-down solution, we use a map `bestSteps` to store the minimum number of steps to `keyIndex` starting from the `ringIndex` of `ring`. To generate a bottom-up solution, we will use a 2D array `bestSteps[ringIndex][keyIndex]` to store the minimum number of steps to the `keyIndex` when the `ringIndex` of `ring` is aligned with the `\"12:00\"` position.\n\nWe declare the 2D array `bestSteps` with `ringLen` in the `ringIndex` dimension and `keyLen + 1` in the `keyIndex` dimension because our base case is when the whole `key` has been spelled, and zero additional steps need to be taken. We initialize every value in the array to the largest integer value. This way, when we iterate through the array updating the minimum number of steps, the steps calculation will always be less than the initialized amount, allowing us to correctly calculate the number of steps.\n\nIn a bottom-up solution, we start by addressing the base case. For every index pair `(ringIndex, keyLen)` in `bestSteps`, we initialize the value to zero because when the entire `key` has been spelled, no additional steps are needed.\n\nOur bottom-up solution will be iterative. We need to iterate through both dimensions of `bestSteps`, so we'll use a nested for loop. We iterate through the indices `keyIndex` of `key`, starting with the last character in `key`, and for each, we iterate through the indices `ringIndex` of `ring`.\n\nSimilar to our top-down solution, we iterate through the characters using `charIndex` of `ring`, searching for indices in `ring` that contain the same character as `key[keyIndex]`. Each iteration of the innermost loop represents a state. We can utilize the function call we made in the top-down solution to build our recurrence relation. The calculations we performed in the top-down solution will be replicated here, but instead of recursion, we'll use our array `bestSteps`.\n\nThe recurrence relation calculates the minimum number of steps to find the character at `keyIndex` of `key` when the `ringIndex` of `ring` is aligned with the `\"12:00\"` position. Our recurrence relation is:\n\n> `bestSteps[r][k] = min(bestSteps[r][k], 1 + countSteps[r, charIndex] + bestSteps[charIndex][key_index + 1])` \n\nThe terms in the recurrence relation represent: \n\n- `bestSteps[ringIndex][keyIndex]`: the previous minimum number of steps to that occurrence of that character. \n- `countSteps[ringIndex, charIndex]`: the minimum number of steps between the `ringIndex` aligned with the `\"12:00\"` position of `ring`, and the index of `charIndex`, the next character of the `key`.\n- `1`: represents selecting the character by pressing the center button.\n- `bestSteps[charIndex][keyIndex + 1]`: the number of steps it took to reach `charIndex` from the last character `key[keyIndex + 1]` the `ring` spelled.\n\nAfter iterating through both strings, we return `bestSteps[0][0]` which stores the minimum number of steps it took to spell `key` when `ring` begins with its zeroth index in the `\"12:00\"` position.\n\n#### Algorithm\n\n1. Define a function `countSteps` that gives the minimum path between two indices of `ring`.\n2. Create the variables `ringLen` to store the length of `ring` and `keyLen` to store the length of `key`.\n3. Declare a 2D array `bestSteps`. It will have `ringLen` rows and `keyLen + 1` columns. \n\n    > `bestSteps` has one extra column because we want to store the base case of `0` steps. \n    \n4. Initialize all values in `bestSteps` to the largest integer to indicate that a path has not been determined.\n5. Set each index `ringIndex, keyLength` of `bestSteps`, to `0` for the base case of zero steps.\n6. Iterate from the end to the beginning of `key` with `keyIndex` and through `ring` with `ringIndex`:\n    - For each character `ring[charIndex]` in `ring`:\n        - If `ring[charIndex]` equals `key` at `keyIndex`: Use the recurrence relation `bestSteps[ringIndex][k] = min(bestSteps[ringIndex][k], 1 + countSteps[ringIndex, charIndex] + bestSteps[charIndex][keyIndex + 1])` to calculate the minimum number of steps to find the character at `keyIndex` of the keyword when the `ringIndex` of `ring` is aligned with the `\"12:00\"` position. \n7. Return `bestSteps[0][0]` which stores the minimum number of steps to spell `key` when `ring` begins with its zeroth index in the `\"12:00\"` position.\n\n#### Implementation#### Complexity Analysis\n\nLet $R$ be the length of `ring` and $K$ be the length of `key`.\n\n* Time Complexity: $O(K \\cdot R^2)$\n\n    We use nested loops iterating $K$ times through `key` and $R$ times through `ring` for all $R$ characters in `ring`. This gives an overall time complexity of $O(K \\cdot R^2)$.\n\n* Space Complexity: $O(KR)$ \n\n    We use a 2D array with the dimensions $K + 1$ and $R$.\n\n---\n\n### Approach 3: Space-Optimized Bottom-Up Dynamic Programming\n\n#### Intuition\n\nUpon analyzing the bottom-up solution, we observe that when calculating the minimum number of steps for the `keyIndex` column of `bestSteps`, the only other column we refer to is the `keyIndex + 1` column. This means we can space-optimize the bottom-up solution, using two 1-D arrays to store the step calculations we need to reference. One array is for the current column, and the other array is for the previous column.\n\nWe will create the array `prev` to store the values of the last column and `curr` to store the values of the current column. We initialize the indices of `prev` to zero to represent that when the whole `key` has been spelled, zero additional steps need to be taken. We initialize the indices of `curr` to the largest integer to indicate that a path has not been determined between those indices.\n\nFor the space-optimized approach, we iterate through `key` and `ring` similarly to the bottom-up approach, but we adjust the recurrence relation to use our two columns `prev` and `curr`. \n\nThe recurrence relation finds the minimum number of steps to find the `key[keyIndex]` when the `ring[ringIndex]` is aligned with the `\"12:00\"` position and stores it in `curr[ringIndex]`. The adjusted relation is:\n\n`curr[ringIndex] = min(curr[ringIndex], 1 + countSteps[ringIndex, charIndex] + prev[charIndex])` \n\nThe terms in the recurrence relation represent:\n\n- `curr[ringIndex]`: the current minimum number of steps to that index. \n- `1`: represents selecting the character by pressing the center button.\n- `countSteps[ringIndex, charIndex]`: gives the minimum number of steps between `ringIndex`, the index aligned with the position of `ring`, and the index of `charIndex`, the next character of the `key`.\n- `prev[charIndex]`: the number of steps it took to reach `charIndex` from the last character the `key[keyIndex + 1]` the `ring` spelled.\n  \nAfter iterating through both strings, we return `prev[0]` which stores the minimum number of steps to spell `key` when `ring` begins with its index `0` in the `\"12:00\"` position.\n\n#### Algorithm\n\n1. Define a function `countSteps` that gives the minimum path between two indices of `ring`.\n2. Create the variables `ringLen` to store the length of `ring` and `keyLen` to store the length of `key`.\n3. Declare a 1D array `prev` of size `ringLen` to store the previous column and initialize all indices to `0` for the base case of zero steps.\n4. Declare a 1D array `curr` of size `ringLen` to store the current column and initialize all indices to the largest integer to indicate that a path has not been determined.\n5. Iterate from the end to the beginning of `key` with `keyIndex`:\n    - Reset all of the indices of `curr` to the largest integer.\n    - For each character `charIndex` in `ring`:\n        - If `ring` at `charIndex` equals `key` at `keyIndex`:\n        - Use the recurrence relation `curr[ringIndex] = min(curr[ringIndex], 1 + countSteps[ringIndex, charIndex] + prev[charIndex])` to calculate the minimum number of steps to find the character at `keyIndex` of key when the `ringIndex` of `ring` is aligned with the `\"12:00\"` position. \n    - Set `prev` to `curr`.\n6. Return `prev[0]` which stores the minimum number of steps to spell `key` when `ring` begins with its zeroth index in the `\"12:00\"` position.\n\n#### Implementation#### Complexity Analysis\n\nLet $R$ be the length of `ring` and $K$ be the length of `key`.\n\n* Time Complexity: $O(K \\cdot R^2)$ \n\n    We use nested loops iterating $K$ times through `key` and $R$ times through `ring` for all $R$ characters in `ring`. This gives an overall time complexity of $O(K \\cdot R^2)$.\n\n* Space Complexity: $O(R)$. \n\n    We used two arrays of length $R$ to store the minimum steps between the characters. This gives an overall space complexity of $O(R)$.\n\n---\n\n### Approach 4: Shortest Path\n\n#### Intuition\n\nIf we think of the possible paths between the characters as a graph, we can spell the keyword using a modified Dijkstra’s algorithm. Dijkstra’s algorithm is used to find the shortest path from a source vertex to each of the other vertices in a weighted graph. It uses a priority queue (min-heap) to greedily determine which edges to use to find the shortest path to the other vertices.\n\n> If you are not familiar with Dijkstra’s algorithm, we suggest you read our relevant [Leetcode Explore Card](https://leetcode.com/explore/featured/card/graph/622/single-source-shortest-path-algorithm/3862/).\n\nWe discussed in the first approach that a greedy solution that just considers the locally optimal next character will not solve the problem optimally. This shortest path solution works because we always choose the next character with the shortest total steps, not the shortest next steps.\n\nFor our purposes, each vertex is a character in the `ring` that is present in the keyword.\n\nDijkstra's algorithm generally uses an adjacency list that contains the neighbors of each vertex. We must visit vertices, or characters, in a certain order to spell the keyword. We need to decide which occurrence of a given character in `ring` we should visit. We use a hash map that stores the indices of each character in `ring`, where the key is the character and the value is the list of indices where it occurs in `ring`. The duplicate occurrences of specific characters are the \"neighbors\".\n\nDijkstra's algorithm often uses a data structure to store vertices that have already been visited. We can use a hash map to store `(keyIndex, ringIndex)` pairs we have seen before.\n\nWe can track how many steps it takes to spell each character with `totalSteps`.\n\nWe use a min-heap to store the steps it takes to spell a given character in the keyword from a given index in `ring`. We start by adding the initial indices to the heap.\n\nWhen we reach the end of the keyword, we have spelled the whole word. Therefore, our base case is when `keyIndex` equals `keyLen`. `totalSteps` accounts for the steps taken to spell the characters in the keyword but does not account for pressing the center button to spell a character. We press the center button exactly `keyLen` times to spell the keyword, once for each character. Therefore, we return the sum of `totalSteps` and `keyLen`.\n\nWhen the keyword has not yet been spelled, we first check whether this `(keyIndex, ringIndex)` pair has been seen before. If so, we continue.\n\nIf we haven't seen this pair before, we need to find the minimum number of steps between the current and next character of the keyword using the metal dial.\n\nFor each occurrence of the current `key[keyIndex]` in `ring`, `nextIndex`, we add an entry to the heap that represents turning the metal dial to the next character in the keyword. The entry consists of three parts:\n- `totalSteps`: the sum of `toalSteps` and the output of `count_steps(ringIndex, nextIndex)`.\n- `nextIndex`: the index of `ring` that will be at the `\"12:00\"` position, and\n- `keyIndex + 1`: the next character in the keyword.\n\nOnce the keyword has been spelled, we will have the answer, because we have greedily chosen the next character with the lowest total steps.\n\n![graph](../Figures/514/graph.png)\n\n> Possible paths to spell the keyword visualized as a graph. The shortest path is highlighted in green.\n\n#### Algorithm\n\n1. Define a function `countSteps` that gives the minimum path between two indices of `ring`.\n2. Create the variables `ringLen` to store the length of `ring` and `keyLen` to store the length of `key`.\n3. Create a hash map `characterIndices` and add each character in `ring` as a key and a list with the indices of the occurrences as the value.\n4. Initialize a priority queue (min-heap) `heap` that stores the `totalSteps` for a `ringIndex` and `keyIndex` pair. The top of the heap will contain the smallest `totalSteps`. Add the starting steps, ring position, and key position, which are all `0` to the heap.\n5. Create a hash set `seen` to store `ringIndex` and `keyIndex` pairs we have already seen.\n6. While the `heap` is not empty:\n    - Pop the element from the top of the heap.\n    - Check whether the `keyIndex` equals the `keyLen`. If so, we have spelled the whole keyword.\n    - Check whether this `ringIndex` and `keyIndex` pair has already been seen. If so, continue.\n    - Otherwise, add this `ringIndex` and `keyIndex` pair to `seen`.\n    - For each occurrence `nextIndex` in `ring` of the letter `key[keyIndex]`:\n        - Add a heap entry that calculates the steps from `nextIndex` to the next character in `key`. The values for this entry are as follows:\n        - `totalSteps`: `totalSteps + count_steps(ringIndex, nextIndex)`.\n        - `ringIndex`: `nextIndex`.\n        - `keyIndex`: `keyIndex + 1`.\n7. Return `totalSteps + keyLen`. We add `keyLen` to the steps to account for the center button being pressed once for each character in `key`.\n\n#### Implementation#### Complexity Analysis\n\nLet $R$ be the length of `ring` and $K$ be the length of `key`. \n\n* Time complexity: $O(RK \\cdot \\log (RK))$\n\n    Building the `characterIndices` hashmap takes $O(R)$ time as we add an entry for each character in `ring`.\n\n    The main loop will run once for each pair that we visit. We use the `seen` set, so we never visit the same `(keyIndex, ringIndex)` pair more than once. The maximum number of pairs we visit is the number of unique possible pairs, which is $R \\cdot K$.\n     \n    Looking up a pair in `seen` takes $O(1)$ time in the average case.\n\n    It takes the priority queue $O(RK \\cdot \\log (RK))$ time to push or pop $R \\cdot K$ elements from the queue.\n\n    Therefore, the overall time complexity is $O(RK \\cdot \\log (RK))$.\n\n* Space complexity: $O(R \\cdot K)$\n\n    The `characterIndices` hashmap is size $R$ because it stores a total of $R$ `(character, index)` mappings.\n\n    The main space used is by the priority queue, which can store up to $R \\cdot K$ pairs.\n\n    We also use the `seen` hash set, which can grow up to size $R \\cdot K$.\n\n---"
}