{
  "title": "Matrix Diagonal Sum",
  "problem_id": "1677",
  "frontend_id": "1572",
  "difficulty": "Easy",
  "problem_slug": "matrix-diagonal-sum",
  "topics": [
    "Array",
    "Matrix"
  ],
  "description": "Given a square matrix mat, return the sum of the matrix diagonals.\nOnly include the sum of all the elements on the primary diagonal and all the elements on the secondary diagonal that are not part of the primary diagonal.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: mat = [[1,2,3],\n              [4,5,6],\n              [7,8,9]]\nOutput: 25\nExplanation: Diagonals sum: 1 + 5 + 9 + 3 + 7 = 25\nNotice that element mat[1][1] = 5 is counted only once.",
      "images": [
        "https://assets.leetcode.com/uploads/2020/08/14/sample_1911.png"
      ]
    },
    {
      "example_num": 2,
      "example_text": "Input: mat = [[1,1,1,1],\n              [1,1,1,1],\n              [1,1,1,1],\n              [1,1,1,1]]\nOutput: 8",
      "images": [
        "https://assets.leetcode.com/uploads/2020/08/14/sample_1911.png"
      ]
    },
    {
      "example_num": 3,
      "example_text": "Input: mat = [[5]]\nOutput: 5",
      "images": [
        "https://assets.leetcode.com/uploads/2020/08/14/sample_1911.png"
      ]
    }
  ],
  "constraints": [
    "n == mat.length == mat[i].length",
    "1 <= n <= 100",
    "1 <= mat[i][j] <= 100"
  ],
  "follow_ups": [],
  "hints": [
    "There will be overlap of elements in the primary and secondary diagonals if and only if the length of the matrix is odd, which is at the center."
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    int diagonalSum(vector<vector<int>>& mat) {\n        \n    }\n};",
    "java": "class Solution {\n    public int diagonalSum(int[][] mat) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def diagonalSum(self, mat):\n        \"\"\"\n        :type mat: List[List[int]]\n        :rtype: int\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def diagonalSum(self, mat: List[List[int]]) -> int:\n        ",
    "c": "int diagonalSum(int** mat, int matSize, int* matColSize) {\n    \n}",
    "csharp": "public class Solution {\n    public int DiagonalSum(int[][] mat) {\n        \n    }\n}",
    "javascript": "/**\n * @param {number[][]} mat\n * @return {number}\n */\nvar diagonalSum = function(mat) {\n    \n};",
    "typescript": "function diagonalSum(mat: number[][]): number {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param Integer[][] $mat\n     * @return Integer\n     */\n    function diagonalSum($mat) {\n        \n    }\n}",
    "swift": "class Solution {\n    func diagonalSum(_ mat: [[Int]]) -> Int {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun diagonalSum(mat: Array<IntArray>): Int {\n        \n    }\n}",
    "dart": "class Solution {\n  int diagonalSum(List<List<int>> mat) {\n    \n  }\n}",
    "golang": "func diagonalSum(mat [][]int) int {\n    \n}",
    "ruby": "# @param {Integer[][]} mat\n# @return {Integer}\ndef diagonal_sum(mat)\n    \nend",
    "scala": "object Solution {\n    def diagonalSum(mat: Array[Array[Int]]): Int = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn diagonal_sum(mat: Vec<Vec<i32>>) -> i32 {\n        \n    }\n}",
    "racket": "(define/contract (diagonal-sum mat)\n  (-> (listof (listof exact-integer?)) exact-integer?)\n  )",
    "erlang": "-spec diagonal_sum(Mat :: [[integer()]]) -> integer().\ndiagonal_sum(Mat) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec diagonal_sum(mat :: [[integer]]) :: integer\n  def diagonal_sum(mat) do\n    \n  end\nend"
  },
  "solution": "[TOC]\n\n## Solution\n\n---\n\n### Overview\n\nWe are given a square matrix `mat`. Our task is to return the sum of the elements on the primary and secondary diagonals without counting any element twice (if it occurs on both the diagonals).\n\n---\n\n### Approach: Iterating over Diagonal Elements\n\n#### Intuition\n\nWe can see that elements along the primary diagonals have the same row and column number. So, all elements of the form `mat[i][i]` with `i` ranging from `i = 0` to `i = n - 1`, where `n` is the number of rows (or columns) in `mat`, form the primary diagonal.\n\nLet's form the secondary diagnal starting with the last row and first column, i.e., `mat[n - 1][0]`. `mat[n - 2][1]` is the next element over the secondary diagonal, one row up and one column ahead. The following element, `mat[n - 3][2]`, is again one row up and one column ahead of the previous element. The final element is `mat[0][n - 1]`. We can notice that the sum of the row and column numbers is constant (`n - 1`) because the column increases by one but the row decreases by one. As a result, all elements of the form `mat[n - 1 - i][i]` with `i` ranging from `i = 0` to `i = n - 1` constitute the secondary diagonal.\n\nWhen we compare a square matrix with an odd number of rows to a square matrix with an even number of rows, we notice that there is a common element `mat[n / 2][n / 2]` at the intersection of the primary and secondary diagonals in the case of the matrix with odd rows:\n\n![img](../Figures/1572/1572-1.png)\n\nWe add the elements on the primary and secondary diagonals and deduct the common element if number of rows in `mat` is odd. \n\n#### Algorithm\n\n1. Create an integer `n` that stores the number of rows (or columns) in `mat`.\n2. Create an answer variable `ans` which will store the sum of elements on the primary and secondary diagonals. Initialize it to `0`.\n2. Iterate from `i = 0` to `i = n - 1`:\n    - Add elements on the primary diagonal to `ans`. We perform `ans += mat[i][i]`.\n    - Add elements on the secondary diagonal to `ans`. We perform `ans += mat[n - 1 - i][i]`.\n3. If the number of rows in `mat` is odd, we have a common element between the primary and secondary diagonals. We decrement it from `ans`. We perform `ans -= mat[n / 2][n / 2]`.\n4. Return `ans`.\n\n#### Implementation#### Complexity Analysis\n\nHere, $n$ is the number of rows (or columns) in `mat`.\n\n* Time complexity: $O(n)$\n\n    - We iterate over primary and secondary diagonals which requires $O(n)$ time each.\n\n* Space complexity: $O(1)$\n\n    - Except using fews like integer `n` and `ans`, which take constant space, we do not consume any other space."
}