{
  "title": "Minimum Number of Vertices to Reach All Nodes",
  "problem_id": "1661",
  "frontend_id": "1557",
  "difficulty": "Medium",
  "problem_slug": "minimum-number-of-vertices-to-reach-all-nodes",
  "topics": [
    "Graph"
  ],
  "description": "Given a directed acyclic graph, with n vertices numbered from 0 to n-1, and an array edges where edges[i] = [fromi, toi] represents a directed edge from node fromi to node toi.\nFind the smallest set of vertices from which all nodes in the graph are reachable. It's guaranteed that a unique solution exists.\nNotice that you can return the vertices in any order.\nExample 1:\nExample 2:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: n = 6, edges = [[0,1],[0,2],[2,5],[3,4],[4,2]]\nOutput: [0,3]\nExplanation: It's not possible to reach all the nodes from a single vertex. From 0 we can reach [0,1,2,5]. From 3 we can reach [3,4,2,5]. So we output [0,3].",
      "images": [
        "https://assets.leetcode.com/uploads/2020/07/07/untitled22.png"
      ]
    },
    {
      "example_num": 2,
      "example_text": "Input: n = 5, edges = [[0,1],[2,1],[3,1],[1,4],[2,4]]\nOutput: [0,2,3]\nExplanation: Notice that vertices 0, 3 and 2 are not reachable from any other node, so we must include them. Also any of these vertices can reach nodes 1 and 4.",
      "images": [
        "https://assets.leetcode.com/uploads/2020/07/07/untitled.png"
      ]
    }
  ],
  "constraints": [
    "2 <= n <= 10^5",
    "1 <= edges.length <= min(10^5, n * (n - 1) / 2)",
    "edges[i].length == 2",
    "0 <= fromi, toi < n",
    "All pairs (fromi, toi) are distinct."
  ],
  "follow_ups": [],
  "hints": [
    "A node that does not have any incoming edge can only be reached by itself.",
    "Any other node with incoming edges can be reached from some other node.",
    "We only have to count the number of nodes with zero incoming edges."
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    vector<int> findSmallestSetOfVertices(int n, vector<vector<int>>& edges) {\n        \n    }\n};",
    "java": "class Solution {\n    public List<Integer> findSmallestSetOfVertices(int n, List<List<Integer>> edges) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def findSmallestSetOfVertices(self, n, edges):\n        \"\"\"\n        :type n: int\n        :type edges: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def findSmallestSetOfVertices(self, n: int, edges: List[List[int]]) -> List[int]:\n        ",
    "c": "/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nint* findSmallestSetOfVertices(int n, int** edges, int edgesSize, int* edgesColSize, int* returnSize) {\n    \n}",
    "csharp": "public class Solution {\n    public IList<int> FindSmallestSetOfVertices(int n, IList<IList<int>> edges) {\n        \n    }\n}",
    "javascript": "/**\n * @param {number} n\n * @param {number[][]} edges\n * @return {number[]}\n */\nvar findSmallestSetOfVertices = function(n, edges) {\n    \n};",
    "typescript": "function findSmallestSetOfVertices(n: number, edges: number[][]): number[] {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param Integer $n\n     * @param Integer[][] $edges\n     * @return Integer[]\n     */\n    function findSmallestSetOfVertices($n, $edges) {\n        \n    }\n}",
    "swift": "class Solution {\n    func findSmallestSetOfVertices(_ n: Int, _ edges: [[Int]]) -> [Int] {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun findSmallestSetOfVertices(n: Int, edges: List<List<Int>>): List<Int> {\n        \n    }\n}",
    "dart": "class Solution {\n  List<int> findSmallestSetOfVertices(int n, List<List<int>> edges) {\n    \n  }\n}",
    "golang": "func findSmallestSetOfVertices(n int, edges [][]int) []int {\n    \n}",
    "ruby": "# @param {Integer} n\n# @param {Integer[][]} edges\n# @return {Integer[]}\ndef find_smallest_set_of_vertices(n, edges)\n    \nend",
    "scala": "object Solution {\n    def findSmallestSetOfVertices(n: Int, edges: List[List[Int]]): List[Int] = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn find_smallest_set_of_vertices(n: i32, edges: Vec<Vec<i32>>) -> Vec<i32> {\n        \n    }\n}",
    "racket": "(define/contract (find-smallest-set-of-vertices n edges)\n  (-> exact-integer? (listof (listof exact-integer?)) (listof exact-integer?))\n  )",
    "erlang": "-spec find_smallest_set_of_vertices(N :: integer(), Edges :: [[integer()]]) -> [integer()].\nfind_smallest_set_of_vertices(N, Edges) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec find_smallest_set_of_vertices(n :: integer, edges :: [[integer]]) :: [integer]\n  def find_smallest_set_of_vertices(n, edges) do\n    \n  end\nend"
  }
}