{
  "title": "Most Profitable Path in a Tree",
  "problem_id": "2564",
  "frontend_id": "2467",
  "difficulty": "Medium",
  "problem_slug": "most-profitable-path-in-a-tree",
  "topics": [
    "Array",
    "Tree",
    "Depth-First Search",
    "Breadth-First Search",
    "Graph"
  ],
  "description": "There is an undirected tree with n nodes labeled from 0 to n - 1, rooted at node 0. You are given a 2D integer array edges of length n - 1 where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the tree.\nAt every node i, there is a gate. You are also given an array of even integers amount, where amount[i] represents:\nThe game goes on as follows:\nReturn the maximum net income Alice can have if she travels towards the optimal leaf node.\nExample 1:\nExample 2:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: edges = [[0,1],[1,2],[1,3],[3,4]], bob = 3, amount = [-2,4,2,-4,6]\nOutput: 6\nExplanation: \nThe above diagram represents the given tree. The game goes as follows:\n- Alice is initially on node 0, Bob on node 3. They open the gates of their respective nodes.\n  Alice's net income is now -2.\n- Both Alice and Bob move to node 1. \n  Since they reach here simultaneously, they open the gate together and share the reward.\n  Alice's net income becomes -2 + (4 / 2) = 0.\n- Alice moves on to node 3. Since Bob already opened its gate, Alice's income remains unchanged.\n  Bob moves on to node 0, and stops moving.\n- Alice moves on to node 4 and opens the gate there. Her net income becomes 0 + 6 = 6.\nNow, neither Alice nor Bob can make any further moves, and the game ends.\nIt is not possible for Alice to get a higher net income.",
      "images": [
        "https://assets.leetcode.com/uploads/2022/10/29/eg1.png"
      ]
    },
    {
      "example_num": 2,
      "example_text": "Input: edges = [[0,1]], bob = 1, amount = [-7280,2350]\nOutput: -7280\nExplanation: \nAlice follows the path 0->1 whereas Bob follows the path 1->0.\nThus, Alice opens the gate at node 0 only. Hence, her net income is -7280.",
      "images": [
        "https://assets.leetcode.com/uploads/2022/10/29/eg2.png"
      ]
    }
  ],
  "constraints": [
    "2 <= n <= 105",
    "edges.length == n - 1",
    "edges[i].length == 2",
    "0 <= ai, bi < n",
    "ai != bi",
    "edges represents a valid tree.",
    "1 <= bob < n",
    "amount.length == n",
    "amount[i] is an even integer in the range [-104, 104]."
  ],
  "follow_ups": [],
  "hints": [
    "Bob travels along a fixed path (from node “bob” to node 0).",
    "Calculate Alice’s distance to each node via DFS.",
    "We can calculate Alice’s score along a path ending at some node easily using Hints 1 and 2."
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    int mostProfitablePath(vector<vector<int>>& edges, int bob, vector<int>& amount) {\n        \n    }\n};",
    "java": "class Solution {\n    public int mostProfitablePath(int[][] edges, int bob, int[] amount) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def mostProfitablePath(self, edges, bob, amount):\n        \"\"\"\n        :type edges: List[List[int]]\n        :type bob: int\n        :type amount: List[int]\n        :rtype: int\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def mostProfitablePath(self, edges: List[List[int]], bob: int, amount: List[int]) -> int:\n        ",
    "c": "int mostProfitablePath(int** edges, int edgesSize, int* edgesColSize, int bob, int* amount, int amountSize) {\n    \n}",
    "csharp": "public class Solution {\n    public int MostProfitablePath(int[][] edges, int bob, int[] amount) {\n        \n    }\n}",
    "javascript": "/**\n * @param {number[][]} edges\n * @param {number} bob\n * @param {number[]} amount\n * @return {number}\n */\nvar mostProfitablePath = function(edges, bob, amount) {\n    \n};",
    "typescript": "function mostProfitablePath(edges: number[][], bob: number, amount: number[]): number {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param Integer[][] $edges\n     * @param Integer $bob\n     * @param Integer[] $amount\n     * @return Integer\n     */\n    function mostProfitablePath($edges, $bob, $amount) {\n        \n    }\n}",
    "swift": "class Solution {\n    func mostProfitablePath(_ edges: [[Int]], _ bob: Int, _ amount: [Int]) -> Int {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun mostProfitablePath(edges: Array<IntArray>, bob: Int, amount: IntArray): Int {\n        \n    }\n}",
    "dart": "class Solution {\n  int mostProfitablePath(List<List<int>> edges, int bob, List<int> amount) {\n    \n  }\n}",
    "golang": "func mostProfitablePath(edges [][]int, bob int, amount []int) int {\n    \n}",
    "ruby": "# @param {Integer[][]} edges\n# @param {Integer} bob\n# @param {Integer[]} amount\n# @return {Integer}\ndef most_profitable_path(edges, bob, amount)\n    \nend",
    "scala": "object Solution {\n    def mostProfitablePath(edges: Array[Array[Int]], bob: Int, amount: Array[Int]): Int = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn most_profitable_path(edges: Vec<Vec<i32>>, bob: i32, amount: Vec<i32>) -> i32 {\n        \n    }\n}",
    "racket": "(define/contract (most-profitable-path edges bob amount)\n  (-> (listof (listof exact-integer?)) exact-integer? (listof exact-integer?) exact-integer?)\n  )",
    "erlang": "-spec most_profitable_path(Edges :: [[integer()]], Bob :: integer(), Amount :: [integer()]) -> integer().\nmost_profitable_path(Edges, Bob, Amount) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec most_profitable_path(edges :: [[integer]], bob :: integer, amount :: [integer]) :: integer\n  def most_profitable_path(edges, bob, amount) do\n    \n  end\nend"
  },
  "solution": "[TOC]\n\n## Solution\n\n---\n\n### Overview\n\nWe are given a tree with `n` nodes, where `n - 1` edges define its structure. The tree is rooted at node `0`. Additionally, we are provided with an array `amount` of size `n`, where each element represents the value of a node. All values in `amount` are even integers. Finally, we are given an integer `bob`, which indicates the starting node for Bob.\n\nThe two players Alice and Bob, traverse the tree simultaneously under the following conditions:\n\n1. Alice starts at node `0` and moves towards a leaf node (a node with only one connection).\n2. Bob starts at node `bob` and moves towards node `0` along the shortest path.\n\nFor each node visited, the income calculations follow these rules:\n- If a player reaches a node first, they collect the full value of that node.\n- If both players arrive at the same node at the same time, they split the value equally.\n- If a node was previously visited by the other player, no income is collected.\n\nOur goal is to find the largest (maximum) income Alice can collect by choosing an optimal path toward a leaf node.\n\nLet's look at an example of finding the maximum income that Alice can achieve:\n\n!?!../Documents/2467/slideshow.json:960,540!?! \n\nIn the given example, Bob’s path is fixed since he must travel toward node 0, while Alice has multiple choices for reaching a leaf. Some paths might yield higher income than others due to how Bob’s movements impact the node values. The key is to strategically choose a path that maximizes Alice’s total earnings.\n\n---\n\n### Approach 1: Depth-First Search and Breadth-First Search\n\n#### Intuition\n\nWe need to find Bob’s path to node `0` and then find the best path Alice can take to maximize her collected amount. Since Bob only has one possible path to node `0` — the unique path from his starting position to the root — we can take advantage of this structure to track Bob’s travel time across each node. \n\nTo find Bob’s path, we use [Depth-First Search (DFS)](https://leetcode.com/explore/learn/card/queue-stack/232/practical-application-stack/). DFS is a natural choice because it fully explores each path before backtracking, allowing us to efficiently find the path Bob follows to the root. As we traverse, we record how long it takes Bob to reach each node along his path. Nodes not on this path are ignored since Bob never visits them.\n\nOnce Bob’s path is established, our next goal is to find Alice’s optimal path to a leaf node. Unlike Bob, Alice has multiple choices since a tree can have multiple leaves. This means we need an approach that considers all possible paths efficiently.\n\nFor this, we use [Breadth-First Search (BFS)](https://leetcode.com/explore/learn/card/queue-stack/231/practical-application-queue/). BFS systematically explores all nodes level by level, making it ideal for finding optimal paths. We start at the root node (`0`) and explore all adjacent nodes before moving deeper into the tree. This ensures that every possible path Alice can take is considered.\n\nAs Alice traverses, we use Bob’s path information to determine how much of the amount Alice can collect from each node. If Alice reaches a node before Bob, she takes the **full amount**. If Alice and Bob arrive at the same time, Alice only takes **half**. If Alice arrives after Bob, she gets **nothing** from that node.\n\nWhenever Alice reaches a leaf node, we check her accumulated income along that path. If it is greater than the maximum recorded income, we update our maximum. By the end of the BFS traversal, we will have explored all valid paths for Alice and can return the highest income she can achieve.\n\n#### Algorithm\n\n- Initialize `tree` as an adjacency list to store the tree structure.\n- Initialize `bobPath` as a hashmap to track how long it takes Bob to traverse from one node to another.\n- Initialize `visited` as an array of boolean values to track the explored nodes.\n- Store the number of nodes `n`.\n\n- Define a Depth-First Search (DFS) function `findBobPath`:\n    - Set `bobPath[sourceNode]` to `time` and `visited[sourceNode]` to `true` to mark the current node as explored.\n    - If `sourceNode` is 0, return `true`.\n    - Iterate through `adjacentNode` of `sourceNode`:\n        - If `visited[adjacentNode]` is set to `false`, recursively call `findBobPath` for the child node and return `true`.\n    - Remove `sourceNode`  from `bobPath` and return `false`, indicating that `sourceNode` is not part of Bob's path.\n\n- Define `mostProfitablePath` function:\n    - Initialize `maxIncome` to 0 to track the maximum income path.\n    - Initialize `nodeQueue` as a queue of integer arrays of size `3`, starting with an initial element `{0,0,0}`.\n    - Set `n` as the number of nodes.\n    - Resize `tree` to store `n` empty lists.\n    - Resize `visited` to store `n` boolean values and set each value to `false`.\n    - Iterate through `edges` and build the adjacency list representation of the tree.\n    - Call `findBobPath(bob, 0)` to build Bob's path.\n    - Set the values of `visited` back to `false`.\n    - Iterate through the elements in `nodeQueue`. For each element:\n        - Initialize `sourceNode`, `time`, and `income` to the values of the top element of `nodeQueue`.\n        - If Alice reaches the node first (`sourceNode` is not in `bobPath` or `bobPath[sourceNode] > time`), add `amount[sourceNode]` to `income`.\n        - If Alice and Bob reach the node at the same time (`bobPath[sourceNode] == time`), add half of `amount[sourceNode]` to `income`.\n        - If Alice reached a leaf node (`tree[sourceNode]` only has one value and `sourceNode` is not `0`), set `maxIncome` to the maximum of `maxIncome` and `income`.\n        - Iterate through `adjacentNode` of `sourceNode`:\n            - If `visited[adjacentNode]` is set to `false`:, push an array consisting of `adjacentNode`, `time + 1`, and `income` into `nodeQueue`.\n        - Set `visited[sourceNode]` as `true` to mark the current node as explored.\n        - Remove the current element from `nodeQueue`.\n    - Return `maxIncome`.\n\n#### Implementation#### Complexity Analysis\n\nLet $n$ be the number of nodes in the tree.\n\n* Time Complexity: $O(n)$\n\n    To begin, to add all the edges to `tree`, we have to iterate through all the elements of `edges`, which is of size $n - 1$. This leads to a time complexity of $O(n - 1)$, which can be simplified to $O(n)$.\n\n    Next, we have to figure out how long it takes Bob to find the optimal path to node 0. In the worst case, a depth-first search for Bob's path takes $O(n)$ time if Bob traverses through every node to reach node `0`. This leads to a time complexity of $O(n)$.\n\n    Finally, we need to calculate the time it takes for Alice to find the optimal path to a leaf node. Here, a breadth-first search traverses each node until every node has been explored. This leads to a time complexity of $O(n)$.\n\n    Combining these time complexities, the overall time complexity of this solution is $O(3 \\cdot n)$, which can be simplified to $O(n)$.\n\n* Space Complexity: $O(n)$\n    \n    The space complexity is determined by the `bobPath` hashmap, `visited` and `tree` arrays,  `nodeQueue` queue, and the recursive stack.\n\n    Firstly, `bobPath` stores the nodes that bob traverses to reach node 0. In the worst case, Bob has to traverse through every node to reach his destination, leading to a space complexity of $O(n)$.\n\n    The `visited` array is initialized to hold `n` boolean values corresponding to each node, leading to a space complexity of $O(n)$.\n\n    The `tree` 2D array is initialized to hold $n$ nodes and $n - 1$ edges. Across all the nodes, the total number of elements stored in the array is $2 \\cdot (n - 1)$, since each edge is stored twice, once for each node. This leads to a space complexity of $O(2 \\cdot (n - 1))$, which simplifies to $O(n)$.\n\n    The `nodeQueue` queue tracks all the nodes being traversed in the breadth-first search. In the worst case, `nodeQueue` holds all the nodes in the tree if all other nodes are directly adjacent to node 0. This leads to a space complexity of $O(n)$.\n\n    Finally, the recursive stack stores the recursive calls performed in the depth-first search to find Bob's path. Its space is determined by the height of the tree. In the worst case, Bob has to linearly traverse through every node to reach his destination, leading to a space complexity of $O(n)$.\n\n    Combining these space complexities, the overall space complexity of this solution is $O(5 \\cdot n)$, which can be simplified to $O(n)$.\n\n---\n\n### Approach 2: Two Depth-First Searches\n\n#### Intuition\n\nIn the previous approach, we used BFS to explore all possible paths Alice could take. However, BFS requires maintaining a queue to track nodes at each level, which can introduce overhead when dealing with large trees. Each node needs to be added and removed from the queue multiple times, leading to additional memory usage.\n\nTo optimize this, we can replace BFS with DFS for Alice’s traversal. DFS naturally fits the problem because we can reuse the recursive call stack instead of an explicit queue, reducing memory overhead. This makes the approach more space-efficient while still ensuring that all paths are explored.\n\nWe start with a **DFS traversal to find Bob’s path** to node `0`. This step remains unchanged from the previous approach. We record the time Bob takes to reach each node along his path. This information will be used later to determine how much Alice can collect from each node.\n\nOnce Bob’s path is identified, we initiate **another DFS traversal for Alice**. During this traversal, we recursively explore each path from node `0` to a leaf, keeping track of Alice’s time and accumulated income. At each node, we compare Alice’s arrival time with Bob’s recorded time:\n- If Alice arrives **before** Bob, she collects the full amount.\n- If Alice and Bob arrive **at the same time**, she collects half.\n- If Alice arrives **after** Bob, she collects nothing.\n\nSince DFS explores one path at a time before backtracking, when Alice reaches a leaf node, we record her total collected income and compare it to the current maximum. We repeat this process until all paths are explored. \n\nBy the end of the traversal, we will have determined the largest income Alice can achieve and return this value as the result.\n\n#### Algorithm\n\n- Initialize `maxIncome` to 0 to track the maximum income path.\n- Initialize `tree` as an adjacency list to store the tree structure.\n- Initialize `bobPath` as a hashmap to track how long it takes Bob to traverse from one node to another.\n- Initialize `visited` as an array of boolean values to track the explored nodes.\n- Store the number of nodes `n`.\n\n- Define a Depth-First Search (DFS) function `findBobPath`:\n    - Set `bobPath[sourceNode]` to `time` and `visited[sourceNode]` to `true` to mark the current node as explored.\n    - If `sourceNode` is 0, return `true`.\n    - Iterate through `adjacentNode` of `sourceNode`:\n        - If `visited[adjacentNode]` is set to `false`, recursively call `findBobPath` for the child node and return `true`.\n    - Remove `sourceNode`  from `bobPath` and return `false`, indicating that `sourceNode` is not part of Bob's path.\n\n- Define a Depth-First Search (DFS) function  `findAlicePath`:\n    - Set `visited[sourceNode]` to `true` to mark the current node as explored.\n    - If Alice and Bob reach the node at the same time (`bobPath[sourceNode] == time`), add half of `amount[sourceNode]` to `income`.\n    - If Alice reached a leaf node (`tree[sourceNode]` only has one value and `sourceNode` is not `0`), set `maxIncome` to the maximum of `maxIncome` and `income`.\n    - If Alice reached a leaf node (`tree[sourceNode]` only has one value and `sourceNode` is not `0`), set `maxIncome` to the maximum of `maxIncome` and `income`.\n    - Iterate through `adjacentNode` of `sourceNode`:\n        - If `visited[adjacentNode]` is set to `false`, recursively call `findAlicePath` for the child node.\n\n- Define `mostProfitablePath` function:\n    - Set `n` as the number of nodes.\n    - Resize `tree` to store `n` empty lists.\n    - Resize `visited` to store `n` boolean values and set each value to `false`.\n    - Iterate through `edges` and build the adjacency list representation of the tree.\n    - Call `findBobPath(bob, 0)` to build Bob's path.\n    - Set the values of `visited` back to `false`.\n    - Call `findAlicePath(0, 0, 0, amount)` to find Alice's optimal path, starting from the root node.\n    - Return `maxIncome`.\n\n#### Implementation#### Complexity Analysis\n\nLet $n$ be the number of nodes in the tree.\n\n* Time Complexity: $O(n)$\n\n    To begin, to add all the edges to `tree`, we have to iterate through all the elements of `edges`, which is of size $n - 1$. This leads to a time complexity of $O(n - 1)$, which can be simplified to $O(n)$.\n\n    Next, we have to figure out how long it takes Bob to find the optimal path to node 0. In the worst case, a depth-first search for Bob's path takes $O(n)$ time if Bob traverses through every node to reach node 0. This leads to a time complexity of $O(n)$.\n\n    Finally, the recursive stack stores the recursive calls performed in the depth-first search to find Bob's path. Its space is determined by the height of the tree. In the worst case, Bob has to linearly traverse through every node to reach his destination, leading to a space complexity of $O(n)$.\n\n    Combining these time complexities, the overall time complexity of this solution is $O(3 \\cdot n)$, which can be simplified to $O(n)$.\n\n* Space Complexity: $O(n)$\n    \n    The space complexity is determined by the hashmap `bobPath`, arrays `visited` and `tree`, queue `nodeQueue`, and recursive stack.\n\n    Firstly, `bobPath` stores the nodes that Bob traverses to reach node `0`. In the worst case, Bob has to traverse through every node to reach his destination, leading to a space complexity of $O(n)$.\n\n    The `visited` array is initialized to hold `n` boolean values, leading to a space complexity of $O(n)$.\n\n    The `tree` 2D array is initialized to hold $n$ nodes and $n - 1$ edges. Across all the nodes, the total number of elements stored in the array is $2(n - 1)$, since each edge is stored twice, once for each node. This leads to a space complexity of $O(2(n - 1))$, which simplifies to $O(n)$.\n\n    Finally, the recursive stack stores the recursive calls performed in the depth-first search to find Bob's path. Its space is determined by the height of the tree. In the worst case, Bob has to linearly traverse through every node to reach his destination, leading to a space complexity of $O(n)$.\n\n    Combining these space complexities, the overall space complexity of this solution is $O(4 \\cdot n)$, which can be simplified to $O(n)$.\n\n---\n\n### Approach 3: Depth-First Search \n\n#### Intuition\n\nThe previous solution used two separate DFS traversals: one to determine Bob’s path and another to explore Alice’s optimal path. However, this causes redundancy, as each node may be visited twice. Instead, we can optimize the process by combining both tasks into a **single DFS traversal**, ensuring that we only explore each node once.\n\nOur strategy is to use DFS to simultaneously track Bob’s path and compute Alice’s best possible income. Here, we first establish Bob’s travel time to each node. We initialize all node distances to `n`, a value greater than any possible travel time. As we traverse the tree, if a node is part of Bob’s path to `0`, we update its distance to reflect how long it takes for Bob to reach it. Nodes not on Bob’s path retain their initial value, ensuring that they are always considered as being reached **after** Alice.\n\nWith Bob’s travel times recorded, we can now determine how much Alice collects from each node while recursively traversing the tree. As Alice moves, we compare her arrival time at each node to Bob’s recorded time. If she reaches a node before Bob, she collects the **full amount**. If she and Bob arrive at the same time, she gets **half**. If she arrives after Bob, she receives **nothing**. By structuring the traversal this way, Alice's maximum income is updated dynamically as she moves deeper into the tree. This ensures that we efficiently compute the highest possible income while keeping the traversal to just one DFS pass.\n\n#### Algorithm\n\n- Initialize `tree` as an adjacency list to store the tree structure.\n- Initialize `distanceFromBob` as an array to store the shortest distance of each node from Bob.\n- Store the number of nodes `n`.\n\n- Define a Depth-First Search (DFS) function `findPaths`:\n  - Initialize `maxIncome` to 0 and `maxChild` to `INT_MIN` to track the maximum income path.\n  - If `sourceNode` is `bob`, set its distance to 0; otherwise, set it to `n` (a large value).\n  - Iterate through `adjacentNode` of `sourceNode`:\n    - If `adjacentNode` is not `parentNode`, recursively call `findPaths` for the child node.\n    - Update `distanceFromBob[sourceNode]` as the minimum of its current value and the child's distance plus one.\n  - If Alice reaches the node first (`distanceFromBob[sourceNode] > time`), add the node’s `amount` to `maxIncome`.\n  - If Alice and Bob reach the node at the same time (`distanceFromBob[sourceNode] == time`), add half of `amount[sourceNode]` to `maxIncome`.\n  - If `maxChild` remains `INT_MIN`, return `maxIncome` (indicating a leaf node).\n  - Otherwise, return `maxIncome + maxChild` (adding the best income from child nodes).\n\n- Define `mostProfitablePath` function:\n  - Set `n` as the number of nodes.\n  - Resize `tree` to store `n` empty lists.\n  - Iterate through `edges` and build the adjacency list representation of the tree.\n  - Resize `distanceFromBob` to store `n` distances.\n  - Return the result of `findPaths(0, 0, 0, bob, amount)`, starting from the root node.\n\n#### Implementation#### Complexity Analysis\n\nLet $n$ be the number of nodes in the tree.\n\n* Time Complexity: $O(n)$\n\n    To begin, to add all the edges to `tree`, we have to iterate through all the elements of `edges`, which is size $n - 1$. This leads to a time complexity of $O(n - 1)$, which can be simplified to $O(n)$.\n\n    Then, we have to figure out how long it takes for Bob to find the path to node `0` and Alice to find an optimal path to a leaf node. Here, a depth-first search visits each node once to process Alice's maximum income based on Bob's distance from his starting point at each node. This leads to a time complexity of $O(n)$.\n\n    Combining these time complexities, the overall time complexity of this solution is $O(2 \\cdot n)$, which can be simplified to $O(n)$.\n\n* Space Complexity: $O(n)$\n    \n    The space complexity is determined by the `distanceFromBob` and `tree` arrays and the recursive stack.\n\n    Firstly, `distanceFromBob` checks every node in the tree, checking if they were traversed by Bob and, if so, how far they are from Bob's starting point. This leads to a space complexity of $O(n)$.\n\n    Next, the `tree` 2D array is initialized to hold $n$ nodes and $n - 1$ edges. Across all the nodes, the total number of elements stored in the array is $2 \\cdot (n - 1)$, since each edge is stored twice, once for each node. This leads to a space complexity of $O(2 \\cdot (n - 1))$, which simplifies to $O(n)$.\n\n    Finally, the recursive stack stores the recursive calls performed in the depth-first search to find Bob's path. Its space is determined by the height of the tree. In the worst case, Bob has to linearly traverse through every node to reach his destination, leading to a space complexity of $O(n)$.\n\n    Combining these space complexities, the overall space complexity of this solution is $O(3 \\cdot n)$, which can be simplified to $O(n)$.\n\n---"
}