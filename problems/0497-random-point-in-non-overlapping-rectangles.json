{
  "title": "Random Point in Non-overlapping Rectangles",
  "problem_id": "914",
  "frontend_id": "497",
  "difficulty": "Medium",
  "problem_slug": "random-point-in-non-overlapping-rectangles",
  "topics": [
    "Array",
    "Math",
    "Binary Search",
    "Reservoir Sampling",
    "Prefix Sum",
    "Ordered Set",
    "Randomized"
  ],
  "description": "You are given an array of non-overlapping axis-aligned rectangles rects where rects[i] = [ai, bi, xi, yi] indicates that (ai, bi) is the bottom-left corner point of the ith rectangle and (xi, yi) is the top-right corner point of the ith rectangle. Design an algorithm to pick a random integer point inside the space covered by one of the given rectangles. A point on the perimeter of a rectangle is included in the space covered by the rectangle.\nAny integer point inside the space covered by one of the given rectangles should be equally likely to be returned.\nNote that an integer point is a point that has integer coordinates.\nImplement the Solution class:\nExample 1:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input\n[\"Solution\", \"pick\", \"pick\", \"pick\", \"pick\", \"pick\"]\n[[[[-2, -2, 1, 1], [2, 2, 4, 6]]], [], [], [], [], []]\nOutput\n[null, [1, -2], [1, -1], [-1, -2], [-2, -2], [0, 0]]\n\nExplanation\nSolution solution = new Solution([[-2, -2, 1, 1], [2, 2, 4, 6]]);\nsolution.pick(); // return [1, -2]\nsolution.pick(); // return [1, -1]\nsolution.pick(); // return [-1, -2]\nsolution.pick(); // return [-2, -2]\nsolution.pick(); // return [0, 0]",
      "images": [
        "https://assets.leetcode.com/uploads/2021/07/24/lc-pickrandomrec.jpg"
      ]
    }
  ],
  "constraints": [
    "1 <= rects.length <= 100",
    "rects[i].length == 4",
    "-109 <= ai < xi <= 109",
    "-109 <= bi < yi <= 109",
    "xi - ai <= 2000",
    "yi - bi <= 2000",
    "All the rectangles do not overlap.",
    "At most 104 calls will be made to pick."
  ],
  "follow_ups": [],
  "hints": [],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    Solution(vector<vector<int>>& rects) {\n        \n    }\n    \n    vector<int> pick() {\n        \n    }\n};\n\n/**\n * Your Solution object will be instantiated and called as such:\n * Solution* obj = new Solution(rects);\n * vector<int> param_1 = obj->pick();\n */",
    "java": "class Solution {\n\n    public Solution(int[][] rects) {\n        \n    }\n    \n    public int[] pick() {\n        \n    }\n}\n\n/**\n * Your Solution object will be instantiated and called as such:\n * Solution obj = new Solution(rects);\n * int[] param_1 = obj.pick();\n */",
    "python": "class Solution(object):\n\n    def __init__(self, rects):\n        \"\"\"\n        :type rects: List[List[int]]\n        \"\"\"\n        \n\n    def pick(self):\n        \"\"\"\n        :rtype: List[int]\n        \"\"\"\n        \n\n\n# Your Solution object will be instantiated and called as such:\n# obj = Solution(rects)\n# param_1 = obj.pick()",
    "python3": "class Solution:\n\n    def __init__(self, rects: List[List[int]]):\n        \n\n    def pick(self) -> List[int]:\n        \n\n\n# Your Solution object will be instantiated and called as such:\n# obj = Solution(rects)\n# param_1 = obj.pick()",
    "c": "\n\n\ntypedef struct {\n    \n} Solution;\n\n\nSolution* solutionCreate(int** rects, int rectsSize, int* rectsColSize) {\n    \n}\n\nint* solutionPick(Solution* obj, int* retSize) {\n    \n}\n\nvoid solutionFree(Solution* obj) {\n    \n}\n\n/**\n * Your Solution struct will be instantiated and called as such:\n * Solution* obj = solutionCreate(rects, rectsSize, rectsColSize);\n * int* param_1 = solutionPick(obj, retSize);\n \n * solutionFree(obj);\n*/",
    "csharp": "public class Solution {\n\n    public Solution(int[][] rects) {\n        \n    }\n    \n    public int[] Pick() {\n        \n    }\n}\n\n/**\n * Your Solution object will be instantiated and called as such:\n * Solution obj = new Solution(rects);\n * int[] param_1 = obj.Pick();\n */",
    "javascript": "/**\n * @param {number[][]} rects\n */\nvar Solution = function(rects) {\n    \n};\n\n/**\n * @return {number[]}\n */\nSolution.prototype.pick = function() {\n    \n};\n\n/** \n * Your Solution object will be instantiated and called as such:\n * var obj = new Solution(rects)\n * var param_1 = obj.pick()\n */",
    "typescript": "class Solution {\n    constructor(rects: number[][]) {\n        \n    }\n\n    pick(): number[] {\n        \n    }\n}\n\n/**\n * Your Solution object will be instantiated and called as such:\n * var obj = new Solution(rects)\n * var param_1 = obj.pick()\n */",
    "php": "class Solution {\n    /**\n     * @param Integer[][] $rects\n     */\n    function __construct($rects) {\n        \n    }\n  \n    /**\n     * @return Integer[]\n     */\n    function pick() {\n        \n    }\n}\n\n/**\n * Your Solution object will be instantiated and called as such:\n * $obj = Solution($rects);\n * $ret_1 = $obj->pick();\n */",
    "swift": "\nclass Solution {\n\n    init(_ rects: [[Int]]) {\n        \n    }\n    \n    func pick() -> [Int] {\n        \n    }\n}\n\n/**\n * Your Solution object will be instantiated and called as such:\n * let obj = Solution(rects)\n * let ret_1: [Int] = obj.pick()\n */",
    "kotlin": "class Solution(rects: Array<IntArray>) {\n\n    fun pick(): IntArray {\n        \n    }\n\n}\n\n/**\n * Your Solution object will be instantiated and called as such:\n * var obj = Solution(rects)\n * var param_1 = obj.pick()\n */",
    "dart": "class Solution {\n\n  Solution(List<List<int>> rects) {\n    \n  }\n  \n  List<int> pick() {\n    \n  }\n}\n\n/**\n * Your Solution object will be instantiated and called as such:\n * Solution obj = Solution(rects);\n * List<int> param1 = obj.pick();\n */",
    "golang": "type Solution struct {\n    \n}\n\n\nfunc Constructor(rects [][]int) Solution {\n    \n}\n\n\nfunc (this *Solution) Pick() []int {\n    \n}\n\n\n/**\n * Your Solution object will be instantiated and called as such:\n * obj := Constructor(rects);\n * param_1 := obj.Pick();\n */",
    "ruby": "class Solution\n\n=begin\n    :type rects: Integer[][]\n=end\n    def initialize(rects)\n        \n    end\n\n\n=begin\n    :rtype: Integer[]\n=end\n    def pick()\n        \n    end\n\n\nend\n\n# Your Solution object will be instantiated and called as such:\n# obj = Solution.new(rects)\n# param_1 = obj.pick()",
    "scala": "class Solution(_rects: Array[Array[Int]]) {\n\n    def pick(): Array[Int] = {\n        \n    }\n\n}\n\n/**\n * Your Solution object will be instantiated and called as such:\n * val obj = new Solution(rects)\n * val param_1 = obj.pick()\n */",
    "rust": "struct Solution {\n\n}\n\n\n/** \n * `&self` means the method takes an immutable reference.\n * If you need a mutable reference, change it to `&mut self` instead.\n */\nimpl Solution {\n\n    fn new(rects: Vec<Vec<i32>>) -> Self {\n        \n    }\n    \n    fn pick(&self) -> Vec<i32> {\n        \n    }\n}\n\n/**\n * Your Solution object will be instantiated and called as such:\n * let obj = Solution::new(rects);\n * let ret_1: Vec<i32> = obj.pick();\n */",
    "racket": "(define solution%\n  (class object%\n    (super-new)\n    \n    ; rects : (listof (listof exact-integer?))\n    (init-field\n      rects)\n    \n    ; pick : -> (listof exact-integer?)\n    (define/public (pick)\n      )))\n\n;; Your solution% object will be instantiated and called as such:\n;; (define obj (new solution% [rects rects]))\n;; (define param_1 (send obj pick))",
    "erlang": "-spec solution_init_(Rects :: [[integer()]]) -> any().\nsolution_init_(Rects) ->\n  .\n\n-spec solution_pick() -> [integer()].\nsolution_pick() ->\n  .\n\n\n%% Your functions will be called as such:\n%% solution_init_(Rects),\n%% Param_1 = solution_pick(),\n\n%% solution_init_ will be called before every test case, in which you can do some necessary initializations.",
    "elixir": "defmodule Solution do\n  @spec init_(rects :: [[integer]]) :: any\n  def init_(rects) do\n    \n  end\n\n  @spec pick() :: [integer]\n  def pick() do\n    \n  end\nend\n\n# Your functions will be called as such:\n# Solution.init_(rects)\n# param_1 = Solution.pick()\n\n# Solution.init_ will be called before every test case, in which you can do some necessary initializations."
  }
}