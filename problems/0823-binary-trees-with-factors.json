{
  "title": "Binary Trees With Factors",
  "problem_id": "843",
  "frontend_id": "823",
  "difficulty": "Medium",
  "problem_slug": "binary-trees-with-factors",
  "topics": [
    "Array",
    "Hash Table",
    "Dynamic Programming",
    "Sorting"
  ],
  "description": "Given an array of unique integers, arr, where each integer arr[i] is strictly greater than 1.\nWe make a binary tree using these integers, and each number may be used for any number of times. Each non-leaf node's value should be equal to the product of the values of its children.\nReturn the number of binary trees we can make. The answer may be too large so return the answer modulo 109 + 7.\nExample 1:\nExample 2:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: arr = [2,4]\nOutput: 3\nExplanation: We can make these trees: [2], [4], [4, 2, 2]",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input: arr = [2,4,5,10]\nOutput: 7\nExplanation: We can make these trees: [2], [4], [5], [10], [4, 2, 2], [10, 2, 5], [10, 5, 2].",
      "images": []
    }
  ],
  "constraints": [
    "1 <= arr.length <= 1000",
    "2 <= arr[i] <= 109",
    "All the values of arr are unique."
  ],
  "follow_ups": [],
  "hints": [],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    int numFactoredBinaryTrees(vector<int>& arr) {\n        \n    }\n};",
    "java": "class Solution {\n    public int numFactoredBinaryTrees(int[] arr) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def numFactoredBinaryTrees(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: int\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def numFactoredBinaryTrees(self, arr: List[int]) -> int:\n        ",
    "c": "int numFactoredBinaryTrees(int* arr, int arrSize) {\n    \n}",
    "csharp": "public class Solution {\n    public int NumFactoredBinaryTrees(int[] arr) {\n        \n    }\n}",
    "javascript": "/**\n * @param {number[]} arr\n * @return {number}\n */\nvar numFactoredBinaryTrees = function(arr) {\n    \n};",
    "typescript": "function numFactoredBinaryTrees(arr: number[]): number {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param Integer[] $arr\n     * @return Integer\n     */\n    function numFactoredBinaryTrees($arr) {\n        \n    }\n}",
    "swift": "class Solution {\n    func numFactoredBinaryTrees(_ arr: [Int]) -> Int {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun numFactoredBinaryTrees(arr: IntArray): Int {\n        \n    }\n}",
    "dart": "class Solution {\n  int numFactoredBinaryTrees(List<int> arr) {\n    \n  }\n}",
    "golang": "func numFactoredBinaryTrees(arr []int) int {\n    \n}",
    "ruby": "# @param {Integer[]} arr\n# @return {Integer}\ndef num_factored_binary_trees(arr)\n    \nend",
    "scala": "object Solution {\n    def numFactoredBinaryTrees(arr: Array[Int]): Int = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn num_factored_binary_trees(arr: Vec<i32>) -> i32 {\n        \n    }\n}",
    "racket": "(define/contract (num-factored-binary-trees arr)\n  (-> (listof exact-integer?) exact-integer?)\n  )",
    "erlang": "-spec num_factored_binary_trees(Arr :: [integer()]) -> integer().\nnum_factored_binary_trees(Arr) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec num_factored_binary_trees(arr :: [integer]) :: integer\n  def num_factored_binary_trees(arr) do\n    \n  end\nend"
  }
}