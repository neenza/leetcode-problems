{
  "title": "Maximum Score After Applying Operations on a Tree",
  "problem_id": "3191",
  "frontend_id": "2925",
  "difficulty": "Medium",
  "problem_slug": "maximum-score-after-applying-operations-on-a-tree",
  "topics": [
    "Dynamic Programming",
    "Tree",
    "Depth-First Search"
  ],
  "description": "There is an undirected tree with n nodes labeled from 0 to n - 1, and rooted at node 0. You are given a 2D integer array edges of length n - 1, where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the tree.\nYou are also given a 0-indexed integer array values of length n, where values[i] is the value associated with the ith node.\nYou start with a score of 0. In one operation, you can:\nA tree is healthy if the sum of values on the path from the root to any leaf node is different than zero.\nReturn the maximum score you can obtain after performing these operations on the tree any number of times so that it remains healthy.\nExample 1:\nExample 2:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: edges = [[0,1],[0,2],[0,3],[2,4],[4,5]], values = [5,2,5,2,1,1]\nOutput: 11\nExplanation: We can choose nodes 1, 2, 3, 4, and 5. The value of the root is non-zero. Hence, the sum of values on the path from the root to any leaf is different than zero. Therefore, the tree is healthy and the score is values[1] + values[2] + values[3] + values[4] + values[5] = 11.\nIt can be shown that 11 is the maximum score obtainable after any number of operations on the tree.",
      "images": [
        "https://assets.leetcode.com/uploads/2023/10/11/graph-13-1.png"
      ]
    },
    {
      "example_num": 2,
      "example_text": "Input: edges = [[0,1],[0,2],[1,3],[1,4],[2,5],[2,6]], values = [20,10,9,7,4,3,5]\nOutput: 40\nExplanation: We can choose nodes 0, 2, 3, and 4.\n- The sum of values on the path from 0 to 4 is equal to 10.\n- The sum of values on the path from 0 to 3 is equal to 10.\n- The sum of values on the path from 0 to 5 is equal to 3.\n- The sum of values on the path from 0 to 6 is equal to 5.\nTherefore, the tree is healthy and the score is values[0] + values[2] + values[3] + values[4] = 40.\nIt can be shown that 40 is the maximum score obtainable after any number of operations on the tree.",
      "images": [
        "https://assets.leetcode.com/uploads/2023/10/11/graph-14-2.png"
      ]
    }
  ],
  "constraints": [
    "2 <= n <= 2 * 104",
    "edges.length == n - 1",
    "edges[i].length == 2",
    "0 <= ai, bi < n",
    "values.length == n",
    "1 <= values[i] <= 109",
    "The input is generated such that edges represents a valid tree."
  ],
  "follow_ups": [],
  "hints": [
    "Let <code>dp[i]</code> be the maximum score we can get on the subtree rooted at <code>i</code> and <code>sum[i]</code> be the sum of all the values of the subtree rooted at <code>i</code>.",
    "If we don’t take <code>value[i]</code> into the final score, we can take all the nodes of the subtrees rooted at <code>i</code>’s children.",
    "If we take <code>value[i]</code> into the score, then each subtree rooted at its children should satisfy the constraints.",
    "<code>dp[x] = max(value[x] + sigma(dp[y]), sigma(sum[y]))</code>, where <code>y</code> is a direct child of <code>x</code>."
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    long long maximumScoreAfterOperations(vector<vector<int>>& edges, vector<int>& values) {\n        \n    }\n};",
    "java": "class Solution {\n    public long maximumScoreAfterOperations(int[][] edges, int[] values) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def maximumScoreAfterOperations(self, edges, values):\n        \"\"\"\n        :type edges: List[List[int]]\n        :type values: List[int]\n        :rtype: int\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def maximumScoreAfterOperations(self, edges: List[List[int]], values: List[int]) -> int:\n        ",
    "c": "long long maximumScoreAfterOperations(int** edges, int edgesSize, int* edgesColSize, int* values, int valuesSize) {\n    \n}",
    "csharp": "public class Solution {\n    public long MaximumScoreAfterOperations(int[][] edges, int[] values) {\n        \n    }\n}",
    "javascript": "/**\n * @param {number[][]} edges\n * @param {number[]} values\n * @return {number}\n */\nvar maximumScoreAfterOperations = function(edges, values) {\n    \n};",
    "typescript": "function maximumScoreAfterOperations(edges: number[][], values: number[]): number {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param Integer[][] $edges\n     * @param Integer[] $values\n     * @return Integer\n     */\n    function maximumScoreAfterOperations($edges, $values) {\n        \n    }\n}",
    "swift": "class Solution {\n    func maximumScoreAfterOperations(_ edges: [[Int]], _ values: [Int]) -> Int {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun maximumScoreAfterOperations(edges: Array<IntArray>, values: IntArray): Long {\n        \n    }\n}",
    "dart": "class Solution {\n  int maximumScoreAfterOperations(List<List<int>> edges, List<int> values) {\n    \n  }\n}",
    "golang": "func maximumScoreAfterOperations(edges [][]int, values []int) int64 {\n    \n}",
    "ruby": "# @param {Integer[][]} edges\n# @param {Integer[]} values\n# @return {Integer}\ndef maximum_score_after_operations(edges, values)\n    \nend",
    "scala": "object Solution {\n    def maximumScoreAfterOperations(edges: Array[Array[Int]], values: Array[Int]): Long = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn maximum_score_after_operations(edges: Vec<Vec<i32>>, values: Vec<i32>) -> i64 {\n        \n    }\n}",
    "racket": "(define/contract (maximum-score-after-operations edges values)\n  (-> (listof (listof exact-integer?)) (listof exact-integer?) exact-integer?)\n  )",
    "erlang": "-spec maximum_score_after_operations(Edges :: [[integer()]], Values :: [integer()]) -> integer().\nmaximum_score_after_operations(Edges, Values) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec maximum_score_after_operations(edges :: [[integer]], values :: [integer]) :: integer\n  def maximum_score_after_operations(edges, values) do\n    \n  end\nend"
  }
}