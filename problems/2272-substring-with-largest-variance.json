{
  "title": "Substring With Largest Variance",
  "problem_id": "2360",
  "frontend_id": "2272",
  "difficulty": "Hard",
  "problem_slug": "substring-with-largest-variance",
  "topics": [
    "Array",
    "Dynamic Programming"
  ],
  "description": "The variance of a string is defined as the largest difference between the number of occurrences of any 2 characters present in the string. Note the two characters may or may not be the same.\nGiven a string s consisting of lowercase English letters only, return the largest variance possible among all substrings of s.\nA substring is a contiguous sequence of characters within a string.\nExample 1:\nExample 2:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: s = \"aababbb\"\nOutput: 3\nExplanation:\nAll possible variances along with their respective substrings are listed below:\n- Variance 0 for substrings \"a\", \"aa\", \"ab\", \"abab\", \"aababb\", \"ba\", \"b\", \"bb\", and \"bbb\".\n- Variance 1 for substrings \"aab\", \"aba\", \"abb\", \"aabab\", \"ababb\", \"aababbb\", and \"bab\".\n- Variance 2 for substrings \"aaba\", \"ababbb\", \"abbb\", and \"babb\".\n- Variance 3 for substring \"babbb\".\nSince the largest possible variance is 3, we return it.",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input: s = \"abcde\"\nOutput: 0\nExplanation:\nNo letter occurs more than once in s, so the variance of every substring is 0.",
      "images": []
    }
  ],
  "constraints": [
    "1 <= s.length <= 104",
    "s consists of lowercase English letters."
  ],
  "follow_ups": [],
  "hints": [
    "Think about how to solve the problem if the string had only two distinct characters.",
    "If we replace all occurrences of the first character by +1 and those of the second character by -1, can we efficiently calculate the largest possible variance of a string with only two distinct characters?",
    "Now, try finding the optimal answer by taking all possible pairs of characters into consideration."
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    int largestVariance(string s) {\n        \n    }\n};",
    "java": "class Solution {\n    public int largestVariance(String s) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def largestVariance(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def largestVariance(self, s: str) -> int:\n        ",
    "c": "int largestVariance(char* s) {\n    \n}",
    "csharp": "public class Solution {\n    public int LargestVariance(string s) {\n        \n    }\n}",
    "javascript": "/**\n * @param {string} s\n * @return {number}\n */\nvar largestVariance = function(s) {\n    \n};",
    "typescript": "function largestVariance(s: string): number {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param String $s\n     * @return Integer\n     */\n    function largestVariance($s) {\n        \n    }\n}",
    "swift": "class Solution {\n    func largestVariance(_ s: String) -> Int {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun largestVariance(s: String): Int {\n        \n    }\n}",
    "dart": "class Solution {\n  int largestVariance(String s) {\n    \n  }\n}",
    "golang": "func largestVariance(s string) int {\n    \n}",
    "ruby": "# @param {String} s\n# @return {Integer}\ndef largest_variance(s)\n    \nend",
    "scala": "object Solution {\n    def largestVariance(s: String): Int = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn largest_variance(s: String) -> i32 {\n        \n    }\n}",
    "racket": "(define/contract (largest-variance s)\n  (-> string? exact-integer?)\n  )",
    "erlang": "-spec largest_variance(S :: unicode:unicode_binary()) -> integer().\nlargest_variance(S) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec largest_variance(s :: String.t) :: integer\n  def largest_variance(s) do\n    \n  end\nend"
  },
  "solution": "[TOC]\n\n## Solution\n\n--- \n\n### Overview\n\n> If you are not familiar with Kadane's algorithm, you may refer to [this wikipedia's page](https://en.wikipedia.org/wiki/Maximum_subarray_problem).\n\nKadane's algorithm is a dynamic programming algorithm that finds the maximum subarray sum in an array of integers.  It maintains two values: global_max, which represents the maximum sum encountered so far, and local_max, which represents the maximum sum ending at the current index.  As the algorithm traverses the array from left to right, it updates these values. The algorithm is efficient because it only requires $$O(n)$$ time and $$O(1)$$ space to store two values and does not need any additional data structures.\n\n\nAs shown in the figure below, `local_max` represents the maximum value of the subarray ending at the current index. We update `local_max` at each index and update `global_max` by the maximum `local_max`. This ensures that we always have the maximum sum subarray at each position.\n\n![img](../Figures/2272/1.png)\n\nNote that if the current subarray has a negative sum, we can discard it. In other words, if `local_max` is less than 0, we reset `local_max` to 0.\n\n---\n\n### Approach: Kadane's Algorithm\n\n#### Intuition    \n\nA similar approach can be used to solve this problem. Although `s` may contain many different characters, we can focus on one pair of letters `(major, minor)` at a time and calculate the maximum difference between their occurrences by applying Kadane's algorithm over all substrings of `s` that contain both `major` and `minor`. \n\n\n> In other words, we assign the value of `major` as 1, the value of `minor` as -1, and the value of all other letters as 0, and use the standard Kadane's algorithm to find the maximum subarray sum in the array representing `s`. \n\n![img](../Figures/2272/exp.png)\n\nFor instance, let's consider the pair of letters `(a, b)` as `(major, minor)` and determine their maximum variance in `s`. We update two variables `major_count` and `minor_count`, to keep track of the number of `major` and `minor` in the substring ending at the current index. Thus, `local_max` can be represented as `major_count - minor_count`. The equivalent of resetting `local_max` to 0 is setting both `major_count` and `minor_count` to 0.\n\n\n![img](../Figures/2272/2.png)\n\nPlease refer to the following slides to see how we update `global_max`. **Note that this algorithm is not completely correct and requires some modifications, which we will explain later.**\n\n\n!?!../Documents/2272/s1.json:601,301!?!\n\n\nWe notice that the standard Kadane's algorithm has failed to solve the problem. This is because Kadane's algorithm allows the subarray being considered to have no element with negative value. However, in our problem, a valid substring must contain at least one `major` and one `minor`, so the maximum variance calculated by regular Kadane's algorithm does not necessarily represent a valid substring.\n\n\nTherefore, we need to modify Kadane's algorithm to solve this problem. \n\n> Update `global_max` only when `minor_count > 0`.\n\nThis ensures that we only consider valid substrings that contain at least one `minor`. As shown in the picture below, we cannot update `global_max` if `minor_count = 0`. However, after encountering at least one `minor`, we can update `global_max` as `global_max = max(global_max, local_max) = 2`.\n\n![img](../Figures/2272/3.png)\n\n> Reset `local_max` to 0 only when there is at least one `minor` in the remaining substring.\n\nRecall that we need a step `local_max = max(local_max, 0)` in regular Kadane's algorithm, which always discards the current subarray if it has a negative sum. \n\nIn this problem, however, we cannot simply reset `local_max` to 0 whenever it becomes negative because doing so would reset both `major_count` and `minor_count` to 0. If there are no more `minor` in the remaining string, the `minor_count` will remain 0, and we will never be able to update `global_max` during the remaining traversal. To avoid this situation, we reset `local_max` to 0 only when there is at least one `minor` in the remaining `s`. To achieve this, we can use an additional variable `rest_minor` to keep track of the number of `minor` in the remaining string.\n\nAs shown below, if `local_max < 0` and there is still `minor` in the remaining string, we can reset it to 0 (i.e., reset both `minor_count` and `major_count` to 0).\n\n![img](../Figures/2272/4.png)\n\nHowever, if there is no `minor` left in the remaining string, we cannot reset `minor_count` or `major_count` to 0, as any valid string found in the following iteration must contain at least one `minor`, so we cannot discard the last `minor` by setting `minor_count` to 0.\n\n![img](../Figures/2272/5.png)\n\nTo sum up, we will identify every pair of different letters in the given string, treat one as a `major` letter and the other as a `minor` letter, and then apply the modified Kadane's algorithm to traverse `s`. During the traversal, we need to keep track of the maximum variance between the occurrences of `major` and `minor`, which we call `global_max`. After traversing all the substrings for each pair of `major` and `minor`, we take the maximum value of `global_max` as the final result.#### Algorithm\n\n1) Initialize a counter to record the count of each distinct character in `s`. (Since we already know in advance that `s` contains only 26 different letters, we can use an array of length 26 as the counter)\n\n\n2) For each pair of distinct letters `major` and `minor`, we apply Kadane's algorithm with modifications. All different pairs of distinct letters are considered, and **two pairs of the same letters in different orders are considered to be different**. In short, we will consider both `(a, b)` and `(b, a)`.\n\n3) Set `global_max`, `major_count` and `minor_count` to 0, and let `rest_minor` be the number of character `minor` in the string.\n\n4) Traverse the string `s`, and for each letter `ch`:\n    - If `ch` is `major`, increment `major_count` by 1.\n    - If `ch` is `minor`, increment `minor_count` by 1 and decrement `rest_minor` by 1.\n\n5) Update `global_max` only when `minor_count > 0` (The first modification).\n\n6) If `major_count - minor_count < 0`, reset them to 0 only when `rest_minor > 0`  (The second modification).\n\n7) Move on to the next pair of letters `(major, minor)` and repeat from step 3.\n\n\n8) Return `global_max` when the iteration is complete.\n\n\n#### Implementation#### Complexity Analysis\n\nLet $$n$$ be the length of the input string `s` and $$k$$ be the number of distinct characters in `s`.\n\n* Time complexity: $$O(n \\cdot k^2)$$\n\n    - Kadane's algorithm requires $$O(n)$$ time to traverse `s`. For each pair of alphabets `(major, minor)`, we need to traverse `s` once. In the worst-case scenario, `s` contains $$k = 26$$ different letters, so there are $$k\\cdot (k - 1)$$ possible pairs of letters. \n    \n\n* Space complexity: $$O(1)$$\n\n    - In the Kadane's algorithm, we only need to update a few variables, `major_count`, `minor_count`, `rest_minor` and `global_max`, which require $$O(1)$$ space."
}