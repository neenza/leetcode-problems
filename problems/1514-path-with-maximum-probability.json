{
  "title": "Path with Maximum Probability",
  "problem_id": "1325",
  "frontend_id": "1514",
  "difficulty": "Medium",
  "problem_slug": "path-with-maximum-probability",
  "topics": [
    "Array",
    "Graph",
    "Heap (Priority Queue)",
    "Shortest Path"
  ],
  "description": "You are given an undirected weighted graph of n nodes (0-indexed), represented by an edge list where edges[i] = [a, b] is an undirected edge connecting the nodes a and b with a probability of success of traversing that edge succProb[i].\nGiven two nodes start and end, find the path with the maximum probability of success to go from start to end and return its success probability.\nIf there is no path from start to end, return 0. Your answer will be accepted if it differs from the correct answer by at most 1e-5.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: n = 3, edges = [[0,1],[1,2],[0,2]], succProb = [0.5,0.5,0.2], start = 0, end = 2\nOutput: 0.25000\nExplanation: There are two paths from start to end, one having a probability of success = 0.2 and the other has 0.5 * 0.5 = 0.25.",
      "images": [
        "https://assets.leetcode.com/uploads/2019/09/20/1558_ex1.png"
      ]
    },
    {
      "example_num": 2,
      "example_text": "Input: n = 3, edges = [[0,1],[1,2],[0,2]], succProb = [0.5,0.5,0.3], start = 0, end = 2\nOutput: 0.30000",
      "images": [
        "https://assets.leetcode.com/uploads/2019/09/20/1558_ex2.png"
      ]
    },
    {
      "example_num": 3,
      "example_text": "Input: n = 3, edges = [[0,1]], succProb = [0.5], start = 0, end = 2\nOutput: 0.00000\nExplanation: There is no path between 0 and 2.",
      "images": [
        "https://assets.leetcode.com/uploads/2019/09/20/1558_ex3.png"
      ]
    }
  ],
  "constraints": [
    "2 <= n <= 10^4",
    "0 <= start, end < n",
    "start != end",
    "0 <= a, b < n",
    "a != b",
    "0 <= succProb.length == edges.length <= 2*10^4",
    "0 <= succProb[i] <= 1",
    "There is at most one edge between every two nodes."
  ],
  "follow_ups": [],
  "hints": [
    "Multiplying probabilities will result in precision errors.",
    "Take log probabilities to sum up numbers instead of multiplying them.",
    "Use Dijkstra's algorithm to find the minimum path between the two nodes after negating all costs."
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start_node, int end_node) {\n        \n    }\n};",
    "java": "class Solution {\n    public double maxProbability(int n, int[][] edges, double[] succProb, int start_node, int end_node) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def maxProbability(self, n, edges, succProb, start_node, end_node):\n        \"\"\"\n        :type n: int\n        :type edges: List[List[int]]\n        :type succProb: List[float]\n        :type start_node: int\n        :type end_node: int\n        :rtype: float\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def maxProbability(self, n: int, edges: List[List[int]], succProb: List[float], start_node: int, end_node: int) -> float:\n        ",
    "c": "double maxProbability(int n, int** edges, int edgesSize, int* edgesColSize, double* succProb, int succProbSize, int start_node, int end_node) {\n    \n}",
    "csharp": "public class Solution {\n    public double MaxProbability(int n, int[][] edges, double[] succProb, int start_node, int end_node) {\n        \n    }\n}",
    "javascript": "/**\n * @param {number} n\n * @param {number[][]} edges\n * @param {number[]} succProb\n * @param {number} start_node\n * @param {number} end_node\n * @return {number}\n */\nvar maxProbability = function(n, edges, succProb, start_node, end_node) {\n    \n};",
    "typescript": "function maxProbability(n: number, edges: number[][], succProb: number[], start_node: number, end_node: number): number {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param Integer $n\n     * @param Integer[][] $edges\n     * @param Float[] $succProb\n     * @param Integer $start_node\n     * @param Integer $end_node\n     * @return Float\n     */\n    function maxProbability($n, $edges, $succProb, $start_node, $end_node) {\n        \n    }\n}",
    "swift": "class Solution {\n    func maxProbability(_ n: Int, _ edges: [[Int]], _ succProb: [Double], _ start_node: Int, _ end_node: Int) -> Double {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun maxProbability(n: Int, edges: Array<IntArray>, succProb: DoubleArray, start_node: Int, end_node: Int): Double {\n        \n    }\n}",
    "dart": "class Solution {\n  double maxProbability(int n, List<List<int>> edges, List<double> succProb, int start_node, int end_node) {\n    \n  }\n}",
    "golang": "func maxProbability(n int, edges [][]int, succProb []float64, start_node int, end_node int) float64 {\n    \n}",
    "ruby": "# @param {Integer} n\n# @param {Integer[][]} edges\n# @param {Float[]} succ_prob\n# @param {Integer} start_node\n# @param {Integer} end_node\n# @return {Float}\ndef max_probability(n, edges, succ_prob, start_node, end_node)\n    \nend",
    "scala": "object Solution {\n    def maxProbability(n: Int, edges: Array[Array[Int]], succProb: Array[Double], start_node: Int, end_node: Int): Double = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn max_probability(n: i32, edges: Vec<Vec<i32>>, succ_prob: Vec<f64>, start_node: i32, end_node: i32) -> f64 {\n        \n    }\n}",
    "racket": "(define/contract (max-probability n edges succProb start_node end_node)\n  (-> exact-integer? (listof (listof exact-integer?)) (listof flonum?) exact-integer? exact-integer? flonum?)\n  )",
    "erlang": "-spec max_probability(N :: integer(), Edges :: [[integer()]], SuccProb :: [float()], Start_node :: integer(), End_node :: integer()) -> float().\nmax_probability(N, Edges, SuccProb, Start_node, End_node) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec max_probability(n :: integer, edges :: [[integer]], succ_prob :: [float], start_node :: integer, end_node :: integer) :: float\n  def max_probability(n, edges, succ_prob, start_node, end_node) do\n    \n  end\nend"
  },
  "solution": "[TOC]\n\n## Solution\n \n---\n\n### Approach 1: Bellman-Ford Algorithm\n\n\n#### Intuition   \n\n> If you are not familiar with the Bellman-Ford algorithm, please refer to our [Bellman-Ford Algorithm Explore Card](https://leetcode.com/explore/learn/card/graph/622/single-source-shortest-path-algorithm/3864/). For the sake of brevity, we will focus only on the usage of Bellman-Ford and not the implementation details.\n\nThe algorithm works by relaxing edges in the graph, meaning that it tries to improve the shortest path estimate for each node in the graph until the solution is found. \n\nBellman-Ford is typically used to find the shortest path in a weighted graph. In this problem, instead of the shortest distance, we are looking for the **maximum probability**. The length of a path is the sum of the weights of its edges. Here, the probability of a path equals the product of the probabilities of its edges.\n\nInitially, we set the probability to reach the starting node `start` as `1` and all other probabilities as `0`. Then we iteratively relax the edges of the graph by updating the probability to each node if a higher probability is found. \n\nConsidering that a path in the graph without a cycle contains at most `n - 1` edges, the process is repeated `n - 1` times, which is enough to relax every edge of every possible path.\n\n- In the first round, we update the maximum probability of reaching each node `u` from the starting node along the path that contains only one edge `(u, v)`.\n- In the second round, we update the maximum probability of reaching each node `u` from the starting node along the path that contains two edges (including `(u, v)`).\n- and so on.\n\nAfter `n - 1` rounds, we have updated `max_prob[end]` to be the maximum probability of reaching `end` from the staring node along every possible path.#### Algorithm\n\n1) Initialize an array `maxProb` as the maximum probability to reach each node from the staring node, set `maxProb[start]` as `1`.\n\n2) Relax all edges: for each edge `(u, v)`, if a higher probability of reaching `u` through this edge is found, update the `max_prob[u]` as `max_prob[u] = max_prob[v] * path_prob`, if a higher probability to reach `v` through this edge is found, update the `max_prob[v]`.\n\n3) If we are unable to update any node with a higher probability, we can stop the iteration by proceeding to step 4. Otherwise, repeat step 2 until all edges are relaxed `n - 1` times.\n\n4) Return `max_prob[end]`.\n\n#### Implementation#### Complexity Analysis\n\nLet $$n$$ be the number of nodes and $$m$$ be the number of edges.\n\n* Time complexity: $$O(n \\cdot m)$$\n\n    - The algorithm relaxes all edges in the graph `n - 1` times, each round contains an iteration over all `m` edges.\n\n* Space complexity: $$O(n)$$\n\n    - We only need an array of size $$n$$ to update the maximum probability to reach each node from the starting node.---\n\n### Approach 2: Shortest Path Faster Algorithm \n\n#### Intuition   \n\nThe Shortest Path Faster Algorithm (SPFA) is an improvement of the Bellman–Ford algorithm which computes single-source shortest paths in a weighted directed graph. \n\nWe start at node `start` and traverse all its neighbors, calculating the probability of moving from `start` to each neighbor. We then add these neighbors to a queue, and continue the process for all nodes in the queue until we empty the queue.\n\nThe key is maintaining a running maximum probability for each node, and using this maximum to calculate the probabilities for its neighbors. If the probability of traveling from the starting node to a neighbor node through a specific edge is greater than the current maximum probability for that neighbor, we update the maximum probability of this neighbor node, and add this neighbor node to the queue.\n\nAnother key point to note is how we calculate the probability of traveling from `start` to a neighbor node. We are given a set of edge weights that represent the probabilities of moving from one node to another. To calculate the probability of traveling from the starting node to a neighbor node through a specific edge, we simply multiply the edge weight (i.e., the probability of traveling through that edge) by the maximum probability of reaching the current node from the starting node. This gives us the probability of reaching the neighbor node through the current edge.\n\nTake the slides below as an example:\n\n!?!../Documents/1514/s1.json:601,301!?!\n\n> You might wonder, will repeatedly adding the same node back to the queue cause an infinite loop and result in a timeout?\n\nThe answer is NO, because we only update the probability of reaching a neighbor node, say `nxt_node` and add it back to `queue` if the current path **increases** the probability of reaching `nxt_node` from the starting node. Moreover, the weight (probability) of each path is less than or equal to 1. Therefore, even if the graph contains a cycle, the product of the probabilities of all edges in the cycle is still less than or equal to 1. Since loops do not increase the probability of reaching a node, paths that contain loops will be excluded from consideration and not added to the queue.\n\n![img](../Figures/1514/c.png)#### Algorithm\n\n1) Initialize an empty queue `queue` to store nodes that need to be visited.\n\n2) Initialize an array `max_prob` to store the maximum probability of reaching each node from the starting node. Set the probability of the starting node `max_prob[start]` as 1, and the probability of all other nodes as 0.\n\n3) Add the starting node `start` to the `queue`.\n\n4) While `queue` is not empty, we remove the first node `cur_node` from the queue.\n\n5) For each neighbor of `nxt_node`, calculate the probability of traveling from the starting node to the `nxt_node` through the current edge (`cur_node --- nxt_node`), and update the maximum probability for this neighbor `max_prob[nxt_node]` if necessary.\n\n6) If the probability to this neighbor node is increased, add `nxt_node` to `queue`.\n\n7) Repeat steps 4-6 until `queue` is empty.\n\n8) Return `max_prob[end]`, the maximum probability of reaching the end node `end` from the starting node.\n\n#### Implementation#### Complexity Analysis\n\nLet $$n$$ be the number of nodes and $$m$$ be the number of edges.\n\n* Time complexity: $$O(n \\cdot m)$$\n\n    - The worst-case running of SPFA is $$O(|V|\\cdot|E|)$$. However, this is only the worst-case scenario, and the average runtime of SPFA is better than in Bellman-Ford.\n\n* Space complexity: $$O(n + m)$$\n    - We build a hash map `graph` based on all edges, which takes $$O(m)$$ space.\n    - The algorithm stores the probability array `max_prob` of size $$O(n)$$ and a queue of vertices `queue`. In the worst-case scenario, there are $$O(m)$$ nodes in `queue` at the same time.---\n\n### Approach 3: Dijkstra's Algorithm\n\n#### Intuition   \n\n> If you are not familiar with the Dijkstra's algorithm, please refer to our [Dijkstra's Algorithm Explore Card](https://leetcode.com/explore/learn/card/graph/622/single-source-shortest-path-algorithm/3862/). For the sake of brevity, we will focus on the usage of the algorithm and not implementation details.\n\nIn BFS, we are exploring the graph in a breadth-first manner, which may not always lead to the shortest path. This is because BFS does not take into account the weights of the edges and only considers the number of hops. As shown in the picture below, even though the two paths to `end`\n- `0` -- `2`\n- `0` -- `1` -- `2`\ndon't have the maximum probability, we still need to update all the nodes along these paths.\n\n![img](../Figures/1514/d1.png)\n\nIn contrast, Dijkstra's algorithm takes into account the weights of the edges and always guarantees to find the highest probability from the source node to any other node in the graph. This is where Dijkstra's algorithm becomes more suitable than BFS, as it takes into account the weights (probabilities) of the edges and can find the path with the highest probability of reaching the end node. \n\n![img](../Figures/1514/d2.png)\n\nWe start from the starting node `start`, and consider its neighbors one by one, updating the probability to each neighboring node `nxt_node` if the probability of reaching `nxt_node` through the current node `cur_node` is higher than the previous stored probability of reaching `nxt_node` (by other paths). In order to always select the node with the highest reaching probability, we use a priority queue `pq` to store the nodes to visit, where the node with the highest probability of being reached from the starting node has the highest priority.#### Algorithm\n\n1) Initialize a priority queue `pq` to store nodes that need to be visited, and an array `max_prob` to store the maximum probability to reach each node from the starting node. Set the probability of the starting node as `1`, and the probability of all other nodes as `0`.\n\n2) Add the starting node `start` and its probability to the priority queue.\n\n3) While `pq` is not empty, remove `cur_node`, the node with the highest priority from it.\n\n4) For each neighbor `nxt_node` of the current node `cur_node`, calculate the probability of traveling from the starting node to the `nxt_node` through the current edge `cur_node --- nxt_node`, and update the maximum probability of `nxt_node` if necessary. To update the maximum probability, compare the product of the probability with the current node and the probability of the edge `cur_node --- nxt_node`, with the current maximum probability to the neighbor node. If the product is larger than the maximum probability stored in `max_prob[nxt_node]`, we update the maximum probability `max_prob[nxt_node]` as their product.\n\n5) If the neighbor node `nxt_node` has not been visited, we add it and its probability to the `pq`.\n\n6) Repeat steps 3-5 until the priority queue is empty or the ending node `end` has been reached.\n\n7) Return `max_prob[end]`.\n\n#### Implementation> Note that Python's heapq module only implements min heaps. Since we want higher probabilities to be popped first, we need a max heap. To fix this, we multiply the probabilities by `-1`.\n\n#### Complexity Analysis\n\nLet $$n$$ be the number of nodes and $$m$$ be the number of edges.\n\n* Time Complexity: $$O((n + m) \\cdot \\log n)$$\n\n   - We build an adjacency list `graph` based on all edges, which takes $$O(m)$$ time.\n   - In the worst case, each node could be pushed into the priority queue exactly once, which results in $$O(n \\cdot \\log n)$$ operations.\n   - Each edge is considered exactly once when its corresponding node is dequeued from the priority queue. This takes $$O(m \\cdot \\log n)$$ time in total, due to the priority queue's $$\\log n$$ complexity for insertion and deletion operations.\n   \n> You can also refer to our [Dijkstra's Algorithm Explore Card](https://leetcode.com/explore/learn/card/graph/622/single-source-shortest-path-algorithm/3862/) for details on the complexity analysis.\n\n* Space Complexity: $$O(n + m)$$\n\n   - We build an adjacency list `graph` based on all edges, which takes $$O(m)$$ space.\n   - The algorithm stores the `maxProb` array, which uses $$O(n)$$ space.\n   - We use a priority queue to keep track of nodes to be visited, and there are at most $$n$$ nodes in the queue.\n   - To sum up, the overall space complexity is $$O(n + m)$$."
}