{
  "title": "Count Nodes Equal to Average of Subtree",
  "problem_id": "2347",
  "frontend_id": "2265",
  "difficulty": "Medium",
  "problem_slug": "count-nodes-equal-to-average-of-subtree",
  "topics": [
    "Tree",
    "Depth-First Search",
    "Binary Tree"
  ],
  "description": "Given the root of a binary tree, return the number of nodes where the value of the node is equal to the average of the values in its subtree.\nNote:\nExample 1:\nExample 2:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: root = [4,8,5,0,1,null,6]\nOutput: 5\nExplanation: \nFor the node with value 4: The average of its subtree is (4 + 8 + 5 + 0 + 1 + 6) / 6 = 24 / 6 = 4.\nFor the node with value 5: The average of its subtree is (5 + 6) / 2 = 11 / 2 = 5.\nFor the node with value 0: The average of its subtree is 0 / 1 = 0.\nFor the node with value 1: The average of its subtree is 1 / 1 = 1.\nFor the node with value 6: The average of its subtree is 6 / 1 = 6.",
      "images": [
        "https://assets.leetcode.com/uploads/2022/03/15/image-20220315203925-1.png"
      ]
    },
    {
      "example_num": 2,
      "example_text": "Input: root = [1]\nOutput: 1\nExplanation: For the node with value 1: The average of its subtree is 1 / 1 = 1.",
      "images": [
        "https://assets.leetcode.com/uploads/2022/03/26/image-20220326133920-1.png"
      ]
    }
  ],
  "constraints": [
    "The number of nodes in the tree is in the range [1, 1000].",
    "0 <= Node.val <= 1000"
  ],
  "follow_ups": [],
  "hints": [
    "What information do we need to calculate the average? We need the sum of the values and the number of values.",
    "Create a recursive function that returns the size of a nodeâ€™s subtree, and the sum of the values of its subtree."
  ],
  "code_snippets": {
    "cpp": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    int averageOfSubtree(TreeNode* root) {\n        \n    }\n};",
    "java": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public int averageOfSubtree(TreeNode root) {\n        \n    }\n}",
    "python": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def averageOfSubtree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        ",
    "python3": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def averageOfSubtree(self, root: TreeNode) -> int:\n        ",
    "c": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     struct TreeNode *left;\n *     struct TreeNode *right;\n * };\n */\nint averageOfSubtree(struct TreeNode* root) {\n    \n}",
    "csharp": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public int val;\n *     public TreeNode left;\n *     public TreeNode right;\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\npublic class Solution {\n    public int AverageOfSubtree(TreeNode root) {\n        \n    }\n}",
    "javascript": "/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nvar averageOfSubtree = function(root) {\n    \n};",
    "typescript": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nfunction averageOfSubtree(root: TreeNode | null): number {\n    \n};",
    "php": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     public $val = null;\n *     public $left = null;\n *     public $right = null;\n *     function __construct($val = 0, $left = null, $right = null) {\n *         $this->val = $val;\n *         $this->left = $left;\n *         $this->right = $right;\n *     }\n * }\n */\nclass Solution {\n\n    /**\n     * @param TreeNode $root\n     * @return Integer\n     */\n    function averageOfSubtree($root) {\n        \n    }\n}",
    "swift": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public var val: Int\n *     public var left: TreeNode?\n *     public var right: TreeNode?\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\n *         self.val = val\n *         self.left = left\n *         self.right = right\n *     }\n * }\n */\nclass Solution {\n    func averageOfSubtree(_ root: TreeNode?) -> Int {\n        \n    }\n}",
    "kotlin": "/**\n * Example:\n * var ti = TreeNode(5)\n * var v = ti.`val`\n * Definition for a binary tree node.\n * class TreeNode(var `val`: Int) {\n *     var left: TreeNode? = null\n *     var right: TreeNode? = null\n * }\n */\nclass Solution {\n    fun averageOfSubtree(root: TreeNode?): Int {\n        \n    }\n}",
    "dart": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *   int val;\n *   TreeNode? left;\n *   TreeNode? right;\n *   TreeNode([this.val = 0, this.left, this.right]);\n * }\n */\nclass Solution {\n  int averageOfSubtree(TreeNode? root) {\n    \n  }\n}",
    "golang": "/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\nfunc averageOfSubtree(root *TreeNode) int {\n    \n}",
    "ruby": "# Definition for a binary tree node.\n# class TreeNode\n#     attr_accessor :val, :left, :right\n#     def initialize(val = 0, left = nil, right = nil)\n#         @val = val\n#         @left = left\n#         @right = right\n#     end\n# end\n# @param {TreeNode} root\n# @return {Integer}\ndef average_of_subtree(root)\n    \nend",
    "scala": "/**\n * Definition for a binary tree node.\n * class TreeNode(_value: Int = 0, _left: TreeNode = null, _right: TreeNode = null) {\n *   var value: Int = _value\n *   var left: TreeNode = _left\n *   var right: TreeNode = _right\n * }\n */\nobject Solution {\n    def averageOfSubtree(root: TreeNode): Int = {\n        \n    }\n}",
    "rust": "// Definition for a binary tree node.\n// #[derive(Debug, PartialEq, Eq)]\n// pub struct TreeNode {\n//   pub val: i32,\n//   pub left: Option<Rc<RefCell<TreeNode>>>,\n//   pub right: Option<Rc<RefCell<TreeNode>>>,\n// }\n// \n// impl TreeNode {\n//   #[inline]\n//   pub fn new(val: i32) -> Self {\n//     TreeNode {\n//       val,\n//       left: None,\n//       right: None\n//     }\n//   }\n// }\nuse std::rc::Rc;\nuse std::cell::RefCell;\nimpl Solution {\n    pub fn average_of_subtree(root: Option<Rc<RefCell<TreeNode>>>) -> i32 {\n        \n    }\n}",
    "racket": "; Definition for a binary tree node.\n#|\n\n; val : integer?\n; left : (or/c tree-node? #f)\n; right : (or/c tree-node? #f)\n(struct tree-node\n  (val left right) #:mutable #:transparent)\n\n; constructor\n(define (make-tree-node [val 0])\n  (tree-node val #f #f))\n\n|#\n\n(define/contract (average-of-subtree root)\n  (-> (or/c tree-node? #f) exact-integer?)\n  )",
    "erlang": "%% Definition for a binary tree node.\n%%\n%% -record(tree_node, {val = 0 :: integer(),\n%%                     left = null  :: 'null' | #tree_node{},\n%%                     right = null :: 'null' | #tree_node{}}).\n\n-spec average_of_subtree(Root :: #tree_node{} | null) -> integer().\naverage_of_subtree(Root) ->\n  .",
    "elixir": "# Definition for a binary tree node.\n#\n# defmodule TreeNode do\n#   @type t :: %__MODULE__{\n#           val: integer,\n#           left: TreeNode.t() | nil,\n#           right: TreeNode.t() | nil\n#         }\n#   defstruct val: 0, left: nil, right: nil\n# end\n\ndefmodule Solution do\n  @spec average_of_subtree(root :: TreeNode.t | nil) :: integer\n  def average_of_subtree(root) do\n    \n  end\nend"
  },
  "solution": "[TOC]\n\n## Solution\n\n---\n\n### Approach: Depth First Search (DFS)\n\n**Intuition**\n\nWe are given a binary tree with nodes that have non-negative integer values. We need to return the number of nodes that have the same value as the average value of all the nodes that have that node as their root (and the root node is included in the subtree). To find the average, we can round down the value to the nearest integer.\n\nTo find the average of some integers, we have two requirements. One is the sum of all the integers, and the other one is the number of integers. If we have both of these, we can find the average by dividing the sum by the number of integers. In this problem, we need the sum of all the nodes in the subtree `Sum of nodes`, and the second is the number of nodes in the subtree `Number of nodes`. We can then find the average as the `Sum of nodes / Number of nodes`.\n\nOne naive way to do this is to iterate over each node in the binary tree and then iterate over the subtree starting with this node, keeping the sum of nodes and count of nodes in two variables. Then, after completing the subtree, we will check if the average is equal to the root node value. If it is, we will increment the count of the answer variable. This approach is, however, inefficient as we will be iterating over the nodes multiple times. For each node, we will have to iterate over the nodes in the subtree, even if they have already been traversed.\n\nIn the above approach, we have to iterate over the nodes multiple times because we have started from top to bottom and as a result, we are not able to reuse the sum and count. Instead of going from to root node to the leaves, we can iterate in the reverse manner. We will first iterate over the left and right subtree of each node and return the sum of nodes as well as the count of nodes, Then we can find the average and check if this node should be counted. We will repeat the process for each node and return the final count once we have iterated over all the nodes.\n\nIf we look closely, traversing the children before traversing the nodes is a depth-first search traversal. We will use a recursive function that will return a pair of integers where the first integer is the sum of the nodes and the second integer is the count of the nodes. Using the pairs returned from the left and right subtrees, we can find the number of nodes in the total subtree and the total number of nodes. We can then find the average and determine whether the node should be counted in the final answer.\n\nNote that at the current node when we get the node values sum and count of nodes in both the left and right subtree, we add these values along with the current node value to get the total sum of this subtree and we add one to the total nodes to get the total nodes.\n\n![fig](../Figures/2265/2265A.png)\n\n**Algorithm**\n\n1. Define the method `postOrder` which takes a node `root` and returns a pair of integers, where the first integer is the sum of all nodes in the subtree under `root` and the second integer is the count of a node in the subtree under `root`. `postOrder` will include these steps:\n\n  1. Return a pair with `(0, 0)` if the `root` is `NULL`.\n  2. Recursively call `postOrder` for the left and the right child of the `root` and store the pairs as `left` and `right` respectively.\n  3. Find the total sum under `root` as the sum of nodes in the pair `left`, and `right` and the `root` itself as `nodeSum`.\n  4. Find the total node count under `root` as the count of nodes in the pair `left`, and `right` and the `1` for the `root`  as `nodeCount`.\n  5. Find the average using `nodeSum` and `nodeCount` and increment the counter `count` if the average is equal to the `root` value.\n  6. Return a pair as `(nodeSum, nodeCount)`.\n2. When `postOrder` is finished, return `count`.\n\n**Implementation****Complexity Analysis**\n\nHere, $N$ is the number of nodes in the binary tree.\n* Time complexity $O(N)$\n\n  We need to iterate over each node in the binary tree only once, and all other operations, like finding the average, are $O(1)$, and hence the total time complexity is equal to $O(N)$.\n\n* Space complexity $O(N)$\n\n  Recursion requires some stack space, and the maximum number of active stack calls would be equal to $N$ (one for each node). The space required by the pair is $O(1)$ and hence the total space complexity is equal to $O(N)$.---"
}