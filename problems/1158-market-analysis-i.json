{
  "title": "Market Analysis I",
  "problem_id": "1268",
  "frontend_id": "1158",
  "difficulty": "Medium",
  "problem_slug": "market-analysis-i",
  "topics": [
    "Database"
  ],
  "description": "Table: Users\nTable: Orders\nTable: Items\nWrite a solution to find for each user, the join date and the number of orders they made as a buyer in 2019.\nReturn the result table in any order.\nThe result format is in the following example.\nExample 1:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "+----------------+---------+\n| Column Name    | Type    |\n+----------------+---------+\n| user_id        | int     |\n| join_date      | date    |\n| favorite_brand | varchar |\n+----------------+---------+\nuser_id is the primary key (column with unique values) of this table.\nThis table has the info of the users of an online shopping website where users can sell and buy items.",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "+---------------+---------+\n| Column Name   | Type    |\n+---------------+---------+\n| order_id      | int     |\n| order_date    | date    |\n| item_id       | int     |\n| buyer_id      | int     |\n| seller_id     | int     |\n+---------------+---------+\norder_id is the primary key (column with unique values) of this table.\nitem_id is a foreign key (reference column) to the Items table.\nbuyer_id and seller_id are foreign keys to the Users table.",
      "images": []
    },
    {
      "example_num": 3,
      "example_text": "+---------------+---------+\n| Column Name   | Type    |\n+---------------+---------+\n| item_id       | int     |\n| item_brand    | varchar |\n+---------------+---------+\nitem_id is the primary key (column with unique values) of this table.",
      "images": []
    },
    {
      "example_num": 4,
      "example_text": "Input: \nUsers table:\n+---------+------------+----------------+\n| user_id | join_date  | favorite_brand |\n+---------+------------+----------------+\n| 1       | 2018-01-01 | Lenovo         |\n| 2       | 2018-02-09 | Samsung        |\n| 3       | 2018-01-19 | LG             |\n| 4       | 2018-05-21 | HP             |\n+---------+------------+----------------+\nOrders table:\n+----------+------------+---------+----------+-----------+\n| order_id | order_date | item_id | buyer_id | seller_id |\n+----------+------------+---------+----------+-----------+\n| 1        | 2019-08-01 | 4       | 1        | 2         |\n| 2        | 2018-08-02 | 2       | 1        | 3         |\n| 3        | 2019-08-03 | 3       | 2        | 3         |\n| 4        | 2018-08-04 | 1       | 4        | 2         |\n| 5        | 2018-08-04 | 1       | 3        | 4         |\n| 6        | 2019-08-05 | 2       | 2        | 4         |\n+----------+------------+---------+----------+-----------+\nItems table:\n+---------+------------+\n| item_id | item_brand |\n+---------+------------+\n| 1       | Samsung    |\n| 2       | Lenovo     |\n| 3       | LG         |\n| 4       | HP         |\n+---------+------------+\nOutput: \n+-----------+------------+----------------+\n| buyer_id  | join_date  | orders_in_2019 |\n+-----------+------------+----------------+\n| 1         | 2018-01-01 | 1              |\n| 2         | 2018-02-09 | 2              |\n| 3         | 2018-01-19 | 0              |\n| 4         | 2018-05-21 | 0              |\n+-----------+------------+----------------+",
      "images": []
    }
  ],
  "constraints": [],
  "follow_ups": [],
  "hints": [],
  "code_snippets": {
    "mysql": "# Write your MySQL query statement below\n",
    "mssql": "/* Write your T-SQL query statement below */\n",
    "oraclesql": "/* Write your PL/SQL query statement below */\n",
    "pythondata": "import pandas as pd\n\ndef market_analysis(users: pd.DataFrame, orders: pd.DataFrame, items: pd.DataFrame) -> pd.DataFrame:\n    ",
    "postgresql": "-- Write your PostgreSQL query statement below\n"
  },
  "solution": "[TOC]\n\n# Solution\n\n---\n\n### Overview\n\nOverview\n\nThe problem revolves around an online shopping platform where users can both buy and sell items.\n\n - **Users Table:** Contains information about individual users, such as when they joined.\n - **Orders Table:** Captures transactions, detailing who bought what, and when.\n - **Items Table:** Lists available items and their associated brands.\n\nThe main objective is to determine for each user:\n - When they joined.\n - How many items they purchased in the year 2019.\n\nThis analysis helps in understanding user engagement on the platform for that specific year.\n\n---\n\n## pandas\n### Approach 1: Right Join and GroupBy\n\n**Flowchart**\n\n![fig](../Figures/1158/1158-1.png)\n\n#### Intuition\n\nLet's break down the intuition behind the approach:\n\n**Purpose**: \nThe function `market_analysis` aims to analyze the number of items each user purchased in the year 2019. It takes three dataframes (`users`, `orders`, and `items`) as input and returns a dataframe summarizing the number of orders each user made in 2019, along with their joining date.\n\n**Step-by-step Intuition**:\n\n1. **Filtering 2019 Orders**: \n   ```python\n   orders.query(\"order_date.dt.year==2019\")\n   ```\n   Here, the algorithm starts by filtering the `orders` dataframe to only include rows where the `order_date` is from the year 2019.\n\n2. **Merging Data**:\n   ```python\n   merge(users, left_on=\"buyer_id\", right_on=\"user_id\", how=\"right\")\n   ```\n   The filtered orders from 2019 are then merged (joined) with the `users` dataframe. This joining happens based on the `buyer_id` from the `orders` dataframe and `user_id` from the `users` dataframe. \n   \n   The key point here is the use of `how=\"right\"`, which is a right join. This ensures that all users are included in the resulting dataframe, even if they didn't make any purchases in 2019. For users without any purchases in 2019, order-related columns will have null values.\n\n3. **Grouping & Counting**:\n   ```python\n   df.groupby([\"user_id\", \"join_date\"]).item_id.count()\n   ```\n   The merged dataframe is grouped by `user_id` and `join_date`. For each group (essentially each user), the algorithm counts the number of `item_id`s, which represents the number of orders the user made in 2019.\n\n4. **Formatting the Output**:\n   ```python\n   .reset_index().rename(columns={\"user_id\": \"buyer_id\", \"item_id\": \"orders_in_2019\"})\n   ```\n   The output from the grouping operation is formatted to present the data in a clearer manner. The index is reset to make `user_id` and `join_date` regular columns. Then, column names are renamed for clarity: \n   - `user_id` is renamed to `buyer_id`.\n   - The count of `item_id` (representing order count) is renamed to `orders_in_2019`.\n\nThe algorithm efficiently combines and transforms data from the `orders` and `users` dataframes to produce a user-centric summary of purchase activity in 2019. Users with zero purchases are not excluded, ensuring a comprehensive overview of all users.\n\n\n#### Implementation---\n\n## Database\n### Approach 1: Left Join and Aggregation\n\n#### Intuition\n\nThe query aims to capture the purchasing behavior of each user in 2019 by leveraging a left join. By joining the users to their respective orders, it ensures all users are represented, tallying up each user's purchases in that year, while also including those who made no purchases.\n\n**Step-by-step Intuition**:\n\n1. **Base Table (FROM Clause)**: \n   The query starts with the `Users` table, aliased as `u`. This table will serve as the foundation of our result, ensuring that all users will be represented in the output, regardless of whether they made any purchases in 2019 or not.\n\n2. **Joining with Orders (LEFT JOIN)**:\n   ```sql\n   LEFT JOIN Orders o ON u.user_id = o.buyer_id AND YEAR(order_date) = '2019'\n   ```\n   The query then performs a `LEFT JOIN` with the `Orders` table (aliased as `o`). This kind of join ensures that even users without matching orders (i.e., users who made no purchases) will still be included in the result. \n\n   Two conditions are applied for the join:\n   - Matching users in the `Users` table with buyers in the `Orders` table based on their IDs.\n   - Filtering the orders to only include those from the year 2019.\n\n3. **Aggregation (GROUP BY)**:\n   ```sql\n   GROUP BY u.user_id\n   ```\n   The query groups the combined data by `user_id`. This is done to consolidate all the orders of each user into a single row.\n\n4. **Selecting Relevant Columns**:\n   The following columns are selected for the final output:\n   - `u.user_id` (aliased as `buyer_id`): The ID of the user.\n   - `join_date`: The date the user joined.\n   - `COUNT(o.order_id) AS orders_in_2019`: This counts the number of orders (from 2019) for each user. If a user didn't make any orders in 2019, this value will be 0, thanks to the nature of the LEFT JOIN.\n\n5. **Ordering the Output**:\n   ```sql\n   ORDER BY u.user_id\n   ```\n   The result is then sorted by `user_id` in ascending order to present the data in a structured manner.\n\n\nThe SQL code is designed to provide insights into the purchasing behavior of users for the year 2019. It's efficient in ensuring that even users with zero purchases are included in the output, giving a comprehensive overview of all users on the platform for that year.\n\n\n#### Implementation\n\n\n```sql\nSELECT \n  u.user_id AS buyer_id, \n  join_date, \n  COUNT(o.order_id) AS orders_in_2019 \nFROM \n  Users u \n  LEFT JOIN Orders o ON u.user_id = o.buyer_id \n  AND YEAR(order_date)= '2019' \nGROUP BY \n  u.user_id \nORDER BY \n  u.user_id\n\n```"
}