{
  "title": "Minimum Cost to Hire K Workers",
  "problem_id": "887",
  "frontend_id": "857",
  "difficulty": "Hard",
  "problem_slug": "minimum-cost-to-hire-k-workers",
  "topics": [
    "Array",
    "Greedy",
    "Sorting",
    "Heap (Priority Queue)"
  ],
  "description": "There are n workers. You are given two integer arrays quality and wage where quality[i] is the quality of the ith worker and wage[i] is the minimum wage expectation for the ith worker.\nWe want to hire exactly k workers to form a paid group. To hire a group of k workers, we must pay them according to the following rules:\nGiven the integer k, return the least amount of money needed to form a paid group satisfying the above conditions. Answers within 10-5 of the actual answer will be accepted.\nExample 1:\nExample 2:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: quality = [10,20,5], wage = [70,50,30], k = 2\nOutput: 105.00000\nExplanation: We pay 70 to 0th worker and 35 to 2nd worker.",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input: quality = [3,1,10,10,1], wage = [4,8,2,2,7], k = 3\nOutput: 30.66667\nExplanation: We pay 4 to 0th worker, 13.33333 to 2nd and 3rd workers separately.",
      "images": []
    }
  ],
  "constraints": [
    "n == quality.length == wage.length",
    "1 <= k <= n <= 104",
    "1 <= quality[i], wage[i] <= 104"
  ],
  "follow_ups": [],
  "hints": [],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    double mincostToHireWorkers(vector<int>& quality, vector<int>& wage, int k) {\n        \n    }\n};",
    "java": "class Solution {\n    public double mincostToHireWorkers(int[] quality, int[] wage, int k) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def mincostToHireWorkers(self, quality, wage, k):\n        \"\"\"\n        :type quality: List[int]\n        :type wage: List[int]\n        :type k: int\n        :rtype: float\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def mincostToHireWorkers(self, quality: List[int], wage: List[int], k: int) -> float:\n        ",
    "c": "double mincostToHireWorkers(int* quality, int qualitySize, int* wage, int wageSize, int k) {\n    \n}",
    "csharp": "public class Solution {\n    public double MincostToHireWorkers(int[] quality, int[] wage, int k) {\n        \n    }\n}",
    "javascript": "/**\n * @param {number[]} quality\n * @param {number[]} wage\n * @param {number} k\n * @return {number}\n */\nvar mincostToHireWorkers = function(quality, wage, k) {\n    \n};",
    "typescript": "function mincostToHireWorkers(quality: number[], wage: number[], k: number): number {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param Integer[] $quality\n     * @param Integer[] $wage\n     * @param Integer $k\n     * @return Float\n     */\n    function mincostToHireWorkers($quality, $wage, $k) {\n        \n    }\n}",
    "swift": "class Solution {\n    func mincostToHireWorkers(_ quality: [Int], _ wage: [Int], _ k: Int) -> Double {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun mincostToHireWorkers(quality: IntArray, wage: IntArray, k: Int): Double {\n        \n    }\n}",
    "dart": "class Solution {\n  double mincostToHireWorkers(List<int> quality, List<int> wage, int k) {\n    \n  }\n}",
    "golang": "func mincostToHireWorkers(quality []int, wage []int, k int) float64 {\n    \n}",
    "ruby": "# @param {Integer[]} quality\n# @param {Integer[]} wage\n# @param {Integer} k\n# @return {Float}\ndef mincost_to_hire_workers(quality, wage, k)\n    \nend",
    "scala": "object Solution {\n    def mincostToHireWorkers(quality: Array[Int], wage: Array[Int], k: Int): Double = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn mincost_to_hire_workers(quality: Vec<i32>, wage: Vec<i32>, k: i32) -> f64 {\n        \n    }\n}",
    "racket": "(define/contract (mincost-to-hire-workers quality wage k)\n  (-> (listof exact-integer?) (listof exact-integer?) exact-integer? flonum?)\n  )",
    "erlang": "-spec mincost_to_hire_workers(Quality :: [integer()], Wage :: [integer()], K :: integer()) -> float().\nmincost_to_hire_workers(Quality, Wage, K) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec mincost_to_hire_workers(quality :: [integer], wage :: [integer], k :: integer) :: float\n  def mincost_to_hire_workers(quality, wage, k) do\n    \n  end\nend"
  },
  "solution": "[TOC]\n\n## Solution\n\n---\n\n### Overview\n\nWe need to hire exactly `k` workers from a pool of `n` workers. Each worker has a quality and a minimum wage expectation. The goal is to form a paid group while satisfying two conditions:\n\n1. Each worker in the paid group must receive at least their minimum wage expectation.\n\n2. Each worker in the paid group should be paid in proportion to their quality relative to other workers in the group.\n\nHow do we determine the workers' wages based on these conditions?\n\nSuppose we have 2 workers `i` and `j`,\n\n$$\\frac{{\\text{wage}[i]}}{{\\text{wage}[j]}} = \\frac{{\\text{quality}[i]}}{{\\text{quality}[j]}}$$\n\n$$\\frac{{\\text{wage}[i]}}{{\\text{quality}[i]}} = \\frac{{\\text{wage}[j]}}{{\\text{quality}[j]}}$$\n\nMeaning if a workerâ€™s quality is double that of another worker in the group, then they must be paid twice as much as the other worker.\n\nConsider the first example($k = 2$) from the problem description:\n\n> **Input:** quality = [10,20,5], wage = [70,50,30], k = 2\n\nTo start, let's say we hire workers `0` and `2`. Their combined quality is 15 units $(10 + 5)$. Now, we allocate payment based on their contribution to this total quality:\n\nWorker `0` will be paid as follows: $\\frac{10}{15} = \\frac{2}{3}$ $\\frac{\\text{individual quality}}{\\text{total quality}}$.\n\nWorker `2` will be paid as follows: $\\frac{5}{15} = \\frac{1}{3}$ $\\frac{\\text{individual quality}}{\\text{total quality}}$.\n\nWe use this to meet condition 2: Workers are compensated in proportion to their quality relative to other workers in the group i.e., worker `0` receives $\\frac{2}{3}$ of the total payment, and Worker `2` receives $\\frac{1}{3}$.\n\nWorker `0` has the higher minimum wage, $$ \\$70 $$. We can set up the following proportion to determine $x$, the amount of money worker `2` will make:\n\n$$ \\frac{\\frac{1}{3}}{\\frac{2}{3}} = \\frac{x}{70} \\rightarrow \\frac{1}{2} = \\frac{x}{70} \\rightarrow 2x = 70 \\rightarrow x = 35$$\n\nThe cost of the paid group is $$70 + 35 = \\$105$$.\n\nThe task is to find the least amount of money needed to form such a paid group. We can calculate the cost of each possible group as follows.\n\nThe wage to quality ratio, for worker `0` is $$ \\$7 $$ per unit ($\\frac{\\text{wage}}{\\text{quality}} = \\frac{70}{10}$), and for worker `2`, its ($\\frac{\\text{wage}}{\\text{quality}} = \\frac{30}{5}$) per unit.\n\nThus, to satisfy both conditions, we must pay each worker at least $$ \\$7 $$ per unit to meet the minimum wage and quality requirements. This internal selection process ensures that both quality and wage requirements are met.\n\nNow, to determine the optimal worker pool, we compute the maximum quality per unit multiplied by the total quality ($\\frac{\\text{max quality}}{\\text{unit}} \\times \\text{total quality}$) for every pair of $$ \\$2 $$ ($k$) workers. This gives the minimum expected wage that fulfills both conditions.\n\n- For worker `0` and `1`: $$7 \\times 30 (\\frac{70}{10} \\times [10 + 20]) = \\$210$$.\n- For worker `0` and `2`: $$7 \\times 15 (\\frac{70}{10} \\times [10 + 5]) = \\$105$$.\n- For worker `1` and `2`: $$6 \\times 25 (\\frac{30}{5} \\times [20 + 5]) = \\$150$$.\n\nThe cost of the cheapest paid group is $$\\$105$$.\n\n---\n\n### Approach: Priority Queue\n\n#### Intuition\n\nOur goal is to minimize the total cost of hiring exactly `k` workers. The cost of hiring a worker depends on two factors: the worker's quality and the ratio of their wage to their quality (wage-to-quality ratio).\n\nFirst, we observe that hiring workers with lower wage-to-quality ratios could potentially lead to a lower overall cost. This observation motivates us to sort the workers based on their wage-to-quality ratios in ascending order. By doing so, we can consider the workers with the lowest ratios first, which are the most cost-effective options.\n\nHowever, we also need to keep track of the qualities of the workers we have hired so far. This is because the total cost is calculated as the sum of the products of each worker's quality and their wage-to-quality ratio. We can use a priority queue (max heap) data structure to efficiently manage the worker qualities. The priority queue will always maintain the `k` workers with the lowest qualities, allowing us to calculate the total cost for the current set of `k` workers.\n\nNow, we can iterate through the sorted list of workers. For each worker, we add their quality to the priority queue and update the sum of qualities in the priority queue. If the size of the priority queue exceeds `k`, we remove the worker with the highest quality to maintain a size of `k`.\n\nOnce the priority queue contains exactly `k` workers, we can calculate the total cost for the current set of workers by multiplying each worker's quality by their wage-to-quality ratio and summing the products. If this cost is lower than the current minimum cost, we update the result.\n\n> **Note:** The above explanation is sufficient to understand the solution to the problem. We've included the explanation using mathematical logic for an alternate representation.Mathematical Representation:We aim to hire a specific number of workers from a pool while ensuring two key conditions:\n\nLet $Worker$ be the worker at position $i$ and $Other$ as any worker not at position $i$.\n\n1. **Condition A:**\n\n$$\\frac{\\text{moneyToBePaid}_{\\text{worker}}}{\\text{quality}_{\\text{worker}}} = \\frac{\\text{moneyToBePaid}_{\\text{other}}}{\\text{quality}_{\\text{other}}}$$\n\n- This condition ensures that the ratio of money to be paid to quality is the same for both chosen workers ($\\text{worker}$ and $\\text{other}$).\n\n**Equation 1: Wage Calculation for Chosen Worker:**\n\n$$\\text{wage}_{\\text{worker}} = \\frac{\\text{moneyToBePaid}}{\\text{quality}_{\\text{worker}} \\times \\text{quality}_{\\text{other}}}$$\n\n- This equation calculates the wage for a chosen worker based on the money to be paid, the worker's quality, and the other worker's quality($\\text{other}$).\n\n2. **Condition B:**\n\n$$\\text{moneyToBePaid}_{\\text{worker}} \\geq \\text{wage}_{\\text{other}}$$\n\n$$\\frac{\\text{wage}_{\\text{worker}}}{\\text{quality}_{\\text{worker}}} \\geq \\frac{\\text{wage}_{\\text{other}}}{\\text{quality}_{\\text{other}}}$$\n\n$$\\text{ratio}_{\\text{worker}} \\geq \\text{ratio}_{\\text{other}}$$\n\n- This condition ensures that the money to be paid to a chosen worker ($\\text{worker}$) is greater than or equal to the wage of any other worker ($\\text{other}$).\n\n**Sorting Workers:**\n\n- If we sort the array workers containing (quality, wage) in increasing order of ratio, then for every index $i$, we know that we can select every worker on the left of $i$ because the group meets condition B:\n\n$\\text{ratio}_j \\leq \\text{ratio}_i$ . . . . . . for $0 \\leq j < i$\n\n- This step ensures that workers are sorted based on their ratio of quality to wage, allowing us to make efficient decisions in selecting workers. Here, $\\text{ratio}_i$ represents the ratio of quality to wage for the worker at index $i$, and $j$ represents indices of workers on the left of $i$.\n\n**Final Selection:**\n\nUsing equation (1), the total cost for a paid group will be:\n\n$$[ \\text{totalWage}_i = \\text{workers}[i].\\text{wage} + \\left( \\sum_{\\text{smallest } k-1 \\text{ qualities on the left of } i} \\right) \\times \\text{ratio}_i]$$\n\nwhere, $$\\text{ratio}_i = \\frac{\\text{workers}[i].\\text{wage}}{\\text{workers}[i].\\text{quality}}$$\n\nThe answer will be the smallest $\\text{totalWage}_i$ for every $i$. \n\nWe can use a priority queue to find the sum of the smallest $k - 1$ qualities on the left of $i$ in $\\log k$ time.The following is an illustration demonstrating the priority queue approach:\n\n!?!../Documents/857/pq.json:977,423!?!\n\n#### Algorithm\n\n- Initialize variables `n` to store the size of the input arrays (`quality` and `wage`), `totalCost` to store the minimum total cost (initially set to the maximum possible value) and `currentTotalQuality` to keep track of the sum of qualities of the current set of workers.\n- Create an array `wageToQualityRatio` to store the wage-to-quality ratio and the quality of each worker as pairs.\n- Calculate the wage-to-quality ratio for each worker and store it in `wageToQualityRatio`.\n- Sort `wageToQualityRatio` in ascending order based on the wage-to-quality ratio.\n- Create a priority queue `workers` (max heap) to store the workers chosen for the paid group. The highest quality worker is stored at the top of the heap, so we can quickly remove them if we find a better candidate for the paid group.\n- Iterate through the sorted `wageToQualityRatio`:\n  - Push the current worker's quality to `workers`.\n  - Update `currentTotalQuality` by adding the current worker's quality.\n  - If the size of `workers` exceeds `k`:\n    - Remove the worker with the highest quality from `workers`.\n    - Update `currentTotalQuality` by subtracting the removed worker's quality.\n  - If the size of `workers` is equal to `k`:\n    - Calculate the total cost for the current set of workers by multiplying `currentTotalQuality` by the wage-to-quality ratio of the current worker.\n    - Update `totalCost` if the calculated cost is smaller than the current minimum cost.\n- After iterating through all workers, return `totalCost`, which holds the minimum total cost for hiring `k` workers.\n- Return `totalCost`.\n\n#### Implementation#### Complexity Analysis\n\nLet $n$ be the number of workers and $k$ be the size of the priority queue (bounded by `k`).\n\n- Time complexity: $O(n \\log n + n \\log k)$\n\n    Sorting the workers based on their wage-to-quality ratio takes $O(n \\log n)$.\n    \n    Each worker is processed once, and for each worker, we perform push/pop operations on the priority queue, which takes $O(\\log k)$, so processing the workers takes $O(n \\log k)$.\n\n    So, the total time complexity is $O(n \\log n + n \\log k)$, which is dominated by the sorting step when `k` is much smaller than `n`.\n\n- Space complexity: $O(n + k)$\n\n    We use $O(n)$ additional space to store the wage-to-quality ratio for each worker.\n        \n    We use a priority queue to keep track of the highest quality workers, which can contain at most $k$ workers.\n    \n    Note that some extra space is used when we sort an array in place. The space complexity of the sorting algorithm depends on the programming language.\n    - In Python, the `sort` method sorts a list using the Tim Sort algorithm which is a combination of Merge Sort and Insertion Sort and has $O(n)$ additional space. Additionally, Tim Sort is designed to be a stable algorithm.\n    - In Java, `Arrays.sort()` is implemented using a variant of the Quick Sort algorithm which has a space complexity of $O( \\log n)$ for sorting an array.\n    - In C++, the `sort()` function is implemented as a hybrid of Quick Sort, Heap Sort, and Insertion Sort, with a worse-case space complexity of $O( \\log n)$.\n    \n    So, the total space complexity is $O(n + k)$, where $n$ is the dominating term when `k` is much smaller than `n`.\n\n---"
}