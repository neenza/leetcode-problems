{
  "title": "Special Array II",
  "problem_id": "3427",
  "frontend_id": "3152",
  "difficulty": "Medium",
  "problem_slug": "special-array-ii",
  "topics": [
    "Array",
    "Binary Search",
    "Prefix Sum"
  ],
  "description": "An array is considered special if every pair of its adjacent elements contains two numbers with different parity.\nYou are given an array of integer nums and a 2D integer matrix queries, where for queries[i] = [fromi, toi] your task is to check that subarray nums[fromi..toi] is special or not.\nReturn an array of booleans answer such that answer[i] is true if nums[fromi..toi] is special.\nExample 1:\nExample 2:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: nums = [3,4,1,2,6], queries = [[0,4]]\nOutput: [false]\nExplanation:\nThe subarray is [3,4,1,2,6] . 2 and 6 are both even.",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input: nums = [4,3,1,6], queries = [[0,2],[2,3]]\nOutput: [false,true]\nExplanation:",
      "images": []
    }
  ],
  "constraints": [
    "1 <= nums.length <= 105",
    "1 <= nums[i] <= 105",
    "1 <= queries.length <= 105",
    "queries[i].length == 2",
    "0 <= queries[i][0] <= queries[i][1] <= nums.length - 1"
  ],
  "follow_ups": [],
  "hints": [
    "Try to split the array into some non-intersected continuous special subarrays.",
    "For each query check that the first and the last elements of that query are in the same subarray or not."
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    vector<bool> isArraySpecial(vector<int>& nums, vector<vector<int>>& queries) {\n        \n    }\n};",
    "java": "class Solution {\n    public boolean[] isArraySpecial(int[] nums, int[][] queries) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def isArraySpecial(self, nums, queries):\n        \"\"\"\n        :type nums: List[int]\n        :type queries: List[List[int]]\n        :rtype: List[bool]\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def isArraySpecial(self, nums: List[int], queries: List[List[int]]) -> List[bool]:\n        ",
    "c": "/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nbool* isArraySpecial(int* nums, int numsSize, int** queries, int queriesSize, int* queriesColSize, int* returnSize) {\n    \n}",
    "csharp": "public class Solution {\n    public bool[] IsArraySpecial(int[] nums, int[][] queries) {\n        \n    }\n}",
    "javascript": "/**\n * @param {number[]} nums\n * @param {number[][]} queries\n * @return {boolean[]}\n */\nvar isArraySpecial = function(nums, queries) {\n    \n};",
    "typescript": "function isArraySpecial(nums: number[], queries: number[][]): boolean[] {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @param Integer[][] $queries\n     * @return Boolean[]\n     */\n    function isArraySpecial($nums, $queries) {\n        \n    }\n}",
    "swift": "class Solution {\n    func isArraySpecial(_ nums: [Int], _ queries: [[Int]]) -> [Bool] {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun isArraySpecial(nums: IntArray, queries: Array<IntArray>): BooleanArray {\n        \n    }\n}",
    "dart": "class Solution {\n  List<bool> isArraySpecial(List<int> nums, List<List<int>> queries) {\n    \n  }\n}",
    "golang": "func isArraySpecial(nums []int, queries [][]int) []bool {\n    \n}",
    "ruby": "# @param {Integer[]} nums\n# @param {Integer[][]} queries\n# @return {Boolean[]}\ndef is_array_special(nums, queries)\n    \nend",
    "scala": "object Solution {\n    def isArraySpecial(nums: Array[Int], queries: Array[Array[Int]]): Array[Boolean] = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn is_array_special(nums: Vec<i32>, queries: Vec<Vec<i32>>) -> Vec<bool> {\n        \n    }\n}",
    "racket": "(define/contract (is-array-special nums queries)\n  (-> (listof exact-integer?) (listof (listof exact-integer?)) (listof boolean?))\n  )",
    "erlang": "-spec is_array_special(Nums :: [integer()], Queries :: [[integer()]]) -> [boolean()].\nis_array_special(Nums, Queries) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec is_array_special(nums :: [integer], queries :: [[integer]]) :: [boolean]\n  def is_array_special(nums, queries) do\n    \n  end\nend"
  },
  "solution": "[TOC]\n\n## Solution\n\n---\n\n### Overview\n\nWe are given an array of integers `nums` and a 2D array of queries `queries`, where each query `queries[i] = [from, to]` refers to the subarray `nums[from ... to]`. Our task is to determine if each subarray `nums[from ... to]` is special. A subarray is considered special if every pair of adjacent elements has different parity â€” that is, the subarray alternates between even and odd elements.\n\n---\n\n### Approach 1: Binary Search\n\n#### Intuition\n\nA brute force solution would involve traversing the entire subarray for each query `queries[i]` and checking if its elements alternate between even and odd parity. However, this approach is inefficient because traversing all subarrays will be very time-consuming, especially if there are many queries or if the subarrays are large. Also, there would be much repeated work if the queries overlap.\n\nInstead, we can perform some precomputations to solve each query faster. If we perform an initial traversal of `nums`, we can easily identify the indices of elements that break or violate the special array property. Specifically, we can find the indices of elements `nums[i]` that have the same parity (even or odd) as its previous element: If `nums[i] % 2 == nums[i-1] % 2` is true, then `nums[i]` is a violating element.\n\nAfter finding these violating indices, we know that any subarray containing any of these indices is not a special array. Conversely, if a subarray contains no violating indices, then it is a special array. \n\nThe problem now is to find an efficient way to check if each subarray defined by `queries[i] = [start, end]` contains any violating indices. Since we can perform our initial traversal of `nums` from left to right, the violating indices are naturally sorted in ascending order. Because they are sorted, we can perform [binary search](https://leetcode.com/explore/learn/card/binary-search/) on the violating indices to see if any violating indices fall between the range `[start + 1, end]`. Note that we start our search at `start + 1` instead of `start` because the violating indices are defined relative to the element to their left. Therefore, the first element of our subarray (at index `start`) is never a violating element, and our search should begin at `start + 1`.\n\nIt is also worth noting that there is usually a single target value we would like to find for traditional binary search problems. However, for this problem, we have a target range of `[start + 1, end]` instead. \n\nThus, our precomputation allows us to more efficiently evaluate each subarray, leading to an $O(\\logn)$ binary search time for each query rather than a $O(n)$ brute force traversal.\n\n#### Algorithm\n\n1. Create a new boolean `ans` array to hold our answers for all queries.\n2. Create a new list `violatingIndices` to store all the indices that violate the special array condition in `nums`.\n3. Iterate through `nums` and add all the violating indices found to `violatingIndices`.\n4. Traverse through `queries` to answer each `queries[i]`:\n    * Initialize variable `start` to `queries[i][0]`.\n    * Initialize variable `end` to `queries[i][1]`.\n    * Call helper function `binarySearch(start + 1, end, violatingIndices)` to search through `violatingIndices` to see if it contains any indices that fall between `start` and `end`. Save result to variable `foundViolatingIndex`.\n    * If `foundViolatingIndex == true`, then we know the answer to the current query is false. Otherwise, the answer is true..\n    * Save answer in `ans[i]`.\n5. Return `ans`.\n6. Define helper function `binarySearch(start, end, violatingIndices)`:\n    * We initialize our search space to the entire list of violating indices: `left = 0` and `right = violatingIndices.size() - 1`\n    * While `left <= right`:\n        * Calculate the midpoint: `mid = (left + right) / 2`.\n        * Access the violating index at that index: `violatingIndex = violatingIndices.get(mid)`.\n        * If `violatingIndex < start`, then we want to look at the right half of our search space, so update `left = mid + 1`.\n        * If `violatingIndex > end`, then we want to look at the left half of our search space, so update `right = mid - 1`.\n        * Otherwise, our violating index falls in between `start` and `end`, meaning we found one in the subarray. Thus, we return `true`. \n    * If we reach this point, then we couldn't find any violating indices in the subarray. We return `false`.\n\n#### Implementation#### Complexity Analysis\n\nLet $M$ be the size of `nums` and $N$ be the size of `queries`.\n\n* Time Complexity: $O(M + N \\cdot \\log M)$\n\n    Our initial traversal of `nums` takes $O(M)$ time. Then, the binary search for each query will take $O(\\log M)$. For all $N$ queries, the total time for all searches is $O(N \\cdot \\log M)$. Thus, the total time complexity is $O(M + N \\cdot \\log M)$.\n\n* Space Complexity: $O(M)$\n\n    We store the violating indices of `nums`, which will take $O(M)$ space.\n\n---\n\n### Approach 2: Prefix Sum\n\n#### Intuition\n\nFor Approach 1, our precomputation involved finding all the violative indices of `nums`. This allowed us to evaluate each query in logarithmic time. \n\nWe will now consider a different precomputation method. We will find the total number of violative indices up to index `i` in `nums` for all indices `i`. In other words, we can create a prefix sum array where `prefix[i]` contains the total number of violative indices considering `nums[0...i]`. This can easily be done in linear time by iterating through `nums` and checking if each element `nums[i]` has the same parity as the previous element. If it does, then we have found a new violating index `i`, and our total number of violative indices increases by 1 (`prefix[i] = prefix[i - 1] + 1`). If it doesn't, then `i` is not a violating index and we keep our number of violative indices the same as before: `prefix[i] = prefix[i - 1]`\n\nThis prefix sum array is convenient because it now allows us to evaluate each query in constant time. Given any query `queries[i] = [start, end]`, we know that there are no violating indices found in the subarray between indices `start` and `end` if `prefix[end] - prefix[start] == 0`. If this condition is true, then the subarray is considered special. Otherwise, it is not special.\n\n#### Algorithm\n\n1. Create a new boolean `ans` array to hold our answers for all queries\n2. Initialize a `prefix` array to contain the prefix sum of the total number of violative indices.\n3. Initialize `prefix[0] = 0`.\n4. Iterate through `nums` from `i = 1` to `i = nums.length - 1`:\n    * If `nums[i] % 2 == nums[i - 1] % 2` then `i` is a new violative index, and we can increase the total number by 1: `prefix[i] = prefix[i-1] + 1`\n    * Otherwise, the total stays the same: `prefix[i] = prefix[i-1]`.\n5. Traverse through `queries` to answer each `queries[i]`:\n    * Let `start = queries[i][0]`.\n    * Let `end = queries[i][1]`.\n    * Fill in `ans[i]` with `prefix[end] - prefix[start] == 0`, evaluating if there are no violating indices in the subarray.\n6. Return `ans`.\n\n#### Implementation#### Complexity Analysis\n\nLet $M$ be the size of `nums` and $N$ be the size of `queries`.\n\n* Time Complexity: $O(M + N)$\n\n    Our initial traversal of `nums` to initialize `prefix` takes $O(M)$ time. Then, answering each query will took constant time. For all $N$ queries, that will take a total of $O(N)$ time. Thus, the total time complexity is $O(M + N)$.\n\n* Space Complexity: $O(M)$\n\n    We maintain a prefix sum array for `nums`, which will take $O(M)$ space.\n\n---\n\n### Approach 3: Sliding Window\n\n#### Intuition\n\nTo make the process more fluent, we need a way to precompute information that can help us answer each query in constant time. The key idea is that for any index `start`, the farthest index we can reach while maintaining alternating parity is independent of the queries themselves. Thus, we can calculate this information beforehand.\n\nWe define an array `maxReach`, where `maxReach[start]` represents the farthest index that can be reached from `start` while adhering to the parity condition. To compute this, we iterate through the array and use a pointer `end` to expand the range as far as possible. Starting with `end = start`, we increment `end` as long as the parity of adjacent elements (`nums[end]` and `nums[end + 1]`) differs. Once this process is complete for a given `start`, we know that any range `[start, end']` with `end' <= maxReach[start]` satisfies the parity condition.\n\nWith this precomputed information, answering queries becomes straightforward. For each query `[start, end]`, we simply check whether `end` is within the range of `maxReach[start]`. If it is, the subarray satisfies the condition; otherwise, it does not.\n\n#### Algorithm\n\n- Initialize `n` as the size of the array `nums` and create a array `maxReach` of size `n` to store the maximum reachable index for each starting index.\n\n- Initialize the last element of `maxReach`:\n  - Set `maxReach[n-1]` to `n-1` because the last index can only reach itself.\n\n- Iterate over the array `nums` from the second-to-last index to the first:\n  - If the parity (odd/even) of `nums[i]` is different from `nums[i+1]`:\n    - Set `maxReach[i]` to `maxReach[i+1]` to extend the reachable range.\n  - Otherwise:\n    - Set `maxReach[i]` to `i`, as it can only reach itself.\n\n- Create a array `ans` of size equal to the number of queries to store the results.\n\n- For each query in `queries`:\n  - Extract `start` and `end` from the query.\n  - Check if the range `[start, end]` lies within the maximum reachable range stored in `maxReach[start]`.\n  - Store `true` if `end <= maxReach[start]`, otherwise store `false`.\n\n- Return the array `ans`, which contains the results for all queries.\n\n#### Implementation#### Complexity Analysis\n\nLet $M$ be the size of `nums` and $N$ be the size of `queries`.\n\n* Time Complexity: $O(M + N)$\n\n    First, we go through the `nums` array to create the `maxReach` array. This process takes $O(M)$ time.\n\n    Next, for each query, we can quickly find the answer using the `maxReach` array. Since each query is answered in constant time, answering all $N$ queries will take $O(N)$ time.\n\n    Combining these two steps, the total time complexity is $O(M + N)$.\n\n* Space Complexity: $O(M)$\n\n    We use an array called `maxReach` to store the maximum reach for each position in the `nums` array. This array takes up $O(M)$ space.\n\n    The `ans` array, which stores the results for each query, is not included in the space complexity calculation because it is considered part of the output. Therefore, the overall space complexity is $O(M)$.\n\n---"
}