{
  "title": "Minimum Number of K Consecutive Bit Flips",
  "problem_id": "1037",
  "frontend_id": "995",
  "difficulty": "Hard",
  "problem_slug": "minimum-number-of-k-consecutive-bit-flips",
  "topics": [
    "Array",
    "Bit Manipulation",
    "Queue",
    "Sliding Window",
    "Prefix Sum"
  ],
  "description": "You are given a binary array nums and an integer k.\nA k-bit flip is choosing a subarray of length k from nums and simultaneously changing every 0 in the subarray to 1, and every 1 in the subarray to 0.\nReturn the minimum number of k-bit flips required so that there is no 0 in the array. If it is not possible, return -1.\nA subarray is a contiguous part of an array.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: nums = [0,1,0], k = 1\nOutput: 2\nExplanation: Flip nums[0], then flip nums[2].",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input: nums = [1,1,0], k = 2\nOutput: -1\nExplanation: No matter how we flip subarrays of size 2, we cannot make the array become [1,1,1].",
      "images": []
    },
    {
      "example_num": 3,
      "example_text": "Input: nums = [0,0,0,1,0,1,1,0], k = 3\nOutput: 3\nExplanation: \nFlip nums[0],nums[1],nums[2]: nums becomes [1,1,1,1,0,1,1,0]\nFlip nums[4],nums[5],nums[6]: nums becomes [1,1,1,1,1,0,0,0]\nFlip nums[5],nums[6],nums[7]: nums becomes [1,1,1,1,1,1,1,1]",
      "images": []
    }
  ],
  "constraints": [
    "1 <= nums.length <= 105",
    "1 <= k <= nums.length"
  ],
  "follow_ups": [],
  "hints": [],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    int minKBitFlips(vector<int>& nums, int k) {\n        \n    }\n};",
    "java": "class Solution {\n    public int minKBitFlips(int[] nums, int k) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def minKBitFlips(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def minKBitFlips(self, nums: List[int], k: int) -> int:\n        ",
    "c": "int minKBitFlips(int* nums, int numsSize, int k) {\n    \n}",
    "csharp": "public class Solution {\n    public int MinKBitFlips(int[] nums, int k) {\n        \n    }\n}",
    "javascript": "/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number}\n */\nvar minKBitFlips = function(nums, k) {\n    \n};",
    "typescript": "function minKBitFlips(nums: number[], k: number): number {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @param Integer $k\n     * @return Integer\n     */\n    function minKBitFlips($nums, $k) {\n        \n    }\n}",
    "swift": "class Solution {\n    func minKBitFlips(_ nums: [Int], _ k: Int) -> Int {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun minKBitFlips(nums: IntArray, k: Int): Int {\n        \n    }\n}",
    "dart": "class Solution {\n  int minKBitFlips(List<int> nums, int k) {\n    \n  }\n}",
    "golang": "func minKBitFlips(nums []int, k int) int {\n    \n}",
    "ruby": "# @param {Integer[]} nums\n# @param {Integer} k\n# @return {Integer}\ndef min_k_bit_flips(nums, k)\n    \nend",
    "scala": "object Solution {\n    def minKBitFlips(nums: Array[Int], k: Int): Int = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn min_k_bit_flips(nums: Vec<i32>, k: i32) -> i32 {\n        \n    }\n}",
    "racket": "(define/contract (min-k-bit-flips nums k)\n  (-> (listof exact-integer?) exact-integer? exact-integer?)\n  )",
    "erlang": "-spec min_k_bit_flips(Nums :: [integer()], K :: integer()) -> integer().\nmin_k_bit_flips(Nums, K) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec min_k_bit_flips(nums :: [integer], k :: integer) :: integer\n  def min_k_bit_flips(nums, k) do\n    \n  end\nend"
  },
  "solution": "[TOC]\n\n## Solution\n\n---\n\n### Overview\n\nIn this question, we will focus more on the applications of [bit manipulation](https://leetcode.com/explore/learn/card/bit-manipulation/), binary flipping, deque, and sliding window rather than their fundamentals. If you are not familiar with these concepts, we recommend reviewing them first.\n\nWe are given an array `nums` consisting only of 0s and 1s. We need to make sure that the `nums` array has all elements as 1s. We can perform `k`-bit flips, meaning selecting a contiguous subarray of length `k` and flipping every 0 to 1 and every 1 to 0 within that subarray. \n\nIn the end, we need to return the minimum number of `k`-bit flips needed to ensure there are no 0s in the array. If not possible, return -1.\n\nConsider example 3 from the problem description:\n```\nInput: nums = [0,0,0,1,0,1,1,0], k = 3\nFlip nums[0], nums[1], nums[2]: nums becomes [1,1,1,1,0,1,1,0]\nFlip nums[4], nums[5], nums[6]: nums becomes [1,1,1,1,1,0,0,0]\nFlip nums[5], nums[6], nums[7]: nums becomes [1,1,1,1,1,1,1,1]\nOutput: 3\n```\n> For brevity, we will represent a series of `k`-bit flip operations by the starting indices of each flip. For instance, the series of 3-bit flips on subarrays nums[0 ... 2], nums[4 ... 6], and nums[5 ... 7] can be represented as [0, 4, 5]. We will call this the flip sequence.\n\nBefore discussing the approaches, let's review a few fundamental properties of **XOR**, which are essential to understanding the mechanics of `k`-bit flips and simplifying the problem.\n\nProperty 1: Order Invariance\n\nThe order in which the flips are applied does not affect the final outcome. For instance, in the given example, whether we flip in the order [0, 4, 5] or [4, 0, 5], the final array will be the same. This means that the solution can be approached by determining the correct indices to flip, regardless of the sequence.\n\nProperty 2: Parity Invariance\n\nThe number of times an index is flipped determines its final value. If an index is flipped an odd number of times, its value will be inverted; if flipped an even number of times, it will remain unchanged.\n\nObservation:\n\nThe problem boils down to finding the minimum flip sequence needed to convert all elements of `nums` to `1`.\n\nTo tackle this problem, we use the property of order invariance, allowing us to sort the sequence by index in ascending order. Once sorted, we minimize the sequence size using the property of parity invariance.\n\nDue to the parity invariance property, duplicate values in the flip sequence can be removed without affecting the final result. For example, given a sequence like $[0, 1, 2, 4, 5, 6, 5, 6, 7]$ (above example 3), we can simplify it to $[0, 4, 5]$, ensuring all indexes are unique and in ascending order.\n\nThus, every flip sequence $S$ can be simplified to a new sequence $S'$, where all indexes in $S'$ are unique and sorted in ascending order. As indexes are sorted, subsequent flips with larger indexes cannot alter the value at prior indexes.\n\n- If $nums[0] = 0$ and 0 is NOT in the flip sequence, $nums[0]$ remains 0 in the final result.\n- If $nums[0] = 1$ and 0 is in the flip sequence, $nums[0]$ becomes 0 in the final result.\n\nFor any given index `i` in `nums`, one of the following two cases must occur to ensure there are no zeros left in `nums`:\n\n- If $nums[i] = 0$, then `i` must be present in the flip sequence, and we flip $nums[i], nums[i + 1], \\ldots, nums[i + k - 1]$.\n- If $nums[i] = 1$, then `i` must NOT be in the sequence, and we do not flip $nums[i], nums[i + 1], \\ldots, nums[i + k - 1]$.\n\nLet's take example 3 to elaborate on these properties in detail. If the sequence of indexes is changed to $\\{0, 1, 1, 4, 4, 4, 5\\}$, what will happen?\n\n1. Flip $nums[0], nums[1], nums[2]$: $nums$ becomes $[1, 1, 1, 1, 0, 1, 1, 0]$.\n2. Flip $nums[1], nums[2], nums[3]$: $nums$ becomes $[1, 0, 0, 0, 0, 1, 1, 0]$.\n3. Flip $nums[1], nums[2], nums[3]$: $nums$ becomes $[1, 1, 1, 1, 0, 1, 1, 0]$.\n4. Flip $nums[4], nums[5], nums[6]$: $nums$ becomes $[1, 1, 1, 1, 1, 0, 0, 0]$.\n5. Flip $nums[4], nums[5], nums[6]$: $nums$ becomes $[1, 1, 1, 1, 0, 1, 1, 0]$.\n6. Flip $nums[4], nums[5], nums[6]$: $nums$ becomes $[1, 1, 1, 1, 1, 0, 0, 0]$.\n7. Flip $nums[5], nums[6], nums[7]$: $nums$ becomes $[1, 1, 1, 1, 1, 1, 1, 1]$.\n\nThe final result is the same as the flip sequence $\\{0, 4, 5\\}$.\n\n---\n\n### Approach 1: Using an Auxiliary Array\n\n#### Intuition\n\nA naive approach to solving this problem is to iterate the array from left to right and flip subarrays whenever a 0 is encountered. This ensures that each 0 is flipped as soon as it is detected, ensuring no 0s remain in the array, assuming the `k`-grouping is possible. However, due to the problem constraints, this approach is not feasible.\n\nWe can optimize the naive approach by using an auxiliary array `isFlipped` to track the indices where a `k`-bit flip is needed. The strategy involves iterating through the original array `nums` while maintaining a variable `flipped`, which indicates whether the current bit is flipped.\n\nIf `flipped` is 0 and `nums[i]` is 0, a flip starting at index `i` is required. Similarly, if `flipped` is 1 and `nums[i]` is 1, a flip at `nums[i]` is needed. The logic ensures that each bit becomes 1. If the bit is 0 and not flipped, we flip it to 1. If the bit is 1 and flipped, we flip it back to 0.\n\nConsider what happens to `nums[5]` in the example above. Initially, we flip it from 1 to 0, then back from 0 to 1. When we reach `i = 5` in the loop and find `nums[5] = 1` with `flipped = 1`, we must flip `nums[5]` again. This ensures that the final value of `nums[5]` is 1, correcting any changes made by previous flips.\n\n#### Algorithm\n\n- Create a boolean array `flipped` of size `nums.size()` to keep track of flipped states.\n- Initialize `validFlipsFromPastWindow` to 0, representing valid flips within the past window.\n- Initialize `flipCount` to 0, representing the total number of flips needed.\n- Iterate through the `nums` array from index 0 to `nums.size() - 1`:\n    - If the current index `i` is greater than or equal to `k`:\n        - If `flipped[i - k]` is true, decrement `validFlipsFromPastWindow` (since the flip at `i - k` is no longer part of the current window).\n    - Check if the current bit `nums[i]` needs to be flipped:\n        - If `validFlipsFromPastWindow % 2 == nums[i]`:\n            - If `i + k > nums.size()`, return -1 (flipping the window extends beyond the array length).\n            - Increment `validFlipsFromPastWindow`.\n            - Set `flipped[i]` to true.\n            - Increment `flipCount`.\n- Return `flipCount`.\n\n#### Implementation#### Complexity Analysis\n\nLet $n$ be the size of the input array.\n\n- Time Complexity: $O(n)$\n    \n    The time complexity is $O(n)$ because we iterate through the input array once, performing constant-time operations inside the loop.\n\n- Space Complexity: $O(n)$\n\n    The space complexity is $O(n)$ because it creates a flipped array of size $n$ to track element states.\n\n---\n\n### Approach 2: Using a Deque\n\n#### Intuition\n\nInstead of using an array of size `n` to track flipped indices, a more space-efficient approach is to use a deque (double-ended queue) to manage the state of a sliding window of size `k`.\n\nAs we progress through the array, we continuously adjust the deque by discarding indices from its front that no longer belong to the current window. This ensures that the deque only retains indices within the current window, thereby eliminating unnecessary data.\n\nSimilar to the previous approach, we determine whether a flip is necessary based on the parity of the deque's size (representing the number of flips so far) compared to the current element's value. If these do not align, a flip operation is performed.\n\n**Proof by Contradiction:** \n\nThe key insight is that the problem has optimal substructure. This means that the optimal solution for the entire array includes optimal solutions for its subarrays.\n\nSuppose there was a better solution that didn't flip immediately upon seeing a 0. This would mean:\n\n1. We skip flipping at position `i` (where `nums[i] = 0`).\n2. We flip at some later position `j` (where `j > i`).\n\nBut this can't be better because:\n\n- We still need to make the same number of flips (or more).\n- We might run out of array length, making the problem unsolvable.\n\nTherefore, the greedy choice of flipping immediately is always optimal.\n\nThe Sliding Window:\n\nThe sliding window approach ensures that we only consider the relevant flips for each position. This is crucial because:\n\n- It allows us to \"forget\" flips that no longer affect the current position.\n- It ensures we accurately track the state of each element based on all relevant previous flips.\n\nIn essence, this greedy algorithm works because for this specific problem:\n\n1. Making the best choice right now (flip if needed) never compromises future choices.\n2. These local optimal choices accumulate to form the global optimal solution.\n\n#### Algorithm\n \n- Initialize `n` with `nums.size()`.\n- Create a deque `flipQueue` to keep track of flips.\n- Initialize `flipped` to 0, representing the current flip state.\n- Initialize `result` to 0, representing the total number of flips.\n- Iterate through the `nums` vector from index 0 to `n - 1`:\n    - If the current index `i` is greater than or equal to `k`:\n        - XOR `flipped` with the front element of `flipQueue`.\n        - Remove the front element from `flipQueue`.\n    - If `flipped == nums[i]` (the current bit needs to be flipped):\n        - If `i + k > n`, return -1 (flipping the window extends beyond the array length).\n        - Push 1 to `flipQueue`.\n        - XOR `flipped` with 1 (toggle the flipped state).\n        - Increment `result`.\n    - Else:\n        - Push 0 to `flipQueue`.\n- Return `result`.\n\nThe algorithm is visualized below:\n\n!?!../Documents/995/approach2.json:975,380!?!\n\n#### Implementation#### Complexity Analysis\n\nLet $n$ be the size of the input array.\n\n- Time complexity: $O(n)$\n\n    The time complexity is $O(n)$ because we make a single linear pass through the input array, performing constant-time operations inside the loop.\n\n- Space complexity: $O(k)$\n\n    The space complexity is $O(k)$ because it uses a deque `flipQueue` to track flips within the window size `k`, resulting in maximum size `k`.\n\n---\n\n### Approach 3: In Constant Space\n\n#### Intuition\n\nThis approach works as a one-pass solution without requiring any additional data structures. The main idea is to maintain a variable `currentFlips` that represents the number of flips in the current sliding window of size `k`, to decide whether we need to perform a flip or not.\n\nIf `currentFlips` is even and `nums[i]` is 0, we need to flip the bit. Similarly, if `currentFlips` is odd and `nums[i]` is 1, we also need to flip the bit. We use the parity of `currentFlips` (whether it's even or odd) to determine if the current bit needs flipping.\n\nTo perform a flip, we mark the current bit by setting `nums[i]` to 2, increment `currentFlips`, and increase `totalFlips`. As the window slides, if the element at the start of the previous window (`i - k`) was flipped (i.e., it was set to 2), we decrement `currentFlips`.\n\nIf flipping the current bit would go beyond the array bounds (i.e., `i + k` exceeds the array size), we return `-1` as it is impossible to make all elements 1. \n\n#### Algorithm\n\n- Initialize `currentFlips` to 0, representing the current number of flips.\n- Initialize `totalFlips` to 0, representing the total number of flips.\n- Iterate through the `nums` array from index 0 to `nums.size() - 1`:\n    - If the current index `i` is greater than or equal to `k` and `nums[i - k] == 2` (the leftmost element is marked as flipped):\n        - Decrement `currentFlips`.\n    - Check if the current bit `nums[i]` needs to be flipped:\n        - If `(currentFlips % 2) == nums[i]`:\n            - If `i + k > nums.size()`, return -1 (flipping the window extends beyond the array length).\n            - Set `nums[i]` to 2 (mark the current bit as flipped).\n            - Increment `currentFlips`.\n            - Increment `totalFlips`.\n- Return `totalFlips`.\n\nThe algorithm is visualized below:\n\n!?!../Documents/995/approach3.json:975,510!?!\n\n\n> Note: We have modified the `nums` array, but sometimes there are restrictions against changing the input. In such cases, you can restore the original value of `nums[i - k]` by subtracting 2 (`nums[i - k] -= 2;`) below the line where we decrement `currentFlips--`. This way, it will restore its original state before marking it as 2. This technique is a clever way to maintain the original array, but we haven't included it in the following implementation for easier visual understanding.\n\n\n#### Implementation#### Complexity Analysis\n\nLet $n$ be the size of input array.\n\n- Time complexity: $O(n)$\n\n    The algorithm iterates through the input array once with constant time operations inside the loop (comparisons, increments/decrements, and array access). This results in a linear time complexity.\n\n- Space complexity: $O(1)$\n\n    The algorithm uses constant additional space for variables like `currentFlips` and `totalFlips`. It doesn't create any data structures that scale with the input size (`n` or `k`). Therefore, the space complexity is constant. \n\n---"
}