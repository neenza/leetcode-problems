{
  "title": "Number of Substrings Containing All Three Characters",
  "problem_id": "1460",
  "frontend_id": "1358",
  "difficulty": "Medium",
  "problem_slug": "number-of-substrings-containing-all-three-characters",
  "topics": [
    "Hash Table",
    "String",
    "Sliding Window"
  ],
  "description": "Given a string sÂ consisting only of characters a, b and c.\nReturn the number of substrings containing at leastÂ one occurrence of all these characters a, b and c.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: s = \"abcabc\"\nOutput: 10\nExplanation: The substrings containingÂ at leastÂ one occurrence of the charactersÂ a,Â bÂ andÂ c are \"abc\", \"abca\", \"abcab\", \"abcabc\", \"bca\", \"bcab\", \"bcabc\", \"cab\", \"cabc\" and \"abc\" (again).",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input: s = \"aaacb\"\nOutput: 3\nExplanation: The substrings containingÂ at leastÂ one occurrence of the charactersÂ a,Â bÂ andÂ c are \"aaacb\", \"aacb\" and \"acb\".",
      "images": []
    },
    {
      "example_num": 3,
      "example_text": "Input: s = \"abc\"\nOutput: 1",
      "images": []
    }
  ],
  "constraints": [
    "3 <= s.length <= 5 x 10^4",
    "sÂ only consists ofÂ a, b or cÂ characters."
  ],
  "follow_ups": [],
  "hints": [
    "For each position we simply need to find the first occurrence of a/b/c on or after this position.",
    "So we can pre-compute three link-list of indices of each a, b, and c."
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    int numberOfSubstrings(string s) {\n        \n    }\n};",
    "java": "class Solution {\n    public int numberOfSubstrings(String s) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def numberOfSubstrings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def numberOfSubstrings(self, s: str) -> int:\n        ",
    "c": "int numberOfSubstrings(char* s) {\n    \n}",
    "csharp": "public class Solution {\n    public int NumberOfSubstrings(string s) {\n        \n    }\n}",
    "javascript": "/**\n * @param {string} s\n * @return {number}\n */\nvar numberOfSubstrings = function(s) {\n    \n};",
    "typescript": "function numberOfSubstrings(s: string): number {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param String $s\n     * @return Integer\n     */\n    function numberOfSubstrings($s) {\n        \n    }\n}",
    "swift": "class Solution {\n    func numberOfSubstrings(_ s: String) -> Int {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun numberOfSubstrings(s: String): Int {\n        \n    }\n}",
    "dart": "class Solution {\n  int numberOfSubstrings(String s) {\n    \n  }\n}",
    "golang": "func numberOfSubstrings(s string) int {\n    \n}",
    "ruby": "# @param {String} s\n# @return {Integer}\ndef number_of_substrings(s)\n    \nend",
    "scala": "object Solution {\n    def numberOfSubstrings(s: String): Int = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn number_of_substrings(s: String) -> i32 {\n        \n    }\n}",
    "racket": "(define/contract (number-of-substrings s)\n  (-> string? exact-integer?)\n  )",
    "erlang": "-spec number_of_substrings(S :: unicode:unicode_binary()) -> integer().\nnumber_of_substrings(S) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec number_of_substrings(s :: String.t) :: integer\n  def number_of_substrings(s) do\n    \n  end\nend"
  },
  "solution": "[TOC]\n\n## Solution\n\n---\n\n### Approach 1: Sliding Window\n\n#### Intuition\n\nThe brute force approach would be to consider every possible substring and individually check whether they contain all three characters. However, this would be quite inefficient and wouldn't meet the problem constraints.\n\nTo optimize this, we need to think about what makes a substring valid. If we find a substring that contains at least one occurrence of each required character, then any larger substring that includes it must also be valid. This means that once we identify a valid substring, we can immediately infer the validity of multiple other substrings that extend from it. For instance, if `\"abc\"` is a valid substring, then `\"abca\"` and `\"abcab\"` are automatically valid because they still include all three required characters.\n\nGiven this insight, we need an efficient way to locate and count valid substrings while avoiding redundant checks. A sliding window approach achieves this by dynamically expanding and contracting the window of characters we are considering. We use two pointers: `left` and `right`, which define the current window. The `right` pointer expands the window by adding new characters, and we maintain a frequency count of `a`, `b`, and `c` within the window. Once the window contains at least one occurrence of each character, we know we have found a valid substring.\n\nAt this point, we can count not just the current substring, but all possible extensions of it that still contain the required characters. To do this, we increment our total count by the number of ways we can extend the substring to the right. Next, we move the `left` pointer forward, shrinking the window while ensuring that it still contains all three characters. As long as it remains valid, we continue counting substrings from this new position. Once the window loses one of the required characters, we stop shrinking and move the `right` pointer again to expand the window.\n\nThe process ends when the `right` pointer reaches the end of the string, having considered all possible valid substrings. We can now return the total count as our required answer.\n\n#### Algorithm\n\nMain method `numberOfSubstrings`:\n- Initialize variables:\n  - `len` to store the length of the input string.\n  - `left` and `right`, both set to `0`, to track the sliding window.\n  - `total` to store the count of valid substrings.\n- Create an integer array `freq` of size 3 to store the frequency of characters `a`, `b`, and `c`.\n- While the `right` pointer is less than the `len`:\n  - Get the current character at the right pointer.\n  - Increment the frequency of the current character in the `freq` array.\n  - While all three characters (`a`, `b`, `c`) are present in the current window:\n    - Add the count of all possible substrings from the current window to the end of the string (`len` - `right`).\n    - Decrement the frequency of the character at the `left` pointer.\n    - Move the `left` pointer one step ahead.\n  - Move the `right` pointer one step ahead.\n- Return the `total` count of valid substrings.\n\nHelper method `hasAllChars(freq)`:\n- Return `true` if the frequency array contains at least one occurrence of each character (`a`, `b`, `c`).\n- Return `false` otherwise.\n\n#### Implementation#### Complexity Analysis\n\nLet $n$ be the length of the input string `s`.  \n\n- Time complexity: $O(n)$  \n\n    The algorithm uses a two-pointer approach with `left` and `right` traversing the string. Each character is processed at most twice - once when expanding `right` and once when contracting `left`. Since each operation inside the loop runs in constant time, the overall time complexity is $O(n)$.  \n\n- Space complexity: $O(1)$  \n\n    The algorithm maintains a fixed-size frequency array `freq` of size $3$ to track the counts of `'a'`, `'b'`, and `'c'`. Since this array does not grow with the input size, the space usage is constant, i.e., $O(1)$.\n\n---\n\n### Approach 2: Last Position Tracking\n\n#### Intuition\n\nInstead of thinking in terms of a sliding window, we can take a different perspective: for each position in the string, how many valid substrings end at this position? The key observation is that a substring is valid if it contains at least one occurrence of each required character (`a`, `b`, and `c`). However, instead of tracking exact counts, we only care about where the most recent occurrence of each character is.\n\nLet's use the string `\"abcab\"` as an example. When we reach position 4 (the last `'b'`), we need to include at least one `'a'` and one `'c'` to form valid substrings ending at this `'b'`. Looking backward, we find the last `'a'` at position 3 and the last `'c'` at position 2. To create a valid substring, we must include everything from the leftmost required character up to our current position.\n\nThis reveals an important pattern. At every position, we determine the leftmost occurrence among the last seen positions of `'a'`, `'b'`, and `'c'`. The number of valid substrings ending at this position is simply the number of possible starting points, which range from the beginning of the string up to this leftmost position.\n\nIn our `\"abcab\"` example, at position 4:\n- The last `'a'` appears at position 3.\n- The last `'b'` is at our current position 4.\n- The last `'c'` appears at position 2.\n\nSince `'c'` appears leftmost at position 2, any substring starting at positions 0, 1, or 2 and ending at position 4 will be valid. This gives us three valid substrings at this position!\n\nThis leads to a simple counting method: at each position, we add 1 plus the minimum of the last positions of `'a'`, `'b'`, and `'c'`. We add 1 because if the minimum position is $k$, we can start our substring at any position from $0$ to $k$, giving us $k + 1$ possible starting points.\n\nTo handle cases where a character hasn't appeared yet, we initialize its last position as `-1`. When calculating the minimum of the last positions, finding a `-1` tells us we don't have all the required characters yet, so we won't count any substrings at that position.\n\n> For a more comprehensive understanding of the sliding window technique, check out the [Sliding Window Explore Card ðŸ”—](https://leetcode.com/explore/learn/card/array-and-string/204/sliding-window/). This resource provides an in-depth look at the sliding window approach, explaining its key concepts and applications with a variety of problems to solidify understanding of the pattern.\n\n#### Algorithm\n \n- Initialize variables:\n  - `len` to store the length of the input string.\n  - `total` to store the count of valid substrings.\n- Create an integer array `lastPos` of size 3 with all values set to `-1` to track the most recent positions of characters `a`, `b`, and `c`.\n- For each position `pos` from `0` to `len`:\n  - Update the last position of the current character in the `lastPos` array.\n  - Find the minimum position among the last positions of `a`, `b`, and `c`.\n  - If all characters are present, the minimum gives the leftmost required character position.\n  - Add `1` plus this minimum position to the `total` count (accounting for 0-based indexing).\n- Return the `total` count of valid substrings.\n\nThe slideshow below demonstrates the algorithm in action:\n\n!?!../Documents/1358/slideshow.json:694,662!?!\n\n#### Implementation#### Complexity Analysis\n\nLet $n$ be the length of the input string `s`.  \n\n- Time complexity: $O(n)$  \n\n    The algorithm processes each character in the string exactly once using a single loop that runs $n$ times. Each iteration performs a constant amount of work, including updating the `lastPos` array and computing the minimum of three values. Thus, the overall time complexity remains linear, i.e., $O(n)$.  \n\n- Space complexity: $O(1)$  \n\n    The algorithm maintains a fixed-size array `lastPos` of length $3$ to track the last seen positions of characters `a`, `b`, and `c`. Since this array does not grow with the input size, the space usage is constant, i.e., $O(1)$.\n\n---"
}