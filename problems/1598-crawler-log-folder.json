{
  "title": "Crawler Log Folder",
  "problem_id": "1720",
  "frontend_id": "1598",
  "difficulty": "Easy",
  "problem_slug": "crawler-log-folder",
  "topics": [
    "Array",
    "String",
    "Stack"
  ],
  "description": "The Leetcode file system keeps a log each time some user performs a change folder operation.\nThe operations are described below:\nYou are given a list of strings logs where logs[i] is the operation performed by the user at the ith step.\nThe file system starts in the main folder, then the operations in logs are performed.\nReturn the minimum number of operations needed to go back to the main folder after the change folder operations.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: logs = [\"d1/\",\"d2/\",\"../\",\"d21/\",\"./\"]\nOutput: 2\nExplanation: Use this change folder operation \"../\" 2 times and go back to the main folder.",
      "images": [
        "https://assets.leetcode.com/uploads/2020/09/09/sample_11_1957.png"
      ]
    },
    {
      "example_num": 2,
      "example_text": "Input: logs = [\"d1/\",\"d2/\",\"./\",\"d3/\",\"../\",\"d31/\"]\nOutput: 3",
      "images": [
        "https://assets.leetcode.com/uploads/2020/09/09/sample_22_1957.png"
      ]
    },
    {
      "example_num": 3,
      "example_text": "Input: logs = [\"d1/\",\"../\",\"../\",\"../\"]\nOutput: 0",
      "images": [
        "https://assets.leetcode.com/uploads/2020/09/09/sample_22_1957.png"
      ]
    }
  ],
  "constraints": [
    "1 <= logs.length <= 103",
    "2 <= logs[i].length <= 10",
    "logs[i] contains lowercase English letters, digits, '.', and '/'.",
    "logs[i] follows the format described in the statement.",
    "Folder names consist of lowercase English letters and digits."
  ],
  "follow_ups": [],
  "hints": [
    "Simulate the process but don’t move the pointer beyond the main folder."
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    int minOperations(vector<string>& logs) {\n        \n    }\n};",
    "java": "class Solution {\n    public int minOperations(String[] logs) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def minOperations(self, logs):\n        \"\"\"\n        :type logs: List[str]\n        :rtype: int\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def minOperations(self, logs: List[str]) -> int:\n        ",
    "c": "int minOperations(char** logs, int logsSize) {\n    \n}",
    "csharp": "public class Solution {\n    public int MinOperations(string[] logs) {\n        \n    }\n}",
    "javascript": "/**\n * @param {string[]} logs\n * @return {number}\n */\nvar minOperations = function(logs) {\n    \n};",
    "typescript": "function minOperations(logs: string[]): number {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param String[] $logs\n     * @return Integer\n     */\n    function minOperations($logs) {\n        \n    }\n}",
    "swift": "class Solution {\n    func minOperations(_ logs: [String]) -> Int {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun minOperations(logs: Array<String>): Int {\n        \n    }\n}",
    "dart": "class Solution {\n  int minOperations(List<String> logs) {\n    \n  }\n}",
    "golang": "func minOperations(logs []string) int {\n    \n}",
    "ruby": "# @param {String[]} logs\n# @return {Integer}\ndef min_operations(logs)\n    \nend",
    "scala": "object Solution {\n    def minOperations(logs: Array[String]): Int = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn min_operations(logs: Vec<String>) -> i32 {\n        \n    }\n}",
    "racket": "(define/contract (min-operations logs)\n  (-> (listof string?) exact-integer?)\n  )",
    "erlang": "-spec min_operations(Logs :: [unicode:unicode_binary()]) -> integer().\nmin_operations(Logs) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec min_operations(logs :: [String.t]) :: integer\n  def min_operations(logs) do\n    \n  end\nend"
  },
  "solution": "[TOC]\n\n## Solution\n\n---\n\n### Overview\n\nGiven a list of strings `logs`, the task is to calculate the minimum steps needed to navigate back to the main folder.\n\nEach string in `logs` represents a moving operation:\n\n- `\"../\"`: To the Parent Folder\n- `\"./\"`: Staying in the same Folder\n- `\"x/\"`: To the Child Folder named `x`\n\n---\n\n### Approach 1: Counter\n\n#### Intuition\n\nTo solve this problem, we need to track the user's position within the folder structure relative to the main folder. We can achieve this using a numerical counter that represents the depth of the current folder.\n\nHere's how the counter system works when we move around the file system:\n\n1. We initialize the counter to 0, representing the main folder.\n2. If we enter a child folder (`\"x/\"`), we increase the counter by 1 to go deeper into the folder structure.\n3. When we encounter `\"../\"`, we decrease the counter by 1 to move up a level. If the counter is already at 0, it remains at 0 because we can't move above the main folder.\n4. `\"./\"` operations do not change the counter since they keep us in the current folder.\n\nWe process each operation in the `logs` sequentially, updating our counter according to these rules. This approach allows us to track the user's depth in the folder structure without needing to store or process the actual folder names or full paths.\n\n#### Algorithm\n\n- Initialize `folderDepth` to `0` to keep track of the current depth in the file system.\n- For each `currentOperation` in `logs`, perform the following steps:\n    - If `currentOperation` equals `\"../\"`, decrease `folderDepth` by `1` to move up one directory level, but ensure `folderDepth` does not go below `0` (to prevent navigating above the root directory).\n    - If `currentOperation` equals `\"./\"`, ignore it, as it means staying in the current directory and does not affect `folderDepth`.\n    - For any other `currentOperation`(`\"x/\"`), increment `folderDepth` by `1`, indicating moving into a new directory.\n- Return `folderDepth` as the minimum number of operations required to navigate back to the main folder.\n\n#### Implementation#### Complexity Analysis\n\nLet $n$ be the size of `logs` array.\n\n- Time complexity: $O(n)$\n\n    The algorithm iterates through each operation exactly once.\n    \n    > Note: String matching operations take linear time with respect to the length of the string. However, given the constraint that the length of the strings is limited to 10, this does not significantly impact the overall time complexity. \n\n- Space complexity: $O(1)$\n\n    The algorithm uses a constant amount of extra space (`folderDepth`), regardless of the size of `logs`.\n\n---\n\n### Approach 2: Stack\n\n#### Intuition\n\nThere’s no need for a stack or other data structures because we only care about the depth, not the actual path taken. We include this approach here for completeness in the article, in case you might be asked about the actual path in an interview scenario.\n\nWe use a stack to represent the folder structure, where each element denotes a folder and the stack's height indicates our current depth in the structure.\n\nStarting with an empty stack represents being in the main folder. We process each operation in the `logs` array sequentially:\n- When we encounter a folder name (any operation that isn't `\"../\"` or `\"./\"`), we push it onto the stack, signifying entry into a new folder.\n- Upon encountering `\"../\"`, we move up to the parent folder by popping the top element from the stack, provided the stack isn't empty. An empty stack means we're already at the main folder.\n- `\"./\"` operations are ignored as they maintain the current folder context.\n\nAfter processing all operations, the stack's height reflects our depth in the folder structure. This height also corresponds to the number of operations needed to return to the main folder, as each `\"../\"` operation represents moving up one level.\n\n> This algorithm may not seem directly useful if you're just looking to solve this specific question, but in practice, it mirrors how we navigate folders in real life. Entering a folder adds it to your path, and going up removes the last folder from your path. It naturally handles redundant operations. If you enter and then immediately exit a folder, the stack returns to its previous state, akin to real folder navigation. It retains only the essential information: the folders necessary to return to the main folder at any point.\n\n#### Algorithm\n \n- Initialize an empty stack `folderStack`. This stack will track the sequence of directories as we navigate through them.\n- For each `currentOperation` in `logs`, perform the following steps:\n    - If `currentOperation` equals `\"../\"`, check if `folderStack` is not empty. If true, pop the top directory from `folderStack` to move up to the parent directory.\n    - If `currentOperation` equals `\"./\"`, ignore it as it signifies staying in the current directory and does not change the stack.\n    - For any other `currentOperation`, push `currentOperation` onto `folderStack`, indicating we are entering a new directory.\n- Operations such as `\"./\"` are ignored because they do not change the current directory structure represented by `folderStack`.\n- Return the size of `folderStack` as it represents the minimum number of operations required to navigate the file system effectively. The size of `folderStack` corresponds to the depth of the directory structure we have navigated.\n\nThe algorithm is visualized below:\n\n!?!../Documents/1598/approach2.json:975,448!?!\n\n#### Implementation#### Complexity Analysis\n\nLet $n$ be the size of `logs` array.\n\n* Time complexity: $O(n)$\n\n    The algorithm iterates through each operation exactly once. This is because each operation (`push` or `pop`) on the stack is $O(1)$, and we perform exactly one operation per entry in logs.\n\n* Space complexity: $O(n)$\n\n    The algorithm uses linear amount of extra space (`folderStack`). This is because the stack (`folderStack`) can store up to `n` entries.\n\n---"
}