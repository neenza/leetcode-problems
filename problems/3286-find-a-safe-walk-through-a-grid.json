{
  "title": "Find a Safe Walk Through a Grid",
  "problem_id": "3558",
  "frontend_id": "3286",
  "difficulty": "Medium",
  "problem_slug": "find-a-safe-walk-through-a-grid",
  "topics": [
    "Array",
    "Breadth-First Search",
    "Graph",
    "Heap (Priority Queue)",
    "Matrix",
    "Shortest Path"
  ],
  "description": "You are given an m x n binary matrix grid and an integer health.\nYou start on the upper-left corner (0, 0) and would like to get to the lower-right corner (m - 1, n - 1).\nYou can move up, down, left, or right from one cell to another adjacent cell as long as your health remains positive.\nCells (i, j) with grid[i][j] = 1 are considered unsafe and reduce your health by 1.\nReturn true if you can reach the final cell with a health value of 1 or more, and false otherwise.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: grid = [[0,1,0,0,0],[0,1,0,1,0],[0,0,0,1,0]], health = 1\nOutput: true\nExplanation:\nThe final cell can be reached safely by walking along the gray cells below.",
      "images": [
        "https://assets.leetcode.com/uploads/2024/08/04/3868_examples_1drawio.png"
      ]
    },
    {
      "example_num": 2,
      "example_text": "Input: grid = [[0,1,1,0,0,0],[1,0,1,0,0,0],[0,1,1,1,0,1],[0,0,1,0,1,0]], health = 3\nOutput: false\nExplanation:\nA minimum of 4 health points is needed to reach the final cell safely.",
      "images": [
        "https://assets.leetcode.com/uploads/2024/08/04/3868_examples_2drawio.png"
      ]
    },
    {
      "example_num": 3,
      "example_text": "Input: grid = [[1,1,1],[1,0,1],[1,1,1]], health = 5\nOutput: true\nExplanation:\nThe final cell can be reached safely by walking along the gray cells below.\n\nAny path that does not go through the cell (1, 1) is unsafe since your health will drop to 0 when reaching the final cell.",
      "images": [
        "https://assets.leetcode.com/uploads/2024/08/04/3868_examples_3drawio.png"
      ]
    }
  ],
  "constraints": [
    "m == grid.length",
    "n == grid[i].length",
    "1 <= m, n <= 50",
    "2 <= m * n",
    "1 <= health <= m + n",
    "grid[i][j] is either 0 or 1."
  ],
  "follow_ups": [],
  "hints": [
    "Use 01 BFS."
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    bool findSafeWalk(vector<vector<int>>& grid, int health) {\n        \n    }\n};",
    "java": "class Solution {\n    public boolean findSafeWalk(List<List<Integer>> grid, int health) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def findSafeWalk(self, grid, health):\n        \"\"\"\n        :type grid: List[List[int]]\n        :type health: int\n        :rtype: bool\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def findSafeWalk(self, grid: List[List[int]], health: int) -> bool:\n        ",
    "c": "bool findSafeWalk(int** grid, int gridSize, int* gridColSize, int health) {\n    \n}",
    "csharp": "public class Solution {\n    public bool FindSafeWalk(IList<IList<int>> grid, int health) {\n        \n    }\n}",
    "javascript": "/**\n * @param {number[][]} grid\n * @param {number} health\n * @return {boolean}\n */\nvar findSafeWalk = function(grid, health) {\n    \n};",
    "typescript": "function findSafeWalk(grid: number[][], health: number): boolean {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param Integer[][] $grid\n     * @param Integer $health\n     * @return Boolean\n     */\n    function findSafeWalk($grid, $health) {\n        \n    }\n}",
    "swift": "class Solution {\n    func findSafeWalk(_ grid: [[Int]], _ health: Int) -> Bool {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun findSafeWalk(grid: List<List<Int>>, health: Int): Boolean {\n        \n    }\n}",
    "dart": "class Solution {\n  bool findSafeWalk(List<List<int>> grid, int health) {\n    \n  }\n}",
    "golang": "func findSafeWalk(grid [][]int, health int) bool {\n    \n}",
    "ruby": "# @param {Integer[][]} grid\n# @param {Integer} health\n# @return {Boolean}\ndef find_safe_walk(grid, health)\n    \nend",
    "scala": "object Solution {\n    def findSafeWalk(grid: List[List[Int]], health: Int): Boolean = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn find_safe_walk(grid: Vec<Vec<i32>>, health: i32) -> bool {\n        \n    }\n}",
    "racket": "(define/contract (find-safe-walk grid health)\n  (-> (listof (listof exact-integer?)) exact-integer? boolean?)\n  )",
    "erlang": "-spec find_safe_walk(Grid :: [[integer()]], Health :: integer()) -> boolean().\nfind_safe_walk(Grid, Health) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec find_safe_walk(grid :: [[integer]], health :: integer) :: boolean\n  def find_safe_walk(grid, health) do\n    \n  end\nend"
  }
}