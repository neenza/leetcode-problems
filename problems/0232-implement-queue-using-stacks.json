{
  "title": "Implement Queue using Stacks",
  "problem_id": "232",
  "frontend_id": "232",
  "difficulty": "Easy",
  "problem_slug": "implement-queue-using-stacks",
  "topics": [
    "Stack",
    "Design",
    "Queue"
  ],
  "description": "Implement a first in first out (FIFO) queue using only two stacks. The implemented queue should support all the functions of a normal queue (push, peek, pop, and empty).\nImplement the MyQueue class:\nNotes:\nExample 1:\nConstraints:\nFollow-up: Can you implement the queue such that each operation is amortized O(1) time complexity? In other words, performing n operations will take overall O(n) time even if one of those operations may take longer.",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input\n[\"MyQueue\", \"push\", \"push\", \"peek\", \"pop\", \"empty\"]\n[[], [1], [2], [], [], []]\nOutput\n[null, null, null, 1, 1, false]\n\nExplanation\nMyQueue myQueue = new MyQueue();\nmyQueue.push(1); // queue is: [1]\nmyQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue)\nmyQueue.peek(); // return 1\nmyQueue.pop(); // return 1, queue is [2]\nmyQueue.empty(); // return false",
      "images": []
    }
  ],
  "constraints": [
    "1 <= x <= 9",
    "At most 100Â calls will be made to push, pop, peek, and empty.",
    "All the calls to pop and peek are valid."
  ],
  "follow_ups": [],
  "hints": [],
  "code_snippets": {
    "cpp": "class MyQueue {\npublic:\n    MyQueue() {\n        \n    }\n    \n    void push(int x) {\n        \n    }\n    \n    int pop() {\n        \n    }\n    \n    int peek() {\n        \n    }\n    \n    bool empty() {\n        \n    }\n};\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue* obj = new MyQueue();\n * obj->push(x);\n * int param_2 = obj->pop();\n * int param_3 = obj->peek();\n * bool param_4 = obj->empty();\n */",
    "java": "class MyQueue {\n\n    public MyQueue() {\n        \n    }\n    \n    public void push(int x) {\n        \n    }\n    \n    public int pop() {\n        \n    }\n    \n    public int peek() {\n        \n    }\n    \n    public boolean empty() {\n        \n    }\n}\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue obj = new MyQueue();\n * obj.push(x);\n * int param_2 = obj.pop();\n * int param_3 = obj.peek();\n * boolean param_4 = obj.empty();\n */",
    "python": "class MyQueue(object):\n\n    def __init__(self):\n        \n\n    def push(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: None\n        \"\"\"\n        \n\n    def pop(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        \n\n    def peek(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        \n\n    def empty(self):\n        \"\"\"\n        :rtype: bool\n        \"\"\"\n        \n\n\n# Your MyQueue object will be instantiated and called as such:\n# obj = MyQueue()\n# obj.push(x)\n# param_2 = obj.pop()\n# param_3 = obj.peek()\n# param_4 = obj.empty()",
    "python3": "class MyQueue:\n\n    def __init__(self):\n        \n\n    def push(self, x: int) -> None:\n        \n\n    def pop(self) -> int:\n        \n\n    def peek(self) -> int:\n        \n\n    def empty(self) -> bool:\n        \n\n\n# Your MyQueue object will be instantiated and called as such:\n# obj = MyQueue()\n# obj.push(x)\n# param_2 = obj.pop()\n# param_3 = obj.peek()\n# param_4 = obj.empty()",
    "c": "\n\n\ntypedef struct {\n    \n} MyQueue;\n\n\nMyQueue* myQueueCreate() {\n    \n}\n\nvoid myQueuePush(MyQueue* obj, int x) {\n    \n}\n\nint myQueuePop(MyQueue* obj) {\n    \n}\n\nint myQueuePeek(MyQueue* obj) {\n    \n}\n\nbool myQueueEmpty(MyQueue* obj) {\n    \n}\n\nvoid myQueueFree(MyQueue* obj) {\n    \n}\n\n/**\n * Your MyQueue struct will be instantiated and called as such:\n * MyQueue* obj = myQueueCreate();\n * myQueuePush(obj, x);\n \n * int param_2 = myQueuePop(obj);\n \n * int param_3 = myQueuePeek(obj);\n \n * bool param_4 = myQueueEmpty(obj);\n \n * myQueueFree(obj);\n*/",
    "csharp": "public class MyQueue {\n\n    public MyQueue() {\n        \n    }\n    \n    public void Push(int x) {\n        \n    }\n    \n    public int Pop() {\n        \n    }\n    \n    public int Peek() {\n        \n    }\n    \n    public bool Empty() {\n        \n    }\n}\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue obj = new MyQueue();\n * obj.Push(x);\n * int param_2 = obj.Pop();\n * int param_3 = obj.Peek();\n * bool param_4 = obj.Empty();\n */",
    "javascript": "\nvar MyQueue = function() {\n    \n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function(x) {\n    \n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.pop = function() {\n    \n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.peek = function() {\n    \n};\n\n/**\n * @return {boolean}\n */\nMyQueue.prototype.empty = function() {\n    \n};\n\n/** \n * Your MyQueue object will be instantiated and called as such:\n * var obj = new MyQueue()\n * obj.push(x)\n * var param_2 = obj.pop()\n * var param_3 = obj.peek()\n * var param_4 = obj.empty()\n */",
    "typescript": "class MyQueue {\n    constructor() {\n        \n    }\n\n    push(x: number): void {\n        \n    }\n\n    pop(): number {\n        \n    }\n\n    peek(): number {\n        \n    }\n\n    empty(): boolean {\n        \n    }\n}\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * var obj = new MyQueue()\n * obj.push(x)\n * var param_2 = obj.pop()\n * var param_3 = obj.peek()\n * var param_4 = obj.empty()\n */",
    "php": "class MyQueue {\n    /**\n     */\n    function __construct() {\n        \n    }\n  \n    /**\n     * @param Integer $x\n     * @return NULL\n     */\n    function push($x) {\n        \n    }\n  \n    /**\n     * @return Integer\n     */\n    function pop() {\n        \n    }\n  \n    /**\n     * @return Integer\n     */\n    function peek() {\n        \n    }\n  \n    /**\n     * @return Boolean\n     */\n    function empty() {\n        \n    }\n}\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * $obj = MyQueue();\n * $obj->push($x);\n * $ret_2 = $obj->pop();\n * $ret_3 = $obj->peek();\n * $ret_4 = $obj->empty();\n */",
    "swift": "\nclass MyQueue {\n\n    init() {\n        \n    }\n    \n    func push(_ x: Int) {\n        \n    }\n    \n    func pop() -> Int {\n        \n    }\n    \n    func peek() -> Int {\n        \n    }\n    \n    func empty() -> Bool {\n        \n    }\n}\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * let obj = MyQueue()\n * obj.push(x)\n * let ret_2: Int = obj.pop()\n * let ret_3: Int = obj.peek()\n * let ret_4: Bool = obj.empty()\n */",
    "kotlin": "class MyQueue() {\n\n    fun push(x: Int) {\n        \n    }\n\n    fun pop(): Int {\n        \n    }\n\n    fun peek(): Int {\n        \n    }\n\n    fun empty(): Boolean {\n        \n    }\n\n}\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * var obj = MyQueue()\n * obj.push(x)\n * var param_2 = obj.pop()\n * var param_3 = obj.peek()\n * var param_4 = obj.empty()\n */",
    "dart": "class MyQueue {\n\n  MyQueue() {\n    \n  }\n  \n  void push(int x) {\n    \n  }\n  \n  int pop() {\n    \n  }\n  \n  int peek() {\n    \n  }\n  \n  bool empty() {\n    \n  }\n}\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue obj = MyQueue();\n * obj.push(x);\n * int param2 = obj.pop();\n * int param3 = obj.peek();\n * bool param4 = obj.empty();\n */",
    "golang": "type MyQueue struct {\n    \n}\n\n\nfunc Constructor() MyQueue {\n    \n}\n\n\nfunc (this *MyQueue) Push(x int)  {\n    \n}\n\n\nfunc (this *MyQueue) Pop() int {\n    \n}\n\n\nfunc (this *MyQueue) Peek() int {\n    \n}\n\n\nfunc (this *MyQueue) Empty() bool {\n    \n}\n\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * obj := Constructor();\n * obj.Push(x);\n * param_2 := obj.Pop();\n * param_3 := obj.Peek();\n * param_4 := obj.Empty();\n */",
    "ruby": "class MyQueue\n    def initialize()\n        \n    end\n\n\n=begin\n    :type x: Integer\n    :rtype: Void\n=end\n    def push(x)\n        \n    end\n\n\n=begin\n    :rtype: Integer\n=end\n    def pop()\n        \n    end\n\n\n=begin\n    :rtype: Integer\n=end\n    def peek()\n        \n    end\n\n\n=begin\n    :rtype: Boolean\n=end\n    def empty()\n        \n    end\n\n\nend\n\n# Your MyQueue object will be instantiated and called as such:\n# obj = MyQueue.new()\n# obj.push(x)\n# param_2 = obj.pop()\n# param_3 = obj.peek()\n# param_4 = obj.empty()",
    "scala": "class MyQueue() {\n\n    def push(x: Int): Unit = {\n        \n    }\n\n    def pop(): Int = {\n        \n    }\n\n    def peek(): Int = {\n        \n    }\n\n    def empty(): Boolean = {\n        \n    }\n\n}\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * val obj = new MyQueue()\n * obj.push(x)\n * val param_2 = obj.pop()\n * val param_3 = obj.peek()\n * val param_4 = obj.empty()\n */",
    "rust": "struct MyQueue {\n\n}\n\n\n/** \n * `&self` means the method takes an immutable reference.\n * If you need a mutable reference, change it to `&mut self` instead.\n */\nimpl MyQueue {\n\n    fn new() -> Self {\n        \n    }\n    \n    fn push(&self, x: i32) {\n        \n    }\n    \n    fn pop(&self) -> i32 {\n        \n    }\n    \n    fn peek(&self) -> i32 {\n        \n    }\n    \n    fn empty(&self) -> bool {\n        \n    }\n}\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * let obj = MyQueue::new();\n * obj.push(x);\n * let ret_2: i32 = obj.pop();\n * let ret_3: i32 = obj.peek();\n * let ret_4: bool = obj.empty();\n */",
    "racket": "(define my-queue%\n  (class object%\n    (super-new)\n    \n    (init-field)\n    \n    ; push : exact-integer? -> void?\n    (define/public (push x)\n      )\n    ; pop : -> exact-integer?\n    (define/public (pop)\n      )\n    ; peek : -> exact-integer?\n    (define/public (peek)\n      )\n    ; empty : -> boolean?\n    (define/public (empty)\n      )))\n\n;; Your my-queue% object will be instantiated and called as such:\n;; (define obj (new my-queue%))\n;; (send obj push x)\n;; (define param_2 (send obj pop))\n;; (define param_3 (send obj peek))\n;; (define param_4 (send obj empty))",
    "erlang": "-spec my_queue_init_() -> any().\nmy_queue_init_() ->\n  .\n\n-spec my_queue_push(X :: integer()) -> any().\nmy_queue_push(X) ->\n  .\n\n-spec my_queue_pop() -> integer().\nmy_queue_pop() ->\n  .\n\n-spec my_queue_peek() -> integer().\nmy_queue_peek() ->\n  .\n\n-spec my_queue_empty() -> boolean().\nmy_queue_empty() ->\n  .\n\n\n%% Your functions will be called as such:\n%% my_queue_init_(),\n%% my_queue_push(X),\n%% Param_2 = my_queue_pop(),\n%% Param_3 = my_queue_peek(),\n%% Param_4 = my_queue_empty(),\n\n%% my_queue_init_ will be called before every test case, in which you can do some necessary initializations.",
    "elixir": "defmodule MyQueue do\n  @spec init_() :: any\n  def init_() do\n    \n  end\n\n  @spec push(x :: integer) :: any\n  def push(x) do\n    \n  end\n\n  @spec pop() :: integer\n  def pop() do\n    \n  end\n\n  @spec peek() :: integer\n  def peek() do\n    \n  end\n\n  @spec empty() :: boolean\n  def empty() do\n    \n  end\nend\n\n# Your functions will be called as such:\n# MyQueue.init_()\n# MyQueue.push(x)\n# param_2 = MyQueue.pop()\n# param_3 = MyQueue.peek()\n# param_4 = MyQueue.empty()\n\n# MyQueue.init_ will be called before every test case, in which you can do some necessary initializations."
  },
  "solution": "[TOC]\n\n## Summary\nThis article is for beginners. It introduces the following ideas:\nQueue, Stack.\n\n## Solution\n\nQueue is **FIFO** (first in - first out) data structure, in which the elements are inserted from one side - `rear` and removed from the other - `front`.\nThe most intuitive way to implement it is with linked lists, but this article will introduce another approach  using stacks.\nStack is **LIFO** (last in - first out) data structure, in which elements are added and removed from the same end, called `top`.\nTo satisfy **FIFO** property of a queue we need to keep two stacks. They serve to reverse arrival order of the  elements and one of them store the queue elements in their final order.\n\n---\n\n### Approach #1 (Two Stacks) Push - $O(n)$ per operation, Pop - $O(1)$ per operation.\n\n#### Push\n\nA queue is FIFO (first-in-first-out) but a stack is LIFO (last-in-first-out). This means the newest element must be pushed to the bottom of the stack. To do so we first transfer all `s1` elements to auxiliary stack `s2`. Then the newly arrived element is pushed on top of `s2` and all its elements are popped and pushed to `s1`.\n\n![Push an element in queue](https://leetcode.com/media/original_images/232_queue_using_stacksBPush.png){:width=\"539px\"}\n\n\n*Figure 1. Push an element in queue*#### Complexity Analysis**\n\n* Time complexity : $O(n)$.\n\n Each element, with the exception of the newly arrived, is pushed and popped twice. The last inserted element is popped and pushed once. Therefore this gives  $4 n + 2$  operations where $n$ is the queue size. The  `push` and `pop` operations have $O(1)$ time complexity.\n\n* Space complexity : $O(n)$.\nWe need additional memory to store the queue elements\n\n#### Pop\n\nThe algorithm pops an element from  the stack `s1`, because `s1` stores always on its top the first inserted element in the queue.\nThe front element of the queue is kept as `front`.\n\n![Pop an element from queue](https://leetcode.com/media/original_images/232_queue_using_stacksBPop.png){:width=\"539px\"}\n\n\n*Figure 2. Pop an element from queue*#### Complexity Analysis\n\n* Time complexity : $O(1)$.\n* Space complexity : $O(1)$.\n\n#### Empty\n\nStack `s1` contains all stack elements, so the algorithm checks `s1` size to return if the queue is empty.#### Complexity Analysis\n\n* Time complexity : $O(1)$.\n* Space complexity : $O(1)$.\n\n#### Peek\n\nThe `front` element is kept in constant memory and is modified when we push or pop an element.#### Complexity Analysis\n\n* Time complexity : $O(1)$. The `front` element has been calculated in advance and only returned in `peek` operation.\n* Space complexity : $O(1)$.\n\n---\n\n### Approach #2 (Two Stacks) Push - $O(1)$ per operation, Pop - Amortized $O(1)$ per operation.\n\n\n#### Push\n\nThe newly arrived element is always added on top of stack `s1` and the first element is kept as `front` queue element\n\n![Push an element in queue](https://leetcode.com/media/original_images/232_queue_using_stacksAPush.png){:width=\"539px\"}\n\n\n*Figure 3. Push an element in queue*#### Complexity Analysis\n\n* Time complexity : $O(1)$. Ðppending an element to a stack is an O(1) operation.\n\n* Space complexity : $O(n)$. We need additional memory to store the queue elements\n\n#### Pop\n\nWe have to remove element in front of the queue. This is the first inserted element in the stack `s1` and it is positioned at the bottom of the stack because of stack's `LIFO (last in - first out)` policy. To remove the bottom element  from  `s1`, we have to pop all elements from `s1` and to push them on to an additional stack `s2`, which helps us to store the elements of `s1` in reversed order. This way  the bottom element of `s1` will be positioned on top of `s2` and we can simply pop it from stack `s2`. Once `s2` is empty, the algorithm transfer data from `s1` to `s2` again.\n\n![Pop an element from stack](https://leetcode.com/media/original_images/232_queue_using_stacksAPop.png){:width=\"539px\"}\n\n\n*Figure 4. Pop an element from stack*#### Complexity Analysis\n\n* Time complexity: Amortized $O(1)$, Worst-case $O(n)$. In the worst case scenario when stack `s2` is empty, the algorithm pops $n$ elements from stack s1 and pushes $n$ elements to `s2`, where $n$ is the queue size. This gives $2n$ operations, which is $O(n)$. But when stack `s2` is not empty the algorithm has $O(1)$ time complexity. So what does it mean by Amortized $O(1)$? Please see the next section on Amortized Analysis for more information.\n\n* Space complexity : $O(1)$.\n\n#### Amortized Analysis\n\nAmortized analysis gives the average performance (over time) of each operation in the worst case. The basic idea is that a worst case operation can alter the state in such a way that the worst case cannot occur again for a long time, thus amortizing its cost.\n\nConsider this example where we start with an empty queue with the following sequence of operations applied:\n\n$$\npush_1, push_2, \\ldots, push_n, pop_1,pop_2 \\ldots, pop_n\n$$\n\nThe worst case time complexity of a single pop operation is $O(n)$. Since we have $n$ pop operations, using the worst-case per operation analysis gives us a total of $O(n^2)$ time.\n\nHowever, in a sequence of operations the worst case does not occur often in each operation - some operations may be cheap, some may be expensive. Therefore, a traditional worst-case per operation analysis can give overly pessimistic bound. For example, in a dynamic array only some inserts take a linear time, though others - a constant time.\n\nIn the example above, the number of times pop operation can be called is limited by the number of push operations before it. Although a single pop operation could be expensive, it is expensive only once per `n` times (queue size), when `s2` is empty and there is a need for data transfer between `s1` and `s2`. Hence the total time complexity of the sequence is : `n` (for push operations) + `2*n` (for first pop operation) + `n - 1` ( for pop operations) which is $O(2*n)$.This gives $O(2n/2n)$ = $O(1)$ average time per operation.\n\n#### Empty\n\nBoth stacks `s1` and `s2` contain all stack elements, so the algorithm checks `s1` and `s2` size to return if the queue is empty.#### Complexity Analysis\n\n* Time complexity : $O(1)$.\n* Space complexity : $O(1)$.\n\n\n#### Peek\n\nThe `front` element is kept in constant memory and is modified when we push an element. When `s2` is not empty, front element is positioned on the top of `s2`#### Complexity Analysis\n\n* Time complexity : $O(1)$. The `front` element was either previously calculated or returned as a top element of stack `s2`. Therefore complexity is $O(1)$\n* Space complexity : $O(1)$."
}