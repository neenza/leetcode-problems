{
  "title": "Minimum Cost to Connect Two Groups of Points",
  "problem_id": "1717",
  "frontend_id": "1595",
  "difficulty": "Hard",
  "problem_slug": "minimum-cost-to-connect-two-groups-of-points",
  "topics": [
    "Array",
    "Dynamic Programming",
    "Bit Manipulation",
    "Matrix",
    "Bitmask"
  ],
  "description": "You are given two groups of points where the first group has size1 points, the second group has size2 points, and size1 >= size2.\nThe cost of the connection between any two points are given in an size1 x size2 matrix where cost[i][j] is the cost of connecting point i of the first group and point j of the second group. The groups are connected if each point in both groups is connected to one or more points in the opposite group. In other words, each point in the first group must be connected to at least one point in the second group, and each point in the second group must be connected to at least one point in the first group.\nReturn the minimum cost it takes to connect the two groups.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: cost = [[15, 96], [36, 2]]\nOutput: 17\nExplanation: The optimal way of connecting the groups is:\n1--A\n2--B\nThis results in a total cost of 17.",
      "images": [
        "https://assets.leetcode.com/uploads/2020/09/03/ex1.jpg"
      ]
    },
    {
      "example_num": 2,
      "example_text": "Input: cost = [[1, 3, 5], [4, 1, 1], [1, 5, 3]]\nOutput: 4\nExplanation: The optimal way of connecting the groups is:\n1--A\n2--B\n2--C\n3--A\nThis results in a total cost of 4.\nNote that there are multiple points connected to point 2 in the first group and point A in the second group. This does not matter as there is no limit to the number of points that can be connected. We only care about the minimum total cost.",
      "images": [
        "https://assets.leetcode.com/uploads/2020/09/03/ex2.jpg"
      ]
    },
    {
      "example_num": 3,
      "example_text": "Input: cost = [[2, 5, 1], [3, 4, 7], [8, 1, 2], [6, 2, 4], [3, 8, 8]]\nOutput: 10",
      "images": [
        "https://assets.leetcode.com/uploads/2020/09/03/ex2.jpg"
      ]
    }
  ],
  "constraints": [
    "size1 == cost.length",
    "size2 == cost[i].length",
    "1 <= size1, size2 <= 12",
    "size1 >= size2",
    "0 <= cost[i][j] <= 100"
  ],
  "follow_ups": [],
  "hints": [
    "Each point on the left would either be connected to exactly point already connected to some left node, or a subset of the nodes on the right which are not connected to any node",
    "Use dynamic programming with bitmasking, where the state will be (number of points assigned in first group, bitmask of points assigned in second group)."
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    int connectTwoGroups(vector<vector<int>>& cost) {\n        \n    }\n};",
    "java": "class Solution {\n    public int connectTwoGroups(List<List<Integer>> cost) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def connectTwoGroups(self, cost):\n        \"\"\"\n        :type cost: List[List[int]]\n        :rtype: int\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def connectTwoGroups(self, cost: List[List[int]]) -> int:\n        ",
    "c": "int connectTwoGroups(int** cost, int costSize, int* costColSize) {\n    \n}",
    "csharp": "public class Solution {\n    public int ConnectTwoGroups(IList<IList<int>> cost) {\n        \n    }\n}",
    "javascript": "/**\n * @param {number[][]} cost\n * @return {number}\n */\nvar connectTwoGroups = function(cost) {\n    \n};",
    "typescript": "function connectTwoGroups(cost: number[][]): number {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param Integer[][] $cost\n     * @return Integer\n     */\n    function connectTwoGroups($cost) {\n        \n    }\n}",
    "swift": "class Solution {\n    func connectTwoGroups(_ cost: [[Int]]) -> Int {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun connectTwoGroups(cost: List<List<Int>>): Int {\n        \n    }\n}",
    "dart": "class Solution {\n  int connectTwoGroups(List<List<int>> cost) {\n    \n  }\n}",
    "golang": "func connectTwoGroups(cost [][]int) int {\n    \n}",
    "ruby": "# @param {Integer[][]} cost\n# @return {Integer}\ndef connect_two_groups(cost)\n    \nend",
    "scala": "object Solution {\n    def connectTwoGroups(cost: List[List[Int]]): Int = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn connect_two_groups(cost: Vec<Vec<i32>>) -> i32 {\n        \n    }\n}",
    "racket": "(define/contract (connect-two-groups cost)\n  (-> (listof (listof exact-integer?)) exact-integer?)\n  )",
    "erlang": "-spec connect_two_groups(Cost :: [[integer()]]) -> integer().\nconnect_two_groups(Cost) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec connect_two_groups(cost :: [[integer]]) :: integer\n  def connect_two_groups(cost) do\n    \n  end\nend"
  }
}