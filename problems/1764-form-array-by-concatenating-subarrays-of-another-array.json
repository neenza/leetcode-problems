{
  "title": "Form Array by Concatenating Subarrays of Another Array",
  "problem_id": "1874",
  "frontend_id": "1764",
  "difficulty": "Medium",
  "problem_slug": "form-array-by-concatenating-subarrays-of-another-array",
  "topics": [
    "Array",
    "Two Pointers",
    "Greedy",
    "String Matching"
  ],
  "description": "You are given a 2D integer array groups of length n. You are also given an integer array nums.\nYou are asked if you can choose n disjoint subarrays from the array nums such that the ith subarray is equal to groups[i] (0-indexed), and if i > 0, the (i-1)th subarray appears before the ith subarray in nums (i.e. the subarrays must be in the same order as groups).\nReturn true if you can do this task, and false otherwise.\nNote that the subarrays are disjoint if and only if there is no index k such that nums[k] belongs to more than one subarray. A subarray is a contiguous sequence of elements within an array.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: groups = [[1,-1,-1],[3,-2,0]], nums = [1,-1,0,1,-1,-1,3,-2,0]\nOutput: true\nExplanation: You can choose the 0th subarray as [1,-1,0,1,-1,-1,3,-2,0] and the 1st one as [1,-1,0,1,-1,-1,3,-2,0].\nThese subarrays are disjoint as they share no common nums[k] element.",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input: groups = [[10,-2],[1,2,3,4]], nums = [1,2,3,4,10,-2]\nOutput: false\nExplanation: Note that choosing the subarrays [1,2,3,4,10,-2] and [1,2,3,4,10,-2] is incorrect because they are not in the same order as in groups.\n[10,-2] must come before [1,2,3,4].",
      "images": []
    },
    {
      "example_num": 3,
      "example_text": "Input: groups = [[1,2,3],[3,4]], nums = [7,7,1,2,3,4,7,7]\nOutput: false\nExplanation: Note that choosing the subarrays [7,7,1,2,3,4,7,7] and [7,7,1,2,3,4,7,7] is invalid because they are not disjoint.\nThey share a common elements nums[4] (0-indexed).",
      "images": []
    }
  ],
  "constraints": [
    "groups.length == n",
    "1 <= n <= 103",
    "1 <= groups[i].length, sum(groups[i].length) <= 103",
    "1 <= nums.length <= 103",
    "-107 <= groups[i][j], nums[k] <= 107"
  ],
  "follow_ups": [],
  "hints": [
    "When we use a subarray, the room for the next subarrays will be the suffix after the used subarray.",
    "If we can match a group with multiple subarrays, we should choose the first one, as this will just leave the largest room for the next subarrays."
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\n        \n    }\n};",
    "java": "class Solution {\n    public boolean canChoose(int[][] groups, int[] nums) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def canChoose(self, groups, nums):\n        \"\"\"\n        :type groups: List[List[int]]\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def canChoose(self, groups: List[List[int]], nums: List[int]) -> bool:\n        ",
    "c": "bool canChoose(int** groups, int groupsSize, int* groupsColSize, int* nums, int numsSize) {\n    \n}",
    "csharp": "public class Solution {\n    public bool CanChoose(int[][] groups, int[] nums) {\n        \n    }\n}",
    "javascript": "/**\n * @param {number[][]} groups\n * @param {number[]} nums\n * @return {boolean}\n */\nvar canChoose = function(groups, nums) {\n    \n};",
    "typescript": "function canChoose(groups: number[][], nums: number[]): boolean {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param Integer[][] $groups\n     * @param Integer[] $nums\n     * @return Boolean\n     */\n    function canChoose($groups, $nums) {\n        \n    }\n}",
    "swift": "class Solution {\n    func canChoose(_ groups: [[Int]], _ nums: [Int]) -> Bool {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun canChoose(groups: Array<IntArray>, nums: IntArray): Boolean {\n        \n    }\n}",
    "dart": "class Solution {\n  bool canChoose(List<List<int>> groups, List<int> nums) {\n    \n  }\n}",
    "golang": "func canChoose(groups [][]int, nums []int) bool {\n    \n}",
    "ruby": "# @param {Integer[][]} groups\n# @param {Integer[]} nums\n# @return {Boolean}\ndef can_choose(groups, nums)\n    \nend",
    "scala": "object Solution {\n    def canChoose(groups: Array[Array[Int]], nums: Array[Int]): Boolean = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn can_choose(groups: Vec<Vec<i32>>, nums: Vec<i32>) -> bool {\n        \n    }\n}",
    "racket": "(define/contract (can-choose groups nums)\n  (-> (listof (listof exact-integer?)) (listof exact-integer?) boolean?)\n  )",
    "erlang": "-spec can_choose(Groups :: [[integer()]], Nums :: [integer()]) -> boolean().\ncan_choose(Groups, Nums) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec can_choose(groups :: [[integer]], nums :: [integer]) :: boolean\n  def can_choose(groups, nums) do\n    \n  end\nend"
  }
}