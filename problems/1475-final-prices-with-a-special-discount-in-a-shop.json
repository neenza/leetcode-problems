{
  "title": "Final Prices With a Special Discount in a Shop",
  "problem_id": "1570",
  "frontend_id": "1475",
  "difficulty": "Easy",
  "problem_slug": "final-prices-with-a-special-discount-in-a-shop",
  "topics": [
    "Array",
    "Stack",
    "Monotonic Stack"
  ],
  "description": "You are given an integer array prices where prices[i] is the price of the ith item in a shop.\nThere is a special discount for items in the shop. If you buy the ith item, then you will receive a discount equivalent to prices[j] where j is the minimum index such that j > i and prices[j] <= prices[i]. Otherwise, you will not receive any discount at all.\nReturn an integer array answer where answer[i] is the final price you will pay for the ith item of the shop, considering the special discount.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: prices = [8,4,6,2,3]\nOutput: [4,2,4,2,3]\nExplanation: \nFor item 0 with price[0]=8 you will receive a discount equivalent to prices[1]=4, therefore, the final price you will pay is 8 - 4 = 4.\nFor item 1 with price[1]=4 you will receive a discount equivalent to prices[3]=2, therefore, the final price you will pay is 4 - 2 = 2.\nFor item 2 with price[2]=6 you will receive a discount equivalent to prices[3]=2, therefore, the final price you will pay is 6 - 2 = 4.\nFor items 3 and 4 you will not receive any discount at all.",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input: prices = [1,2,3,4,5]\nOutput: [1,2,3,4,5]\nExplanation: In this case, for all items, you will not receive any discount at all.",
      "images": []
    },
    {
      "example_num": 3,
      "example_text": "Input: prices = [10,1,1,6]\nOutput: [9,0,1,6]",
      "images": []
    }
  ],
  "constraints": [
    "1 <= prices.length <= 500",
    "1 <= prices[i] <= 1000"
  ],
  "follow_ups": [],
  "hints": [
    "Use brute force: For the ith item in the shop with a loop find the first position j satisfying the conditions and apply the discount, otherwise, the discount is 0."
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    vector<int> finalPrices(vector<int>& prices) {\n        \n    }\n};",
    "java": "class Solution {\n    public int[] finalPrices(int[] prices) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def finalPrices(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: List[int]\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def finalPrices(self, prices: List[int]) -> List[int]:\n        ",
    "c": "/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nint* finalPrices(int* prices, int pricesSize, int* returnSize) {\n    \n}",
    "csharp": "public class Solution {\n    public int[] FinalPrices(int[] prices) {\n        \n    }\n}",
    "javascript": "/**\n * @param {number[]} prices\n * @return {number[]}\n */\nvar finalPrices = function(prices) {\n    \n};",
    "typescript": "function finalPrices(prices: number[]): number[] {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param Integer[] $prices\n     * @return Integer[]\n     */\n    function finalPrices($prices) {\n        \n    }\n}",
    "swift": "class Solution {\n    func finalPrices(_ prices: [Int]) -> [Int] {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun finalPrices(prices: IntArray): IntArray {\n        \n    }\n}",
    "dart": "class Solution {\n  List<int> finalPrices(List<int> prices) {\n    \n  }\n}",
    "golang": "func finalPrices(prices []int) []int {\n    \n}",
    "ruby": "# @param {Integer[]} prices\n# @return {Integer[]}\ndef final_prices(prices)\n    \nend",
    "scala": "object Solution {\n    def finalPrices(prices: Array[Int]): Array[Int] = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn final_prices(prices: Vec<i32>) -> Vec<i32> {\n        \n    }\n}",
    "racket": "(define/contract (final-prices prices)\n  (-> (listof exact-integer?) (listof exact-integer?))\n  )",
    "erlang": "-spec final_prices(Prices :: [integer()]) -> [integer()].\nfinal_prices(Prices) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec final_prices(prices :: [integer]) :: [integer]\n  def final_prices(prices) do\n    \n  end\nend"
  },
  "solution": "[TOC]\n\n## Solution\n\n---\n\n### Overview\n\nWe have an integer array `prices` listing the prices of items from a shop. Items can receive a special discount based on the price of the next item on the list that is less than or equal to it (if such an item exists). In other words, the discount for `prices[i]` is `prices[j]`, where `j > i`, `prices[j] <= prices[i]`, and `j` is the smallest such index that satisfies these conditions.\n\nThe task is to calculate the final price for each item, after applying this special discount, and return these final prices in an array called answer.\n    \n---\n\n### Approach 1: Brute-Force\n\n#### Intuition\n\nSince the constraints are small, we can solve this problem using a brute-force approach. For each item in the `prices` array, we need to find a price that is smaller or equal to it and appears later in the array. This price will be our discount amount. We then subtract this discount from the original price to get the final discounted price.\n\nTo implement this, let's start by creating a copy of the `prices` array called `result`. We'll loop through the `prices` array and apply the discount we find for each element to the corresponding element in the `result` array.\n\nFor each element in the `prices` array, we'll run another loop starting from the next element to the right. If we find a price that is less than or equal to the current element, we'll subtract this price from the original price in the `result` array and stop looking further. If we don't find any suitable discount after checking all subsequent prices, the item's price in the `result` array will remain unchanged.\n\nAfter processing all the prices in this manner, the `result` array will contain the final discounted prices for each item. We can then return this array as our answer.\n\n#### Algorithm\n\n- Initialize a variable `n` to store the length of the input `prices` array.\n- Initialize a `result` array by creating a copy of the input `prices` array. This ensures we have a copy of the original `prices` to work with.\n- Start an outer loop that iterates from `0` to `n - 1`, with loop variable `i`:\n  - Start an inner loop that iterates from index `i + 1` to `n - 1`, with loop variable `j`.\n    - If `prices[j]` is less than or equal to `prices[i]`:\n      - Calculate the discounted price by subtracting `prices[j]` from `prices[i]`.\n      - Store the calculated discounted price in `result[i]`.\n      - Break the inner loop as we have found the first valid discount.\n- Return the `result` array containing all final prices after discounts.\n\n#### Implementation#### Complexity Analysis\n\nLet $n$ be the length of the input array `prices`.\n\n- Time complexity: $O(n^2)$\n\n    The algorithm uses two nested loops. The outer loop iterates through each element of the array, and for each element, the inner loop can potentially iterate through all remaining elements. In the worst case, where prices are in strictly increasing order, for each element `i`, we need to check all elements from `i + 1` to `n - 1`. Thus, the time complexity is quadratic, $O(n^2)$.\n\n- Space complexity: $O(n)$\n\n    The algorithm creates a new array `result` of the same size as the input array to store the final prices. Besides this, only a constant amount of extra space is used for loop variables and temporary calculations. \n    \n    Therefore, the space complexity is $O(n)$.  \n\n---\n\n### Approach 2: Monotonic Stack\n\n#### Intuition\n\nLet's focus on a key part of the problem: for any given item, we need to find the first price that is smaller or equal to it and comes after it. This is similar to a classic problem known as finding the \"next smaller element,\" which can be efficiently solved using a stack. But why does a stack work so well here?\n\nImagine we are processing prices from left to right. At each step, we need to determine if the current price can serve as a discount for any previous prices. The stack helps us keep track of those previous prices that haven't found their discount yet.\n\nThe key intuition is that when we find a price that is smaller than some earlier prices, it must be the discount for those earlier prices that are larger than it. We only care about the most recent of these prices because we want the first available discount.\n\nSo, for each element, our stack must contain all the most recent prices before that element that are greater than it. This implies that each element present in the stack must be in increasing order of value. This is called a monotonic stack.\n\nWhen we encounter an element that is smaller than the top of the stack, this means a discount can be applied to the stack element. We continue popping prices from the stack and applying the discount until the stack is empty or the top price is less than the current price. Then, we push the current price to the top of the stack, to wait for a discount which may come further down. This way, we can both apply discounts and also maintain the monotonic property of the stack.\n\nTo implement this idea, we'll maintain a `stack` of indices (not prices, since we need the positions to apply discounts). We iterate over the `prices` array and check if the current price is less than or equal to the price at the top of the `stack`. If it is, the current element can be used as a discount to the elements waiting in the `stack`. We remove each larger price from the `stack` and apply the discount, then add the current price to the `stack`. Any prices left on the `stack` at the end of the main loop had no discount available.\n\nThe slideshow below demonstrates this algorithm in action:\n\n!?!../Documents/1475/slideshow.json:916,756!?!> Note: If you are unfamiliar with the workings of monotonic stacks, try out these problems to practice:\n> - [496. Next Greater Element I 🔗](https://leetcode.com/problems/next-greater-element-i/)\n> - [503. Next Greater Element II 🔗](https://leetcode.com/problems/next-greater-element-ii/)\n> - [739. Daily Temperatures 🔗](https://leetcode.com/problems/daily-temperatures/)\n\n> For a more comprehensive understanding of stacks, check out the [Stack Explore Card 🔗](https://leetcode.com/explore/learn/card/queue-stack/230/usage-stack/). This resource provides an in-depth look at the stack data structure, explaining its key concepts and applications with a variety of problems to solidify understanding of the pattern.\n\n#### Algorithm\n\n- Initialize: \n  - a `result` array by creating a copy of the input `prices` array to store the discounted prices.\n  - an empty `stack` that will store indices of prices.\n- For each index `i` of the prices array:\n  - Start a while loop that continues as long as:\n    1. The `stack` is not empty, AND\n    2. The price at the index stored at the `stack`'s top is greater than or equal to the current price\n    - Inside the while loop, pop the top index from the `stack`.\n    - Calculate the discounted price by subtracting the current price from the price at the popped index.\n    - Store the result in the `result` array at the popped index.\n  - Add the current index `i` to the stack.\n- Return the `result` array containing all final prices after discounts.\n\n#### Implementation#### Complexity Analysis\n\nLet $n$ be the length of the input array `prices`.\n\n- Time complexity: $O(n)$\n\n    The algorithm iterates through the array once with a single loop. Although there is a while loop inside, each element can be pushed and popped from the `stack` exactly once. This means the total number of operations on the `stack` across all iterations is at most $2 \\cdot n$ ($n$ pushes and $n$ pops). \n    \n    Thus, the time complexity is $O(2 \\cdot n) = O(n)$.\n\n- Space complexity: $O(n)$\n\n    The algorithm uses a `result` array of size $n$ to store the final prices. Additionally, in the worst case scenario (when prices are in strictly increasing order), the stack could store all $n$ indices. \n    \n    Thus, the total space complexity is linear, $O(n)$.\n\n---"
}