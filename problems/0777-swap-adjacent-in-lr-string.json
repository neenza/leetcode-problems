{
  "title": "Swap Adjacent in LR String",
  "problem_id": "793",
  "frontend_id": "777",
  "difficulty": "Medium",
  "problem_slug": "swap-adjacent-in-lr-string",
  "topics": [
    "Two Pointers",
    "String"
  ],
  "description": "In a string composed of 'L', 'R', and 'X' characters, like \"RXXLRXRXL\", a move consists of either replacing one occurrence of \"XL\" with \"LX\", or replacing one occurrence of \"RX\" with \"XR\". Given the starting string start and the ending string result, return True if and only if there exists a sequence of moves to transform start to result.\nExample 1:\nExample 2:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: start = \"RXXLRXRXL\", result = \"XRLXXRRLX\"\nOutput: true\nExplanation: We can transform start to result following these steps:\nRXXLRXRXL ->\nXRXLRXRXL ->\nXRLXRXRXL ->\nXRLXXRRXL ->\nXRLXXRRLX",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input: start = \"X\", result = \"L\"\nOutput: false",
      "images": []
    }
  ],
  "constraints": [
    "1 <= start.length <= 104",
    "start.length == result.length",
    "Both start and result will only consist of characters in 'L', 'R', and 'X'."
  ],
  "follow_ups": [],
  "hints": [
    "Think of the L and R's as people on a horizontal line, where X is a space.  The people can't cross each other, and also you can't go from XRX to RXX."
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    bool canTransform(string start, string result) {\n        \n    }\n};",
    "java": "class Solution {\n    public boolean canTransform(String start, String result) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def canTransform(self, start, result):\n        \"\"\"\n        :type start: str\n        :type result: str\n        :rtype: bool\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def canTransform(self, start: str, result: str) -> bool:\n        ",
    "c": "bool canTransform(char* start, char* result) {\n    \n}",
    "csharp": "public class Solution {\n    public bool CanTransform(string start, string result) {\n        \n    }\n}",
    "javascript": "/**\n * @param {string} start\n * @param {string} result\n * @return {boolean}\n */\nvar canTransform = function(start, result) {\n    \n};",
    "typescript": "function canTransform(start: string, result: string): boolean {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param String $start\n     * @param String $result\n     * @return Boolean\n     */\n    function canTransform($start, $result) {\n        \n    }\n}",
    "swift": "class Solution {\n    func canTransform(_ start: String, _ result: String) -> Bool {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun canTransform(start: String, result: String): Boolean {\n        \n    }\n}",
    "dart": "class Solution {\n  bool canTransform(String start, String result) {\n    \n  }\n}",
    "golang": "func canTransform(start string, result string) bool {\n    \n}",
    "ruby": "# @param {String} start\n# @param {String} result\n# @return {Boolean}\ndef can_transform(start, result)\n    \nend",
    "scala": "object Solution {\n    def canTransform(start: String, result: String): Boolean = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn can_transform(start: String, result: String) -> bool {\n        \n    }\n}",
    "racket": "(define/contract (can-transform start result)\n  (-> string? string? boolean?)\n  )",
    "erlang": "-spec can_transform(Start :: unicode:unicode_binary(), Result :: unicode:unicode_binary()) -> boolean().\ncan_transform(Start, Result) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec can_transform(start :: String.t, result :: String.t) :: boolean\n  def can_transform(start, result) do\n    \n  end\nend"
  }
}