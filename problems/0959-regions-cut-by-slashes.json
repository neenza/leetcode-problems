{
  "title": "Regions Cut By Slashes",
  "problem_id": "999",
  "frontend_id": "959",
  "difficulty": "Medium",
  "problem_slug": "regions-cut-by-slashes",
  "topics": [
    "Array",
    "Hash Table",
    "Depth-First Search",
    "Breadth-First Search",
    "Union Find",
    "Matrix"
  ],
  "description": "An n x n grid is composed of 1 x 1 squares where each 1 x 1 square consists of a '/', '\\', or blank space ' '. These characters divide the square into contiguous regions.\nGiven the grid grid represented as a string array, return the number of regions.\nNote that backslash characters are escaped, so a '\\' is represented as '\\\\'.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: grid = [\" /\",\"/ \"]\nOutput: 2",
      "images": [
        "https://assets.leetcode.com/uploads/2018/12/15/1.png"
      ]
    },
    {
      "example_num": 2,
      "example_text": "Input: grid = [\" /\",\"  \"]\nOutput: 1",
      "images": [
        "https://assets.leetcode.com/uploads/2018/12/15/2.png"
      ]
    },
    {
      "example_num": 3,
      "example_text": "Input: grid = [\"/\\\\\",\"\\\\/\"]\nOutput: 5\nExplanation: Recall that because \\ characters are escaped, \"\\\\/\" refers to \\/, and \"/\\\\\" refers to /\\.",
      "images": [
        "https://assets.leetcode.com/uploads/2018/12/15/4.png"
      ]
    }
  ],
  "constraints": [
    "n == grid.length == grid[i].length",
    "1 <= n <= 30",
    "grid[i][j] is either '/', '\\', or ' '."
  ],
  "follow_ups": [],
  "hints": [],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    int regionsBySlashes(vector<string>& grid) {\n        \n    }\n};",
    "java": "class Solution {\n    public int regionsBySlashes(String[] grid) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def regionsBySlashes(self, grid):\n        \"\"\"\n        :type grid: List[str]\n        :rtype: int\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def regionsBySlashes(self, grid: List[str]) -> int:\n        ",
    "c": "int regionsBySlashes(char** grid, int gridSize) {\n    \n}",
    "csharp": "public class Solution {\n    public int RegionsBySlashes(string[] grid) {\n        \n    }\n}",
    "javascript": "/**\n * @param {string[]} grid\n * @return {number}\n */\nvar regionsBySlashes = function(grid) {\n    \n};",
    "typescript": "function regionsBySlashes(grid: string[]): number {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param String[] $grid\n     * @return Integer\n     */\n    function regionsBySlashes($grid) {\n        \n    }\n}",
    "swift": "class Solution {\n    func regionsBySlashes(_ grid: [String]) -> Int {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun regionsBySlashes(grid: Array<String>): Int {\n        \n    }\n}",
    "dart": "class Solution {\n  int regionsBySlashes(List<String> grid) {\n    \n  }\n}",
    "golang": "func regionsBySlashes(grid []string) int {\n    \n}",
    "ruby": "# @param {String[]} grid\n# @return {Integer}\ndef regions_by_slashes(grid)\n    \nend",
    "scala": "object Solution {\n    def regionsBySlashes(grid: Array[String]): Int = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn regions_by_slashes(grid: Vec<String>) -> i32 {\n        \n    }\n}",
    "racket": "(define/contract (regions-by-slashes grid)\n  (-> (listof string?) exact-integer?)\n  )",
    "erlang": "-spec regions_by_slashes(Grid :: [unicode:unicode_binary()]) -> integer().\nregions_by_slashes(Grid) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec regions_by_slashes(grid :: [String.t]) :: integer\n  def regions_by_slashes(grid) do\n    \n  end\nend"
  },
  "solution": "[TOC]\n\n## Solution\n\n---\n\n### Overview\n\nMany have found this problem to be a difficult medium problem, so if that is how you are feeling, you are not alone. [Number of Islands](https://leetcode.com/problems/number-of-islands/description/) is a good starter problem if you find yourself struggling with this one.  \n\nWe are given an array of strings called `grid`, which contains three types of characters: forward slash `/`, backslash `\\\\`, and space `' '`. Each slash divides its cell into two contiguous sections, as shown in the following image:\n\n![examples to show how the grid is formed](../Figures/959__re/image_1.png)\n\nOur objective is to determine the total number of distinct regions formed within the grid as a result of these slash divisions.\n\n---\n\n### Approach 1: Expanded Grid\n\n#### Intuition\n\nWhen a cell in the grid contains a slash, it effectively divides it into two parts. A forward slash divides the cell into top-left and bottom-right sections, while a backslash divides it into top-right and bottom-left sections. As you can see in Example 2 of the problem, counting the regions directly is challenging since a divided cell does not always lead to an additional region. \n\nTo address this, we can magnify the grid by expanding each cell into a $3 \\times 3$ sub-grid, with slashes represented by diagonal cells marked as barriers:\n\n![](../Figures/959__re/image_2.png)\n\nThis transformation simplifies our task. If we treat the slashes and grid boundaries as water, and the remaining cells as land, the problem becomes analogous to the [Number of Islands](https://leetcode.com/problems/number-of-islands/description/).\n\nWe can solve this using the [flood-fill algorithm](https://en.wikipedia.org/wiki/Flood_fill) to visit each connected region in the grid. We iterate over each cell of the grid and invoke `floodfill` whenever we encounter an unvisited land cell. The `floodfill` function explores all reachable land cells from the current cell and marks them as visited.  Then, we continue to iterate over each cell in the grid until we reach the next unvisited cell, which signifies the next land region. The total number of `floodfill` calls corresponds to the number of regions in the grid, which is our desired answer.\n\n> Note: In our implementation, we use Breadth-First Search (BFS) for the flood-fill algorithm. Alternatively, Depth-First Search (DFS) can also be employed, yielding similar time and space complexities.\n\n#### Algorithm\n\n- Initialize an array `DIRECTIONS` to specify traversal directions: right, left, down, and up.\n\nMain method `regionsBySlashes`:\n\n- Set `gridSize` as the size of the original grid.\n- Create a new 2D array `expandedGrid` with dimensions three times the original grid size.\n- Iterate through each cell `(i, j)` in the original `grid`:\n  - Calculate `baseRow` and `baseCol` as three times of `i` and `j`.\n  - Check the character in the current cell:\n    - If it is a backslash (`\\\\`):\n      - Mark the cells in the main diagonal `(baseRow, baseCol)`, `(baseRow+1, baseCol+1)`, `(baseRow+2, baseCol+2)` as `1`.\n    - If it is a forward slash (`/`): \n      - Mark the other diagonal `(baseRow, baseCol+2)`, `(baseRow+1, baseCol+1)`, `(baseRow+2, baseCol)` as `1`. \n- Initialize a counter `regionCount` to `0`.\n- Iterate through each cell `(i, j)` in `expandedGrid`:\n  - If the cell is unvisited (value `0`):\n    - Call the `floodfill` method to fill the region.\n    - Increment `regionCount`.\n- Return `regionCount` as the total number of distinct regions.\n\nHelper method `floodfill`:\n\n- Define a method `floodfill` with parameters: `expandedGrid` and the `row` and `col` indices.\n- Initialize a queue and add the starting cell `(row, col)` to it.\n- Mark the starting cell as visited by setting `expandedGrid[row][col]` to `1`.\n- While the `queue` is not empty:\n  - Dequeue `currentCell`.\n  - For each `direction` in `DIRECTIONS`:\n    - Set `newRow` as `currentCell[0] + direction[0]`.\n    - Set `newCol` as `currentCell[1] + direction[1]`.\n    - Check if the new cell is valid and unvisited using the `isValidCell` method:\n      - If valid, mark the cell as visited and add it to the `queue`.\n\nHelper method `isValidCell`.\n\n- Define a method `isValidCell` with parameters: `expandedGrid`, `row`, and `col`.\n- Return `true` if the cell `(row, col)` is within bounds and unvisited.\n- Otherwise, return `false`.\n\n#### Implementation#### Complexity Analysis\n\nLet $n$ be the height and width of the grid.\n\n- Time complexity: $O(n^2)$\n\n    The algorithm populates the expanded grid by iterating over the original grid, which takes $O(n^2)$ time. \n\n    In the worst case, the flood fill algorithm will visit every cell in the expanded grid once. The expanded grid is $3n \\times 3n$, resulting in $O((3n)^2) = O(9n^2) = O(n^2)$ operations.\n\n    Thus, the overall time complexity of the algorithm is $2 \\cdot O(n^2)$, which simplifies to $O(n^2)$.\n\n- Space complexity: $O(n^2)$\n\n    The expanded grid has dimensions $3n \\times 3n$, which requires $O(n^2)$ space. \n    \n    In the flood fill algorithm, the queue can store all $9n^2$ cells of the expanded grid in the worst case. This results in a space complexity of $O(9n^2) = O(n^2)$.\n\n    Thus, the total time complexity of the algorithm is $O(n^2) + O(n^2) = O(n^2)$.\n\n---\n\n### Approach 2: Disjoint Set Union (Triangles)\n\n#### Intuition\n\nOur previous approach involved magnifying each cell into a $3 \\times 3$ grid, increasing the number of unit cells by a factor of 9. We can further optimize this process by reconceptualizing how regions are formed and connected. Instead of viewing the grid as squares, let's envision each cell divided into four triangles. This allows for a more precise representation of slashes.\n\n![cell divided into four triangles](../Figures/959__re/image_3.png)\n\nInitially, each triangle is considered its own region. As we traverse the grid, we can group together all triangles not separated by slashes as belonging to one component (region). The total number of these groups will be our required answer.\n\nA widely used data structure for grouping connected components is the Disjoint Set Union (DSU). A DSU assigns each component (a unit triangle) a parent, which is initially itself. To connect or union two components, we assign them to the same parent, meaning units with the same parent belong to the same connected component. To learn more about how the disjoint set union data structure is implemented, refer to this LeetCode [Explore Card](https://leetcode.com/explore/learn/card/graph/618/disjoint-set/3881/).\n\nWe iterate over the grid and perform two main types of operations:\n1. Union adjacent components:\n\n   Regardless of whether a cell contains a forward slash or backslash, the top triangle of a cell will always connect to the bottom triangle of the cell above it. The same principle applies to the left triangle of a cell and the right triangle of the cell to its left. \n\n   ![connecting top and left cells](../Figures/959__re/image_4.png)\n\n2. Union intra-cell components:\n\n   A slash divides the cell diagonally, allowing us to combine the two adjacent triangles on each side of the diagonal.\n\nWe begin with the total number of triangles as our initial region count. Each successful union operation indicates that two distinct components have been merged into one, reducing the total number of regions by one. After processing all cells, the remaining count represents the number of distinct regions.\n\n#### Algorithm\n \nMain method `regionsBySlashes`:\n\n- Set `gridSize` as the size of the `grid`.\n- Calculate `totalTriangles` in the grid as `gridSize * gridSize * 4`.\n- Create a `parentArray` to represent the disjoint sets of triangles and initialize each element to `-1`.\n- Initialize `regionCount` to `totalTriangles`, assuming each triangle is initially a separate region.\n- Iterate through each cell of `grid`:\n  - If there is a cell above the current cell, union the bottom triangle of the above cell with the top triangle of the current cell.\n  - If there is a cell to the left of the current cell, union the right triangle of the left cell with the left triangle of the current cell.\n  - If the current cell is not `/`:\n    - Union the top triangle with the right triangle.\n    - Union the bottom triangle with the left triangle.\n  - If the current cell is not `\\\\`:\n    - Union the top triangle with the left triangle.\n    - Union the bottom triangle with the right triangle.\n- Return `regionCount` as our answer.\n\nHelper method `getTriangleIndex`:\n\n- Define a method `getTriangleIndex` with parameters: `gridSize`, the `row` and `col` indices, and the `triangleNum`.\n- Return `(gridSize * row + col) * 4 + triangleNum`.\n\nHelper method `unionTriangles`:\n\n- Define a method `unionTriangles` with parameters: `parentArray` and the two indices `x` and `y`.\n- Find `parentX` and `parentY` using the `findParent` method.\n- If `parentX` is not equal to `parentY`:\n  - Set `parentArray[parentX]` to `parentY` and return `1`.\n- Return `0`. \n\nHelper method `findParent`:\n\n- Define a method `findParent` with parameters: `parentArray` and the index `x`.\n- If `parentArray[x]` is equal to `-1`:\n  - `x` has no parent. Return `x`.\n- Set `parentArray[x]` to the parent of `parentArray[x]` using `findParent`. Return `parentArray[x]`.\n\n#### Implementation#### Complexity Analysis\n\nLet $n$ be the height and width of the grid. \n\n* Time complexity: $O(n^2 \\cdot \\alpha (n))$\n\n    Initializing the `parentArray` takes $O(4 \\cdot n^2)$ time.\n\n    The main loop iterates over all $n^2$ cells in the grid. In each iteration, it calls the `unionTriangles` method which includes `findPath` operations. With path compression, the amortized time complexity of `findPath` is denoted as $\\alpha(n)$, where $\\alpha$ is the inverse Ackermann function. Thus, the time complexity of the loop comes out to be $O(n^2 \\cdot \\alpha (n))$.\n\n    Thus, the overall time complexity of the algorithm is $O(4 \\cdot n^2) + O(n^2 \\cdot \\alpha (n)) = O(n^2 \\cdot \\alpha (n))$\n\n* Space complexity: $O(n^2)$\n\n    The only additional data structure used by the algorithm is the `parentArray`, which takes $O(n^2)$ space.\n\n    The recursive `find` operation can have a call stack of size $O(\\log n)$ in the worst case.\n\n    Thus, the overall space complexity is $O(n^2)$.\n\n---\n\n### Approach 3: Disjoint Set Union (Graph)\n\n#### Intuition\n\nLet's shift our perspective and consider slashes as connectors rather than dividers. Imagine each cell as a graph with four vertices at its corners, with slashes acting as edges between these vertices. The following diagram illustrates this concept:\n\n![cell as a graph](../Figures/959__re/image_5.png)\n\nIn this paradigm, a slash can be represented as follows:\n- A `/` slash connects the top-right point of a cell to the bottom-left point.\n- A `\\` slash connects the top-left point to the bottom-right point.\n- An empty space doesn't add any new connections.\n\nThe edges of the grid form the boundaries of the graph, creating an initial region. As we connect vertices (slashes), cycles may form, indicating the creation of new regions within the graph. By tracking the total number of cycles formed while iterating over all slashes, we determine the final count of regions.\n\nTo manage connected components, we use a DSU (Disjoint Set Union) data structure. We start by connecting the boundary points as the first region. As we process each cell, we treat each slash as an edge and union the corresponding vertices. If a union operation reveals that the vertices already share the same parent, it indicates a cycle, prompting us to increment our counter.\n\n#### Algorithm\n \nMain method `regionsBySlashes`:\n\n- Initialize variables:\n  - `gridSize` to the length of `grid`.\n  - `pointsPerSide` to `gridSize + 1`.\n  - `totalPoints` to `pointsPerSide * pointsPerSide`.\n- Create an array `parentArray` to represent the disjoint set, initialized with `-1`.\n- Loop over the each point:\n  - If the point lies on the border, set its `parent` to `0`.\n- Set `parent[0]` (top-left corner) to `-1` to make it the root.\n- Initialize `regionCount` to `1`, accounting for the border region.\n- Iterate through each cell `(i, j)` in the `grid`:\n  - If it's a forward slash (`/`):\n    - Calculate the `topRight` and `bottomLeft` indices.\n    - Call `union` on these points and add the result to `regionCount`.\n  - If it's a backslash (`\\\\`):\n    - Calculate the `topLeft` and `bottomRight` indices.\n    - Call `union` on these points and add the result to `regionCount`.\n- Return the final `regionCount`. \n\nHelper method `find`:\n\n- Define a method `find` with parameters: `parentArray` and the `node`.\n- If `parentArray[node]` is equal to `-1`:\n  - `node` does not have any parent. Return `node`.\n- Set `parentArray[node]` to the parent of `parentArray[node]` using the `find` method. Return `parentArray[node]`.\n\nHelper method `union`:\n\n- Define a method union with parameters: `parentArray` and nodes `node1` and `node2`.\n- Set `parent1` to `parent2` to the parents of `node1` and `node2` respectively. \n- If `parent1` is equal to `parent2`, return `1`.\n- Set `parentArray[parent2]` to `parent1`.\n- Return `0`.\n\n#### Implementation#### Complexity Analysis\n\nLet $n$ be the height and width of the `grid`.\n\n* Time complexity: $O(n^2 \\cdot \\alpha (n^2))$\n\n    Filling the parent array requires $O((n+1) \\cdot (n+1))$ time, which can be simplified to $O(n^2)$. Connecting the border points requires another $O(n^2)$ time. \n\n    As the algorithm iterates over the grid, it potentially performs two `union` operations for each cell. The time complexity of a single `find`/`union` operation is $O(\\alpha (n^2))$, where $\\alpha$ is the inverse Ackermann function. We perform at most $O(n^2)$ union operations, making the complexity of this part $O(n^2 \\cdot \\alpha (n^2))$.\n\n    Thus, the overall time complexity is $2 \\cdot O(n^2) + O(n^2 \\cdot 2 \\alpha (n^2)) = O(n^2 \\cdot \\alpha (n^2))$\n\n* Space complexity: $O(n^2)$\n\n    The algorithm creates an array of size $(n+1)^2$, which is $O(n^2)$.\n\n    The recursive call stack for `find` operation is $O(\\log n)$ in the worst case.\n\n    Thus, the total time complexity of the algorithm is $O(n^2)$. \n\n---"
}