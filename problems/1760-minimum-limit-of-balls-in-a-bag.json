{
  "title": "Minimum Limit of Balls in a Bag",
  "problem_id": "1886",
  "frontend_id": "1760",
  "difficulty": "Medium",
  "problem_slug": "minimum-limit-of-balls-in-a-bag",
  "topics": [
    "Array",
    "Binary Search"
  ],
  "description": "You are given an integer array nums where the ith bag contains nums[i] balls. You are also given an integer maxOperations.\nYou can perform the following operation at most maxOperations times:\nYour penalty is the maximum number of balls in a bag. You want to minimize your penalty after the operations.\nReturn the minimum possible penalty after performing the operations.\nExample 1:\nExample 2:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: nums = [9], maxOperations = 2\nOutput: 3\nExplanation: \n- Divide the bag with 9 balls into two bags of sizes 6 and 3. [9] -> [6,3].\n- Divide the bag with 6 balls into two bags of sizes 3 and 3. [6,3] -> [3,3,3].\nThe bag with the most number of balls has 3 balls, so your penalty is 3 and you should return 3.",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input: nums = [2,4,8,2], maxOperations = 4\nOutput: 2\nExplanation:\n- Divide the bag with 8 balls into two bags of sizes 4 and 4. [2,4,8,2] -> [2,4,4,4,2].\n- Divide the bag with 4 balls into two bags of sizes 2 and 2. [2,4,4,4,2] -> [2,2,2,4,4,2].\n- Divide the bag with 4 balls into two bags of sizes 2 and 2. [2,2,2,4,4,2] -> [2,2,2,2,2,4,2].\n- Divide the bag with 4 balls into two bags of sizes 2 and 2. [2,2,2,2,2,4,2] -> [2,2,2,2,2,2,2,2].\nThe bag with the most number of balls has 2 balls, so your penalty is 2, and you should return 2.",
      "images": []
    }
  ],
  "constraints": [
    "1 <= nums.length <= 105",
    "1 <= maxOperations, nums[i] <= 109"
  ],
  "follow_ups": [],
  "hints": [
    "Let's change the question if we know the maximum size of a bag what is the minimum number of bags you can make",
    "note that as the maximum size increases the minimum number of bags decreases so we can binary search the maximum size"
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    int minimumSize(vector<int>& nums, int maxOperations) {\n        \n    }\n};",
    "java": "class Solution {\n    public int minimumSize(int[] nums, int maxOperations) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def minimumSize(self, nums, maxOperations):\n        \"\"\"\n        :type nums: List[int]\n        :type maxOperations: int\n        :rtype: int\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def minimumSize(self, nums: List[int], maxOperations: int) -> int:\n        ",
    "c": "int minimumSize(int* nums, int numsSize, int maxOperations) {\n    \n}",
    "csharp": "public class Solution {\n    public int MinimumSize(int[] nums, int maxOperations) {\n        \n    }\n}",
    "javascript": "/**\n * @param {number[]} nums\n * @param {number} maxOperations\n * @return {number}\n */\nvar minimumSize = function(nums, maxOperations) {\n    \n};",
    "typescript": "function minimumSize(nums: number[], maxOperations: number): number {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @param Integer $maxOperations\n     * @return Integer\n     */\n    function minimumSize($nums, $maxOperations) {\n        \n    }\n}",
    "swift": "class Solution {\n    func minimumSize(_ nums: [Int], _ maxOperations: Int) -> Int {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun minimumSize(nums: IntArray, maxOperations: Int): Int {\n        \n    }\n}",
    "dart": "class Solution {\n  int minimumSize(List<int> nums, int maxOperations) {\n    \n  }\n}",
    "golang": "func minimumSize(nums []int, maxOperations int) int {\n    \n}",
    "ruby": "# @param {Integer[]} nums\n# @param {Integer} max_operations\n# @return {Integer}\ndef minimum_size(nums, max_operations)\n    \nend",
    "scala": "object Solution {\n    def minimumSize(nums: Array[Int], maxOperations: Int): Int = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn minimum_size(nums: Vec<i32>, max_operations: i32) -> i32 {\n        \n    }\n}",
    "racket": "(define/contract (minimum-size nums maxOperations)\n  (-> (listof exact-integer?) exact-integer? exact-integer?)\n  )",
    "erlang": "-spec minimum_size(Nums :: [integer()], MaxOperations :: integer()) -> integer().\nminimum_size(Nums, MaxOperations) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec minimum_size(nums :: [integer], max_operations :: integer) :: integer\n  def minimum_size(nums, max_operations) do\n    \n  end\nend"
  },
  "solution": "[TOC]\n\n## Solution\n\n---\n\n### Overview\n\nWe are given an integer array `nums` representing a collection of bags that contain different numbers of balls. We are allowed to perform the following operation on any bag of our choosing up to `maxOperations` times:\n\n1. Choose a bag from the array.\n2. Split the balls in the chosen bag into two new bags (the total number of balls remains the same).\n3. Add these two new bags to the array, replacing the original bag.\n\nAfter applying the allowed operations, we receive a penalty equal to the highest number of balls in any single bag. Our goal is to choose how to split the bags in such a way that we receive the lowest penalty possible, and return that number. \n\nAn intuitive but incorrect strategy would be to use all `maxOperations` operations to split the balls as much as possible. This would result in a final array of length $n + maxOperations$ since each operation adds one additional bag to the array.\n\nAccording to this strategy, we would attempt to evenly distribute all balls across the $n + maxOperations$ available bags. Therefore, the expected result would be:\n\n$$\n\\begin{aligned}\n    \\frac{\\text{Total balls}}{n  + \\text{maxOperations}}.\n\\end{aligned}\n$$\n\nHowever, this approach fails because we are only permitted to split an existing bag into two new bags. We are not permitted to distribute balls into other existing bags.\n\n![Wrong Approach](../Figures/1760/1760_wrong_approach.png)\n\n### Approach: Binary Search on The Answer\n\n#### Intuition\n\nLetâ€™s make some simple observations: the largest possible penalty canâ€™t be less than 1 or more than the largest value in `nums`. We need to find our answer within that range. We can also observe that:\n\n- if itâ€™s not possible to achieve a certain penalty with the allowed number of operations, we wonâ€™t be able to achieve a lower penalty than that. \n- if itâ€™s possible to achieve a certain penalty with less than the allowed number of operations, we can ultimately achieve an unknown lower penalty. \n\nThis understanding reveals a monotonic relationship between the number of operations we are allowed to perform and the size of the penalty.\n\nNow, one inefficient way to solve this problem would be to check each possible value from least to greatest until we find the lowest achievable value given the number of allowed operations. Is there a way we can more efficiently pick which values to test?\n\nWhenever we see a phrase like \"maximize the minimum\" or \"minimize the maximum\", the natural approach to solve the problem is binary search on the answer. Aditionally binary search works best when you can formulate the problem as a \"yes/no\" decision and when thereâ€™s a clear order to the possible answers. In this case, the question becomes: \"Can we split the bags so that no bag contains more than `maxBallsInBag` balls, performing at most `maxOperations` operations?\"\n\nThis monotonic property allows us to leverage binary search to efficiently narrow down the range of possible penalties. By checking the middle value in our current range, we can determine whether a given penalty is achievable. If it is, then any larger penalty will also be achievable, and if it is not, smaller penalties will not be achievable either.\n\n> For a more comprehensive understanding of binary search, check out the [Binary Search Explore Card ðŸ”—](https://leetcode.com/explore/learn/card/binary-search/). This resource provides an in-depth look at binary search, explaining its key concepts and applications with a variety of problems to solidify understanding of the pattern.\n\nBy repeatedly halving the search space based on whether the current penalty is achievable or not, we can quickly converge to the smallest penalty that can be achieved within the allowed operations. This allows us to find the optimal penalty in logarithmic time relative to the size of the range, making the solution much more efficient than testing each possibility one by one.\n\nNow, how will we determine whether a particular target is achievable?\n\n1. Reducing the number of balls in a bag: We can split a bag with `nums[i]` balls into smaller bags. After $operations_i$ splits, the original bag is replaced with $operations_i + 1$ smaller bags.\n\n2. Checking if the target is achievable: After all operations have been applied, all bags must have a number of balls less than or equal to the target we are testing. Mathematically:\n\n    $$\n    \\begin{aligned}\n        \\text{nums}[i] \\leq (\\text{operations}_i + 1) \\cdot \\text{maxBallsInBag}\n    \\end{aligned}\n    $$\n\n3. Calculating the number of splits (`operations_i`) required to achieve the target: Solving for $operations_i$, we get:\n\n    $$\n    \\begin{aligned}\n        \\text{operations}_i = \\lceil \\frac{\\text{nums}[i]}{\\text{maxBallsInBag}} \\rceil - 1\n    \\end{aligned}\n    $$\n\n    This tells us the minimum splits needed to ensure no smaller bag exceeds `maxBallsInBag`.\n\n4. Checking if the plan works: If the total operations (i.e., the sum of $operations_i$ for all `i`) is less than `maxOperations`, a split is possible. Otherwise, it isn't.\n\nThe example below illustrates the monotonic relationship between the number of operations we are allowed to perform and the minimum maximum number of balls in any bag. The answer (`result`) is found by performing a binary search on the values of the horizontal axis.\n\n![Monotonic Graph](../Figures/1760/1760_monotonic_graph.png)\n\n##### Why the Heap Approach Doesnâ€™t Work ?\n\nOne might consider a priority queue (or max-heap) approach where we repeatedly split the largest bag to minimize the maximum size. While this approach works for many greedy problems, it doesnâ€™t work here as it doesnâ€™t guarantee an optimal distribution of the balls.\n\nWith some changes, it is possible to use a heap if we write a custom comparison function. Specifically, we can represent each element in the heap as a pair: the first value is the number of balls in a bag, and the second value is the number of divisions we have made. The heap can then prioritize the division ratio by comparing the number of balls each bag will have after further division.\n\nHowever, this approach fails under the problemâ€™s constraints. If we attempt to perform operations like dividing the largest element and updating the heap, the constraints (with `nums` potentially containing up to $10^5$ elements and values up to $10^9$) would cause a Time Limit Exceeded (TLE) error.\n\nIf the constraints were reversed â€” say, if we had larger elements ($10^9$) but fewer values ($10^5$) â€” the heap approach would be the perfect approach. So with the current constraints, binary search remains the most efficient solution.\n\n#### Algorithm\n\n-   Define a function `isPossible`, which takes an integer `maxBallsInBag`, the `nums` array, and `maxOperations` as parameters and returns a boolean, indicating whether itâ€™s possible to split the balls such that no bag contains more than `maxBallsinBag` balls.\n    -   Initialize an integer `totalOperations` to `0`.\n    -   Loop through each bag with `i` from `0` to `n - 1`:\n        -   Calculate the operations needed for the `i`-th bag: `operations = ceil(nums[i] / maxBallsInBag) - 1`.\n        -   Add `operations` to `totalOperations`.\n        -   Check if `totalOperations > maxOperations`. If so, a distribution is impossible; return `false`.\n    -   If the loop ends without returning `false`, the balls can be split satisfying the constraint, so return `true`.\n-   In the `minimumSize` main function:\n    -   Initialize the boundaries of the binary search: `left = 1` and `right = max(nums[i])`.\n    -   While `left < right`:\n        -   Set `middle = (left + right) / 2`.\n        -   Check whether balls can be split with no bag finally containing more than `middle` products, using the `isPossible` function.\n            -   If this condition is `true`, set `right = middle`.\n            -   Otherwise, set `left = middle + 1`.\n    -   When the loop ends, `left == right`, so return `left`.\n\n#### Implementation#### Complexity Analysis\n\nLet $k$ be the maximum value in the `nums` array.\n\n-   Time complexity: $O(n \\log k)$\n\n    The `isPossible` function iterates through the `n` bags, executing constant-time operations during each iteration. As a result, its time complexity is $O(n)$.\n\n    The main function, `minimumSize`, performs a binary search over the range $(1, k)$, calling in each iteration the `canDistribute` function. Since the binary search runs in $O(\\log k)$ time, the overall time complexity of the `minimumSize` function is $O(n \\log k)$.\n\n-   Space complexity: $O(1)$\n\n    We only use a fixed number of integer variables, which doesn't depend on the input size.\n\n---"
}