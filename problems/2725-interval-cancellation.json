{
  "title": "Interval Cancellation",
  "problem_id": "2862",
  "frontend_id": "2725",
  "difficulty": "Easy",
  "problem_slug": "interval-cancellation",
  "topics": [],
  "description": "Given a function fn, an array of arguments args, and an interval time t, return a cancel function cancelFn.\nAfter a delay of cancelTimeMs, the returned cancel function cancelFn will be invoked.\nThe function fn should be called with args immediately and then called again every t milliseconds until cancelFn is called at cancelTimeMs ms.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "setTimeout(cancelFn, cancelTimeMs)",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input: fn = (x) => x * 2, args = [4], t = 35\nOutput: \n[\n   {\"time\": 0, \"returned\": 8},\n   {\"time\": 35, \"returned\": 8},\n   {\"time\": 70, \"returned\": 8},\n   {\"time\": 105, \"returned\": 8},\n   {\"time\": 140, \"returned\": 8},\n   {\"time\": 175, \"returned\": 8}\n]\nExplanation: \nconst cancelTimeMs = 190;\nconst cancelFn = cancellable((x) => x * 2, [4], 35);\nsetTimeout(cancelFn, cancelTimeMs);\n\nEvery 35ms, fn(4) is called. Until t=190ms, then it is cancelled.\n1st fn call is at 0ms. fn(4) returns 8.\n2nd fn call is at 35ms. fn(4) returns 8.\n3rd fn call is at 70ms. fn(4) returns 8.\n4th fn call is at 105ms. fn(4) returns 8.\n5th fn call is at 140ms. fn(4) returns 8.\n6th fn call is at 175ms. fn(4) returns 8.\nCancelled at 190ms",
      "images": []
    },
    {
      "example_num": 3,
      "example_text": "Input: fn = (x1, x2) => (x1 * x2), args = [2, 5], t = 30\nOutput: \n[\n   {\"time\": 0, \"returned\": 10},\n   {\"time\": 30, \"returned\": 10},\n   {\"time\": 60, \"returned\": 10},\n   {\"time\": 90, \"returned\": 10},\n   {\"time\": 120, \"returned\": 10},\n   {\"time\": 150, \"returned\": 10}\n]\nExplanation: \nconst cancelTimeMs = 165; \nconst cancelFn = cancellable((x1, x2) => (x1 * x2), [2, 5], 30) \nsetTimeout(cancelFn, cancelTimeMs)\n\nEvery 30ms, fn(2, 5) is called. Until t=165ms, then it is cancelled.\n1st fn call is at 0ms \n2nd fn call is at 30ms \n3rd fn call is at 60ms \n4th fn call is at 90ms \n5th fn call is at 120ms \n6th fn call is at 150ms\nCancelled at 165ms",
      "images": []
    },
    {
      "example_num": 4,
      "example_text": "Input: fn = (x1, x2, x3) => (x1 + x2 + x3), args = [5, 1, 3], t = 50\nOutput: \n[\n   {\"time\": 0, \"returned\": 9},\n   {\"time\": 50, \"returned\": 9},\n   {\"time\": 100, \"returned\": 9},\n   {\"time\": 150, \"returned\": 9}\n]\nExplanation: \nconst cancelTimeMs = 180;\nconst cancelFn = cancellable((x1, x2, x3) => (x1 + x2 + x3), [5, 1, 3], 50)\nsetTimeout(cancelFn, cancelTimeMs)\n\nEvery 50ms, fn(5, 1, 3) is called. Until t=180ms, then it is cancelled. \n1st fn call is at 0ms\n2nd fn call is at 50ms\n3rd fn call is at 100ms\n4th fn call is at 150ms\nCancelled at 180ms",
      "images": []
    }
  ],
  "constraints": [
    "fn is a function",
    "args is a valid JSON array",
    "1 <= args.length <= 10",
    "30 <= t <= 100",
    "10 <= cancelTimeMs <= 500"
  ],
  "follow_ups": [],
  "hints": [],
  "code_snippets": {
    "javascript": "/**\n * @param {Function} fn\n * @param {Array} args\n * @param {number} t\n * @return {Function}\n */\nvar cancellable = function(fn, args, t) {\n    \n};\n\n/**\n *  const result = [];\n *\n *  const fn = (x) => x * 2;\n *  const args = [4], t = 35, cancelTimeMs = 190;\n *\n *  const start = performance.now();\n *\n *  const log = (...argsArr) => {\n *      const diff = Math.floor(performance.now() - start);\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr)});\n *  }\n *       \n *  const cancel = cancellable(log, args, t);\n *\n *  setTimeout(cancel, cancelTimeMs);\n *   \n *  setTimeout(() => {\n *      console.log(result); // [\n *                           //     {\"time\":0,\"returned\":8},\n *                           //     {\"time\":35,\"returned\":8},\n *                           //     {\"time\":70,\"returned\":8},\n *                           //     {\"time\":105,\"returned\":8},\n *                           //     {\"time\":140,\"returned\":8},\n *                           //     {\"time\":175,\"returned\":8}\n *                           // ]\n *  }, cancelTimeMs + t + 15)    \n */",
    "typescript": "type JSONValue = null | boolean | number | string | JSONValue[] | { [key: string]: JSONValue };\ntype Fn = (...args: JSONValue[]) => void\n\nfunction cancellable(fn: Fn, args: JSONValue[], t: number): Function {\n    \n};\n\n/**\n *  const result = [];\n *\n *  const fn = (x) => x * 2;\n *  const args = [4], t = 35, cancelTimeMs = 190;\n *\n *  const start = performance.now();\n *\n *  const log = (...argsArr) => {\n *      const diff = Math.floor(performance.now() - start);\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr)});\n *  }\n *       \n *  const cancel = cancellable(log, args, t);\n *\n *  setTimeout(cancel, cancelTimeMs);\n *   \n *  setTimeout(() => {\n *      console.log(result); // [\n *                           //     {\"time\":0,\"returned\":8},\n *                           //     {\"time\":35,\"returned\":8},\n *                           //     {\"time\":70,\"returned\":8},\n *                           //     {\"time\":105,\"returned\":8},\n *                           //     {\"time\":140,\"returned\":8},\n *                           //     {\"time\":175,\"returned\":8}\n *                           // ]\n *  }, cancelTimeMs + t + 15)    \n */"
  },
  "solution": "[TOC]\n\n## Overview:\nYou are given a function `fn`, an array of arguments `args`, and an interval time `t`. You need to implement a function `cancelFn` that calls `fn` immediately with `args` and then schedules subsequent calls to `fn` every `t` milliseconds until `cancelFn` is called.\n\n---\n\n## Use Cases:\n\n* **Auto-Saving in Editing Applications:** When working with text editors, document processors, or other content creation tools, it's common to have an auto-save feature that periodically saves changes. You can use interval cancellation to schedule auto-saving at regular intervals. If the user explicitly saves the document or exits the application, you can cancel the interval to prevent unnecessary saving operations.\n\n* **Animation and Slideshow Timings:** During development, you may want to create animations or slideshows that automatically transition between different states or images. Interval cancellation can be used to control the timing of these transitions. If the user interacts with the animation or slideshow, you can cancel the interval to pause or stop the automatic progression.\n\n> Note:  For more complex or performance-critical animations, it's recommended to use the `requestAnimationFrame` method instead of `setInterval`, as it provides better performance and efficiency.\n\n* **Time-based Reminders:** Consider a task management application where users can set reminders for specific tasks. Interval cancellation can be used to trigger reminders at specified intervals. Once the user acknowledges the reminder or the task is completed, you can cancel the interval to stop further reminders.\n\n---\n\nBefore going any further, we need to learn two concepts: `setInterval` and `clearInterval`.\n\n1. **`setInterval`:** \nThe `setInterval` function is used to repeatedly execute a function or a code snippet with a fixed time delay between each call. It takes two arguments: the function or code snippet to be executed and the time delay specified in milliseconds.\n```js\nsetInterval(function, delay);\n```\n* The `function` parameter represents the function or code snippet that will be executed at each interval.\n* The `delay` parameter specifies the time delay in milliseconds between each execution of the function.\n\nWhen `setInterval` is called, it schedules the first execution of the specified function after the initial delay. Subsequent executions will occur repeatedly based on the specified delay.\n`setInterval` returns an interval ID, which is a unique numeric value. This ID can be used later to identify and control the interval schedule. Also, note that `setInterval` is not totally precise.\n\nTo gain a deeper understanding, you can review the explanation provided in the [Sleep editorial](https://leetcode.com/problems/sleep/editorial/).\n\n2. **`clearInterval`:**\nThe `clearInterval` function is used to cancel a timed, repeating action that was previously established by a call to `setInterval`. It takes the interval ID returned by `setInterval` as an argument.\n\n```js\nclearInterval(intervalID);\n```\n\n* The `intervalID` parameter represents the unique ID returned by the `setInterval` function when the interval was created.\nBy calling `clearInterval` with the appropriate interval ID, you can effectively stop the subsequent executions of the function specified in `setInterval`. It cancels the scheduled interval and prevents any further calls to the specified function.\n\n---\n\n## Approach 1: Using `setInterval` & `clearInterval` \n\nTo set an interval timer, we use the `setInterval` function. In the code snippet below, `setInterval` will repeatedly call `() => fn(...args)` every `t` milliseconds. It's important to note that `setInterval` does not immediately call the function before `t` milliseconds, which is why we manually call `fn(...args)` once before setting the interval.\n\nNext, we define a function called `cancelFn` that clears the interval when it's called. We return `cancelFn` from the main function. It's worth mentioning that `cancelFn` is not called when our `cancellable` function is initially defined. However, whenever the `cancellable` function is called, it returns `cancelFn`. The `cancelFn` can then be called at a later time to clear the interval.\n\n### Implementation:### Complexity Analysis:\n\n* **Time complexity:** $O(1)$\n\n* **Space complexity:** $O(1)$\n\n---\n\n## Approach 2: Using Recursion\n\n### Intuition:\nWe can set up a timed interval where the function is repeatedly executed. This will provide a way to cancel the interval execution when desired. In simpler words, each function will keep calling itself (after `t` ms, via a `timeout`), as long as the boolean flag is not flipped.\n\n### Algorithm:\nWhen we call the `cancellable` function, it first executes the provided function `(fn)` with the given arguments `(args)` i.e `(fn(...args))`. This ensures that the function is called at least once before we start the interval.\n\nNext, we define an internal function called `startInterval`. This function will be held for setting up the interval by using `setTimeout`. It waits for the specified `t` and then executes the function `(fn)` again. It repeats this process until we decide to cancel the interval which will be decided by the boolean `isCancelled` that we declared at the start of the code.\n\nTo create this repeated execution, `startInterval` uses a clever trick. It calls itself recursively within the `setTimeout` callback function. This means that after each execution of the function, it schedules the next execution by calling `startInterval` again. This creates a loop-like behavior where the function is executed, and then `startInterval` is called again to schedule the next execution.\n\n### Implementation 1:### Implementation 2:\n\nImplementation 1 is good, but it's more efficient to use `clearTimeout` to clear those recursive timeouts. This approach ensures that the callback isn't called unnecessarily:### Complexity Analysis:\n\nIn the given implementations, the execution involves setting a `setTimeout` function with a delay of `t` milliseconds. However, it's important to note that the scheduling of the function call does not introduce recursion or affect the complexity in terms of the JavaScript engine's memory usage.\n\nLet's dig a little deeper:\n\n* The JavaScript engine initializes and creates the context for the `cancellable` function.\n* The statements of the `cancellable` function, including the `setTimeout` call, are executed.\n* The `setTimeout` function instructs the JavaScript engine to schedule a function call after a delay of `t` milliseconds.\n* The context of the `cancellable` function is destroyed, and the JavaScript engine continues with other operations.\n* At this point, in terms of memory usage, the JavaScript engine returns to its initial state without any additional memory allocation or recursion. The only remaining information is a reference to the function and the scheduled time for the future call.\n* After the specified delay, the JavaScript engine executes the scheduled function without any impact on memory usage or recursion.\n* Once the function execution is completed, any remaining references or data related to the scheduled call are cleared.\n\nConsidering this sequence of events, we can conclude that the complexity of this code is constant `O(1)`. The memory utilization does not grow with the duration of the delay, and there is no recursion or memory buildup as the JavaScript engine handles the scheduling and execution of the function independently.\n\n* **Time complexity:** $O(1)$\n\n* **Space complexity:** $O(1)$\n\n---\n\n## Interview Tips:Can the interval time be dynamically changed after it has been set?Yes, the interval time can be dynamically changed by canceling the existing interval usingclearIntervaland then setting a new interval usingsetIntervalwith the updated time. This allows you to adjust the timing dynamically based on changing requirements or user interactions.Note: While it's true that you can create the illusion of a dynamic interval by clearing and resetting it, it's important to note that this doesn't truly change the original interval time dynamically. It rather cancels the previous interval and starts a new one.Are there any limitations or performance considerations to keep in mind when using interval cancellation?When working with interval cancellation, it's important to consider the interval time and the potential impact on performance. Frequent and short intervals can consume significant CPU resources. Additionally, if the execution time of thefnfunction is longer than the interval time, the subsequent calls may overlap, leading to unexpected behavior. It's crucial to ensure the interval time and the execution time offnare appropriately balanced. That's why in some situations it is highly recommended to use something else likerequestAnimationFrame.TherequestAnimationFrameaccepts a single parameter, a function to execute. When the browser is ready to repaint the screen, the function you specify torequestAnimationFramewill be called. When this function runs, it depends on the CPU power of the computer executing the code, the refresh rate of the display the browser is on, and a few other criteria to guarantee the animation is as smooth as possible while taking as little resources as feasible.What happens if the interval time `(t)` is set to a negative value or zero?It is going to execute immediately and continuously and will keep repeating for 0 or negative nums, potentially blocking the main thread and causing the browser to become unresponsive.Is it possible to restart or reschedule the interval after it has been canceled?While you can't directly restart a canceled interval, you can create a new interval by callingsetIntervalagain with the desired interval time and the function to be executed.---"
}