{
  "title": "Subarrays with K Different Integers",
  "problem_id": "1034",
  "frontend_id": "992",
  "difficulty": "Hard",
  "problem_slug": "subarrays-with-k-different-integers",
  "topics": [
    "Array",
    "Hash Table",
    "Sliding Window",
    "Counting"
  ],
  "description": "Given an integer array nums and an integer k, return the number of good subarrays of nums.\nA good array is an array where the number of different integers in that array is exactly k.\nA subarray is a contiguous part of an array.\nExample 1:\nExample 2:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: nums = [1,2,1,2,3], k = 2\nOutput: 7\nExplanation: Subarrays formed with exactly 2 different integers: [1,2], [2,1], [1,2], [2,3], [1,2,1], [2,1,2], [1,2,1,2]",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input: nums = [1,2,1,3,4], k = 3\nOutput: 3\nExplanation: Subarrays formed with exactly 3 different integers: [1,2,1,3], [2,1,3], [1,3,4].",
      "images": []
    }
  ],
  "constraints": [
    "1 <= nums.length <= 2 * 104",
    "1 <= nums[i], k <= nums.length"
  ],
  "follow_ups": [],
  "hints": [
    "Try generating all possible subarrays and check for the number of unique integers. Increment the count accordingly.",
    "How about using a map to store the count of integers?",
    "Think about the Sliding Window and 2-pointer approach."
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    int subarraysWithKDistinct(vector<int>& nums, int k) {\n        \n    }\n};",
    "java": "class Solution {\n    public int subarraysWithKDistinct(int[] nums, int k) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def subarraysWithKDistinct(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def subarraysWithKDistinct(self, nums: List[int], k: int) -> int:\n        ",
    "c": "int subarraysWithKDistinct(int* nums, int numsSize, int k) {\n    \n}",
    "csharp": "public class Solution {\n    public int SubarraysWithKDistinct(int[] nums, int k) {\n        \n    }\n}",
    "javascript": "/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number}\n */\nvar subarraysWithKDistinct = function(nums, k) {\n    \n};",
    "typescript": "function subarraysWithKDistinct(nums: number[], k: number): number {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @param Integer $k\n     * @return Integer\n     */\n    function subarraysWithKDistinct($nums, $k) {\n        \n    }\n}",
    "swift": "class Solution {\n    func subarraysWithKDistinct(_ nums: [Int], _ k: Int) -> Int {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun subarraysWithKDistinct(nums: IntArray, k: Int): Int {\n        \n    }\n}",
    "dart": "class Solution {\n  int subarraysWithKDistinct(List<int> nums, int k) {\n    \n  }\n}",
    "golang": "func subarraysWithKDistinct(nums []int, k int) int {\n    \n}",
    "ruby": "# @param {Integer[]} nums\n# @param {Integer} k\n# @return {Integer}\ndef subarrays_with_k_distinct(nums, k)\n    \nend",
    "scala": "object Solution {\n    def subarraysWithKDistinct(nums: Array[Int], k: Int): Int = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn subarrays_with_k_distinct(nums: Vec<i32>, k: i32) -> i32 {\n        \n    }\n}",
    "racket": "(define/contract (subarrays-with-k-distinct nums k)\n  (-> (listof exact-integer?) exact-integer? exact-integer?)\n  )",
    "erlang": "-spec subarrays_with_k_distinct(Nums :: [integer()], K :: integer()) -> integer().\nsubarrays_with_k_distinct(Nums, K) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec subarrays_with_k_distinct(nums :: [integer], k :: integer) :: integer\n  def subarrays_with_k_distinct(nums, k) do\n    \n  end\nend"
  },
  "solution": "[TOC]\n\n## Solution\n\n---\n\n### Overview\n\nWe are given an array of integers `nums` and an integer `k`. The task is to count the number of contiguous subarrays that contain exactly `k` distinct integers.\n\n**Key Observations:**\n1. A \"good subarray\" is defined as a contiguous subarray that contains exactly `k` distinct elements.\n2. There can be duplicate elements present in the `nums` array.\n\n---\n\n### Approach 1: Sliding Window\n\n#### Intuition\n\nThe brute force method involves finding all the subarrays and then selecting those subarrays that have exactly `k` distinct integers. However, this approach becomes costly in terms of time complexity, reaching $O(n^2)$.\n\nFor a more efficient approach, let's use the sliding window pattern. This pattern can be applied when the problem entails achieving a goal using subarrays, and individual elements cannot be independently selected.\n\nThe concept behind the sliding window pattern is to maintain a window that continuously expands from the right by adding elements until the condition is met. Once the condition is satisfied, we adjust the window by shrinking it from the left until the condition is met again.\n\nFor each valid window, we can calculate the total number of subarrays it can form using the formula `right - left + 1`. This represents the number of subarrays ending at the current element (`right`) and starting anywhere from the current left boundary (`left`) to the right pointer (`right`) (inclusive).\n\nOnce the window contains more than `k` distinct elements, we start shrinking it from the left side. We remove the element at the leftmost position and update the set of distinct elements. This process continues until the window size becomes valid again for the condition.\n\nAnother crucial realization is that the subarrays exceeding the `k` distinct integers are irrelevant to our objective. We focus on subarrays whose distinct integers are either equal to `k` or less than `k`.\n\nThe calculation `right - left + 1`, counts the subarrays with at most `k` distinct integers.\n\nAfter calculating the total count of subarrays with distinct integers less than or equal to `k` using `slidingWindowAtMost(nums, k)`, we need to isolate the subarrays that strictly meet the target `k`.\n\nThis can be achieved by subtracting the total count of subarrays with distinct integers less than `k` (`slidingWindowAtMost(nums, k - 1)`) from the total count obtained earlier. By subtracting the latter from the former, we essentially remove the subarrays that don't reach `k` and are left with only the subarrays that have exactly `k` distinct integers.\n\nConsider `nums = [1, 2, 1, 2, 3]` and `k = 2`.\n\n`slidingWindowAtMost(nums, 2)` will count all subarrays (12) with at most 2 distinct elements (including those with exactly 2 and 1).\n`slidingWindowAtMost(nums, 1)` will count all subarrays (5) with at most 1 distinct element.\n\nThe difference, `slidingWindowAtMost(nums, 2) - slidingWindowAtMost(nums, 1)`, removes subarrays with 1 distinct element, leaving only those with exactly 2, which is our answer (7).\n\nRefer to the visual slideshow demonstrating the sliding window on `slidingWindowAtMost(nums, k)`.\n\n!?!../Documents/992_re/atmostk.json:1010,570!?!\n\nNow, refer to the visual slideshow demonstrating the sliding window on `slidingWindowAtMost(nums, k - 1)`.\n\n!?!../Documents/992_re/atmostk_1.json:1010,510!?!\n\nRefer to the below Venn diagram for a better understanding of how subtracting `slidingWindowAtMost(nums, k - 1)` from `slidingWindowAtMost(nums, k)` gives exactly `k` distinct elements.\n\n![img](../Figures/992_re/atmost_venn_diagram.png)\n\n#### Algorithm\n\nThe `slidingWindowAtMost` function is responsible for counting the subarrays with at most `distinctK` distinct elements. \n\n- Initialize an empty `freqMap` to store the frequency of elements in the current window.\n- Initialize `left` and `totalCount` to 0.\n- Iterate through the `nums` array using the `right` pointer:\n   - Increment the frequency of `nums[right]` in the `freqMap`.\n   - While the size of `freqMap` (the number of distinct elements) is greater than `distinctK`:\n      - Decrement the frequency of `nums[left]` in the `freqMap`.\n      - If the frequency of `nums[left]` becomes 0, remove it from the `freqMap`.\n      - Increment `left` to shrink the window.\n   - Add `right - left + 1` to `totalCount`. This counts the number of subarrays ending at `right` with at most `distinctK` distinct elements.\n- Return `totalCount`.\n\nThe `subarraysWithKDistinct` function calls the `slidingWindowAtMost` function twice, once with `k` and once with `k - 1`, and subtracts the result of the latter from the result of the former to get the exact `k` distinct elements.\n\n#### Implementation#### Complexity Analysis\n\nLet `n` be the length of the `nums` array.\n\n- Time complexity: $O(n)$\n\n    The time complexity is $O(n)$ because the `slidingWindowAtMost` function iterates through the array once using the sliding window technique, and each element is processed at most twice (once when it enters the window and once when it exits the window). Inside the loop, the operations of updating the frequency map and shrinking the window take $O(1)$ time on average, assuming the underlying hash table implementation has constant-time operations. Therefore, the overall time complexity is linear with respect to the size of the input array. \n\n- Space complexity: $O(n)$\n\n    The space complexity is $O(n)$ due to the use of the `freqMap` to store the frequency of elements in the current window. In the worst case, when all elements in the array are distinct, the `freqMap` will store all the elements, resulting in a space complexity of $O(n)$.\n\n    It's important to note that the space complexity is also affected by the underlying implementation of the hash table used for the `freqMap`. Some implementations may have additional overhead, leading to a slightly higher space complexity. \n\n---\n\n### Approach 2: Sliding Window in One Pass\n\n#### Intuition\n\nWhen we create a subarray with an element, we can add `k - 1` additional distinct elements to the subarray without invalidating it.\n\nIf we subtract `1` from `k` when we encounter a new element, when `k` becomes zero, it means we have exactly `k` distinct elements in the current window. At this point, we need to count the number of valid subarrays we can form with these `k` distinct elements within the window.\n\nHowever, if `k` becomes negative, it indicates that there are more than `k` distinct elements in the current window. We need to adjust the window from the left side by moving the left pointer and reducing the frequency of `nums[left]` until the number of distinct elements is valid again (equal to `k`).\n\nIf there are duplicates of `nums[left]` within the current window, we need to keep shrinking the window from the left side until the frequency of `nums[left]` is zero. This is crucial because we need to maintain the correct count of distinct elements within the window.\n\nNow if `k` has become 0 and if the frequency of `nums[left]` is greater than 1, it means there are duplicates of the current left. For each duplicate, we increment `currCount`, which represents the number of subarrays that can be formed by including these duplicates along with the distinct elements in the current window.\n\nOnce we find the smallest subarray with exactly `k` distinct elements, we can add `currCount + 1` to `totalCount`. The 1 is added to include the current subarray formed by the `k` distinct elements within the window.\n\nBy continuously adjusting the window and counting subarrays when we have exactly `k` distinct elements, we can find the total count of valid subarrays with at most `k` distinct elements in just a single pass.\n\nRefer to the visual slideshow demonstrating the sliding window in one pass.\n\n!?!../Documents/992_re/onepass_re.json:1015,700!?!\n\n#### Algorithm\n\n- Initialize an array `distinctCount` of size `nums.size() + 1` to store the count of distinct values encountered.\n- Initialize `totalCount` to 0, which will store the total count of subarrays with `k` distinct elements.\n- Initialize `left` and `right` pointers to 0, representing the sliding window.\n- Initialize `currCount` to 0, which will store the count of subarrays with the current distinct elements.\n\n- Start the sliding window approach by iterating through the `nums` array using the `right` pointer:\n   - Increment the count of the element at `nums[right]` in the `distinctCount` array.\n   - If the count changes from 0 to 1, it means a new distinct element is encountered, so decrement `k`.\n   - If `k` becomes negative, it means there are more than `k` distinct elements in the current window:\n      - Move the `left` pointer until the count of distinct elements becomes valid again by decrementing the count of `nums[left]` in the `distinctCount` array and incrementing `k`.\n      - Reset `currCount` to 0.\n   - If `k` becomes 0, it means there are exactly `k` distinct elements in the current window:\n      - While there are duplicate elements (count > 1) in the window, move the `left` pointer, decrement the count of `nums[left]` in the `distinctCount` array, and increment `currCount`.\n      - Add `currCount + 1` to `totalCount`.\n   - Increment `right` to move the sliding window.\n\n- After the loop, return `totalCount`, which holds the total count of subarrays with `k` distinct elements.\n\n#### Implementation#### Complexity Analysis\n\nLet `n` be the length of the `nums` array.\n\n* Time complexity: $O(n)$\n\n    The time complexity is $O(n)$ because the algorithm iterates through the array once using the sliding window technique, and each element is processed at most twice (once when it enters the window and once when it exits the window), resulting in linear time complexity.\n\n* Space complexity: $O(n)$\n\n    The space complexity is also $O(n)$ because the algorithm uses a mapping array to store the count of distinct elements encountered in the current window. In the worst case, this array can grow to the size of the input array; hence, the space complexity is linear with respect to the size of the input.\n\n---"
}