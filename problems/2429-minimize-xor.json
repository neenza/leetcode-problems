{
  "title": "Minimize XOR",
  "problem_id": "2509",
  "frontend_id": "2429",
  "difficulty": "Medium",
  "problem_slug": "minimize-xor",
  "topics": [
    "Greedy",
    "Bit Manipulation"
  ],
  "description": "Given two positive integers num1 and num2, find the positive integer x such that:\nNote that XOR is the bitwise XOR operation.\nReturn the integer x. The test cases are generated such that x is uniquely determined.\nThe number of set bits of an integer is the number of 1's in its binary representation.\nExample 1:\nExample 2:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: num1 = 3, num2 = 5\nOutput: 3\nExplanation:\nThe binary representations of num1 and num2 are 0011 and 0101, respectively.\nThe integer 3 has the same number of set bits as num2, and the value 3 XOR 3 = 0 is minimal.",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input: num1 = 1, num2 = 12\nOutput: 3\nExplanation:\nThe binary representations of num1 and num2 are 0001 and 1100, respectively.\nThe integer 3 has the same number of set bits as num2, and the value 3 XOR 1 = 2 is minimal.",
      "images": []
    }
  ],
  "constraints": [
    "1 <= num1, num2 <= 109"
  ],
  "follow_ups": [],
  "hints": [
    "To arrive at a small xor, try to turn off some bits from num1",
    "If there are still left bits to set, try to set them from the least significant bit"
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    int minimizeXor(int num1, int num2) {\n        \n    }\n};",
    "java": "class Solution {\n    public int minimizeXor(int num1, int num2) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def minimizeXor(self, num1, num2):\n        \"\"\"\n        :type num1: int\n        :type num2: int\n        :rtype: int\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def minimizeXor(self, num1: int, num2: int) -> int:\n        ",
    "c": "int minimizeXor(int num1, int num2) {\n    \n}",
    "csharp": "public class Solution {\n    public int MinimizeXor(int num1, int num2) {\n        \n    }\n}",
    "javascript": "/**\n * @param {number} num1\n * @param {number} num2\n * @return {number}\n */\nvar minimizeXor = function(num1, num2) {\n    \n};",
    "typescript": "function minimizeXor(num1: number, num2: number): number {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param Integer $num1\n     * @param Integer $num2\n     * @return Integer\n     */\n    function minimizeXor($num1, $num2) {\n        \n    }\n}",
    "swift": "class Solution {\n    func minimizeXor(_ num1: Int, _ num2: Int) -> Int {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun minimizeXor(num1: Int, num2: Int): Int {\n        \n    }\n}",
    "dart": "class Solution {\n  int minimizeXor(int num1, int num2) {\n    \n  }\n}",
    "golang": "func minimizeXor(num1 int, num2 int) int {\n    \n}",
    "ruby": "# @param {Integer} num1\n# @param {Integer} num2\n# @return {Integer}\ndef minimize_xor(num1, num2)\n    \nend",
    "scala": "object Solution {\n    def minimizeXor(num1: Int, num2: Int): Int = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn minimize_xor(num1: i32, num2: i32) -> i32 {\n        \n    }\n}",
    "racket": "(define/contract (minimize-xor num1 num2)\n  (-> exact-integer? exact-integer? exact-integer?)\n  )",
    "erlang": "-spec minimize_xor(Num1 :: integer(), Num2 :: integer()) -> integer().\nminimize_xor(Num1, Num2) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec minimize_xor(num1 :: integer, num2 :: integer) :: integer\n  def minimize_xor(num1, num2) do\n    \n  end\nend"
  },
  "solution": "[TOC]\n\n## Solution\n\n---\n\n### Overview\n\nWe are given two integers, `num1` and `num2`. Our task is to find an integer `result`, such that:\n\n1. `result` has the same number of set bits (1s in its binary representation) as `num2`.\n2. The value of `result XOR num1` is as close to `0` as possible, meaning the two numbers `result` and `num1` should differ in as few bit positions as possible.\n\n> Note: The *XOR operation* compares the bits of two numbers. A bit in the result is 1 if the bits at that position in the two numbers are different, and 0 if they are the same.\n\nLetâ€™s go over some essential bitmasking operations that will be useful in solving the problem:\n\n-   To check if the `i-th` bit of `num` is set:\n\n    -   Shift 1 left by `i` (`1 << i`) positions to isolate the `i-th` bit.\n    -   Perform a bitwise AND: `num & (1 << i)`.\n\n    If the result is not 0, the `i-th` bit of `num` is set.\n\n    !?!../Documents/2429/2429_check_bit.json:960,540!?!\n\n-   To set the `i-th` bit of `num`:\n\n    -   Shift 1 left by `i` (`1 << i`) positions to isolate the `i-th` bit.\n    -   Perfom a bitwise OR: `num | (1 << i)`.\n\n    !?!../Documents/2429/2429_set_bit.json:960,540!?!\n\n-   To unset the `i-th` bit of `num`:\n\n    -   Shift 1 left by `i` (`1 << i`) positions to create a mask.\n    -   Invert the mask using `~(1 << i)` to make the `i-th` bit 0 and all the other bits 1.\n    -   Perform a bitwise AND: `num & ~(1 << i)`.\n\n    !?!../Documents/2429/2429_unset_bit.json:960,540!?!\n\n> For a more comprehensive understanding of bit manipulation, check out the [Bit Manipulation Explore Card ðŸ”—](https://leetcode.com/explore/learn/card/bit-manipulation/). This resource provides an in-depth look at bit-level operations, explaining their key concepts and applications with a variety of problems to solidify understanding of the pattern.\n\n---\n\n### Approach 1: From Optimal to Valid\n\n#### Intuition\n\nA simple observation is that if there were no constraints, the best choice for `result` would be `num1` itself because: `num1 XOR num1 = 0` (all bits match, resulting in no differences).\nHowever, `result` must also have the same number of set bits as `num2`, so we cannot always use `num1` as is. To make `result` valid, we need to adjust it to match the number of set bits in `num2` while trying to keep it as close to `num1` as possible. A good way to adjust `result` is as follows:\n\n1. Start with `result = num1`.\n2. Compare the number of set bits in `result` and `num2`:\n    - If `result` has more set bits than `num2`, we remove extra 1s from `result` by unsetting bits, starting from the least significant bits (because they are less important for matching `num1` closely).\n    - If `result` has fewer set bits than `num2`, we add more 1s to `result` by setting bits, starting from the least significant unset bits.\n\n#### Algorithm\n\n-   Initialize `result` to `num1`.\n-   Initialize `targetSetBitsCount` to the number of set bits in `num2` and `setBitsCount` to the number of set bits in `result`, using the provided built-in function.\n-   Initialize `currentBit` to `0` (the least significant).\n-   While `result` has fewer set bits than `num2` (i.e., `setBitsCount < targetSetBitsCount`):\n    -   If the `currentBit` of `result` is unset:\n        -   Set it.\n        -   Increment `setBitsCount` by `1`.\n    -   Move to the next bit; increment `currentBit` by `1`.\n-   While `result` has more set bits than `num2` (i.e., `setBitsCount > targetSetBitsCount`):\n    -   If the `currentBit` of `result` is set:\n        -   Unset it.\n        -   Decrement `setBitsCount` by `1`.\n    -   Move to the next bit; increment `currentBit` by `1`.\n-   Return `result`.\n\n#### Implementation#### Complexity Analysis\n\nLet $n$ be the maximum possible value of `num1` or `num2`.\n\n-   Time Complexity: $O(\\log{n})$.\n\n    The time complexity of the given solution is $O(\\log{n})$. This is because the algorithm primarily involves two operations: counting the number of set bits in the integers and adjusting the set bits of `result` to match the target count. The counting of set bits requires iterating over the binary representation of the integer, which takes $O(\\log{n})$ time since the number of bits in an integer is proportional to $\\log{n}$.\n\n    Additionally, the while loops iterate over the bits of `result`, setting or unsetting bits as needed, which also takes logn time in the worst case, as we may need to process up to all 32 bits. The helper functions (`isSet`, `setBit`, and `unsetBit`) involve constant-time bitwise operations and do not impact the overall complexity. \n\n    As a result, the time complexity is dominated by the bit manipulation and bit counting operations, both of which are $O(\\log{n})$. \n\n-   Space Complexity: $O(1)$.\n\n    We only use a fixed number of variables and therefore the algorithm requires constant extra space.\n\n---\n\n### Approach 2: Building the Answer \n\n#### Intuition\n\nIn this approach, we build the result from scratch instead of adjusting an existing answer. The idea is to start setting bits of `result` that match the set bits of `num1`, starting from the most significant bits, and continue until `result` has the same number of set bits as `num2`.\n\nBy setting bits from the most significant positions first, we ensure that `result` remains as close as possible to `num1`. Higher bits contribute more to the numerical value of a number, so matching them helps reduce the differences between `result` and `num1`.\n\nIf there arenâ€™t enough set bits in the higher positions, we use the lower bits to \"fill in\" the remaining set bits required to meet the condition of `num2`. This ensures that `result` has the correct number of set bits while maintaining as much similarity to `num1` as possible.\n\n> In this problem, we handle 32-bit integers, and therefore their most significant bit is at index 31 (counting indices from 0). However, the approach can be generalized to handle numbers with an arbitrary bit string length.\n\n#### Algorithm\n\n-   Initialize `result` to `0`.\n-   Initialize `targetSetBitsCount` to the number of set bits in `num2` and `setBitsCount` to `0`.\n-   Initialize `currentBit` to `31` (the most significant).\n-   While `result` has fewer set bits than `num2` (i.e. `setBitsCount < targetSetBitsCount`):\n    -   If the `currentBit` of `num1` is set or we must set all remaining bits in `result` (i.e. `targetSetBitsCount - setBitsCount > currentBit`):\n        -   Set the `currentBit` of `result`.\n        -   Increment `setBitsCount` by `1`.\n    -   Move to the next bit; decrement `currentBit` by `1`.\n-   Return `result`.\n\n#### Implementation#### Complexity Analysis\n\nLet $n$ be the maximum possible value of `num1` or `num2`.\n\n-   Time Complexity: $O(\\log{n})$.\n\n    Like in the previous approach, the algorithm involves iterating over the bits of the numbers, which is proportional to $\\log{n}$. \n\n-   Space Complexity: $O(1)$.\n\n    The algorithm uses only a fixed number of variables which does not depend on the input.\n\n---"
}