{
  "title": "Max Difference You Can Get From Changing an Integer",
  "problem_id": "1529",
  "frontend_id": "1432",
  "difficulty": "Medium",
  "problem_slug": "max-difference-you-can-get-from-changing-an-integer",
  "topics": [
    "Math",
    "Greedy"
  ],
  "description": "You are given an integer num. You will apply the following steps to num two separate times:\nLet a and b be the two results from applying the operation to num independently.\nReturn the max difference between a and b.\nNote that neither a nor b may have any leading zeros, and must not be 0.\nExample 1:\nExample 2:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: num = 555\nOutput: 888\nExplanation: The first time pick x = 5 and y = 9 and store the new integer in a.\nThe second time pick x = 5 and y = 1 and store the new integer in b.\nWe have now a = 999 and b = 111 and max difference = 888",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input: num = 9\nOutput: 8\nExplanation: The first time pick x = 9 and y = 9 and store the new integer in a.\nThe second time pick x = 9 and y = 1 and store the new integer in b.\nWe have now a = 9 and b = 1 and max difference = 8",
      "images": []
    }
  ],
  "constraints": [
    "1 <= num <= 108"
  ],
  "follow_ups": [],
  "hints": [
    "We need to get the max and min value after changing num and the answer is max - min.",
    "Use brute force, try all possible changes and keep the minimum and maximum values."
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    int maxDiff(int num) {\n        \n    }\n};",
    "java": "class Solution {\n    public int maxDiff(int num) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def maxDiff(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def maxDiff(self, num: int) -> int:\n        ",
    "c": "int maxDiff(int num) {\n    \n}",
    "csharp": "public class Solution {\n    public int MaxDiff(int num) {\n        \n    }\n}",
    "javascript": "/**\n * @param {number} num\n * @return {number}\n */\nvar maxDiff = function(num) {\n    \n};",
    "typescript": "function maxDiff(num: number): number {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param Integer $num\n     * @return Integer\n     */\n    function maxDiff($num) {\n        \n    }\n}",
    "swift": "class Solution {\n    func maxDiff(_ num: Int) -> Int {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun maxDiff(num: Int): Int {\n        \n    }\n}",
    "dart": "class Solution {\n  int maxDiff(int num) {\n    \n  }\n}",
    "golang": "func maxDiff(num int) int {\n    \n}",
    "ruby": "# @param {Integer} num\n# @return {Integer}\ndef max_diff(num)\n    \nend",
    "scala": "object Solution {\n    def maxDiff(num: Int): Int = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn max_diff(num: i32) -> i32 {\n        \n    }\n}",
    "racket": "(define/contract (max-diff num)\n  (-> exact-integer? exact-integer?)\n  )",
    "erlang": "-spec max_diff(Num :: integer()) -> integer().\nmax_diff(Num) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec max_diff(num :: integer) :: integer\n  def max_diff(num) do\n    \n  end\nend"
  },
  "solution": "[TOC]\n\n## Solution\n\n---\n\n### Approach 1: Enumeration\n\n#### Intuition\n\nTo maximize the difference between $a$ and $b$, we aim to find the largest and smallest integers that can be obtained from $\\textit{num}$, to be used as $a$ and $b$, respectively.\n\nAccording to the problem description, we can arbitrarily choose two digits $x$ and $y$, and replace all occurrences of $x$ in $\\textit{num}$ with $y$. Since both $x$ and $y$ range from $0$ to $9$, there are at most $10 \\times 10 = 100$ different replacement methods.\n\nTherefore, we can use a double loop to enumerate all possible replacements. Among all the resulting integers, we find the maximum and minimum values and assign them to $a$ and $b$.\n\n#### Implementation#### Complexity Analysis\n\n- Time complexity: $O(d^2 \\log (\\textit{num}))$, where $d = 10$, since $\\textit{num}$ is a \"decimal\" number.\n  \n  We use a double loop to enumerate all possible replacement methods, which takes $O(d^2)$ time. For each replacement method, we convert $\\textit{num}$ to a string and perform the replacement operation. The time required for this is proportional to the number of digits in $\\textit{num}$, which is $O(\\log (\\textit{num}))$.\n\n- Space complexity: $O(\\log (\\textit{num}))$.\n\n  The algorithm stores string representations of the input number, which have length proportional to the number of digits.\n\n### Approach 2: Greedy\n\n#### Intuition\n\nIf we want to find the largest number, the best strategy is to find a high-order digit and change it to $9$. Similarly, if we want to find the smallest number, the best strategy is to find a high-order digit and change it to $0$.\n\n**Finding the largest number**\n\nTo find the largest number, we iterate through each digit of $\\textit{num}$ from left to right (most significant to least significant). If the digit at the current position is not $9$, we replace all occurrences of that digit with $9$ to obtain the largest possible number.\n\n**Finding the smallest number**\n\nTo find the smallest number, we again iterate through each digit of $\\textit{num}$ from left to right. If the digit at the current position is not $0$, we replace all occurrences of that digit with $0$ to obtain the smallest possible number.\n\nWait, if we replace digits with $0$, could we end up with leading zeros? For example, if $\\textit{num} = 123$ and we replace the highest digit $1$ with $0$, the result would be $023$, which introduces a leading zero and is not a valid number. Therefore, we must handle the issue of leading zeros carefully:\n\n- If we are enumerating the most significant digit, we can only replace it with $1$; otherwise, the result will have a leading zero.\n\n- For all other digits:\n  - If the current digit is different from the most significant digit, we can replace it with $0$.\n  - If the current digit is equal to the most significant digit, we skip it. This is because when we evaluated the most significant digit, we already decided not to replace it, either due to the leading zero restriction or because we chose a different replacement. So we skip further replacement of this digit.\n\nBy greedily identifying the high-order digits to replace, we can find both the maximum and minimum values, and thereby determine the final result.\n\n#### Implementation#### Complexity Analysis\n\n- Time complexity: $O(\\log (\\textit{num}))$.\n  \n  We only need to enumerate each digit of $\\textit{num}$ at most once.\n\n- Space complexity: $O(\\log (\\textit{num}))$.\n\n  The algorithm stores string representations of the input number, which have length proportional to the number of digits."
}