{
  "title": "Check If Two String Arrays are Equivalent",
  "problem_id": "1781",
  "frontend_id": "1662",
  "difficulty": "Easy",
  "problem_slug": "check-if-two-string-arrays-are-equivalent",
  "topics": [
    "Array",
    "String"
  ],
  "description": "Given two string arrays word1 and word2, return true if the two arrays represent the same string, and false otherwise.\nA string is represented by an array if the array elements concatenated in order forms the string.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: word1 = [\"ab\", \"c\"], word2 = [\"a\", \"bc\"]\nOutput: true\nExplanation:\nword1 represents string \"ab\" + \"c\" -> \"abc\"\nword2 represents string \"a\" + \"bc\" -> \"abc\"\nThe strings are the same, so return true.",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input: word1 = [\"a\", \"cb\"], word2 = [\"ab\", \"c\"]\nOutput: false",
      "images": []
    },
    {
      "example_num": 3,
      "example_text": "Input: word1  = [\"abc\", \"d\", \"defg\"], word2 = [\"abcddefg\"]\nOutput: true",
      "images": []
    }
  ],
  "constraints": [
    "1 <= word1.length, word2.length <= 103",
    "1 <= word1[i].length, word2[i].length <= 103",
    "1 <= sum(word1[i].length), sum(word2[i].length) <= 103",
    "word1[i] and word2[i] consist of lowercase letters."
  ],
  "follow_ups": [],
  "hints": [
    "Concatenate all strings in the first array into a single string in the given order, the same for the second array.",
    "Both arrays represent the same string if and only if the generated strings are the same."
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    bool arrayStringsAreEqual(vector<string>& word1, vector<string>& word2) {\n        \n    }\n};",
    "java": "class Solution {\n    public boolean arrayStringsAreEqual(String[] word1, String[] word2) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def arrayStringsAreEqual(self, word1, word2):\n        \"\"\"\n        :type word1: List[str]\n        :type word2: List[str]\n        :rtype: bool\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def arrayStringsAreEqual(self, word1: List[str], word2: List[str]) -> bool:\n        ",
    "c": "bool arrayStringsAreEqual(char** word1, int word1Size, char** word2, int word2Size) {\n    \n}",
    "csharp": "public class Solution {\n    public bool ArrayStringsAreEqual(string[] word1, string[] word2) {\n        \n    }\n}",
    "javascript": "/**\n * @param {string[]} word1\n * @param {string[]} word2\n * @return {boolean}\n */\nvar arrayStringsAreEqual = function(word1, word2) {\n    \n};",
    "typescript": "function arrayStringsAreEqual(word1: string[], word2: string[]): boolean {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param String[] $word1\n     * @param String[] $word2\n     * @return Boolean\n     */\n    function arrayStringsAreEqual($word1, $word2) {\n        \n    }\n}",
    "swift": "class Solution {\n    func arrayStringsAreEqual(_ word1: [String], _ word2: [String]) -> Bool {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun arrayStringsAreEqual(word1: Array<String>, word2: Array<String>): Boolean {\n        \n    }\n}",
    "dart": "class Solution {\n  bool arrayStringsAreEqual(List<String> word1, List<String> word2) {\n    \n  }\n}",
    "golang": "func arrayStringsAreEqual(word1 []string, word2 []string) bool {\n    \n}",
    "ruby": "# @param {String[]} word1\n# @param {String[]} word2\n# @return {Boolean}\ndef array_strings_are_equal(word1, word2)\n    \nend",
    "scala": "object Solution {\n    def arrayStringsAreEqual(word1: Array[String], word2: Array[String]): Boolean = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn array_strings_are_equal(word1: Vec<String>, word2: Vec<String>) -> bool {\n        \n    }\n}",
    "racket": "(define/contract (array-strings-are-equal word1 word2)\n  (-> (listof string?) (listof string?) boolean?)\n  )",
    "erlang": "-spec array_strings_are_equal(Word1 :: [unicode:unicode_binary()], Word2 :: [unicode:unicode_binary()]) -> boolean().\narray_strings_are_equal(Word1, Word2) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec array_strings_are_equal(word1 :: [String.t], word2 :: [String.t]) :: boolean\n  def array_strings_are_equal(word1, word2) do\n    \n  end\nend"
  },
  "solution": "[TOC]\n\n## Solution\n\n---\n\n#### Overview\n\nIt's a fairly basic problem and we have many different ways to solve it.\n\nBelow, we will discuss five approaches: *Connecting*, *Splitting*, *No Pretreatment*, *Splitting One*, and *Connecting One*.\n\nGenerally, we recommend *Connecting* and *Splitting* since they are easy to implement. We also provide other solutions for exploring possibilities. The ideas of those solutions are similar, but their implementations are different.\n\n---\n\n#### Approach 1: Connecting\n\n**Intuition**\n\nSince many programming languages have built-in methods to compare two strings, it is natural to concatenate `word1` and `word2` into whole strings, and then compare them.\n\n![Figure 1.1](../Documents/5605/5605_1_1.drawio.svg)\n\n**Algorithm**\n\n*Step 1:* Build concatenated strings for `word1` and `word2`.\n\n*Step 2:* Check if the strings are the same.\n\n> Challenge: Can you implement the code yourself without seeing our implementations?\n\n**Implementation****Complexity Analysis**\n\nLet $$N$$ be the maximum of the number of all characters in `word1` and the number of all characters in `word2`.\n\n* Time Complexity: $$\\mathcal{O}(N)$$, since we need to iterate over all characters in `word1` and `word2` to build the new strings.\n\n* Space Complexity: $$\\mathcal{O}(N)$$, since we need extra $$\\mathcal{O}(N)$$ space to store the new built strings.\n\n---\n\n#### Approach 2: Splitting\n\n**Intuition**\n\nIf you do not like concatenating, we can split them into single characters, and then use for-loop to compare them.\n\n![Figure 2.1](../Documents/5605/5605_2_1.drawio.svg)\n\n**Algorithm**\n\n*Step 1:* Build lists of split characters for `word1` and `word2`.\n\n*Step 2:* Check if the lists are the same.\n\n> Challenge: Can you implement the code yourself without seeing our implementations?\n\n**Implementation****Complexity Analysis**\n\nLet $$N$$ be the maximum of the number of all characters in `word1` and the number of all characters in `word2`.\n\n* Time Complexity: $$\\mathcal{O}(N)$$, since we need to iterate over all characters in `word1` and `word2` to split them in the list.\n\n* Space Complexity: $$\\mathcal{O}(N)$$, since we need extra $$\\mathcal{O}(N)$$ space to store the lists.\n\n---\n\n#### Approach 3: No Pretreatment\n\n**Intuition**\n\nBoth approaches above require some preprocessing on `word1` or `word2`. Can we compare them directly?\n\nOf course. We can iterate over each character in one string array and compare the corresponding character in the other string array.\n\nTo achieve this, we need some index to track the character in the other string array.\n\nHere we use two indexes: `stringIndex ` and `characterIndex `. `stringIndex` points to the index of the string in the string array, and `characterIndex` represents the index of the character in the string.\n\nFor example:\n\n![Figure 3.1](../Documents/5605/5605_3_1.drawio.svg)\n\n**Algorithm**\n\n*Step 1:* Iterate over `word1` and check if the corresponding character in `word2` is the same.\n\n> Note: You can switch the position of `word1` and `word2`.\n\n> Challenge: Can you implement the code yourself without seeing our implementations?\n\n**Implementation**> Note: We precalculate the lengths of strings in `word2` to prevent re-calculate it during the iteration. However, some built-in data structures automatically maintain the lengths as integers (such as list in Python). In this case, you can skip this precalculation. We here explicitly write the precalculation to emphasize it.\n> \n\n**Complexity Analysis**\n\nLet $$N$$ be the number of all characters in `word1`, and $$M$$ be the length of `word2`.\n\n* Time Complexity: $$\\mathcal{O}(N)$$, since we need to iterate over `word1` to check if characters match.\n\n* Space Complexity: $$\\mathcal{O}(M)$$, since we need extra $$\\mathcal{O}(M)$$ space to store the lengths of strings in `word2`. You can save this space if the data structure automatically stores the lengths.\n\n---\n\n#### Approach 4: Splitting One\n\n**Intuition**\n\nThe tracking method in *Approach 3* seems to be a little complicated: we need two indexes! Can we simplify it? \n\nYes! If we split the string array into a character array, then only one index is needed.\n\n![Figure 4.1](../Documents/5605/5605_4_1.drawio.svg)\n\n**Algorithm**\n\n*Step 1:* Build lists of split characters for `word2`.\n\n*Step 2:* Iterate over `word1` and check if the corresponding character in `word2` is the same.\n\n> Note: You can switch the position of `word1` and `word2`.\n\n> Challenge: Can you implement the code yourself without seeing our implementations?\n\n**Implementation****Complexity Analysis**\n\nLet $$N$$ be the maximum of the number of all characters in `word1` and the number of all characters in `word2`.\n\n* Time Complexity: $$\\mathcal{O}(N)$$, since we need to iterate over `word1` to check if characters match.\n\n* Space Complexity: $$\\mathcal{O}(N)$$, since we need extra $$\\mathcal{O}(N)$$ space to store the list in the worst case.\n\n---\n\n#### Approach 5: Connecting One\n\n**Intuition**\n\nOf course, instead of splitting in *Approach 4*, we can connect them into a whole array. In this case also, we only need one index.\n\n![Figure 5.1](../Documents/5605/5605_5_1.drawio.svg)\n\n**Algorithm**\n\n*Step 1:* Build concatenated strings for `word2`.\n\n*Step 2:* Iterate over `word1` and check if the corresponding character in `word2` is the same.\n\n> Note: You can switch the position of `word1` and `word2`.\n\n> Challenge: Can you implement the code yourself without seeing our implementations?\n\n**Implementation****Complexity Analysis**\n\nLet $$N$$ be the maximum of the number of all characters in `word1` and the number of all characters in `word2`.\n\n* Time Complexity: $$\\mathcal{O}(N)$$, since we need to iterate over `word1` to check if characters match.\n\n* Space Complexity: $$\\mathcal{O}(N)$$, since we need extra $$\\mathcal{O}(N)$$ space to store the new string in the worst case."
}