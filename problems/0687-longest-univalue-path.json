{
  "title": "Longest Univalue Path",
  "problem_id": "687",
  "frontend_id": "687",
  "difficulty": "Medium",
  "problem_slug": "longest-univalue-path",
  "topics": [
    "Tree",
    "Depth-First Search",
    "Binary Tree"
  ],
  "description": "Given the root of a binary tree, return the length of the longest path, where each node in the path has the same value. This path may or may not pass through the root.\nThe length of the path between two nodes is represented by the number of edges between them.\nExample 1:\nExample 2:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: root = [5,4,5,1,1,null,5]\nOutput: 2\nExplanation: The shown image shows that the longest path of the same value (i.e. 5).",
      "images": [
        "https://assets.leetcode.com/uploads/2020/10/13/ex1.jpg"
      ]
    },
    {
      "example_num": 2,
      "example_text": "Input: root = [1,4,5,4,4,null,5]\nOutput: 2\nExplanation: The shown image shows that the longest path of the same value (i.e. 4).",
      "images": [
        "https://assets.leetcode.com/uploads/2020/10/13/ex2.jpg"
      ]
    }
  ],
  "constraints": [
    "The number of nodes in the tree is in the range [0, 104].",
    "-1000 <= Node.val <= 1000",
    "The depth of the tree will not exceed 1000."
  ],
  "follow_ups": [],
  "hints": [],
  "code_snippets": {
    "cpp": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    int longestUnivaluePath(TreeNode* root) {\n        \n    }\n};",
    "java": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public int longestUnivaluePath(TreeNode root) {\n        \n    }\n}",
    "python": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def longestUnivaluePath(self, root):\n        \"\"\"\n        :type root: Optional[TreeNode]\n        :rtype: int\n        \"\"\"\n        ",
    "python3": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def longestUnivaluePath(self, root: Optional[TreeNode]) -> int:\n        ",
    "c": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     struct TreeNode *left;\n *     struct TreeNode *right;\n * };\n */\nint longestUnivaluePath(struct TreeNode* root) {\n    \n}",
    "csharp": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public int val;\n *     public TreeNode left;\n *     public TreeNode right;\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\npublic class Solution {\n    public int LongestUnivaluePath(TreeNode root) {\n        \n    }\n}",
    "javascript": "/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nvar longestUnivaluePath = function(root) {\n    \n};",
    "typescript": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nfunction longestUnivaluePath(root: TreeNode | null): number {\n    \n};",
    "php": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     public $val = null;\n *     public $left = null;\n *     public $right = null;\n *     function __construct($val = 0, $left = null, $right = null) {\n *         $this->val = $val;\n *         $this->left = $left;\n *         $this->right = $right;\n *     }\n * }\n */\nclass Solution {\n\n    /**\n     * @param TreeNode $root\n     * @return Integer\n     */\n    function longestUnivaluePath($root) {\n        \n    }\n}",
    "swift": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public var val: Int\n *     public var left: TreeNode?\n *     public var right: TreeNode?\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\n *         self.val = val\n *         self.left = left\n *         self.right = right\n *     }\n * }\n */\nclass Solution {\n    func longestUnivaluePath(_ root: TreeNode?) -> Int {\n        \n    }\n}",
    "kotlin": "/**\n * Example:\n * var ti = TreeNode(5)\n * var v = ti.`val`\n * Definition for a binary tree node.\n * class TreeNode(var `val`: Int) {\n *     var left: TreeNode? = null\n *     var right: TreeNode? = null\n * }\n */\nclass Solution {\n    fun longestUnivaluePath(root: TreeNode?): Int {\n        \n    }\n}",
    "dart": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *   int val;\n *   TreeNode? left;\n *   TreeNode? right;\n *   TreeNode([this.val = 0, this.left, this.right]);\n * }\n */\nclass Solution {\n  int longestUnivaluePath(TreeNode? root) {\n    \n  }\n}",
    "golang": "/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\nfunc longestUnivaluePath(root *TreeNode) int {\n    \n}",
    "ruby": "# Definition for a binary tree node.\n# class TreeNode\n#     attr_accessor :val, :left, :right\n#     def initialize(val = 0, left = nil, right = nil)\n#         @val = val\n#         @left = left\n#         @right = right\n#     end\n# end\n# @param {TreeNode} root\n# @return {Integer}\ndef longest_univalue_path(root)\n    \nend",
    "scala": "/**\n * Definition for a binary tree node.\n * class TreeNode(_value: Int = 0, _left: TreeNode = null, _right: TreeNode = null) {\n *   var value: Int = _value\n *   var left: TreeNode = _left\n *   var right: TreeNode = _right\n * }\n */\nobject Solution {\n    def longestUnivaluePath(root: TreeNode): Int = {\n        \n    }\n}",
    "rust": "// Definition for a binary tree node.\n// #[derive(Debug, PartialEq, Eq)]\n// pub struct TreeNode {\n//   pub val: i32,\n//   pub left: Option<Rc<RefCell<TreeNode>>>,\n//   pub right: Option<Rc<RefCell<TreeNode>>>,\n// }\n// \n// impl TreeNode {\n//   #[inline]\n//   pub fn new(val: i32) -> Self {\n//     TreeNode {\n//       val,\n//       left: None,\n//       right: None\n//     }\n//   }\n// }\nuse std::rc::Rc;\nuse std::cell::RefCell;\nimpl Solution {\n    pub fn longest_univalue_path(root: Option<Rc<RefCell<TreeNode>>>) -> i32 {\n        \n    }\n}",
    "racket": "; Definition for a binary tree node.\n#|\n\n; val : integer?\n; left : (or/c tree-node? #f)\n; right : (or/c tree-node? #f)\n(struct tree-node\n  (val left right) #:mutable #:transparent)\n\n; constructor\n(define (make-tree-node [val 0])\n  (tree-node val #f #f))\n\n|#\n\n(define/contract (longest-univalue-path root)\n  (-> (or/c tree-node? #f) exact-integer?)\n  )",
    "erlang": "%% Definition for a binary tree node.\n%%\n%% -record(tree_node, {val = 0 :: integer(),\n%%                     left = null  :: 'null' | #tree_node{},\n%%                     right = null :: 'null' | #tree_node{}}).\n\n-spec longest_univalue_path(Root :: #tree_node{} | null) -> integer().\nlongest_univalue_path(Root) ->\n  .",
    "elixir": "# Definition for a binary tree node.\n#\n# defmodule TreeNode do\n#   @type t :: %__MODULE__{\n#           val: integer,\n#           left: TreeNode.t() | nil,\n#           right: TreeNode.t() | nil\n#         }\n#   defstruct val: 0, left: nil, right: nil\n# end\n\ndefmodule Solution do\n  @spec longest_univalue_path(root :: TreeNode.t | nil) :: integer\n  def longest_univalue_path(root) do\n    \n  end\nend"
  },
  "solution": "[TOC]\n\n## Solution\n\n---\n\n### Approach 1: Depth-First Search\n\n**Intuition**\n\nWe can try to solve the problem in a recursive manner, as for trees the recursive solutions are intuitive and easy to follow. Let's suppose we have a node in the binary tree, and for both the left and right child, we have the count of nodes in the path that is equal to the node's value. How can we determine the longest univalue path for this node? If the node count for the left and right child is `x` and `y` respectively, then the answer for the parent node should be `x + y`. This is because the longest path would be considering the nodes on both children starting from one child to the parent node and then to the other child.\n\nIn the image below, the univalue path for the root node will be 3, as the number of nodes on the left child path that have the same value as the root node is 1 and the number of nodes on the right child path having the same value as the root node is 2. Hence, the path will include the nodes on both left and right and thus will have a length of 3.\n\n![fig](../Figures/687/687B.png)\n\nNow, we know that, for each left and right child path, we can find the number of nodes equal to their parent node. Then we can find the longest univalue path for the parent node. How to find the count of these nodes? As we just discussed above, if the number of nodes on the left and right child path have the same value as the node `x` and `y`, then the number of nodes that are equal to the parent node should be `max(x, y) + 1`. This is because we will consider only the longest child path, and there's an extra `1` representing the current node.\n\nTherefore, in the recursive function, the base condition would be that if the node is null then we can return `0`. Otherwise, we will recursively call for the left and right child and store the count of nodes in the variables `left` and `right`. Update the answer variable if it's less than the univalue path at the current node which is `x + y`. Return the `max(x, y) + 1` which is the maximum number of nodes that have the same value as `root` on either the left or right side.\n\n![fig](../Figures/687/687A.png)\n\n**Algorithm**\n\n1. Define the recursive function `solve()`, which accepts two arguments first the current node` root` and the second is the value of its parent node `parent`. This method returns the maximum number of consecutive nodes that are present on either the left or right side of the `root` with the same value, including the `root`.\n\n    1. If the root is `NULL`, then return `0`.\n    2. Recursively call `solve()` for the left and right child with the parent value as the value of `root`.\n    3. Update the answer variable `ans` if `left + right` is greater than `ans`.\n    4. If the value of `root` is equal to the parent, return `max(left, right) + 1`, otherwise, return `0`.\n\n2. Call `solve()` with `root` and parent value as `-1`.\n3. Return the maximum univalue path length `ans`.\n\n\n**Implementation****Complexity Analysis**\n\nHere, $N$ is the number of nodes in the binary tree.\n\n* Time complexity: $O(N)$\n\n  We are iterating over each node only once and hence the time complexity is equal to $O(N)$.\n\n* Space complexity: $O(N)$\n\n  The only space we need is during the recursion, the maximum number of active stack calls would be equal to the height of the tree. In the case of a skewed tree, the height of the tree will be equal to $N$, hence the space complexity is equal to $O(N)$.---"
}