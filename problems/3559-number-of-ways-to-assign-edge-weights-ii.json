{
  "title": "Number of Ways to Assign Edge Weights II",
  "problem_id": "3842",
  "frontend_id": "3559",
  "difficulty": "Hard",
  "problem_slug": "number-of-ways-to-assign-edge-weights-ii",
  "topics": [
    "Array",
    "Math",
    "Dynamic Programming",
    "Tree",
    "Depth-First Search"
  ],
  "description": "There is an undirected tree with n nodes labeled from 1 to n, rooted at node 1. The tree is represented by a 2D integer array edges of length n - 1, where edges[i] = [ui, vi] indicates that there is an edge between nodes ui and vi.\nInitially, all edges have a weight of 0. You must assign each edge a weight of either 1 or 2.\nThe cost of a path between any two nodes u and v is the total weight of all edges in the path connecting them.\nYou are given a 2D integer array queries. For each queries[i] = [ui, vi], determine the number of ways to assign weights to edges in the path such that the cost of the path between ui and vi is odd.\nReturn an array answer, where answer[i] is the number of valid assignments for queries[i].\nSince the answer may be large, apply modulo 109 + 7 to each answer[i].\nNote: For each query, disregard all edges not in the path between node ui and vi.\nExample 1:\nExample 2:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "\nInput: edges = [[1,2]], queries = [[1,1],[1,2]]\nOutput: [0,1]\nExplanation:",
      "images": [
        "https://assets.leetcode.com/uploads/2025/03/23/screenshot-2025-03-24-at-060006.png"
      ]
    },
    {
      "example_num": 2,
      "example_text": "Input: edges = [[1,2],[1,3],[3,4],[3,5]], queries = [[1,4],[3,4],[2,5]]\nOutput: [2,1,4]\nExplanation:",
      "images": []
    }
  ],
  "constraints": [
    "2 <= n <= 105",
    "edges.length == n - 1",
    "edges[i] == [ui, vi]",
    "1 <= queries.length <= 105",
    "queries[i] == [ui, vi]",
    "1 <= ui, vi <= n",
    "edges represents a valid tree."
  ],
  "follow_ups": [],
  "hints": [
    "Dynamic programming with states <code>chainLength</code> and <code>sumParity</code>.",
    "Use Lowest Common Ancestor to find the distance between any two nodes quickly in <code>O(logn)</code>."
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    vector<int> assignEdgeWeights(vector<vector<int>>& edges, vector<vector<int>>& queries) {\n        \n    }\n};",
    "java": "class Solution {\n    public int[] assignEdgeWeights(int[][] edges, int[][] queries) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def assignEdgeWeights(self, edges, queries):\n        \"\"\"\n        :type edges: List[List[int]]\n        :type queries: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def assignEdgeWeights(self, edges: List[List[int]], queries: List[List[int]]) -> List[int]:\n        ",
    "c": "/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nint* assignEdgeWeights(int** edges, int edgesSize, int* edgesColSize, int** queries, int queriesSize, int* queriesColSize, int* returnSize) {\n    \n}",
    "csharp": "public class Solution {\n    public int[] AssignEdgeWeights(int[][] edges, int[][] queries) {\n        \n    }\n}",
    "javascript": "/**\n * @param {number[][]} edges\n * @param {number[][]} queries\n * @return {number[]}\n */\nvar assignEdgeWeights = function(edges, queries) {\n    \n};",
    "typescript": "function assignEdgeWeights(edges: number[][], queries: number[][]): number[] {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param Integer[][] $edges\n     * @param Integer[][] $queries\n     * @return Integer[]\n     */\n    function assignEdgeWeights($edges, $queries) {\n        \n    }\n}",
    "swift": "class Solution {\n    func assignEdgeWeights(_ edges: [[Int]], _ queries: [[Int]]) -> [Int] {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun assignEdgeWeights(edges: Array<IntArray>, queries: Array<IntArray>): IntArray {\n        \n    }\n}",
    "dart": "class Solution {\n  List<int> assignEdgeWeights(List<List<int>> edges, List<List<int>> queries) {\n    \n  }\n}",
    "golang": "func assignEdgeWeights(edges [][]int, queries [][]int) []int {\n    \n}",
    "ruby": "# @param {Integer[][]} edges\n# @param {Integer[][]} queries\n# @return {Integer[]}\ndef assign_edge_weights(edges, queries)\n    \nend",
    "scala": "object Solution {\n    def assignEdgeWeights(edges: Array[Array[Int]], queries: Array[Array[Int]]): Array[Int] = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn assign_edge_weights(edges: Vec<Vec<i32>>, queries: Vec<Vec<i32>>) -> Vec<i32> {\n        \n    }\n}",
    "racket": "(define/contract (assign-edge-weights edges queries)\n  (-> (listof (listof exact-integer?)) (listof (listof exact-integer?)) (listof exact-integer?))\n  )",
    "erlang": "-spec assign_edge_weights(Edges :: [[integer()]], Queries :: [[integer()]]) -> [integer()].\nassign_edge_weights(Edges, Queries) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec assign_edge_weights(edges :: [[integer]], queries :: [[integer]]) :: [integer]\n  def assign_edge_weights(edges, queries) do\n    \n  end\nend"
  }
}