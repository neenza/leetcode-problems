{
  "title": "Number of Valid Move Combinations On Chessboard",
  "problem_id": "2166",
  "frontend_id": "2056",
  "difficulty": "Hard",
  "problem_slug": "number-of-valid-move-combinations-on-chessboard",
  "topics": [
    "Array",
    "String",
    "Backtracking",
    "Simulation"
  ],
  "description": "There is an 8 x 8 chessboard containing n pieces (rooks, queens, or bishops). You are given a string array pieces of length n, where pieces[i] describes the type (rook, queen, or bishop) of the ith piece. In addition, you are given a 2D integer array positions also of length n, where positions[i] = [ri, ci] indicates that the ith piece is currently at the 1-based coordinate (ri, ci) on the chessboard.\nWhen making a move for a piece, you choose a destination square that the piece will travel toward and stop on.\nYou must make a move for every piece on the board simultaneously. A move combination consists of all the moves performed on all the given pieces. Every second, each piece will instantaneously travel one square towards their destination if they are not already at it. All pieces start traveling at the 0th second. A move combination is invalid if, at a given time, two or more pieces occupy the same square.\nReturn the number of valid move combinations​​​​​.\nNotes:\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: pieces = [\"rook\"], positions = [[1,1]]\nOutput: 15\nExplanation: The image above shows the possible squares the piece can move to.",
      "images": [
        "https://assets.leetcode.com/uploads/2021/09/23/a1.png"
      ]
    },
    {
      "example_num": 2,
      "example_text": "Input: pieces = [\"queen\"], positions = [[1,1]]\nOutput: 22\nExplanation: The image above shows the possible squares the piece can move to.",
      "images": [
        "https://assets.leetcode.com/uploads/2021/09/23/a2.png"
      ]
    },
    {
      "example_num": 3,
      "example_text": "Input: pieces = [\"bishop\"], positions = [[4,3]]\nOutput: 12\nExplanation: The image above shows the possible squares the piece can move to.",
      "images": [
        "https://assets.leetcode.com/uploads/2021/09/23/a3.png"
      ]
    }
  ],
  "constraints": [
    "n == pieces.length",
    "n == positions.length",
    "1 <= n <= 4",
    "pieces only contains the strings \"rook\", \"queen\", and \"bishop\".",
    "There will be at most one queen on the chessboard.",
    "1 <= ri, ci <= 8",
    "Each positions[i] is distinct."
  ],
  "follow_ups": [],
  "hints": [
    "N is small, we can generate all possible move combinations.",
    "For each possible move combination, determine which ones are valid."
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    int countCombinations(vector<string>& pieces, vector<vector<int>>& positions) {\n        \n    }\n};",
    "java": "class Solution {\n    public int countCombinations(String[] pieces, int[][] positions) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def countCombinations(self, pieces, positions):\n        \"\"\"\n        :type pieces: List[str]\n        :type positions: List[List[int]]\n        :rtype: int\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def countCombinations(self, pieces: List[str], positions: List[List[int]]) -> int:\n        ",
    "c": "int countCombinations(char** pieces, int piecesSize, int** positions, int positionsSize, int* positionsColSize) {\n    \n}",
    "csharp": "public class Solution {\n    public int CountCombinations(string[] pieces, int[][] positions) {\n        \n    }\n}",
    "javascript": "/**\n * @param {string[]} pieces\n * @param {number[][]} positions\n * @return {number}\n */\nvar countCombinations = function(pieces, positions) {\n    \n};",
    "typescript": "function countCombinations(pieces: string[], positions: number[][]): number {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param String[] $pieces\n     * @param Integer[][] $positions\n     * @return Integer\n     */\n    function countCombinations($pieces, $positions) {\n        \n    }\n}",
    "swift": "class Solution {\n    func countCombinations(_ pieces: [String], _ positions: [[Int]]) -> Int {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun countCombinations(pieces: Array<String>, positions: Array<IntArray>): Int {\n        \n    }\n}",
    "dart": "class Solution {\n  int countCombinations(List<String> pieces, List<List<int>> positions) {\n    \n  }\n}",
    "golang": "func countCombinations(pieces []string, positions [][]int) int {\n    \n}",
    "ruby": "# @param {String[]} pieces\n# @param {Integer[][]} positions\n# @return {Integer}\ndef count_combinations(pieces, positions)\n    \nend",
    "scala": "object Solution {\n    def countCombinations(pieces: Array[String], positions: Array[Array[Int]]): Int = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn count_combinations(pieces: Vec<String>, positions: Vec<Vec<i32>>) -> i32 {\n        \n    }\n}",
    "racket": "(define/contract (count-combinations pieces positions)\n  (-> (listof string?) (listof (listof exact-integer?)) exact-integer?)\n  )",
    "erlang": "-spec count_combinations(Pieces :: [unicode:unicode_binary()], Positions :: [[integer()]]) -> integer().\ncount_combinations(Pieces, Positions) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec count_combinations(pieces :: [String.t], positions :: [[integer]]) :: integer\n  def count_combinations(pieces, positions) do\n    \n  end\nend"
  }
}