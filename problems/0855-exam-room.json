{
  "title": "Exam Room",
  "problem_id": "885",
  "frontend_id": "855",
  "difficulty": "Medium",
  "problem_slug": "exam-room",
  "topics": [
    "Design",
    "Heap (Priority Queue)",
    "Ordered Set"
  ],
  "description": "There is an exam room with n seats in a single row labeled from 0 to n - 1.\nWhen a student enters the room, they must sit in the seat that maximizes the distance to the closest person. If there are multiple such seats, they sit in the seat with the lowest number. If no one is in the room, then the student sits at seat number 0.\nDesign a class that simulates the mentioned exam room.\nImplement the ExamRoom class:\nExample 1:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input\n[\"ExamRoom\", \"seat\", \"seat\", \"seat\", \"seat\", \"leave\", \"seat\"]\n[[10], [], [], [], [], [4], []]\nOutput\n[null, 0, 9, 4, 2, null, 5]\n\nExplanation\nExamRoom examRoom = new ExamRoom(10);\nexamRoom.seat(); // return 0, no one is in the room, then the student sits at seat number 0.\nexamRoom.seat(); // return 9, the student sits at the last seat number 9.\nexamRoom.seat(); // return 4, the student sits at the last seat number 4.\nexamRoom.seat(); // return 2, the student sits at the last seat number 2.\nexamRoom.leave(4);\nexamRoom.seat(); // return 5, the student sits at the last seat number 5.",
      "images": []
    }
  ],
  "constraints": [
    "1 <= n <= 109",
    "It is guaranteed that there is a student sitting at seat p.",
    "At most 104 calls will be made to seat and leave."
  ],
  "follow_ups": [],
  "hints": [],
  "code_snippets": {
    "cpp": "class ExamRoom {\npublic:\n    ExamRoom(int n) {\n        \n    }\n    \n    int seat() {\n        \n    }\n    \n    void leave(int p) {\n        \n    }\n};\n\n/**\n * Your ExamRoom object will be instantiated and called as such:\n * ExamRoom* obj = new ExamRoom(n);\n * int param_1 = obj->seat();\n * obj->leave(p);\n */",
    "java": "class ExamRoom {\n\n    public ExamRoom(int n) {\n        \n    }\n    \n    public int seat() {\n        \n    }\n    \n    public void leave(int p) {\n        \n    }\n}\n\n/**\n * Your ExamRoom object will be instantiated and called as such:\n * ExamRoom obj = new ExamRoom(n);\n * int param_1 = obj.seat();\n * obj.leave(p);\n */",
    "python": "class ExamRoom(object):\n\n    def __init__(self, n):\n        \"\"\"\n        :type n: int\n        \"\"\"\n        \n\n    def seat(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        \n\n    def leave(self, p):\n        \"\"\"\n        :type p: int\n        :rtype: None\n        \"\"\"\n        \n\n\n# Your ExamRoom object will be instantiated and called as such:\n# obj = ExamRoom(n)\n# param_1 = obj.seat()\n# obj.leave(p)",
    "python3": "class ExamRoom:\n\n    def __init__(self, n: int):\n        \n\n    def seat(self) -> int:\n        \n\n    def leave(self, p: int) -> None:\n        \n\n\n# Your ExamRoom object will be instantiated and called as such:\n# obj = ExamRoom(n)\n# param_1 = obj.seat()\n# obj.leave(p)",
    "c": "\n\n\ntypedef struct {\n    \n} ExamRoom;\n\n\nExamRoom* examRoomCreate(int n) {\n    \n}\n\nint examRoomSeat(ExamRoom* obj) {\n    \n}\n\nvoid examRoomLeave(ExamRoom* obj, int p) {\n    \n}\n\nvoid examRoomFree(ExamRoom* obj) {\n    \n}\n\n/**\n * Your ExamRoom struct will be instantiated and called as such:\n * ExamRoom* obj = examRoomCreate(n);\n * int param_1 = examRoomSeat(obj);\n \n * examRoomLeave(obj, p);\n \n * examRoomFree(obj);\n*/",
    "csharp": "public class ExamRoom {\n\n    public ExamRoom(int n) {\n        \n    }\n    \n    public int Seat() {\n        \n    }\n    \n    public void Leave(int p) {\n        \n    }\n}\n\n/**\n * Your ExamRoom object will be instantiated and called as such:\n * ExamRoom obj = new ExamRoom(n);\n * int param_1 = obj.Seat();\n * obj.Leave(p);\n */",
    "javascript": "/**\n * @param {number} n\n */\nvar ExamRoom = function(n) {\n    \n};\n\n/**\n * @return {number}\n */\nExamRoom.prototype.seat = function() {\n    \n};\n\n/** \n * @param {number} p\n * @return {void}\n */\nExamRoom.prototype.leave = function(p) {\n    \n};\n\n/** \n * Your ExamRoom object will be instantiated and called as such:\n * var obj = new ExamRoom(n)\n * var param_1 = obj.seat()\n * obj.leave(p)\n */",
    "typescript": "class ExamRoom {\n    constructor(n: number) {\n        \n    }\n\n    seat(): number {\n        \n    }\n\n    leave(p: number): void {\n        \n    }\n}\n\n/**\n * Your ExamRoom object will be instantiated and called as such:\n * var obj = new ExamRoom(n)\n * var param_1 = obj.seat()\n * obj.leave(p)\n */",
    "php": "class ExamRoom {\n    /**\n     * @param Integer $n\n     */\n    function __construct($n) {\n        \n    }\n  \n    /**\n     * @return Integer\n     */\n    function seat() {\n        \n    }\n  \n    /**\n     * @param Integer $p\n     * @return NULL\n     */\n    function leave($p) {\n        \n    }\n}\n\n/**\n * Your ExamRoom object will be instantiated and called as such:\n * $obj = ExamRoom($n);\n * $ret_1 = $obj->seat();\n * $obj->leave($p);\n */",
    "swift": "\nclass ExamRoom {\n\n    init(_ n: Int) {\n        \n    }\n    \n    func seat() -> Int {\n        \n    }\n    \n    func leave(_ p: Int) {\n        \n    }\n}\n\n/**\n * Your ExamRoom object will be instantiated and called as such:\n * let obj = ExamRoom(n)\n * let ret_1: Int = obj.seat()\n * obj.leave(p)\n */",
    "kotlin": "class ExamRoom(n: Int) {\n\n    fun seat(): Int {\n        \n    }\n\n    fun leave(p: Int) {\n        \n    }\n\n}\n\n/**\n * Your ExamRoom object will be instantiated and called as such:\n * var obj = ExamRoom(n)\n * var param_1 = obj.seat()\n * obj.leave(p)\n */",
    "dart": "class ExamRoom {\n\n  ExamRoom(int n) {\n    \n  }\n  \n  int seat() {\n    \n  }\n  \n  void leave(int p) {\n    \n  }\n}\n\n/**\n * Your ExamRoom object will be instantiated and called as such:\n * ExamRoom obj = ExamRoom(n);\n * int param1 = obj.seat();\n * obj.leave(p);\n */",
    "golang": "type ExamRoom struct {\n    \n}\n\n\nfunc Constructor(n int) ExamRoom {\n    \n}\n\n\nfunc (this *ExamRoom) Seat() int {\n    \n}\n\n\nfunc (this *ExamRoom) Leave(p int)  {\n    \n}\n\n\n/**\n * Your ExamRoom object will be instantiated and called as such:\n * obj := Constructor(n);\n * param_1 := obj.Seat();\n * obj.Leave(p);\n */",
    "ruby": "class ExamRoom\n\n=begin\n    :type n: Integer\n=end\n    def initialize(n)\n        \n    end\n\n\n=begin\n    :rtype: Integer\n=end\n    def seat()\n        \n    end\n\n\n=begin\n    :type p: Integer\n    :rtype: Void\n=end\n    def leave(p)\n        \n    end\n\n\nend\n\n# Your ExamRoom object will be instantiated and called as such:\n# obj = ExamRoom.new(n)\n# param_1 = obj.seat()\n# obj.leave(p)",
    "scala": "class ExamRoom(_n: Int) {\n\n    def seat(): Int = {\n        \n    }\n\n    def leave(p: Int): Unit = {\n        \n    }\n\n}\n\n/**\n * Your ExamRoom object will be instantiated and called as such:\n * val obj = new ExamRoom(n)\n * val param_1 = obj.seat()\n * obj.leave(p)\n */",
    "rust": "struct ExamRoom {\n\n}\n\n\n/** \n * `&self` means the method takes an immutable reference.\n * If you need a mutable reference, change it to `&mut self` instead.\n */\nimpl ExamRoom {\n\n    fn new(n: i32) -> Self {\n        \n    }\n    \n    fn seat(&self) -> i32 {\n        \n    }\n    \n    fn leave(&self, p: i32) {\n        \n    }\n}\n\n/**\n * Your ExamRoom object will be instantiated and called as such:\n * let obj = ExamRoom::new(n);\n * let ret_1: i32 = obj.seat();\n * obj.leave(p);\n */",
    "racket": "(define exam-room%\n  (class object%\n    (super-new)\n    \n    ; n : exact-integer?\n    (init-field\n      n)\n    \n    ; seat : -> exact-integer?\n    (define/public (seat)\n      )\n    ; leave : exact-integer? -> void?\n    (define/public (leave p)\n      )))\n\n;; Your exam-room% object will be instantiated and called as such:\n;; (define obj (new exam-room% [n n]))\n;; (define param_1 (send obj seat))\n;; (send obj leave p)",
    "erlang": "-spec exam_room_init_(N :: integer()) -> any().\nexam_room_init_(N) ->\n  .\n\n-spec exam_room_seat() -> integer().\nexam_room_seat() ->\n  .\n\n-spec exam_room_leave(P :: integer()) -> any().\nexam_room_leave(P) ->\n  .\n\n\n%% Your functions will be called as such:\n%% exam_room_init_(N),\n%% Param_1 = exam_room_seat(),\n%% exam_room_leave(P),\n\n%% exam_room_init_ will be called before every test case, in which you can do some necessary initializations.",
    "elixir": "defmodule ExamRoom do\n  @spec init_(n :: integer) :: any\n  def init_(n) do\n    \n  end\n\n  @spec seat() :: integer\n  def seat() do\n    \n  end\n\n  @spec leave(p :: integer) :: any\n  def leave(p) do\n    \n  end\nend\n\n# Your functions will be called as such:\n# ExamRoom.init_(n)\n# param_1 = ExamRoom.seat()\n# ExamRoom.leave(p)\n\n# ExamRoom.init_ will be called before every test case, in which you can do some necessary initializations."
  }
}