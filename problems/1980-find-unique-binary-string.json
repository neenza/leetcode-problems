{
  "title": "Find Unique Binary String",
  "problem_id": "2107",
  "frontend_id": "1980",
  "difficulty": "Medium",
  "problem_slug": "find-unique-binary-string",
  "topics": [
    "Array",
    "Hash Table",
    "String",
    "Backtracking"
  ],
  "description": "Given an array of strings nums containing n unique binary strings each of length n, return a binary string of length n that does not appear in nums. If there are multiple answers, you may return any of them.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: nums = [\"01\",\"10\"]\nOutput: \"11\"\nExplanation: \"11\" does not appear in nums. \"00\" would also be correct.",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input: nums = [\"00\",\"01\"]\nOutput: \"11\"\nExplanation: \"11\" does not appear in nums. \"10\" would also be correct.",
      "images": []
    },
    {
      "example_num": 3,
      "example_text": "Input: nums = [\"111\",\"011\",\"001\"]\nOutput: \"101\"\nExplanation: \"101\" does not appear in nums. \"000\", \"010\", \"100\", and \"110\" would also be correct.",
      "images": []
    }
  ],
  "constraints": [
    "n == nums.length",
    "1 <= n <= 16",
    "nums[i].length == n",
    "nums[i] is either '0' or '1'.",
    "All the strings of nums are unique."
  ],
  "follow_ups": [],
  "hints": [
    "We can convert the given strings into base 10 integers.",
    "Can we use recursion to generate all possible strings?"
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    string findDifferentBinaryString(vector<string>& nums) {\n        \n    }\n};",
    "java": "class Solution {\n    public String findDifferentBinaryString(String[] nums) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def findDifferentBinaryString(self, nums):\n        \"\"\"\n        :type nums: List[str]\n        :rtype: str\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def findDifferentBinaryString(self, nums: List[str]) -> str:\n        ",
    "c": "char* findDifferentBinaryString(char** nums, int numsSize) {\n    \n}",
    "csharp": "public class Solution {\n    public string FindDifferentBinaryString(string[] nums) {\n        \n    }\n}",
    "javascript": "/**\n * @param {string[]} nums\n * @return {string}\n */\nvar findDifferentBinaryString = function(nums) {\n    \n};",
    "typescript": "function findDifferentBinaryString(nums: string[]): string {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param String[] $nums\n     * @return String\n     */\n    function findDifferentBinaryString($nums) {\n        \n    }\n}",
    "swift": "class Solution {\n    func findDifferentBinaryString(_ nums: [String]) -> String {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun findDifferentBinaryString(nums: Array<String>): String {\n        \n    }\n}",
    "dart": "class Solution {\n  String findDifferentBinaryString(List<String> nums) {\n    \n  }\n}",
    "golang": "func findDifferentBinaryString(nums []string) string {\n    \n}",
    "ruby": "# @param {String[]} nums\n# @return {String}\ndef find_different_binary_string(nums)\n    \nend",
    "scala": "object Solution {\n    def findDifferentBinaryString(nums: Array[String]): String = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn find_different_binary_string(nums: Vec<String>) -> String {\n        \n    }\n}",
    "racket": "(define/contract (find-different-binary-string nums)\n  (-> (listof string?) string?)\n  )",
    "erlang": "-spec find_different_binary_string(Nums :: [unicode:unicode_binary()]) -> unicode:unicode_binary().\nfind_different_binary_string(Nums) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec find_different_binary_string(nums :: [String.t]) :: String.t\n  def find_different_binary_string(nums) do\n    \n  end\nend"
  },
  "solution": "[TOC]\n\n## Solution\n\n---\n\n### Approach 1: Recursively Generate All Strings\n\n**Intuition**\n\nIn the constraints, we see that $$n \\leq 16$$. Given that there are only $$2^{16} = 65536$$ possible binary strings, it is feasible to generate all of them in an attempt to find one that does not appear in `nums`.\n\nWe will use a recursive function `generate(curr)` to generate the binary strings. At each function call, `curr` is the current string we have. First, we check if `curr.length = n`. If it is, we need to stop adding characters and assess if we have an answer. If `curr` is in `nums`, we return an empty string. If it isn't, we return `curr`.\n\nIf `curr.length != n`, we will add a character. Since we are generating all strings, we will call both `generate(curr + \"0\")` and `generate(curr + \"1\")`. Note that in our base case, we return an empty string if we did not generate a valid answer. Thus, if either call returns a **non-empty** string, the value it returns is a valid answer.\n\nAs each call to `generate` creates two more calls, the algorithm will have a time complexity of at least $$O(2^n)$$. However, we can implement a crucial optimization. We will first call `generate(curr + \"0\")` and store the value in `addZero`. If `addZero` is not an empty string, we can immediately return it as the answer without needing to make the additional call to `generate(curr + \"1\")`. If `addZero` is an empty string, it means all possible paths from adding a `\"0\"` lead to invalid answers, and thus `generate(curr + \"1\")` must generate a valid answer, since it's guaranteed that a valid answer exists.\n\nWhy is this optimization such a big deal? Notice that the length of `nums` is `n`. Thus, if we check `n + 1` different strings of length `n`, we will surely find a valid answer. By returning `addZero` early, we terminate the recursion as soon as we find a valid answer, thus we won't check more than `n + 1` strings of length `n`. Without any early returns, we would check $$2^n$$ strings of length `n`.\n\nAdditionally, we will convert `nums` to a hash set prior to starting the recursion, allowing for membership checks in $O(n)$ time complexity in the base case due to the length of the strings.\n\n**Algorithm**\n\n1. Create a function `generate(curr)`:\n    - If `curr.length = n`:\n        - If `curr` is not in `numsSet`, return `curr`.\n        - Return an empty string.\n    - Set `addZero = generate(curr + \"0\")`.\n    - If `addZero` is not an empty string, return it.\n    - Return `generate(curr + \"1\")`.\n2. Set `n = nums.length`.\n3. Convert `nums` to a hash set `numsSet`.\n4. Return `generate(\"\")`.\n\n**Implementation****Complexity Analysis**\n\nGiven $$n$$ as the length of `nums` (and the length of each binary string),\n\n* Time complexity: $$O(n^2)$$\n\n    We require $$O(n^2)$$ to convert `nums` to a hash set.\n\n    Due to the optimization, we check $$O(n)$$ binary strings in our recursion. At each call, we perform some string concatenation operations, which costs up to $$O(n)$$ (unless you have mutable strings like in C++).\n\n- Space complexity: $O(n^2)$\n\n    The space complexity is primarily determined by the `numsSet` and the recursion stack. The `numsSet` stores all $n$ binary strings from the input, each of length $n$, contributing $O(n \\cdot n) = O(n^2)$ space.\n\n    The recursion stack can go up to depth $n$, as the function builds strings of length $n$. Each level of recursion stores a string of length up to $n$, so the recursion stack contributes $O(n^2)$ space. However, this is already accounted for in the $O(n^2)$ space complexity of the `numsSet`.\n\n    Therefore, the overall space complexity is $O(n^2)$.---\n\n### Approach 2: Iterate Over Integer Equivalents\n\n**Intuition**\n\nWithout the optimization, the previous approach would be reasonable when the length of `nums` is not bounded. However, `nums` has a length of `n`. There are many more possible binary strings than there are strings in `nums`.\n\nIn fact, since there are only `n` strings in `nums`, we never need to check more than `n + 1` different binary strings, since at least one of them would not appear in `nums` and thus be a valid answer. How do we decide which `n + 1` binary strings we should check?\n\nLet's start by converting each string in `nums` to its equivalent base-10 integer. We will store these integers in a hash set `integers`. Now, we can simply use a for loop to iterate over the range `[0, n]` (the size of this range is `n + 1`, so it is guaranteed to contain at least one valid answer). For each number, we check if it is in `integers`. If it isn't, it represents a valid answer. We just need to convert it back to a binary string of length `n` and return it.\n\nNote that in some cases, if a valid answer, when converted to a binary string, has a length shorter than `n`, we need to add \"0\"s to the beginning to make its length equal to `n`.\n\n**Algorithm**\n\n1. Create `integers`, a hash set containing all the elements of `nums` in their base-10 integer form.\n2. Initialize `n = nums.length`.\n3. Iterate `num` from `0` to `n`:\n    - If `num` is not in `integers`, convert it to a binary string of length `n` and return it.\n4. The code should never reach this point. Return anything.\n\n**Implementation****Complexity Analysis**\n\nGiven $$n$$ as the length of `nums` (and the length of each binary string),\n\n* Time complexity: $$O(n^2)$$\n\n    We iterate over $$n$$ strings and convert them to integers, costing $$O(n)$$ for each integer.\n\n    We then iterate `num` in the range `[0, n]`. When we find the answer, we spend $$O(n)$$ to convert it to a string.\n\n* Space complexity: $$O(n)$$\n\n    The hash set `integers` has a size of $$n$$.---\n\n### Approach 3: Random\n\n**Intuition**\n\nAs mentioned before, there are many more possible binary strings than there are \"banned\" binary strings in `nums`.\n\nWe can randomly generate binary strings until we find one that is not in `nums`. For `n = 16`, there are $$2^{16} = 65536$$ strings we could generate, and only $$16$$ that would not be valid. Thus, the probability of finding a valid answer is $$\\dfrac{65536 - 16}{65536}$$, over 99.9%.\n\nIn general, the probability of generating a valid answer randomly is $$\\dfrac{2^n - n}{2^n}$$. Because $$2^n$$ grows much faster than $$n$$, the probability is very favorable for us.\n\nFor ease of implementation, we will start by converting each binary string in `num` to its base-10 equivalent, then storing these integers in a hash set `integers`, just like in approach 2.\n\nThen, we will generate random numbers in the range $$[0, 2^n]$$ until we find one not in `integers`. Once we do, we convert it to a binary string of length `n` and return it.\n\n**Algorithm**\n\n1. Create `integers`, a hash set containing all the elements of `nums` in their base-10 integer form.\n2. Set `ans` to any value in `integers` and `n = nums.length`.\n3. While `ans` is in `integers`:\n    - Randomly generate an integer between `0` (inclusive) and $$2^n$$.\n    - Set `ans` to the randomly generated integer.\n4. Convert `ans` to a binary string and return it.\n\n**Implementation****Complexity Analysis**\n\nGiven $$n$$ as the length of `nums` (and the length of each binary string),\n\n* Time complexity: $$O(\\infty)$$\n\n    Technically, the worst-case scenario would see the algorithm running infinitely, always selecting elements in `integers`. However, the probability that the algorithm runs for more than a few steps, let alone infinitely, is so low that we can assume it to be effectively 0. This probability also lowers exponentially as `n` increases.\n\n    For `n = 16`, there is an over 99.9% chance that we find an answer on the first iteration. For `n = 20`, we have an over 99.998% chance. Practically, this algorithm runs extremely quickly.\n\n* Space complexity: $$O(n)$$\n\n    The hash set `integers` has a size of $$n$$.\n    \n    We don't count the answer as part of the space complexity.---\n\n### Approach 4: Cantor's Diagonal Argument\n\n**Intuition**\n\n[Cantor's diagonal argument](https://en.wikipedia.org/wiki/Cantor%27s_diagonal_argument) is a proof in set theory.\n\nWhile we do not need to fully understand the proof and its consequences, this approach uses very similar ideas.\n\nWe start by initializing the answer `ans` to an empty string. To build `ans`, we need to assign either `\"0\"` or `\"1\"` to each index `i` for indices `0` to `n - 1`. How do we assign them so `ans` is guaranteed to be different from every string in `nums`? We know that two strings are different, as long as they differ by at least one character. We can intentionally construct our `ans` based on this fact.\n\nFor each index `i`, we will check the $$i^{th}$$ character of the $$i^{th}$$ string in `nums`. That is, we check `curr = nums[i][i]`. We then assign `ans[i]` to the opposite of `curr`. That is, if `curr = \"0\"`, we assign `ans[i] = \"1\"`. If `curr = \"1\"`, we assign `ans[i] = \"0\"`.\n\nWhat is the point of this strategy? `ans` will differ from every string in **at least** one position. More specifically:\n- `ans` differs from `nums[0]` in `nums[0][0]`.\n- `ans` differs from `nums[1]` in  `nums[1][1]`.\n- `ans` differs from `nums[2]` in  `nums[2][2]`.\n- ...\n- `ans` differs from `nums[n - 1]` in  `nums[n - 1][n - 1]`.\n\nThus, it is guaranteed that `ans` does not appear in `nums` and is a valid answer. \n\n> This strategy is applicable because both the length of `ans` and the length of each string in `nums` are larger than or equal to `n`, the number of strings in `nums`. Therefore, we can find one unique position for each string in `nums`.\n\n**Algorithm**\n\n1. Initialize the answer `ans`. Note that you should build the answer in an efficient manner according to the programming language you're using.\n2. Iterate `i` over the indices of `nums`:\n    - Set `curr = nums[i][i]`.\n    - If `curr = \"0\"`, add `\"1\"` to `ans`. Otherwise, add `\"0\"` to `ans`.\n3. Return `ans`.\n\n**Implementation****Complexity Analysis**\n\nGiven $$n$$ as the length of `nums` (and the length of each binary string),\n\n* Time complexity: $$O(n)$$\n\n    We iterate over each string in `nums`. Assuming the string building is efficient, each iteration costs $$O(1)$$, and joining the answer string at the end costs $$O(n)$$.\n\n* Space complexity: $$O(1)$$\n\n    We don't count the answer as part of the space complexity.---"
}