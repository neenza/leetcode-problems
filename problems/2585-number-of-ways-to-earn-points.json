{
  "title": "Number of Ways to Earn Points",
  "problem_id": "2648",
  "frontend_id": "2585",
  "difficulty": "Hard",
  "problem_slug": "number-of-ways-to-earn-points",
  "topics": [
    "Array",
    "Dynamic Programming"
  ],
  "description": "There is a test that has n types of questions. You are given an integer target and a 0-indexed 2D integer array types where types[i] = [counti, marksi] indicates that there are counti questions of the ith type, and each one of them is worth marksi points.\nReturn the number of ways you can earn exactly target points in the exam. Since the answer may be too large, return it modulo 109 + 7.\nNote that questions of the same type are indistinguishable.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: target = 6, types = [[6,1],[3,2],[2,3]]\nOutput: 7\nExplanation: You can earn 6 points in one of the seven ways:\n- Solve 6 questions of the 0th type: 1 + 1 + 1 + 1 + 1 + 1 = 6\n- Solve 4 questions of the 0th type and 1 question of the 1st type: 1 + 1 + 1 + 1 + 2 = 6\n- Solve 2 questions of the 0th type and 2 questions of the 1st type: 1 + 1 + 2 + 2 = 6\n- Solve 3 questions of the 0th type and 1 question of the 2nd type: 1 + 1 + 1 + 3 = 6\n- Solve 1 question of the 0th type, 1 question of the 1st type and 1 question of the 2nd type: 1 + 2 + 3 = 6\n- Solve 3 questions of the 1st type: 2 + 2 + 2 = 6\n- Solve 2 questions of the 2nd type: 3 + 3 = 6",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input: target = 5, types = [[50,1],[50,2],[50,5]]\nOutput: 4\nExplanation: You can earn 5 points in one of the four ways:\n- Solve 5 questions of the 0th type: 1 + 1 + 1 + 1 + 1 = 5\n- Solve 3 questions of the 0th type and 1 question of the 1st type: 1 + 1 + 1 + 2 = 5\n- Solve 1 questions of the 0th type and 2 questions of the 1st type: 1 + 2 + 2 = 5\n- Solve 1 question of the 2nd type: 5",
      "images": []
    },
    {
      "example_num": 3,
      "example_text": "Input: target = 18, types = [[6,1],[3,2],[2,3]]\nOutput: 1\nExplanation: You can only earn 18 points by answering all questions.",
      "images": []
    }
  ],
  "constraints": [
    "1 <= target <= 1000",
    "n == types.length",
    "1 <= n <= 50",
    "types[i].length == 2",
    "1 <= counti, marksi <= 50"
  ],
  "follow_ups": [],
  "hints": [
    "Use Dynamic Programming",
    "Let ways[i][points] be the number of ways to score a given number of points after solving some questions of the first i types.",
    "ways[i][points] is equal to the sum of ways[i-1][points - solved * marks[i] over 0 <= solved <= count_i"
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    int waysToReachTarget(int target, vector<vector<int>>& types) {\n        \n    }\n};",
    "java": "class Solution {\n    public int waysToReachTarget(int target, int[][] types) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def waysToReachTarget(self, target, types):\n        \"\"\"\n        :type target: int\n        :type types: List[List[int]]\n        :rtype: int\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def waysToReachTarget(self, target: int, types: List[List[int]]) -> int:\n        ",
    "c": "int waysToReachTarget(int target, int** types, int typesSize, int* typesColSize) {\n    \n}",
    "csharp": "public class Solution {\n    public int WaysToReachTarget(int target, int[][] types) {\n        \n    }\n}",
    "javascript": "/**\n * @param {number} target\n * @param {number[][]} types\n * @return {number}\n */\nvar waysToReachTarget = function(target, types) {\n    \n};",
    "typescript": "function waysToReachTarget(target: number, types: number[][]): number {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param Integer $target\n     * @param Integer[][] $types\n     * @return Integer\n     */\n    function waysToReachTarget($target, $types) {\n        \n    }\n}",
    "swift": "class Solution {\n    func waysToReachTarget(_ target: Int, _ types: [[Int]]) -> Int {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun waysToReachTarget(target: Int, types: Array<IntArray>): Int {\n        \n    }\n}",
    "dart": "class Solution {\n  int waysToReachTarget(int target, List<List<int>> types) {\n    \n  }\n}",
    "golang": "func waysToReachTarget(target int, types [][]int) int {\n    \n}",
    "ruby": "# @param {Integer} target\n# @param {Integer[][]} types\n# @return {Integer}\ndef ways_to_reach_target(target, types)\n    \nend",
    "scala": "object Solution {\n    def waysToReachTarget(target: Int, types: Array[Array[Int]]): Int = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn ways_to_reach_target(target: i32, types: Vec<Vec<i32>>) -> i32 {\n        \n    }\n}",
    "racket": "(define/contract (ways-to-reach-target target types)\n  (-> exact-integer? (listof (listof exact-integer?)) exact-integer?)\n  )",
    "erlang": "-spec ways_to_reach_target(Target :: integer(), Types :: [[integer()]]) -> integer().\nways_to_reach_target(Target, Types) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec ways_to_reach_target(target :: integer, types :: [[integer]]) :: integer\n  def ways_to_reach_target(target, types) do\n    \n  end\nend"
  }
}