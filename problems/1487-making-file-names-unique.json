{
  "title": "Making File Names Unique",
  "problem_id": "1611",
  "frontend_id": "1487",
  "difficulty": "Medium",
  "problem_slug": "making-file-names-unique",
  "topics": [
    "Array",
    "Hash Table",
    "String"
  ],
  "description": "Given an array of strings names of size n. You will create n folders in your file system such that, at the ith minute, you will create a folder with the name names[i].\nSince two files cannot have the same name, if you enter a folder name that was previously used, the system will have a suffix addition to its name in the form of (k), where, k is the smallest positive integer such that the obtained name remains unique.\nReturn an array of strings of length n where ans[i] is the actual name the system will assign to the ith folder when you create it.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: names = [\"pes\",\"fifa\",\"gta\",\"pes(2019)\"]\nOutput: [\"pes\",\"fifa\",\"gta\",\"pes(2019)\"]\nExplanation: Let's see how the file system creates folder names:\n\"pes\" --> not assigned before, remains \"pes\"\n\"fifa\" --> not assigned before, remains \"fifa\"\n\"gta\" --> not assigned before, remains \"gta\"\n\"pes(2019)\" --> not assigned before, remains \"pes(2019)\"",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input: names = [\"gta\",\"gta(1)\",\"gta\",\"avalon\"]\nOutput: [\"gta\",\"gta(1)\",\"gta(2)\",\"avalon\"]\nExplanation: Let's see how the file system creates folder names:\n\"gta\" --> not assigned before, remains \"gta\"\n\"gta(1)\" --> not assigned before, remains \"gta(1)\"\n\"gta\" --> the name is reserved, system adds (k), since \"gta(1)\" is also reserved, systems put k = 2. it becomes \"gta(2)\"\n\"avalon\" --> not assigned before, remains \"avalon\"",
      "images": []
    },
    {
      "example_num": 3,
      "example_text": "Input: names = [\"onepiece\",\"onepiece(1)\",\"onepiece(2)\",\"onepiece(3)\",\"onepiece\"]\nOutput: [\"onepiece\",\"onepiece(1)\",\"onepiece(2)\",\"onepiece(3)\",\"onepiece(4)\"]\nExplanation: When the last folder is created, the smallest positive valid k is 4, and it becomes \"onepiece(4)\".",
      "images": []
    }
  ],
  "constraints": [
    "1 <= names.length <= 5 * 104",
    "1 <= names[i].length <= 20",
    "names[i] consists of lowercase English letters, digits, and/or round brackets."
  ],
  "follow_ups": [],
  "hints": [
    "Keep a map of each name and the smallest valid integer that can be appended as a suffix to it.",
    "If the name is not present in the map, you can use it without adding any suffixes.",
    "If the name is present in the map, append the smallest proper suffix, and add the new name to the map."
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    vector<string> getFolderNames(vector<string>& names) {\n        \n    }\n};",
    "java": "class Solution {\n    public String[] getFolderNames(String[] names) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def getFolderNames(self, names):\n        \"\"\"\n        :type names: List[str]\n        :rtype: List[str]\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def getFolderNames(self, names: List[str]) -> List[str]:\n        ",
    "c": "/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nchar** getFolderNames(char** names, int namesSize, int* returnSize) {\n    \n}",
    "csharp": "public class Solution {\n    public string[] GetFolderNames(string[] names) {\n        \n    }\n}",
    "javascript": "/**\n * @param {string[]} names\n * @return {string[]}\n */\nvar getFolderNames = function(names) {\n    \n};",
    "typescript": "function getFolderNames(names: string[]): string[] {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param String[] $names\n     * @return String[]\n     */\n    function getFolderNames($names) {\n        \n    }\n}",
    "swift": "class Solution {\n    func getFolderNames(_ names: [String]) -> [String] {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun getFolderNames(names: Array<String>): Array<String> {\n        \n    }\n}",
    "dart": "class Solution {\n  List<String> getFolderNames(List<String> names) {\n    \n  }\n}",
    "golang": "func getFolderNames(names []string) []string {\n    \n}",
    "ruby": "# @param {String[]} names\n# @return {String[]}\ndef get_folder_names(names)\n    \nend",
    "scala": "object Solution {\n    def getFolderNames(names: Array[String]): Array[String] = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn get_folder_names(names: Vec<String>) -> Vec<String> {\n        \n    }\n}",
    "racket": "(define/contract (get-folder-names names)\n  (-> (listof string?) (listof string?))\n  )",
    "erlang": "-spec get_folder_names(Names :: [unicode:unicode_binary()]) -> [unicode:unicode_binary()].\nget_folder_names(Names) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec get_folder_names(names :: [String.t]) :: [String.t]\n  def get_folder_names(names) do\n    \n  end\nend"
  }
}