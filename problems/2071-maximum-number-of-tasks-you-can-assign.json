{
  "title": "Maximum Number of Tasks You Can Assign",
  "problem_id": "2180",
  "frontend_id": "2071",
  "difficulty": "Hard",
  "problem_slug": "maximum-number-of-tasks-you-can-assign",
  "topics": [
    "Array",
    "Two Pointers",
    "Binary Search",
    "Greedy",
    "Queue",
    "Sorting",
    "Monotonic Queue"
  ],
  "description": "You have n tasks and m workers. Each task has a strength requirement stored in a 0-indexed integer array tasks, with the ith task requiring tasks[i] strength to complete. The strength of each worker is stored in a 0-indexed integer array workers, with the jth worker having workers[j] strength. Each worker can only be assigned to a single task and must have a strength greater than or equal to the task's strength requirement (i.e., workers[j] >= tasks[i]).\nAdditionally, you have pills magical pills that will increase a worker's strength by strength. You can decide which workers receive the magical pills, however, you may only give each worker at most one magical pill.\nGiven the 0-indexed integer arrays tasks and workers and the integers pills and strength, return the maximum number of tasks that can be completed.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: tasks = [3,2,1], workers = [0,3,3], pills = 1, strength = 1\nOutput: 3\nExplanation:\nWe can assign the magical pill and tasks as follows:\n- Give the magical pill to worker 0.\n- Assign worker 0 to task 2 (0 + 1 >= 1)\n- Assign worker 1 to task 1 (3 >= 2)\n- Assign worker 2 to task 0 (3 >= 3)",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input: tasks = [5,4], workers = [0,0,0], pills = 1, strength = 5\nOutput: 1\nExplanation:\nWe can assign the magical pill and tasks as follows:\n- Give the magical pill to worker 0.\n- Assign worker 0 to task 0 (0 + 5 >= 5)",
      "images": []
    },
    {
      "example_num": 3,
      "example_text": "Input: tasks = [10,15,30], workers = [0,10,10,10,10], pills = 3, strength = 10\nOutput: 2\nExplanation:\nWe can assign the magical pills and tasks as follows:\n- Give the magical pill to worker 0 and worker 1.\n- Assign worker 0 to task 0 (0 + 10 >= 10)\n- Assign worker 1 to task 1 (10 + 10 >= 15)\nThe last pill is not given because it will not make any worker strong enough for the last task.",
      "images": []
    }
  ],
  "constraints": [
    "n == tasks.length",
    "m == workers.length",
    "1 <= n, m <= 5 * 104",
    "0 <= pills <= m",
    "0 <= tasks[i], workers[j], strength <= 109"
  ],
  "follow_ups": [],
  "hints": [
    "Is it possible to assign the first k smallest tasks to the workers?",
    "How can you efficiently try every k?"
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    int maxTaskAssign(vector<int>& tasks, vector<int>& workers, int pills, int strength) {\n        \n    }\n};",
    "java": "class Solution {\n    public int maxTaskAssign(int[] tasks, int[] workers, int pills, int strength) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def maxTaskAssign(self, tasks, workers, pills, strength):\n        \"\"\"\n        :type tasks: List[int]\n        :type workers: List[int]\n        :type pills: int\n        :type strength: int\n        :rtype: int\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def maxTaskAssign(self, tasks: List[int], workers: List[int], pills: int, strength: int) -> int:\n        ",
    "c": "int maxTaskAssign(int* tasks, int tasksSize, int* workers, int workersSize, int pills, int strength) {\n    \n}",
    "csharp": "public class Solution {\n    public int MaxTaskAssign(int[] tasks, int[] workers, int pills, int strength) {\n        \n    }\n}",
    "javascript": "/**\n * @param {number[]} tasks\n * @param {number[]} workers\n * @param {number} pills\n * @param {number} strength\n * @return {number}\n */\nvar maxTaskAssign = function(tasks, workers, pills, strength) {\n    \n};",
    "typescript": "function maxTaskAssign(tasks: number[], workers: number[], pills: number, strength: number): number {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param Integer[] $tasks\n     * @param Integer[] $workers\n     * @param Integer $pills\n     * @param Integer $strength\n     * @return Integer\n     */\n    function maxTaskAssign($tasks, $workers, $pills, $strength) {\n        \n    }\n}",
    "swift": "class Solution {\n    func maxTaskAssign(_ tasks: [Int], _ workers: [Int], _ pills: Int, _ strength: Int) -> Int {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun maxTaskAssign(tasks: IntArray, workers: IntArray, pills: Int, strength: Int): Int {\n        \n    }\n}",
    "dart": "class Solution {\n  int maxTaskAssign(List<int> tasks, List<int> workers, int pills, int strength) {\n    \n  }\n}",
    "golang": "func maxTaskAssign(tasks []int, workers []int, pills int, strength int) int {\n    \n}",
    "ruby": "# @param {Integer[]} tasks\n# @param {Integer[]} workers\n# @param {Integer} pills\n# @param {Integer} strength\n# @return {Integer}\ndef max_task_assign(tasks, workers, pills, strength)\n    \nend",
    "scala": "object Solution {\n    def maxTaskAssign(tasks: Array[Int], workers: Array[Int], pills: Int, strength: Int): Int = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn max_task_assign(tasks: Vec<i32>, workers: Vec<i32>, pills: i32, strength: i32) -> i32 {\n        \n    }\n}",
    "racket": "(define/contract (max-task-assign tasks workers pills strength)\n  (-> (listof exact-integer?) (listof exact-integer?) exact-integer? exact-integer? exact-integer?)\n  )",
    "erlang": "-spec max_task_assign(Tasks :: [integer()], Workers :: [integer()], Pills :: integer(), Strength :: integer()) -> integer().\nmax_task_assign(Tasks, Workers, Pills, Strength) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec max_task_assign(tasks :: [integer], workers :: [integer], pills :: integer, strength :: integer) :: integer\n  def max_task_assign(tasks, workers, pills, strength) do\n    \n  end\nend"
  },
  "solution": "[TOC]\n\n## Solution\n\n--- \n\n### Approach: Binary Search + Greedy Worker Selection\n\n#### Hint 1\n\nIf we already know that it’s possible to complete exactly $k$ tasks, then:\n\n* We should select the $k$ lowest-valued tasks from the `tasks` array.\n* We should select the $k$ highest-valued workers from the `workers` array.\n\n#### Hint 2\n\nIf it’s possible to complete $k$ tasks while satisfying Hint 1, then it’s also possible to complete $k - 1$ tasks using the $k - 1$ lowest-valued tasks and the $k - 1$ highest-valued workers, which also satisfies Hint 1.\n\n#### Intuition\n\nBased on Hint 2, we can use binary search to find the largest value $k'$ such that we can complete $k'$ tasks, but not $k' + 1$. This value $k'$ is our final answer.\n\nDuring each step of binary search, after selecting the $k$ lowest-valued tasks and the $k$ highest-valued workers, we need to determine whether it’s possible to assign the tasks to the workers.\n\nTo do this, we process the selected tasks in decreasing order of value. For each task, we consider the following two cases:\n\n- **Case 1**: The worker with the highest available value is greater than or equal to the task value.\n  In this case, we do not need to use a pill. We assign this worker (with the maximum value) to this task and remove them from the pool.\n\n  > Why this is optimal: Since this is the most difficult (i.e., highest-valued) task, any worker who can complete it can also complete the easier ones. If we assign a weaker worker instead (even with a pill), and later assign the stronger worker to an easier task, we could have swapped the assignments to make a better match. So it’s always optimal to assign the strongest available worker to the hardest task that doesn't need a pill.\n\n- **Case 2**: No worker can complete the task without a pill.\n  In this case, we must use a pill. We look for the weakest worker who can complete the task with the pill (i.e., a worker with value ≥ $t - \\textit{strength}$) and remove them from the pool.\n\n  > Why this is optimal: Again, since we're processing the hardest task first, any worker who can complete it using a pill can also complete easier tasks using a pill. So, it is always safe (and best) to use the weakest such worker for this hardest task.\n\nTherefore, we can iterate through the tasks in decreasing order of difficulty and maintain an ordered set of available workers. For each task value $t$:\n\n* If the maximum value in the set is ≥ $t$, we remove that maximum worker (no pill needed).\n* If not, we look for the minimum worker with value ≥ $t - \\textit{strength}$. If such a worker exists and we still have pills remaining, we use a pill and remove that worker.\n  Otherwise, it's not possible to complete all tasks with the current value of $k$.\n\nUsing this process, we can find whether a given value of $k$ is feasible.\n\n#### Implementation#### Complexity Analysis\n\n- Time complexity: $O(n \\log n + m \\log m + \\min(m, n) \\log^2 \\min(m, n))$\n\n    - Sorting the `tasks` array requires $O(n \\log n)$ time.\n\n    - Sorting the `workers` array requires $O(m \\log m)$ time.\n\n    - The lower bound of binary search is 1, and the upper bound is the smaller value between $m$ and $n$, so the number of binary search iterations is $\\log \\min(m, n)$. Each iteration involves enumerating $\\min(m, n)$ tasks. During this enumeration, deletion operations are performed on the ordered set of workers, with the time complexity of a single operation being $\\log \\min(m, n)$. Therefore, the total time complexity of binary search is $O(\\min(m, n) \\log^2 \\min(m, n))$.\n\n- Space complexity: $O(\\log n + \\log m + \\min(m, n))$\n\n    - Sorting the `tasks` array requires $O(\\log n)$ stack space.\n\n    - Sorting the `workers` array requires $O(\\log m)$ stack space.\n\n    - The ordered set used in binary search requires $O(\\min(m, n))$ space.\n\n#### Expansion:\n\nIt can be observed that when we enumerate each task from highest to lowest value, and maintain all workers who can complete the task (with the help of pills), then:\n\n- If there is a worker who can complete the task without using a pill, we select (and remove) the worker with the highest value.\n\n- If all available workers need to use a pill to complete the task, we select (and remove) the worker with the lowest value.\n\nAs the task value decreases, the number of workers who can complete it increases or remains the same, but never decreases. Therefore, we can use a deque to maintain all workers who can complete the task (with the use of pills). At this point, we either select (and remove) the worker at the front of the deque or the worker at the back. This reduces the time complexity of a single deletion operation from $O(\\log \\min(m, n))$ to $O(1)$, and the total time complexity becomes:\n\n$$\nO(n \\log n + m \\log m + \\min(m, n) \\log \\min(m, n)) = O(n \\log n + m \\log m)\n$$\n\n#### Implementation"
}