{
  "title": "Maximum Average Pass Ratio",
  "problem_id": "1917",
  "frontend_id": "1792",
  "difficulty": "Medium",
  "problem_slug": "maximum-average-pass-ratio",
  "topics": [
    "Array",
    "Greedy",
    "Heap (Priority Queue)"
  ],
  "description": "There is a school that has classes of students and each class will be having a final exam. You are given a 2D integer array classes, where classes[i] = [passi, totali]. You know beforehand that in the ith class, there are totali total students, but only passi number of students will pass the exam.\nYou are also given an integer extraStudents. There are another extraStudents brilliant students that are guaranteed to pass the exam of any class they are assigned to. You want to assign each of the extraStudents students to a class in a way that maximizes the average pass ratio across all the classes.\nThe pass ratio of a class is equal to the number of students of the class that will pass the exam divided by the total number of students of the class. The average pass ratio is the sum of pass ratios of all the classes divided by the number of the classes.\nReturn the maximum possible average pass ratio after assigning the extraStudents students. Answers within 10-5 of the actual answer will be accepted.\nExample 1:\nExample 2:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: classes = [[1,2],[3,5],[2,2]], extraStudents = 2\nOutput: 0.78333\nExplanation: You can assign the two extra students to the first class. The average pass ratio will be equal to (3/4 + 3/5 + 2/2) / 3 = 0.78333.",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input: classes = [[2,4],[3,9],[4,5],[2,10]], extraStudents = 4\nOutput: 0.53485",
      "images": []
    }
  ],
  "constraints": [
    "1 <= classes.length <= 105",
    "classes[i].length == 2",
    "1 <= passi <= totali <= 105",
    "1 <= extraStudents <= 105"
  ],
  "follow_ups": [],
  "hints": [
    "Pay attention to how much the pass ratio changes when you add a student to the class. If you keep adding students, what happens to the change in pass ratio? The more students you add to a class, the smaller the change in pass ratio becomes.",
    "Since the change in the pass ratio is always decreasing with the more students you add, then the very first student you add to each class is the one that makes the biggest change in the pass ratio.",
    "Because each class's pass ratio is weighted equally, it's always optimal to put the student in the class that makes the biggest change among all the other classes.",
    "Keep a max heap of the current class sizes and order them by the change in pass ratio. For each extra student, take the top of the heap, update the class size, and put it back in the heap."
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    double maxAverageRatio(vector<vector<int>>& classes, int extraStudents) {\n        \n    }\n};",
    "java": "class Solution {\n    public double maxAverageRatio(int[][] classes, int extraStudents) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def maxAverageRatio(self, classes, extraStudents):\n        \"\"\"\n        :type classes: List[List[int]]\n        :type extraStudents: int\n        :rtype: float\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def maxAverageRatio(self, classes: List[List[int]], extraStudents: int) -> float:\n        ",
    "c": "double maxAverageRatio(int** classes, int classesSize, int* classesColSize, int extraStudents) {\n    \n}",
    "csharp": "public class Solution {\n    public double MaxAverageRatio(int[][] classes, int extraStudents) {\n        \n    }\n}",
    "javascript": "/**\n * @param {number[][]} classes\n * @param {number} extraStudents\n * @return {number}\n */\nvar maxAverageRatio = function(classes, extraStudents) {\n    \n};",
    "typescript": "function maxAverageRatio(classes: number[][], extraStudents: number): number {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param Integer[][] $classes\n     * @param Integer $extraStudents\n     * @return Float\n     */\n    function maxAverageRatio($classes, $extraStudents) {\n        \n    }\n}",
    "swift": "class Solution {\n    func maxAverageRatio(_ classes: [[Int]], _ extraStudents: Int) -> Double {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun maxAverageRatio(classes: Array<IntArray>, extraStudents: Int): Double {\n        \n    }\n}",
    "dart": "class Solution {\n  double maxAverageRatio(List<List<int>> classes, int extraStudents) {\n    \n  }\n}",
    "golang": "func maxAverageRatio(classes [][]int, extraStudents int) float64 {\n    \n}",
    "ruby": "# @param {Integer[][]} classes\n# @param {Integer} extra_students\n# @return {Float}\ndef max_average_ratio(classes, extra_students)\n    \nend",
    "scala": "object Solution {\n    def maxAverageRatio(classes: Array[Array[Int]], extraStudents: Int): Double = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn max_average_ratio(classes: Vec<Vec<i32>>, extra_students: i32) -> f64 {\n        \n    }\n}",
    "racket": "(define/contract (max-average-ratio classes extraStudents)\n  (-> (listof (listof exact-integer?)) exact-integer? flonum?)\n  )",
    "erlang": "-spec max_average_ratio(Classes :: [[integer()]], ExtraStudents :: integer()) -> float().\nmax_average_ratio(Classes, ExtraStudents) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec max_average_ratio(classes :: [[integer]], extra_students :: integer) :: float\n  def max_average_ratio(classes, extra_students) do\n    \n  end\nend"
  },
  "solution": "[TOC]\n\n## Solution\n\n--- \n\n### Overview\n\nImagine a school where each class has students preparing for their final exams. Some students in each class are expected to pass, while others may fail. Now, imagine you have a few extra brilliant students who are guaranteed to pass, and you can assign them to any class. The goal is to determine the highest possible average pass ratio across all classes after distributing these extra students.\n\nThe pass ratio of a class is calculated as the number of passing students divided by the total number of students in that class. To find the highest possible average pass ratio, we should focus on assigning each extra student to the class where the addition of that student results in the highest relative increase in pass ratio. For example, adding a brilliant student to a class with fewer passing students can have a bigger impact than adding them to a class that already has a high pass ratio.\n\n##### Key Details:\n\n1. The pass ratio for a class is calculated as:  \n\n$$\n\\begin{aligned}\n   \\boxed{\\text{Pass Ratio} = \\frac{\\text{pass}_i}{\\text{total}_i} \\text{, where } \\text{pass}_i \\text{ is the number of passing students and } \\text{total}_i \\text{ is the total number of students.}}\n\\end{aligned}\n$$\n\n2. The average pass ratio is defined as:\n\n$$\n\\begin{aligned}\n    \\boxed{\\text{Average Pass Ratio} = \\frac{\\text{Sum of Pass Ratios of All Classes}}{\\text{Number of Classes}}}\n\\end{aligned}\n$$\n\nNow the question is, how is this greedy strategy working? This strategy picks the class that shows the largest increase in ratio when an extra student is added at each step. Why don't we pick the class with the largest increase in ratio when adding two extra students? Why is it guaranteed that the current step is optimal, as it seems to depend on the result of the previous step? Let's formally prove this in the proof below.Formal Proof (Click Here!)#### Formal Proof:\n\n$\n\\begin{aligned}\n    \\boxed{\\text{Optimality of Greedy Strategy in Distributing Extra Students}}\n\\end{aligned}\n$\n\n##### Definitions and Notation\n\n- Let $C$ be the set of classes.\n- For each class $c \\in C$, let:\n  - $p_c$ be the number of students who have passed.\n  - $t_c$ be the total number of students.\n  - The pass ratio of class $c$ is defined as $r_c = \\frac{p_c}{t_c}$.\n- Let $S$ be the total number of extra students to be distributed.\n- Let $\\Delta(c, k)$ be the increase in the pass ratio of class $c$ when $k$ extra students are added.\n\n##### Objective\n\nWe aim to maximize the average pass ratio across all classes after distributing the extra students. The average pass ratio is given by:\n\n$\n\\begin{aligned}\n    \\boxed{\\text{AvgPassRatio} = \\frac{1}{|C|} \\sum_{c \\in C} r_c}\n\\end{aligned}\n$\n\n##### Strategy\n\n1. **Calculate Gain Function**: Define a function $\\Delta(c, k)$ that computes the increase in the pass ratio of class $c$ when $k$ extra students are added.\n2. **Greedy Allocation**: At each step, add one extra student to the class $c$ that maximizes $\\Delta(c, 1)$.\n\n##### Proof\n\n**Lemma 1**: For each class $c$, the increase in the pass ratio $\\Delta(c, k)$ is decreasing as $k$ increases.\n\n**Proof**:\n\nConsider the pass ratio $r_c$ of class $c$ after adding $k$ extra students:\n\n$\n\\begin{aligned}\n    \\boxed{r_c = \\frac{p_c + k}{t_c + k}}\n\\end{aligned}\n$\n\nThe increase in the pass ratio when adding $k$ extra students is:\n\n$\n\\begin{aligned}\n    \\boxed{\\Delta(c, k) = \\frac{p_c + k}{t_c + k} - \\frac{p_c}{t_c}}\n\\end{aligned}\n$\n\nTo show that $\\Delta(c, k)$ is decreasing, consider the difference $\\Delta(c, k+1) - \\Delta(c, k)$:\n\n$\n\\begin{aligned}\n    \\boxed{\\Delta(c, k+1) = \\frac{p_c + k + 1}{t_c + k + 1} - \\frac{p_c}{t_c}}\n\\end{aligned}\n$\n\n$\n\\begin{aligned}\n    \\boxed{\\Delta(c, k) = \\frac{p_c + k}{t_c + k} - \\frac{p_c}{t_c}}\n\\end{aligned}\n$\n\nThe difference is:\n\n$\n\\begin{aligned}\n    \\boxed{\\Delta(c, k+1) - \\Delta(c, k) = \\left( \\frac{p_c + k + 1}{t_c + k + 1} - \\frac{p_c}{t_c} \\right) - \\left( \\frac{p_c + k}{t_c + k} - \\frac{p_c}{t_c} \\right)}\n\\end{aligned}\n$\n\nSimplifying, we get:\n\n$\n\\begin{aligned}\n    \\boxed{\\Delta(c, k+1) - \\Delta(c, k) = \\frac{p_c + k + 1}{t_c + k + 1} - \\frac{p_c + k}{t_c + k}}\n\\end{aligned}\n$\n\nThis expression is always non-positive because the pass ratio $r_c$ is a concave function of $k$ (since the derivative of $r_c$ with respect to $k$: $\\frac{p_c - t_c}{(t_c + k)^2}$ is decreasing). Therefore, $\\Delta(c, k)$ is decreasing as $k$ increases.\n\n**Lemma 2**: The best local option (adding one extra student to the class with the highest $\\Delta(c, 1)$) is always the best.\n\n**Proof**:\n\nAssume for contradiction that there exists a better strategy that does not always add one extra student to the class with the highest $\\Delta(c, 1)$. Let $c_1$ be the class with the highest $\\Delta(c, 1)$ at some step, and let $c_2$ be another class chosen by the alternative strategy.\n\n- Let $\\Delta(c_1, 1) = \\delta_1$ and $\\Delta(c_2, 1) = \\delta_2$.\n- By definition, $\\delta_1 \\geq \\delta_2$.\n\nIf we add one extra student to $c_1$, the immediate gain is $\\delta_1$. If we add one extra student to $c_2$, the immediate gain is $\\delta_2$. Since $\\delta_1 \\geq \\delta_2$, the immediate gain is maximized by adding the student to $c_1$. This contradicts the assumption that there exists a better strategy. Therefore, the greedy strategy is optimal at each step.\n\n**Lemma 3**: It is a loss if we don't take the best local option.\n\n**Proof**:\n\nIf we do not take the best local option (adding one extra student to the class with the highest $\\Delta(c, 1)$), we are choosing a class with a lower $\\Delta(c, 1)$. By Lemma 1, the increase in the pass ratio is decreasing as we add more students. Therefore, not taking the best local option results in a smaller increase in the pass ratio, which is a loss.\n\n**Theorem**: The described greedy algorithm maximizes the average pass ratio after distributing the extra students.\n\n**Proof**:\n\nBy Lemma 1, the increase in the pass ratio $\\Delta(c, k)$ is decreasing as $k$ increases. By Lemma 2, the best local option (adding one extra student to the class with the highest $\\Delta(c, 1)$) is always the best. By Lemma 3, it is a loss if we don't take the best local option. Therefore, the greedy algorithm systematically optimizes the overall pass ratio by focusing on the class that yields the highest immediate gain at each step.\n\nThus, the final average pass ratio computed by the algorithm is the maximum possible average pass ratio achievable with the given number of extra students.---\n\n### Approach 1: Brute Force (Time Limit Exceeded Error)\n\n#### Intuition\n\nSo, from what we've gathered, our main goal is to maximize the overall pass rate across all classes by strategically adding a set number of extra students. To do this, we need to figure out where each extra student will make the biggest difference in terms of improving the pass rate. This means we need to evaluate how much each class's pass rate would improve if we added just one more student.\n\nFirst off, we calculate the current pass rate for each class. This is simply the ratio of students who passed to the total number of students in that class. \n\nOnce we have these ratios, we can start looking at each class one by one and see how much the pass rate would go up if we added one student. By comparing these improvements across all classes, we can identify which class would benefit the most from an extra student. This way, we make sure that each extra student is placed where they'll have the greatest impact on the overall pass rate.\n\nAfter placing a student in the class that benefits the most, we update that class's pass rate and repeat the process until we've distributed all the extra students. \n\nFinally, once we've updated all the pass rates, we calculate the average pass rate across all classes.\n\nHowever, given that there can be up to 100,000 classes and 100,000 extra students, this approach will result in a Time Limit Exceeded (TLE) error.\n\n#### Algorithm\n\n- Initialize a `passRatios` array to store the initial pass ratio for each class.\n  - For each class in `classes`, compute the ratio of passed students to total students and store it in `passRatios`.\n\n- While `extraStudents` is greater than zero:\n  - Decrement `extraStudents` by 1.\n  - Initialize an `updatedRatios` array to store the pass ratios if an extra student is added to each class.\n    - For each class in `classes`, calculate the new ratio of passed students to total students after adding one student and store it in `updatedRatios`.\n  - Find the class that gains the most from an extra student:\n    - Initialize `bestClassIndex` to 0 and `maximumGain` to 0.\n    - For each class, compute the gain in the pass ratio by subtracting the current ratio from the updated ratio.\n    - If the gain is greater than `maximumGain`, update `bestClassIndex` and `maximumGain` accordingly.\n  - Update the selected class by incrementing its passed students and total students.\n  - Update `passRatios` with the new ratio for the selected class.\n\n- Initialize `totalPassRatio` to 0.\n  - Sum up all the pass ratios from `passRatios`.\n\n- Return the average pass ratio by dividing `totalPassRatio` by the number of classes.\n\n#### Implementation#### Complexity Analysis\n\nLet $n$ be the number of classes in the `classes` array and $k$ be the number of extra students.\n\n- Time complexity: $O(k \\cdot n)$\n\n    The outer loop runs $k$ times (once for each extra student).\n\n    Inside the loop, we have two main operations:\n        1. Calculating the updated pass ratios for all classes: This involves iterating over all $n$ classes, resulting in $O(n)$ time.\n        2. Finding the class with the maximum gain: This involves another iteration over all $n$ classes, resulting in $O(n)$ time.\n    \n    Therefore, the total time complexity is $O(k \\cdot n)$.\n\n- Space complexity: $O(n)$\n\n    We use a array `passRatios` of size $n$ to store the pass ratios of all classes. Additionally, we use a temporary array `updatedRatios` of size $n$ to store the updated pass ratios. The space complexity is dominated by these two arrays, resulting in $O(n)$ space.\n\n---\n\n### Approach 2: Priority Queue\n\n#### Intuition\n\nIn Approach 1, we used an array and maintained a tracking variable, `maximumGain`, to record the maximum difference between the new and old pass ratios. However, this approach resulted in a TLE due to the extra loop used to find the maximum difference. To optimize this, we can eliminate the loop by using a priority queue.\n\nFirst, we need a clear way to measure improvement. We create a lambda function called `calculateGain` to compute how much the pass ratio of a class would increase if an extra student were added. This provides a consistent metric to evaluate and compare the potential impact on different classes.\n\nNext, we build a max heap. Each class is represented by a tuple containing its negative gain (to simulate a max heap using Python's default min heap), along with its current number of passed and total students. This ensures that the class with the highest gain can always be retrieved efficiently.\n\nWe then distribute the extra students iteratively. At each step, we pop the class with the highest potential gain from the heap. We simulate the addition of one extra student to this class, updating its number of passed and total students. We then recalculate its gain and push the updated class back into the heap, allowing us to continuously adjust to the changing gains of each class as students are allocated.\n\nAfter all extra students are distributed, we compute the final result. By popping all classes from the heap and summing their current pass ratios, we calculate the total pass ratio. Dividing this sum by the number of classes gives us the average pass ratio.\n\n#### Algorithm\n\n- Define a lambda function `calculateGain` to compute the gain in pass ratio by adding an extra student to a class.\n\n- Initialize a max heap (`maxHeap`) to store tuples of the form `(-gain, {passes, totalStudents})` ; The negative gain ensures the largest gain is at the top of the heap.\n  - For each class in `classes`, calculate the gain using `calculateGain` and push the tuple into `maxHeap`.\n\n- While there are `extraStudents` to distribute:\n  - Decrement `extraStudents` by 1.\n  - Pop the class with the maximum gain from `maxHeap`.\n  - Extract `passes` and `totalStudents` of the class.\n  - Update the class with one additional pass and one additional total student.\n  - Recalculate the gain for this updated class and push the new tuple back into `maxHeap`.\n\n- Initialize `totalPassRatio` to 0 for calculating the overall pass ratio.\n  - While `maxHeap` is not empty, pop each class and add its pass ratio (`passes / totalStudents`) to `totalPassRatio`.\n\n- Return the final average pass ratio by dividing `totalPassRatio` by the number of classes.\n\n#### Implementation#### Complexity Analysis\n\nLet $n$ be the number of classes in the `classes` array and $k$ be the number of extra students.\n\n- Time complexity: $O(k \\cdot \\log(n) + n)$\n\n    Building the max heap: Inserting each class into the max heap takes $O(\\log n)$ time per insertion, and since there are $n$ classes, this step takes $O(n \\log n)$ time.\n    - Distributing extra students: Each insertion and removal from the max heap takes $O(\\log n)$ time. Since we perform this operation $k \\cdot$ times, this step takes $O(k \\cdot \\log n)$ time.\n    - Calculating the final average pass ratio: This involves iterating through the heap, which takes $O(n \\log n)$ time in the worst case.\n\n    Overall, the dominant factor is the initial heap construction and the distribution of extra students, leading to a time complexity of $O(k \\log n + n \\log n) = O(k \\cdot \\log(n) + n)$.\n\n> Note: When we create an array and directly heapify it, the process takes $O(n)$ time to convert the array into a valid heap. If we then perform $k$ additional operations (e.g., extracting or inserting elements), each operation takes $O(\\log(n))$, leading to a total complexity of $O(k \\cdot \\log(n) + n)$.\n\n- Space complexity: $O(n)$\n\n    The space complexity is determined by the max heap, which stores $n$ elements (one for each class). Additionally, the lambda function and other local variables consume constant space.\n\n    Therefore, the space complexity is $O(n)$.\n\n---"
}