{
  "title": "Contiguous Array",
  "problem_id": "525",
  "frontend_id": "525",
  "difficulty": "Medium",
  "problem_slug": "contiguous-array",
  "topics": [
    "Array",
    "Hash Table",
    "Prefix Sum"
  ],
  "description": "Given a binary array nums, return the maximum length of a contiguous subarray with an equal number of 0 and 1.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: nums = [0,1]\nOutput: 2\nExplanation: [0, 1] is the longest contiguous subarray with an equal number of 0 and 1.",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input: nums = [0,1,0]\nOutput: 2\nExplanation: [0, 1] (or [1, 0]) is a longest contiguous subarray with equal number of 0 and 1.",
      "images": []
    },
    {
      "example_num": 3,
      "example_text": "Input: nums = [0,1,1,1,1,1,0,0,0]\nOutput: 6\nExplanation: [1,1,1,0,0,0] is the longest contiguous subarray with equal number of 0 and 1.",
      "images": []
    }
  ],
  "constraints": [
    "1 <= nums.length <= 105",
    "nums[i] is either 0 or 1."
  ],
  "follow_ups": [],
  "hints": [],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    int findMaxLength(vector<int>& nums) {\n        \n    }\n};",
    "java": "class Solution {\n    public int findMaxLength(int[] nums) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def findMaxLength(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def findMaxLength(self, nums: List[int]) -> int:\n        ",
    "c": "int findMaxLength(int* nums, int numsSize) {\n    \n}",
    "csharp": "public class Solution {\n    public int FindMaxLength(int[] nums) {\n        \n    }\n}",
    "javascript": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar findMaxLength = function(nums) {\n    \n};",
    "typescript": "function findMaxLength(nums: number[]): number {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @return Integer\n     */\n    function findMaxLength($nums) {\n        \n    }\n}",
    "swift": "class Solution {\n    func findMaxLength(_ nums: [Int]) -> Int {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun findMaxLength(nums: IntArray): Int {\n        \n    }\n}",
    "dart": "class Solution {\n  int findMaxLength(List<int> nums) {\n    \n  }\n}",
    "golang": "func findMaxLength(nums []int) int {\n    \n}",
    "ruby": "# @param {Integer[]} nums\n# @return {Integer}\ndef find_max_length(nums)\n    \nend",
    "scala": "object Solution {\n    def findMaxLength(nums: Array[Int]): Int = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn find_max_length(nums: Vec<i32>) -> i32 {\n        \n    }\n}",
    "racket": "(define/contract (find-max-length nums)\n  (-> (listof exact-integer?) exact-integer?)\n  )",
    "erlang": "-spec find_max_length(Nums :: [integer()]) -> integer().\nfind_max_length(Nums) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec find_max_length(nums :: [integer]) :: integer\n  def find_max_length(nums) do\n    \n  end\nend"
  },
  "solution": "[TOC]\n\n## Solution\n\n---\n### Approach #1 Brute Force [Time Limit Exceeded]\n\n#### Algorithm\n\nThe brute force approach is really simple. We consider every possible subarray within the given array and count the number of zeros and ones in each subarray. Then, we find out the maximum size subarray with equal no. of zeros and ones out of them.\n\n#### Implementation#### Complexity Analysis\n\n* Time complexity : $$O(n^2)$$. We consider every possible subarray by traversing over the complete array for every start point possible.\n\n* Space complexity : $$O(1)$$. Only two variables $$zeroes$$ and $$ones$$ are required.\n\n---\n\n### Approach #2 Using Hash Map [Accepted]\n\n#### Algorithm\n\nImagine a `count` variable, which is used to store the relative number of ones and zeros encountered so far while traversing the array. The `count` variable is incremented by one for every $$\\text{1}$$ encountered and the same is decremented by one for every $$\\text{0}$$ encountered.\n\nWe start traversing the array from the beginning. If at any moment, the $$count$$ becomes zero, it implies that we've encountered an equal number of zeros and ones from the beginning till the current index of the array($$i$$). Not only this, another point to be noted is that if we encounter the same $$count$$ twice (for any value, not just 0) while traversing the array, it means that the number of zeros and ones are equal between the indices corresponding to the equal $$count$$ values. The following figure illustrates the observation for the sequence `[0 0 1 0 0 0 1 1]`:\n\n![Contiguous_Array](../Figures/535_Contiguous_Array.PNG)\n\nIn the above figure, the subarrays between (A,B), (B,C), and (A,C) (lying between indices corresponding to $$count = -2$$) have an equal number of zeros and ones.\n\nAnother point to be noted is that the largest subarray is the one between the points (A, C). Thus, if we keep a track of the indices corresponding to the same $$count$$ values that lie farthest apart, we can determine the size of the largest subarray with equal no. of zeros and ones easily.\n\nWe can use a hash map that maps values of `count` to the first index where that `count` was seen. We maintain the value of `count` and at each index, if we have seen the same value of `count` before, it means the subarray starting from where we saw that value of `count` and ending at the current index has an equal number of 0s and 1s. Otherwise, we put `count` in the map for future iterations.\n\nThe following animation depicts the process:!?!../Documents/525_Contiguous_Array.json:1000,563!?!\n\n#### Implementation#### Complexity Analysis\n\n* Time complexity : $$O(n)$$. The entire array is traversed only once.\n\n* Space complexity : $$O(n)$$. Maximum size of the HashMap $$map$$ will be $$\\text{n}$$, if all the elements are either 1 or 0."
}