{
  "title": "Find the City With the Smallest Number of Neighbors at a Threshold Distance",
  "problem_id": "1456",
  "frontend_id": "1334",
  "difficulty": "Medium",
  "problem_slug": "find-the-city-with-the-smallest-number-of-neighbors-at-a-threshold-distance",
  "topics": [
    "Dynamic Programming",
    "Graph",
    "Shortest Path"
  ],
  "description": "There are n cities numbered from 0 to n-1. Given the array edges where edges[i] = [fromi, toi, weighti] represents a bidirectional and weighted edge between cities fromi and toi, and given the integer distanceThreshold.\nReturn the city with the smallest number of cities that are reachable through some path and whose distance is at most distanceThreshold, If there are multiple such cities, return the city with the greatest number.\nNotice that the distance of a path connecting cities i and j is equal to the sum of the edges' weights along that path.\nExample 1:\nExample 2:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: n = 4, edges = [[0,1,3],[1,2,1],[1,3,4],[2,3,1]], distanceThreshold = 4\nOutput: 3\nExplanation: The figure above describes the graph. \nThe neighboring cities at a distanceThreshold = 4 for each city are:\nCity 0 -> [City 1, City 2] \nCity 1 -> [City 0, City 2, City 3] \nCity 2 -> [City 0, City 1, City 3] \nCity 3 -> [City 1, City 2] \nCities 0 and 3 have 2 neighboring cities at a distanceThreshold = 4, but we have to return city 3 since it has the greatest number.",
      "images": [
        "https://assets.leetcode.com/uploads/2024/08/23/problem1334example1.png"
      ]
    },
    {
      "example_num": 2,
      "example_text": "Input: n = 5, edges = [[0,1,2],[0,4,8],[1,2,3],[1,4,2],[2,3,1],[3,4,1]], distanceThreshold = 2\nOutput: 0\nExplanation: The figure above describes the graph. \nThe neighboring cities at a distanceThreshold = 2 for each city are:\nCity 0 -> [City 1] \nCity 1 -> [City 0, City 4] \nCity 2 -> [City 3, City 4] \nCity 3 -> [City 2, City 4]\nCity 4 -> [City 1, City 2, City 3] \nThe city 0 has 1 neighboring city at a distanceThreshold = 2.",
      "images": [
        "https://assets.leetcode.com/uploads/2024/08/23/problem1334example0.png"
      ]
    }
  ],
  "constraints": [
    "2 <= n <= 100",
    "1 <= edges.length <= n * (n - 1) / 2",
    "edges[i].length == 3",
    "0 <= fromi < toi < n",
    "1 <= weighti, distanceThreshold <= 10^4",
    "All pairs (fromi, toi) are distinct."
  ],
  "follow_ups": [],
  "hints": [
    "Use Floyd-Warshall's algorithm to compute any-point to any-point distances. (Or can also do Dijkstra from every node due to the weights are non-negative).",
    "For each city calculate the number of reachable cities within the threshold, then search for the optimal city."
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    int findTheCity(int n, vector<vector<int>>& edges, int distanceThreshold) {\n        \n    }\n};",
    "java": "class Solution {\n    public int findTheCity(int n, int[][] edges, int distanceThreshold) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def findTheCity(self, n, edges, distanceThreshold):\n        \"\"\"\n        :type n: int\n        :type edges: List[List[int]]\n        :type distanceThreshold: int\n        :rtype: int\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def findTheCity(self, n: int, edges: List[List[int]], distanceThreshold: int) -> int:\n        ",
    "c": "int findTheCity(int n, int** edges, int edgesSize, int* edgesColSize, int distanceThreshold) {\n    \n}",
    "csharp": "public class Solution {\n    public int FindTheCity(int n, int[][] edges, int distanceThreshold) {\n        \n    }\n}",
    "javascript": "/**\n * @param {number} n\n * @param {number[][]} edges\n * @param {number} distanceThreshold\n * @return {number}\n */\nvar findTheCity = function(n, edges, distanceThreshold) {\n    \n};",
    "typescript": "function findTheCity(n: number, edges: number[][], distanceThreshold: number): number {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param Integer $n\n     * @param Integer[][] $edges\n     * @param Integer $distanceThreshold\n     * @return Integer\n     */\n    function findTheCity($n, $edges, $distanceThreshold) {\n        \n    }\n}",
    "swift": "class Solution {\n    func findTheCity(_ n: Int, _ edges: [[Int]], _ distanceThreshold: Int) -> Int {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun findTheCity(n: Int, edges: Array<IntArray>, distanceThreshold: Int): Int {\n        \n    }\n}",
    "dart": "class Solution {\n  int findTheCity(int n, List<List<int>> edges, int distanceThreshold) {\n    \n  }\n}",
    "golang": "func findTheCity(n int, edges [][]int, distanceThreshold int) int {\n    \n}",
    "ruby": "# @param {Integer} n\n# @param {Integer[][]} edges\n# @param {Integer} distance_threshold\n# @return {Integer}\ndef find_the_city(n, edges, distance_threshold)\n    \nend",
    "scala": "object Solution {\n    def findTheCity(n: Int, edges: Array[Array[Int]], distanceThreshold: Int): Int = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn find_the_city(n: i32, edges: Vec<Vec<i32>>, distance_threshold: i32) -> i32 {\n        \n    }\n}",
    "racket": "(define/contract (find-the-city n edges distanceThreshold)\n  (-> exact-integer? (listof (listof exact-integer?)) exact-integer? exact-integer?)\n  )",
    "erlang": "-spec find_the_city(N :: integer(), Edges :: [[integer()]], DistanceThreshold :: integer()) -> integer().\nfind_the_city(N, Edges, DistanceThreshold) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec find_the_city(n :: integer, edges :: [[integer]], distance_threshold :: integer) :: integer\n  def find_the_city(n, edges, distance_threshold) do\n    \n  end\nend"
  },
  "solution": "[TOC]\n\n## Solution\n\n---\n\n### Overview\n\nImagine we're city planners analyzing the connectivity of cities in a region. We have:\n\n1. A network of `n` cities, numbered from `0` to `n-1`.\n2. A list of roads (edges) connecting these cities, with each road having a certain length (weight).\n3. A maximum travel distance (`distanceThreshold`) we're willing to consider.\n\nOur goal is to find the most isolated city — the one that can reach the fewest other cities within the `distanceThreshold`. If there's a tie, we choose the city with the highest number.\n\nThis is a graph problem where we calculate the reachability of each city within the given distance constraint and then select the optimal city accordingly.\n\nIn this article, we'll cover applications of four different graph algorithms to provide a comprehensive guide on the main traversal techniques used in [graphs for finding the shortest path](https://leetcode.com/explore/featured/card/graph/). If you are completely unaware of these algorithms, it is recommended to check them out first. Users can treat this as a template and refer back whenever they need clarification on shortest path algorithms. We will maintain a consistent main function throughout the article, changing only the specific algorithm logic. This article will help keep the focus on the dynamic parts that vary according to different algorithms, without overwhelming you with a wall of text.\n\nThe four algorithms we'll discuss are:\n\n1. Dijkstra's Algorithm\n2. Bellman-Ford Algorithm\n3. Shortest Path First Algorithm (SPFA)\n4. Floyd-Warshall Algorithm\n\n---\n\n### Approach 1: Dijkstra Algorithm\n\n#### Intuition\n\nDijkstra's algorithm is a graph search algorithm that finds the shortest paths between nodes in a graph. It is particularly effective for finding the shortest path from a single source node to all other nodes in graphs with non-negative edge weights. \n\nThe algorithm uses a greedy strategy, maintaining a set of vertices whose shortest distance from the source is known. At each step, it selects the vertex with the minimum distance value from the set of unvisited vertices.\n\nWe initialize distances to all vertices as infinity, except for the source vertex, which is set to zero. A priority queue is used to efficiently select the vertex with the minimum distance in each iteration, ensuring that the most promising paths are processed first and saving unnecessary computations.\n\nFor each neighbor of the current vertex, we calculate the distance through the current vertex. If this calculated distance is less than the previously known distance to that neighbor, the distance is updated — a process known as relaxation. Dijkstra's algorithm performs relaxation efficiently by always processing the most promising vertex next.\n\nAfter computing all shortest paths, we count reachable cities and select the most isolated ones.\n\nIn summary, the algorithm involves three main steps:\n\n1. **Initialization:** Set the distance to the source city as zero and all others as infinity. Use a priority queue to process cities based on their shortest distance.\n\n2. **Relaxation:** Extract the city with the smallest distance from the priority queue. Update the distances to their neighboring cities, adding them back to the queue if their distances are updated.\n\n3. **Result Computation:** Compute the shortest paths from each city. Count the number of reachable cities within the distance threshold. Choose the city with the fewest reachable cities or, in case of ties, the city with the greatest number.\n\n#### Algorithm\n \n- Create an adjacency list `adjacencyList` to store the graph.\n- Create a 2D array `shortestPathMatrix` with dimensions `n x n` to store shortest path distances between all pairs of cities.\n\n- For each city `i`:\n  - Set all distances in `shortestPathMatrix[i]` to the maximum integer value.\n  - Set the distance from the city `i` to itself (`shortestPathMatrix[i][i]`) to `0`.\n  - Initialize `adjacencyList[i]` as an empty list.\n\n- Iterate through each edge in `edges`:\n  - Extract `start`, `end`, and `weight` from each edge.\n  - Add `(end, weight)` to `adjacencyList[start]`.\n  - Add `(start, weight)` to `adjacencyList[end]`.\n\n- For each city `i`:\n  - Call `dijkstra(n, adjacencyList, shortestPathMatrix[i], i)`, where `i` is the source city and `shortestPathMatrix[i]` is the array that will hold the shortest path distances from city `i`.\n\n- Return the city identified by calling `getCityWithFewestReachable(n, shortestPathMatrix, distanceThreshold)` as having the fewest number of reachable cities within the given distance threshold.\n\n**`dijkstra(n, adjacencyList, shortestPathDistances, source)` Function:**\n\n- Use a priority queue to process nodes with the smallest distance first:\n  - Initialize the priority queue with the `source` city.\n  - Set all distances in `shortestPathDistances` to `Integer.MAX_VALUE`.\n  - Set the distance to the `source` city itself (`shortestPathDistances[source]`) to `0`.\n  \n- Process nodes in priority order:\n  - For each node, update distances to neighboring cities if a shorter path is found.\n\n**`getCityWithFewestReachable(n, shortestPathMatrix, distanceThreshold)` Function:**\n\n- Initialize `cityWithFewestReachable` to `-1` and `fewestReachableCount` to `n`.\n\n- For each city `i`:\n  - Count how many cities are reachable from the city `i` within the `distanceThreshold`:\n    - For each city `j`, check if `shortestPathMatrix[i][j]` is less than or equal to `distanceThreshold`.\n    - Increment `reachableCount` if city `j` is reachable within the threshold.\n\n  - Update `cityWithFewestReachable` if the current city `i` has fewer reachable cities compared to previously evaluated cities.\n\nThe algorithm is visualized below:\n\n!?!../Documents/1334/approach1.json:975,490!?!\n\n#### Implementation#### Complexity Analysis\n\nLet `n` refer to the number of cities, where the constraints are $2 <= n <= 100$, and `m` refer to the number of edges, with $1 <= edges.length <= \\frac{n \\cdot (n - 1)}{2}$. This means that `m` can be at most $\\frac{n \\cdot (n - 1)}{2}$, representing the maximum number of edges in an undirected graph where every city is connected to every other city with a unique edge. \n\n* Time complexity: $O(n^3 \\log n)$\n\n    For one source, Dijkstra's algorithm using a priority queue runs in $O(m \\cdot \\log n)$. With the maximum number of edges `m`, this becomes $O(n \\cdot (n - 1) / 2 \\cdot \\log n) = O(n^2 \\log n)$. Running Dijkstra's algorithm for each city (source), the overall time complexity is $O(n \\cdot n^2 \\log n) = O(n^3 \\log n)$.\n\n* Space complexity: $O(n^2)$\n\n    The space complexity is $O(n^2)$ for the `shortestPathMatrix` and $O(m + n)$ for the adjacency list and auxiliary data structures. Since $m = O(n^2)$ in the worst case, the overall space complexity simplifies to $O(n^2)$.\n\n---\n\n### Approach 2: Bellman-Ford Algorithm\n\n#### Intuition\n\nThe Bellman-Ford algorithm is a graph search algorithm that finds the shortest paths from a single source vertex to all other vertices in a weighted graph. Unlike Dijkstra's algorithm, Bellman-Ford can handle graphs with negative edge weights, making it more versatile but potentially slower.\n\nWe start by initializing distances to all vertices as infinity, except the source vertex, which is set to zero. This initialization represents our initial state of knowledge - we don't know any paths yet, so we assume they're infinitely long, except for the trivial path from a vertex to itself.\n\nNext, we perform the key operation, relaxation. For each edge in the graph, we check if the distance to the destination vertex can be improved by going through the source vertex of that edge. We repeat this relaxation step for V-1 times, where V is the number of vertices. In the worst case, where vertices form a line, it might take V-1 steps for changes to propagate from one end to the other.\n\nIn our implementation, we apply Bellman-Ford from each city as a source, giving us the shortest paths from every city to every other city. We could have used a single source and run Bellman-Ford once, then repeated for other sources, but running it independently for each source simplifies our code structure.\n\nAfter computing all shortest paths, we count how many cities are reachable from each city within the distance threshold, and then select the city that can reach the fewest others, breaking ties by choosing the higher-numbered city.\n\nThis approach guarantees correctness even with negative edge weights (though we don't have those here). Its simplicity makes Bellman-Ford a good algorithm, even if it's not the most efficient for our specific problem. We don't need to implement cycle detection or early termination, keeping our code straightforward at the cost of potentially unnecessary computations.\n\n#### Algorithm\n\n- Create a 2D array `shortestPathMatrix` with dimensions `n x n` to store shortest path distances between all pairs of cities.\n\n- For each city `i`:\n  - Call `bellmanFord(n, edges, shortestPathMatrix[i], i)`, where `i` is the source city and `shortestPathMatrix[i]` is the array that will hold the shortest path distances from the city `i`.\n\n- Return the city identified by calling `getCityWithFewestReachable(n, shortestPathMatrix, distanceThreshold)` as having the fewest number of reachable cities within the given distance threshold.\n\n**`bellmanFord(n, edges, shortestPathDistances, source)` Function:**\n\n- Initialize the distances from the `source` city:\n  - Set all distances in `shortestPathDistances` (initially set to `Integer.MAX_VALUE`, which represents `INF`) to a large value, indicating that the shortest distance is unknown at the start.\n  - Set the distance to the `source` city itself (`shortestPathDistances[source]`) to `0`.\n  \n- Relax edges up to `n-1` times:\n  - Iterate through all edges in `edges`:\n    - For each edge, extract `start`, `end`, and `weight`.\n    - Update the shortest path distances if a shorter path is found. Specifically:\n      - If the distance from `start` to `end` can be reduced by taking the current edge, update `shortestPathDistances[end]`.\n      - Similarly, update `shortestPathDistances[start]` if a shorter path is found through the `end` city.\n\n**`getCityWithFewestReachable(n, shortestPathMatrix, distanceThreshold)` Function:**\n\n- Initialize `cityWithFewestReachable` to `-1` and `fewestReachableCount` to `n`.\n\n- For each city `i`:\n  - Count how many cities are reachable from city `i` within the `distanceThreshold`:\n    - For each city `j`, check if `shortestPathMatrix[i][j]` is less than or equal to `distanceThreshold`.\n    - Increment `reachableCount` if city `j` is reachable within the threshold.\n\n  - Update `cityWithFewestReachable` if the current city `i` has fewer reachable cities compared to previously evaluated cities.\n\n#### Implementation\n\n> Note: We have introduced an `updated` flag to break out of the loop early (relaxation of edges) if no updates are made in an iteration. This optimization can reduce the number of iterations in some cases, addressing the Time Limit Exceeded (TLE) issues that occur when the algorithm is run without this adjustment in Python implementations. For those implementing this algorithm in C++ or Java, refer to the Python code to see how this simple `updated` flag has been integrated.#### Complexity Analysis\n\nLet `n` refer to the number of cities, where the constraints are $2 <= n <= 100$, and `m` refer to the number of edges, with $1 <= edges.length <= \\frac{n \\cdot (n - 1)}{2}$. This means that `m` can be at most $\\frac{n \\cdot (n - 1)}{2}$, representing the maximum number of edges in an undirected graph where every city is connected to every other city with a unique edge.  \n\n* Time complexity: $O(n^4)$\n\n    For one source, Bellman-Ford runs in $O(n \\cdot m)$, where `m` is the number of edges. In the worst case, `m` is $n \\cdot (n - 1) / 2$ (checkout the constraints), so the time complexity for one source becomes $O(n \\cdot (n \\cdot (n - 1) / 2)) = O(n^3)$. Since Bellman-Ford must be run for each city (source), the overall time complexity is $O(n \\cdot n^3) = O(n^4)$.\n\n* Space complexity: $O(n^2)$\n\n    The space complexity is dominated by the `shortestPathMatrix`, which stores the shortest path distances between each pair of cities. This matrix requires $O(n^2)$ space.\n\n---\n\n### Approach 3: Shortest Path First Algorithm (SPFA)\n\n#### Intuition\n\nThe Shortest Path Faster Algorithm (SPFA) is an improvement of the Bellman-Ford algorithm, designed to work faster on average, especially for sparse graphs, while still handling negative edge weights.\n\nSPFA starts similarly to Bellman-Ford by initializing all distances to infinity except for the source vertex. However, instead of blindly relaxing all edges in each iteration, SPFA uses a queue to keep track of which vertices need to be processed. We begin by adding the source vertex to the queue, then enter a loop that continues as long as the queue is not empty. In each iteration, we remove a vertex from the queue and relax its outgoing edges. If relaxing an edge updates the distance to a neighbor, we add that neighbor to the queue if it's not already there.\n\nThis queue-based approach allows SPFA to focus on the parts of the graph where improvements are still possible, potentially skipping large portions of the graph that won't lead to better paths. This targeted processing often makes SPFA faster than Bellman-Ford in practice.\n\nOur implementation includes a cycle detection mechanism. We keep track of how many times each vertex has been processed. If any vertex is processed more than V times (where V is the number of vertices), it indicates a negative weight cycle. While not strictly necessary for our problem (as we're guaranteed no negative weights), this showcases SPFA's ability to handle more general graphs and could be useful if the algorithm is repurposed for other problems.\n\nLike in previous approaches, we run SPFA from each city as a source to build our complete shortest path matrix. After computing all shortest paths, we perform the same counting and selection process to find the most isolated city.\n\nSPFA offers a middle ground between Bellman-Ford and Dijkstra's algorithm. It can handle negative edge weights like Bellman-Ford, but it's often much faster in practice, sometimes approaching the efficiency of Dijkstra's algorithm. It allows for more efficient processing, especially in graphs where only a few edges contribute to the shortest paths. However, it's worth noting that SPFA's worst-case time complexity is still O(VE) like Bellman-Ford, so it's not guaranteed to be faster in all cases.\n\n#### Algorithm\n \n- Create an adjacency list `adjacencyList` to store the graph.\n- Create a 2D array `shortestPathMatrix` with dimensions `n x n` to store shortest path distances between all pairs of cities.\n\n- For each city `i`:\n  - Set all distances in `shortestPathMatrix[i]` to `Integer.MAX_VALUE`.\n  - Set the distance from city `i` to itself (`shortestPathMatrix[i][i]`) to `0`.\n  - Initialize `adjacencyList[i]` as an empty list.\n\n- Iterate through each edge in `edges`:\n  - Extract `start`, `end`, and `weight` from each edge.\n  - Add `(end, weight)` to `adjacencyList[start]`.\n  - Add `(start, weight)` to `adjacencyList[end]`.\n\n- For each city `i`:\n  - Call `spfa(n, adjacencyList, shortestPathMatrix[i], i)`, where `i` is the source city and `shortestPathMatrix[i]` is the array that will hold the shortest path distances from city `i`.\n\n- Return the city identified by calling `getCityWithFewestReachable(n, shortestPathMatrix, distanceThreshold)` as having the fewest number of reachable cities within the given distance threshold.\n\n**`spfa(n, adjacencyList, shortestPathDistances, source)` Function:**\n\n- Use a queue to process nodes with updated shortest path distances:\n  - Initialize the queue with the `source` city.\n  - Set all distances in `shortestPathDistances` to `Integer.MAX_VALUE`.\n  - Set the distance to the `source` city itself (`shortestPathDistances[source]`) to `0`.\n  \n- Process nodes in queue:\n  - For each node, update distances to neighboring cities if a shorter path is found.\n  - Track the number of updates for each node.\n\n**`getCityWithFewestReachable(n, shortestPathMatrix, distanceThreshold)` Function:**\n\n- Initialize `cityWithFewestReachable` to `-1` and `fewestReachableCount` to `n`.\n\n- For each city `i`:\n  - Count how many cities are reachable from city `i` within the `distanceThreshold`:\n    - For each city `j`, check if `shortestPathMatrix[i][j]` is less than or equal to `distanceThreshold`.\n    - Increment `reachableCount` if city `j` is reachable within the threshold.\n  \n  - Update `cityWithFewestReachable` if the current city `i` has fewer reachable cities compared to previously evaluated cities.\n\n#### Implementation#### Complexity Analysis\n\nLet `n` refer to the number of cities, where the constraints are $2 <= n <= 100$, and `m` refer to the number of edges, with $1 <= edges.length <= \\frac{n \\cdot (n - 1)}{2}$. This means that `m` can be at most $\\frac{n \\cdot (n - 1)}{2}$, representing the maximum number of edges in an undirected graph where every city is connected to every other city with a unique edge.   \n\n* Time complexity: $O(n^4)$\n\n    The average time complexity of SPFA is $Θ(m)$ per source, which is $Θ(n^2)$ in the worst case per source. Running SPFA for each city (source), the overall average time complexity is $Θ(n \\cdot m) = Θ(n \\cdot n^2) = Θ(n^3)$, and the worst-case time complexity is $O(n \\cdot n^3) = O(n^4)$.\n\n* Space complexity: $O(n^2)$\n\n    The space complexity is $O(n^2)$ for the `shortestPathMatrix` and $O(m + n)$ for the adjacency list and auxiliary data structures. Since $m = O(n^2)$ in the worst case, the overall space complexity simplifies to $O(n^2)$.\n\n---\n\n\n### Approach 4: Floyd-Warshall Algorithm\n\n#### Intuition\n\nThe Floyd-Warshall algorithm finds the shortest paths in a weighted graph with positive or negative edge weights, as long as there are no negative cycles. Unlike algorithms that compute shortest paths from a single source, Floyd-Warshall computes the shortest paths between all pairs of vertices in the graph.\n\nThis algorithm takes a fundamentally different approach by computing all-pairs shortest paths in one go, rather than separately for each source. We start by initializing a distance matrix where direct connections between cities are filled with their edge weights, and all other distances are set to infinity. The distance from a city to itself is set to zero. This matrix serves both as our working space and our final result.\n\nThe core of the our algorithm involves three nested loops. The outermost loop iterates through all vertices, considering each as a potential intermediate point on the shortest path between every other pair of vertices. For each pair of vertices `(i, j)`, we check if passing through the current intermediate vertex `k` offers a shorter path than we currently know. If it does, we update the distance.\n\n\nThis iterative process gradually refines our shortest paths. By the time all vertices have been considered as intermediates, we have determined all shortest paths. After running Floyd-Warshall, our distance matrix contains all the information needed. We can directly count reachable cities for each source and select our answer, similar to previous approaches.\n\nFloyd-Warshall has several advantages: it solves the all-pairs shortest path problem directly with a simple and elegant one-pass implementation. For dense graphs, its time complexity of O(V^3) can be more efficient than running algorithms like Dijkstra’s or SPFA multiple times. However, for sparse graphs or when only a few sources are involved, other algorithms might be more efficient.\n\n#### Algorithm\n \n- Define `INF` as a large constant value (e.g., `1e9 + 7`) to represent an infinite distance for initial comparisons.\n- Create a 2D array `distanceMatrix` with dimensions `n x n` to store shortest path distances between all pairs of cities.\n\n- For each city `i`:\n  - Set all distances in `distanceMatrix[i]` to `INF`.\n  - Set the distance from city `i` to itself (`distanceMatrix[i][i]`) to `0`.\n\n- Iterate through each edge in `edges`:\n  - Extract `start`, `end`, and `weight` from each edge.\n  - Update `distanceMatrix[start][end]` and `distanceMatrix[end][start]` with `weight`.\n\n- Call `floyd(n, distanceMatrix)` to compute shortest paths between all pairs of cities.\n\n- Return the city identified by calling `getCityWithFewestReachable(n, distanceMatrix, distanceThreshold)` as having the fewest number of reachable cities within the given distance threshold.\n\n**`floyd(n, distanceMatrix)` Function:**\n\n- Use three nested loops to update the `distanceMatrix`:\n  - Outer Loop: Iterate over each intermediate city `k`.\n  - Middle Loop: Iterate over each source city `i`.\n  - Inner Loop: Iterate over each destination city `j`.\n  \n- For each combination of cities `(i, j)` and intermediate city `k`, update the distance if a shorter path is found through `k`:\n  - Condition: If `distanceMatrix[i][j] > distanceMatrix[i][k] + distanceMatrix[k][j]`, then update:\n    - Update: `distanceMatrix[i][j] = distanceMatrix[i][k] + distanceMatrix[k][j]`\n    - Explanation: This means that if the path from city `i` to city `j` is longer than the path from city `i` to city `k` plus the path from city `k` to city `j`, update the shortest distance from `i` to `j` to be the sum of distances `i` to `k` and `k` to `j`.\n\n**`getCityWithFewestReachable(n, shortestPathMatrix, distanceThreshold)` Function:**\n\n- Initialize `cityWithFewestReachable` to `-1` and `fewestReachableCount` to `n`.\n\n- For each city `i`:\n  - Count how many cities are reachable from the city `i` within the `distanceThreshold`:\n    - For each city `j`, check if `shortestPathMatrix[i][j]` is less than or equal to `distanceThreshold`.\n    - Increment `reachableCount` if city `j` is reachable within the threshold.\n  \n  - Update `cityWithFewestReachable` if the current city `i` has fewer reachable cities compared to previously evaluated cities.\n\nThe algorithm is visualized below:\n\n!?!../Documents/1334/approach4_re.json:980,485!?!\n\n#### Implementation#### Complexity Analysis\n\nLet `n` refer to the number of cities, where the constraints are $2 <= n <= 100$, and `m` refer to the number of edges, with $1 <= edges.length <= \\frac{n \\cdot (n - 1)}{2}$. This means that `m` can be at most $\\frac{n \\cdot (n - 1)}{2}$, representing the maximum number of edges in an undirected graph where every city is connected to every other city with a unique edge.   \n\n* Time complexity: $O(n^3)$\n\n    The Floyd-Warshall algorithm directly computes the shortest paths between all pairs of cities in $O(n^3)$, regardless of the number of edges. This comes from the three nested loops, each iterating `n` times.\n\n* Space complexity: $O(n^2)$\n\n    The space complexity is dominated by the `distanceMatrix`, which requires $O(n^2)$ space to store the shortest path distances between each pair of cities.\n\n---"
}