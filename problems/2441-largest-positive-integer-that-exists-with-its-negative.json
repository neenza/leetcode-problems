{
  "title": "Largest Positive Integer That Exists With Its Negative",
  "problem_id": "2524",
  "frontend_id": "2441",
  "difficulty": "Easy",
  "problem_slug": "largest-positive-integer-that-exists-with-its-negative",
  "topics": [
    "Array",
    "Hash Table",
    "Two Pointers",
    "Sorting"
  ],
  "description": "Given an integer array nums that does not contain any zeros, find the largest positive integer k such that -k also exists in the array.\nReturn the positive integer k. If there is no such integer, return -1.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: nums = [-1,2,-3,3]\nOutput: 3\nExplanation: 3 is the only valid k we can find in the array.",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input: nums = [-1,10,6,7,-7,1]\nOutput: 7\nExplanation: Both 1 and 7 have their corresponding negative values in the array. 7 has a larger value.",
      "images": []
    },
    {
      "example_num": 3,
      "example_text": "Input: nums = [-10,8,6,7,-2,-3]\nOutput: -1\nExplanation: There is no a single valid k, we return -1.",
      "images": []
    }
  ],
  "constraints": [
    "1 <= nums.length <= 1000",
    "-1000 <= nums[i] <= 1000",
    "nums[i] != 0"
  ],
  "follow_ups": [],
  "hints": [
    "What data structure can help you to determine if an element exists?",
    "Would a hash table help?"
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    int findMaxK(vector<int>& nums) {\n        \n    }\n};",
    "java": "class Solution {\n    public int findMaxK(int[] nums) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def findMaxK(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def findMaxK(self, nums: List[int]) -> int:\n        ",
    "c": "int findMaxK(int* nums, int numsSize) {\n    \n}",
    "csharp": "public class Solution {\n    public int FindMaxK(int[] nums) {\n        \n    }\n}",
    "javascript": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar findMaxK = function(nums) {\n    \n};",
    "typescript": "function findMaxK(nums: number[]): number {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @return Integer\n     */\n    function findMaxK($nums) {\n        \n    }\n}",
    "swift": "class Solution {\n    func findMaxK(_ nums: [Int]) -> Int {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun findMaxK(nums: IntArray): Int {\n        \n    }\n}",
    "dart": "class Solution {\n  int findMaxK(List<int> nums) {\n    \n  }\n}",
    "golang": "func findMaxK(nums []int) int {\n    \n}",
    "ruby": "# @param {Integer[]} nums\n# @return {Integer}\ndef find_max_k(nums)\n    \nend",
    "scala": "object Solution {\n    def findMaxK(nums: Array[Int]): Int = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn find_max_k(nums: Vec<i32>) -> i32 {\n        \n    }\n}",
    "racket": "(define/contract (find-max-k nums)\n  (-> (listof exact-integer?) exact-integer?)\n  )",
    "erlang": "-spec find_max_k(Nums :: [integer()]) -> integer().\nfind_max_k(Nums) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec find_max_k(nums :: [integer]) :: integer\n  def find_max_k(nums) do\n    \n  end\nend"
  },
  "solution": "[TOC]\n\n## Solution\n\n---\n\n### Overview\n\nWe need to find the largest value `k` in the given array `nums` such that `-k` is also present in the array. In other words, we must find the largest positive number in the array that has a corresponding negative counterpart. If there is no positive number with a negative counterpart, return `-1`.\n\n**Key Observations:**\n- The `nums` array does not contain any zeros.\n- The `nums` array has up to $1000$ elements, and each element can range from $-1000$ to $1000$\n\n---\n\n### Approach 1: Brute Force\n\n#### Intuition\n\nThe brute force approach is to iterate through the input array using a nested loop, checking every possible pair of numbers to see if they are additive inverses. Additive inverses sum to zero. We can check this by comparing one number to the negation of the other number. If they are equal, the positive number is a possible `k` value. We update the answer if this number is larger than the current answer.\n\n#### Algorithm\n\n- Initialize `ans` to -1 to ensure it starts lower than any valid absolute value, so the first encountered valid absolute value will always replace it.\n- For each `i` in `nums`, iterate through the `nums` array again for `j`.\n   - If `i` is equal to the negation of `j`, update `ans` to `max(ans, abs(i))`.\n- Return `ans`.\n\n#### Implementation#### Complexity Analysis\n\nLet $n$ be the size of the `nums` array.\n\n- Time complexity: $O(n^2)$\n\n    The nested loops iterate through the entire array for each element, resulting in a quadratic time complexity.\n\n    Let's consider the worst-case scenario where nums has $1000$ elements, and each element can range from $-1000$ to $1000$\n\n    - The outer loop will run $1000$ times (once for each element).\n    - For each iteration of the outer loop, the inner loop will run another $1000$ times (once for each element).\n    - This results in a total of $1000 \\cdot 1000 = 1,000,000$ iterations of the inner loop.\n\n    For this problem, the brute force solution is accepted.\n\n- Space complexity: $O(1)$\n\n    The algorithm only uses a constant amount of extra space to store the answer.\n \n---\n\n### Approach 2: Two Pointer\n\n#### Intuition\n\nThe key observation is that if a pair of numbers sum to 0, they must have opposite signs.\n\nThis suggests that we can sort the input array first and then use a two-pointer approach to find pairs of numbers that sum to 0. \n\nSince the array is sorted, `nums[lo]` begins as the largest negative number in the array, and `nums[hi]`  starts as the largest positive value in the array. If `-nums[lo]` and `nums[hi]` are equal, then we have found the largest pair of numbers with opposite signs that sum to 0, so `nums[hi]` is the answer.\n\nThis is similar to the classic [two sum problem](https://leetcode.com/problems/two-sum/description/), but with the added constraint that the numbers must have opposite signs.\n\nThe following is an illustration demonstrating the two pointer approach:\n\n!?!../Documents/2441/twopointer.json:472,127!?!\n\n#### Algorithm\n \n- Sort the `nums` array in ascending order.\n- Initialize `lo` to 0 and `hi` to the last index of the `nums` array.\n- While `lo` is less than `hi`:\n   - If `-nums[lo]` is equal to `nums[hi]`, return `nums[hi]`.\n   - If `-nums[lo]` is greater than `nums[hi]`, increment `lo`.\n   - If `-nums[lo]` is less than `nums[hi]`, decrement `hi`.\n- If the loop completes without finding a matching pair, return -1.\n\n#### Implementation#### Complexity Analysis\n\nLet $n$ be the size of the `nums` array.\n\n* Time complexity: $O(n \\cdot \\log n)$\n\n    The sorting step takes $O(n \\cdot \\log n)$ time. The while loop will process each element in `nums` at most once, so this step takes $O(n)$. The sorting step dominates the time complexity, with the two-pointer step being linear.\n\n* Space complexity: $O(n)$ or $O(\\log n)$\n\n    The algorithm only uses a constant amount of extra space to store the pointers.\n\n    Some extra space is used when we sort the `nums` in place. The space complexity of the sorting algorithms depends on the programming language.\n\n    - In Python, the `sort` method sorts a list using the Timsort algorithm which is a combination of Merge Sort and Insertion Sort and has $O(n)$ additional space.\n    - In C++, the `sort()` function is implemented as a hybrid of Quick Sort, Heap Sort, and Insertion Sort, with a worst-case space complexity of $O(\\log n)$.\n    - In Java, `Arrays.sort()` is implemented using a variant of the Quick Sort algorithm which has a space complexity of $O(\\log n)$ for sorting two arrays.\n\n---\n\n### Approach 3: Two Pass Hash Set\n\n#### Intuition\n\nIn the brute force approach, we sacrificed runtime to find the solution. The key insight from this approach was to use nested loops to search for the negative versions of positive numbers. If we search for values without traversing the entire range, we can eliminate the need for the nested loop. This implies the necessity of a data structure with constant lookup time ($O(1)$), allowing us to store all negative numbers encountered during the first pass.\n\nThe idea is to use a hash set to store all negative numbers encountered in the first pass. Then, in the second pass, we can check if the negatives of the positive numbers exist in the hash set and update the maximum value accordingly.\n\n#### Algorithm\n \n- Initialize a hash set named `neg` to store negative numbers.\n- Iterate over `nums` and add negative numbers to `neg`.\n- Initialize `ans` to -1.\n- Iterate over `nums`:\n   - For each `num`, check if `num` is greater than `ans` and if `-num` exists in the `neg` set.\n   - If the condition is true, update `ans` to `num`.\n- Return `ans`.\n\n#### Implementation#### Complexity Analysis\n\nLet $n$ be the size of the `nums` array.\n\n* Time complexity: $O(n)$\n\n    The algorithm uses a single loop to identify the negative numbers and another loop to find the maximum value `k`. The use of the hash set allows for constant-time lookups in the average case.\n\n* Space complexity: $O(n)$\n\n    The hash set used to store the negative numbers requires linear space.\n\n---\n\n### Approach 4: One Pass Hash Set\n\n#### Intuition\n\nIn the previous hash set approach, we used two passes: one to populate the `neg` set with negative numbers and another to determine the maximum value `k`.\n\nHowever, we can optimize this process to achieve the same goal with just a single iteration through the array. During this iteration, we can simultaneously check for the existence of the negation of each encountered number and update the maximum value `k` accordingly. This optimization allows us to reduce our approach to a one-pass solution.\n\nThe following is an illustration demonstrating the one pass hash set approach:\n\n!?!../Documents/2441/onepass_hashset.json:471,131!?!\n\n#### Algorithm\n \n- Initialize `ans` to -1.\n- Initialize a hash set `seen` to store the absolute values of the numbers.\n- Iterate over `nums`:\n   - For each `num`, get the absolute value `abs_num`.\n   - Check if `abs_num` is greater than `ans` and if the negation of `num` is present in the `seen` set.\n   - If the condition is true, update `ans` to `abs_num`.\n   - Add the current `num` to the `seen` set.\n- Return `ans`\n\n#### Implementation#### Complexity Analysis\n\nLet $n$ be the size of the `nums` array.\n\n* Time complexity: $O(n)$\n\n    The algorithm uses a single loop to process the array. Hash set lookups take constant time in the average case.\n \n* Space complexity: $O(n)$\n\n    The hash set used to store the encountered numbers requires linear space.\n\n---\n\n### Approach 5: One Pass Bitset\n\n#### Intuition\n\nGiven the range $-1000 <= nums[i] <= 1000$, we can track all numbers encountered using a bitset. For instance, we can set a bit if the number is negative and leave it unset if the number is positive.\n\nTo accomplish this, we use a bitset of size $1024$ to denote the existence of negative numbers encountered during the traversal of the input array. Initially, all bits in the bitset are set to `0`. Then, as we iterate through the array, we set the bit corresponding to the index of the negative value to `1` whenever a negative number is encountered.\n\nIn the subsequent pass, we check if the negatives of the positive numbers are present in the bitset. This operation is highly efficient, as bitsets offer constant-time access to individual bits.\n\nThis would be a two-pass solution, but we can further optimize it to use a single pass.\n\nWe'll track both negative and positive numbers encountered using a bitset array size of $2048$. Each index in the bitset corresponds to a number in the range $[-1024, 1023]$. According to the constraints, this range covers the possible values in the input array.\n\nDuring the traversal, we will check if the absolute value of the current number is greater than the current maximum value and if the negation of the current number has been encountered before. If both conditions are met, we will update `ans` to the absolute value of the current number.\n\nAfter checking the conditions, we need to mark the current number as encountered by setting the corresponding bit in the seen bitset. This can be done by marking the `num + 1024` value as `true`. Adding $1024$ to `num` maps both positive and negative numbers to non-negative indices in the bitset. This ensures that the indices used in the bitset cover the entire range of possible values encountered in the input array.\n\nThe following is an illustration demonstrating the one pass bitset approach:\n\n!?!../Documents/2441/onepass_bitset.json:672,262!?!\n\n#### Algorithm\n\n- Initialize `ans` to -1.\n- Initialize a bitset array of size 2048 named as `seen` to store the presence of the numbers (shifted by 1024 to handle negative numbers).\n- Iterate over `nums`:\n   - For each `num`, get the absolute value `abs_num`.\n   - Check if `abs_num` is greater than `ans` and if the negation of `num` (shifted by 1024) is present in the `seen` bitset.\n   - If the condition is true, update `ans = abs_num`.\n   - Set the bit at index `num + 1024` in the `seen` bitset to true.\n- Return `ans`.\n\n#### Implementation\n\n> Note: We have used a Set instead of the bitset function from the Bitset library. As of 9/9/2024, the Bitset library is available for installation from [Python's official repository (Link)](https://pypi.org/project/bitsets/0.4/) but is not supported in the LeetCode environment. The implementation code below simulates similar logic to what would be achieved with the bitset function, using a Set instead.Dropdown Click to See the Python Bitset Implementation:from bitarray import bitarray\nfrom typing import List\nclass Solution:\n    def findMaxK(self, nums: List[int]) -> int:\n        ans = -1\n        # Initialize a bitarray to keep track of seen numbers\n        bitset = bitarray(2 * 1024)  # Sufficient size for positive and negative offsets\n        bitset.setall(False)  # Set all bits to False initially\n\n        for num in nums:\n            abs_num = abs(num)\n            bit_index = abs_num + 1024  # Offset for handling both positive and negative values\n\n            # If the absolute value is greater than the current answer\n            # and its negation was seen before, update the answer\n            if abs_num > ans and bitset[-num + 1024]:\n                ans = abs_num\n\n            # Mark the current number as seen\n            bitset[bit_index] = True\n\n        return ans> As the Bitset library is not supported in the LeetCode environment, so the above dropdown implementation is provided for illustrative purposes.#### Complexity Analysis\n\nLet $n$ be the size of the `nums` array and $m$ be the size of the range of input values.\n\n* Time complexity: $O(n)$\n\n    The algorithm uses a single loop to process the array and perform constant-time lookups in the bitset.\n\n* Space complexity: $O(m)$\n\n    The bitset is size $2048$ in our implementation, so it can store data about $2000$ numbers, as the constraints specify that the numbers will be between $-1000$ and $1000$.\n\n---"
}