{
  "title": "Total Cost to Hire K Workers",
  "problem_id": "2553",
  "frontend_id": "2462",
  "difficulty": "Medium",
  "problem_slug": "total-cost-to-hire-k-workers",
  "topics": [
    "Array",
    "Two Pointers",
    "Heap (Priority Queue)",
    "Simulation"
  ],
  "description": "You are given a 0-indexed integer array costs where costs[i] is the cost of hiring the ith worker.\nYou are also given two integers k and candidates. We want to hire exactly k workers according to the following rules:\nReturn the total cost to hire exactly k workers.\nExample 1:\nExample 2:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: costs = [17,12,10,2,7,2,11,20,8], k = 3, candidates = 4\nOutput: 11\nExplanation: We hire 3 workers in total. The total cost is initially 0.\n- In the first hiring round we choose the worker from [17,12,10,2,7,2,11,20,8]. The lowest cost is 2, and we break the tie by the smallest index, which is 3. The total cost = 0 + 2 = 2.\n- In the second hiring round we choose the worker from [17,12,10,7,2,11,20,8]. The lowest cost is 2 (index 4). The total cost = 2 + 2 = 4.\n- In the third hiring round we choose the worker from [17,12,10,7,11,20,8]. The lowest cost is 7 (index 3). The total cost = 4 + 7 = 11. Notice that the worker with index 3 was common in the first and last four workers.\nThe total hiring cost is 11.",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input: costs = [1,2,4,1], k = 3, candidates = 3\nOutput: 4\nExplanation: We hire 3 workers in total. The total cost is initially 0.\n- In the first hiring round we choose the worker from [1,2,4,1]. The lowest cost is 1, and we break the tie by the smallest index, which is 0. The total cost = 0 + 1 = 1. Notice that workers with index 1 and 2 are common in the first and last 3 workers.\n- In the second hiring round we choose the worker from [2,4,1]. The lowest cost is 1 (index 2). The total cost = 1 + 1 = 2.\n- In the third hiring round there are less than three candidates. We choose the worker from the remaining workers [2,4]. The lowest cost is 2 (index 0). The total cost = 2 + 2 = 4.\nThe total hiring cost is 4.",
      "images": []
    }
  ],
  "constraints": [
    "1 <= costs.length <= 105",
    "1 <= costs[i] <= 105",
    "1 <= k, candidates <= costs.length"
  ],
  "follow_ups": [],
  "hints": [
    "Maintain two minheaps: one for the left and one for the right.",
    "Compare the top element from two heaps and remove the appropriate one.",
    "Add a new element to the heap and maintain its size as k."
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    long long totalCost(vector<int>& costs, int k, int candidates) {\n        \n    }\n};",
    "java": "class Solution {\n    public long totalCost(int[] costs, int k, int candidates) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def totalCost(self, costs, k, candidates):\n        \"\"\"\n        :type costs: List[int]\n        :type k: int\n        :type candidates: int\n        :rtype: int\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def totalCost(self, costs: List[int], k: int, candidates: int) -> int:\n        ",
    "c": "long long totalCost(int* costs, int costsSize, int k, int candidates) {\n    \n}",
    "csharp": "public class Solution {\n    public long TotalCost(int[] costs, int k, int candidates) {\n        \n    }\n}",
    "javascript": "/**\n * @param {number[]} costs\n * @param {number} k\n * @param {number} candidates\n * @return {number}\n */\nvar totalCost = function(costs, k, candidates) {\n    \n};",
    "typescript": "function totalCost(costs: number[], k: number, candidates: number): number {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param Integer[] $costs\n     * @param Integer $k\n     * @param Integer $candidates\n     * @return Integer\n     */\n    function totalCost($costs, $k, $candidates) {\n        \n    }\n}",
    "swift": "class Solution {\n    func totalCost(_ costs: [Int], _ k: Int, _ candidates: Int) -> Int {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun totalCost(costs: IntArray, k: Int, candidates: Int): Long {\n        \n    }\n}",
    "dart": "class Solution {\n  int totalCost(List<int> costs, int k, int candidates) {\n    \n  }\n}",
    "golang": "func totalCost(costs []int, k int, candidates int) int64 {\n    \n}",
    "ruby": "# @param {Integer[]} costs\n# @param {Integer} k\n# @param {Integer} candidates\n# @return {Integer}\ndef total_cost(costs, k, candidates)\n    \nend",
    "scala": "object Solution {\n    def totalCost(costs: Array[Int], k: Int, candidates: Int): Long = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn total_cost(costs: Vec<i32>, k: i32, candidates: i32) -> i64 {\n        \n    }\n}",
    "racket": "(define/contract (total-cost costs k candidates)\n  (-> (listof exact-integer?) exact-integer? exact-integer? exact-integer?)\n  )",
    "erlang": "-spec total_cost(Costs :: [integer()], K :: integer(), Candidates :: integer()) -> integer().\ntotal_cost(Costs, K, Candidates) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec total_cost(costs :: [integer], k :: integer, candidates :: integer) :: integer\n  def total_cost(costs, k, candidates) do\n    \n  end\nend"
  },
  "solution": "[TOC]\n\n## Solution\n\n--- \n\n### Approach 1: 2 Priority Queues\n\n#### Intuition   \n\n> If you are not familiar with the priority queue, please refer to our explore cards [Heaps Explore Card](https://leetcode.com/explore/featured/card/graph/619/depth-first-search-in-graph/). We will focus on the usage in this article and not the implementation details.\n\n\n**For the sake of brevity, let `m` represent the input integer `candidates` for the rest of the article.**\n\n\nTo begin with, we need to understand the problem requirements. In each of the `k` hiring rounds, we must hire a worker with the lowest cost (with the smallest index being a tiebreaker) based on the provided rules.\n\n\nWe have the option to select the worker with the lowest cost from either the first `m` candidates or the last `m` candidates from `costs`. Once we choose a worker from either of these sections, we remove the chosen worker from the array, which makes space for another worker to be in either the first or last `m` candidates. We continue to select the worker with the lowest cost, each time making space for another worker from `costs` to be into consideration. Because we need to repeatedly find the minimum cost, using a priority queue is the most appropriate approach to simulate this process.During each hiring session, our goal is to select the worker with the lowest cost. As mentioned above, after selecting a worker, a spot will open up for another worker to be among the first or last `m` candidates. As such, we need to distinguish between the first `m` candidates and the last `m` candidates. That way, when we choose a worker, we know if a spot was opened in the first `m` candidates or the last `m` candidates.\n\n\n\n![img](../Figures/2462/1.png)\n\nTo store the workers in two sections separately, we can use two priority queues, `head_workers` and `tail_workers`, where the worker with the lowest cost has the highest priority. \n\n\n![img](../Figures/2462/2.png)\n\n\nThroughout the process, after we hire a worker from a section, we need to add an additional candidate to this section. Therefore, we need two pointers, `next_head` and `next_tail`, that denotes the next worker to be added to the respective queues.\n\n![img](../Figures/2462/3.png)\n\n\nJust like in this situation shown in the picture, if two workers with the same cost appear at the top of both queues, we will hire the one from `head_workers`, since this worker has a smaller index compared with the other one from `tail_workers`. Afterwards, we need to refill `head_workers` with the worker at `next_head` to ensure that it still contains the first `m` unselected candidates.\n\n![img](../Figures/2462/4.png)\n\nWe add the worker `costs[next_head]` to `head_workers`, and then increment this pointer by 1, indicating the next unselected worker.\n\n![img](../Figures/2462/5.png)\n\n\nHowever, if we encounter the condition `next_tail < next_head`, it indicates that all the workers have been selected as candidates and there are no more workers outside the two queues. To avoid double counting, we should not add a worker to both queues or update either pointer. Therefore, we can simply move on without making any updates to the queues or pointers.\n\n![img](../Figures/2462/6.png)#### Algorithm\n\n1) Initialize two priority queues `head_workers` and `tail_workers` that store the first `m` workers and the last `m` workers, where the worker with the lowest cost has the highest priority.\n\n2) Set up two pointers `next_head = m`, `next_tail = n - m - 1` indicating the next worker to be added to two queues.\n\n3) Compare the top workers in both queues, and hire the one with the lowest cost, if both workers have the same cost, hire the worker from `head_workers`. Add the cost of this worker to the total cost.\n\n4) If `next_head <= next_tail`, we need to fill the queue with one worker:\n\n    - If the hired worker is from `head_workers`, we add the worker `costs[next_head]` to it and increment `next_head` by 1. \n    - If the hired worker is from `tail_workers`, we add the worker `costs[tail_head]` to it and decrement `tail_head` by 1.\n\n    Otherwise, skip this step.\n\n5) Repeat steps 3 and 4 `k` times.\n\n\n6) Return the total cost of all the hired workers.\n\n#### Implementation#### Complexity Analysis\n\nLet $$m$$ be the given integer `candidates`.\n\n\n* Time complexity: $$O((k + m) \\cdot\\log m)$$\n\n    - We need to initialize two priority queues of size $$m$$, which takes $$O(m \\cdot\\log m)$$ time.\n    - During the hiring rounds, we keep removing the top element from priority queues and adding new elements for up to $$k$$ times. Operations on a priority queue take amortized $$O(\\log m)$$ time. Thus this process takes $$O(k \\cdot\\log m)$$ time.\n    - Note: in Python, `heapq.heapify()` creates the priority queue in linear time. Therefore, in Python, the time complexity is $$O(m + k \\cdot \\log m)$$.\n\n    \n\n* Space complexity: $$O(m)$$\n\n    - We need to store the first $$m$$ and the last $$m$$ workers in two priority queues.---\n\n### Approach 2: 1 Priority Queue\n\n#### Intuition   \n\nWe can also implement the hiring process using a single priority queue. However, if we only store the costs of the candidates as before, we cannot sort them based on their index. To address this, we can add a new field to each worker to denote their section ID. For instance, we can assign `0` to the first `m` candidates and `1` to the last `m` candidates. This way, when two workers have the same cost, the priority queue can sort them based on their section IDs, and the worker with the smaller section ID will be hired. This approach fully meets the requirements given in the problem.\n\nAs illustrated in the following picture, we store each candidate in `pq`, in the format of `(cost, section ID)`. For example:\n- `costs[1] = 12` is from the head section and stored as `(12, 0)`.\n\n- `costs[9] = 2` is from the tail section and stored as `(2, 1)`.\n\n![img](../Figures/2462/7.png)\n\nWe will proceed with the hiring process for `k` rounds by hiring the top worker from `pq` each time. \n\n\nSimilar to the previous solution: \n> If we choose a worker from `head_workers`, we add the worker at `next_head` to `head_workers`. \n> If we choose a worker from `tail_workers`, we add the worker at `next_tail` to `tail_workers`.\n\n\nHere, we check whether the hired worker is from the first `m` candidates or the last `m` candidates by checking his section ID.\n> If the section ID is `0`, it means that the worker is from the first `m` candidates, we add the worker at `next_head` to `pq` with a section ID as `0`. \n> If the section ID is `1`, it means that the worker is from the last `m` candidates, we add the worker at `next_tail` to `pq` with a section ID as `1`. \n\n![img](../Figures/2462/8.png)#### Algorithm\n\n1) Create a priority queue `pq` and initialize it with the first `m` workers and last `m` workers from `costs`, along with their section IDs (0 for the first `m` workers, and 1 for the last `m` workers). The worker with the lowest cost has the highest priority.\n\n2) Initialize two pointers `next_head = m` and `next_tail = n - m - 1`, indicating the next worker to be added to `pq`.\n\n3) Pop the top worker with the lowest cost from `pq` and add the cost of this hired worker to the total cost.\n\n4) If `next_head >= next_tail`, we need to fill `pq` with the next worker:\n    - If the hired worker's section ID is `0`, we push the worker `costs[next_head]` to into `pq` and increment `next_head` by 1. \n    - If the hired worker's section ID is `1`, we push the worker `costs[next_tail]` to into `pq` and decrement `next_tail` by 1.\n\n    Otherwise, skip this step.\n\n5) Repeat steps 3 and 4 `k` times.\n\n\n6) Return the total cost of all the hired workers.\n\n#### Implementation#### Complexity Analysis\n\nFor the sake of brevity, let $$m$$ be the given integer `candidates`.\n\n* Time complexity: $$O((k + m) \\cdot\\log m)$$\n\n    - We need to initialize one priority queue `pq` of size up to $$2\\cdot m$$, which takes $$O(m \\cdot\\log m)$$ time.\n    - During `k` hiring rounds, we keep popping top elements from `pq` and pushing new elements into `pq` for up to $$k$$ times. Operations on a priority queue take amortized $$O(\\log m)$$ time. Thus this process takes $$O(k \\cdot\\log m)$$ time.\n    - Note: in Python, `heapq.heapify()` creates the priority queue in linear time. Therefore, in Python, the time complexity is $$O(m + k \\cdot \\log m)$$.\n\n    \n\n* Space complexity: $$O(m)$$\n\n    - We need to store at most $$2 \\cdot m$$ elements (the first $$m$$ and the last $$m$$ elements) of `costs` in the priority queue `pq`."
}