{
  "title": "Shortest Path to Get All Keys",
  "problem_id": "895",
  "frontend_id": "864",
  "difficulty": "Hard",
  "problem_slug": "shortest-path-to-get-all-keys",
  "topics": [
    "Array",
    "Bit Manipulation",
    "Breadth-First Search",
    "Matrix"
  ],
  "description": "You are given an m x n grid grid where:\nYou start at the starting point and one move consists of walking one space in one of the four cardinal directions. You cannot walk outside the grid, or walk into a wall.\nIf you walk over a key, you can pick it up and you cannot walk over a lock unless you have its corresponding key.\nFor some 1 <= k <= 6, there is exactly one lowercase and one uppercase letter of the first k letters of the English alphabet in the grid. This means that there is exactly one key for each lock, and one lock for each key; and also that the letters used to represent the keys and locks were chosen in the same order as the English alphabet.\nReturn the lowest number of moves to acquire all keys. If it is impossible, return -1.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: grid = [\"@.a..\",\"###.#\",\"b.A.B\"]\nOutput: 8\nExplanation: Note that the goal is to obtain all the keys not to open all the locks.",
      "images": [
        "https://assets.leetcode.com/uploads/2021/07/23/lc-keys2.jpg"
      ]
    },
    {
      "example_num": 2,
      "example_text": "Input: grid = [\"@..aA\",\"..B#.\",\"....b\"]\nOutput: 6",
      "images": [
        "https://assets.leetcode.com/uploads/2021/07/23/lc-key2.jpg"
      ]
    },
    {
      "example_num": 3,
      "example_text": "Input: grid = [\"@Aa\"]\nOutput: -1",
      "images": [
        "https://assets.leetcode.com/uploads/2021/07/23/lc-keys3.jpg"
      ]
    }
  ],
  "constraints": [
    "m == grid.length",
    "n == grid[i].length",
    "1 <= m, n <= 30",
    "grid[i][j] is either an English letter, '.', '#', or '@'.",
    "There is exactly one '@' in the grid.",
    "The number of keys in the grid is in the range [1, 6].",
    "Each key in the grid is unique.",
    "Each key in the grid has a matching lock."
  ],
  "follow_ups": [],
  "hints": [],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    int shortestPathAllKeys(vector<string>& grid) {\n        \n    }\n};",
    "java": "class Solution {\n    public int shortestPathAllKeys(String[] grid) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def shortestPathAllKeys(self, grid):\n        \"\"\"\n        :type grid: List[str]\n        :rtype: int\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def shortestPathAllKeys(self, grid: List[str]) -> int:\n        ",
    "c": "int shortestPathAllKeys(char** grid, int gridSize) {\n    \n}",
    "csharp": "public class Solution {\n    public int ShortestPathAllKeys(string[] grid) {\n        \n    }\n}",
    "javascript": "/**\n * @param {string[]} grid\n * @return {number}\n */\nvar shortestPathAllKeys = function(grid) {\n    \n};",
    "typescript": "function shortestPathAllKeys(grid: string[]): number {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param String[] $grid\n     * @return Integer\n     */\n    function shortestPathAllKeys($grid) {\n        \n    }\n}",
    "swift": "class Solution {\n    func shortestPathAllKeys(_ grid: [String]) -> Int {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun shortestPathAllKeys(grid: Array<String>): Int {\n        \n    }\n}",
    "dart": "class Solution {\n  int shortestPathAllKeys(List<String> grid) {\n    \n  }\n}",
    "golang": "func shortestPathAllKeys(grid []string) int {\n    \n}",
    "ruby": "# @param {String[]} grid\n# @return {Integer}\ndef shortest_path_all_keys(grid)\n    \nend",
    "scala": "object Solution {\n    def shortestPathAllKeys(grid: Array[String]): Int = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn shortest_path_all_keys(grid: Vec<String>) -> i32 {\n        \n    }\n}",
    "racket": "(define/contract (shortest-path-all-keys grid)\n  (-> (listof string?) exact-integer?)\n  )",
    "erlang": "-spec shortest_path_all_keys(Grid :: [unicode:unicode_binary()]) -> integer().\nshortest_path_all_keys(Grid) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec shortest_path_all_keys(grid :: [String.t]) :: integer\n  def shortest_path_all_keys(grid) do\n    \n  end\nend"
  },
  "solution": "[TOC]\n\n## Solution\n---\n### Approach 1: Brute Force + Permutations\n\n**Intuition and Algorithm**\n\nWe have to pick up the keys $$K$$ in some order, say $$K_{\\sigma_i}$$.\n\nFor each ordering, let's do a breadth first search to find the distance to the next key.\n\nFor example, if the keys are `'abcdef'`, then for each ordering such as `'bafedc'`, we will try to calculate the candidate distance from `'@' -> 'b' -> 'a' -> 'f' -> 'e' -> 'd' -> 'c'`.\n\nBetween each segment of our path (and corresponding breadth-first search), we should remember what keys we've picked up.  Keys that are picked up become part of a mask that helps us identify what locks we are allowed to walk through during the next breadth-first search.\n\nEach part of the algorithm is relatively straightforward, but the implementation in total can be quite challenging.  See the comments for more details.**Complexity Analysis**\n\n* Time Complexity:  $$O(R * C * \\mathcal{A} * \\mathcal{A}!)$$, where $$R, C$$ are the dimensions of the grid, and $$\\mathcal{A}$$ is the maximum number of keys ($$\\mathcal{A}$$ because it is the \"size of the alphabet\".)  Each `bfs` is performed up to $$\\mathcal{A} * \\mathcal{A}!$$ times.\n\n* Space Complexity:  $$O(R * C + \\mathcal{A}!)$$, the space for the `bfs` and to store the candidate key permutations.---\n### Approach 2: Points of Interest + Dijkstra\n\n**Intuition and Algorithm**\n\nClearly, we only really care about walking between points of interest: the keys, locks, and starting position.  We can use this insight to speed up our calculation.\n\nLet's make this intuition more formal: any walk can be decomposed into *primitive* segments, where each segment (between two points of interest) is primitive if and only if it doesn't touch any other point of interest in between.\n\nThen, we can calculate the distance (of a primitive segment) between any two points of interest, using a breadth first search.\n\nAfterwards, we have some graph (where each node refers to at most $$13$$ places, and at most $$2^6$$ states of keys).  We have a starting node (at `'@'` with no keys) and ending nodes (at anywhere with all keys.)  We also know all the costs to go from one node to another - each node has outdegree at most 13.  This shortest path problem is now ideal for using Dijkstra's algorithm.\n\nDijkstra's algorithm uses a priority queue to continually searches the path with the lowest cost to destination, so that when we reach the target, we know it must have been through the lowest cost path.  Refer to [this link](https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm) for more detail.\n\nAgain, each part of the algorithm is relatively straightforward (for those familiar with BFS and Dijkstra's algorithm), but the implementation in total can be quite challenging.**Complexity Analysis**\n\n* Time Complexity:  $$O(RC(2\\mathcal{A} + 1) + \\mathcal{E} \\log \\mathcal{N})$$, where $$R, C$$ are the dimensions of the grid, and $$\\mathcal{A}$$ is the maximum number of keys, $$\\mathcal{N} = (2\\mathcal{A} + 1) * 2^\\mathcal{A}$$ is the number of nodes when we perform Dijkstra's, and $$\\mathcal{E} = \\mathcal{N} * (2 \\mathcal{A} + 1)$$ is the maximum number of edges.\n\n* Space Complexity:  $$O(\\mathcal{N})$$."
}