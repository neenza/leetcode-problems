{
  "title": "Design Circular Deque",
  "problem_id": "859",
  "frontend_id": "641",
  "difficulty": "Medium",
  "problem_slug": "design-circular-deque",
  "topics": [
    "Array",
    "Linked List",
    "Design",
    "Queue"
  ],
  "description": "Design your implementation of the circular double-ended queue (deque).\nImplement the MyCircularDeque class:\nExample 1:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input\n[\"MyCircularDeque\", \"insertLast\", \"insertLast\", \"insertFront\", \"insertFront\", \"getRear\", \"isFull\", \"deleteLast\", \"insertFront\", \"getFront\"]\n[[3], [1], [2], [3], [4], [], [], [], [4], []]\nOutput\n[null, true, true, true, false, 2, true, true, true, 4]\n\nExplanation\nMyCircularDeque myCircularDeque = new MyCircularDeque(3);\nmyCircularDeque.insertLast(1);  // return True\nmyCircularDeque.insertLast(2);  // return True\nmyCircularDeque.insertFront(3); // return True\nmyCircularDeque.insertFront(4); // return False, the queue is full.\nmyCircularDeque.getRear();      // return 2\nmyCircularDeque.isFull();       // return True\nmyCircularDeque.deleteLast();   // return True\nmyCircularDeque.insertFront(4); // return True\nmyCircularDeque.getFront();     // return 4",
      "images": []
    }
  ],
  "constraints": [
    "1 <= k <= 1000",
    "0 <= value <= 1000",
    "At most 2000 calls will be made to insertFront, insertLast, deleteFront, deleteLast, getFront, getRear, isEmpty, isFull."
  ],
  "follow_ups": [],
  "hints": [],
  "code_snippets": {
    "cpp": "class MyCircularDeque {\npublic:\n    MyCircularDeque(int k) {\n        \n    }\n    \n    bool insertFront(int value) {\n        \n    }\n    \n    bool insertLast(int value) {\n        \n    }\n    \n    bool deleteFront() {\n        \n    }\n    \n    bool deleteLast() {\n        \n    }\n    \n    int getFront() {\n        \n    }\n    \n    int getRear() {\n        \n    }\n    \n    bool isEmpty() {\n        \n    }\n    \n    bool isFull() {\n        \n    }\n};\n\n/**\n * Your MyCircularDeque object will be instantiated and called as such:\n * MyCircularDeque* obj = new MyCircularDeque(k);\n * bool param_1 = obj->insertFront(value);\n * bool param_2 = obj->insertLast(value);\n * bool param_3 = obj->deleteFront();\n * bool param_4 = obj->deleteLast();\n * int param_5 = obj->getFront();\n * int param_6 = obj->getRear();\n * bool param_7 = obj->isEmpty();\n * bool param_8 = obj->isFull();\n */",
    "java": "class MyCircularDeque {\n\n    public MyCircularDeque(int k) {\n        \n    }\n    \n    public boolean insertFront(int value) {\n        \n    }\n    \n    public boolean insertLast(int value) {\n        \n    }\n    \n    public boolean deleteFront() {\n        \n    }\n    \n    public boolean deleteLast() {\n        \n    }\n    \n    public int getFront() {\n        \n    }\n    \n    public int getRear() {\n        \n    }\n    \n    public boolean isEmpty() {\n        \n    }\n    \n    public boolean isFull() {\n        \n    }\n}\n\n/**\n * Your MyCircularDeque object will be instantiated and called as such:\n * MyCircularDeque obj = new MyCircularDeque(k);\n * boolean param_1 = obj.insertFront(value);\n * boolean param_2 = obj.insertLast(value);\n * boolean param_3 = obj.deleteFront();\n * boolean param_4 = obj.deleteLast();\n * int param_5 = obj.getFront();\n * int param_6 = obj.getRear();\n * boolean param_7 = obj.isEmpty();\n * boolean param_8 = obj.isFull();\n */",
    "python": "class MyCircularDeque(object):\n\n    def __init__(self, k):\n        \"\"\"\n        :type k: int\n        \"\"\"\n        \n\n    def insertFront(self, value):\n        \"\"\"\n        :type value: int\n        :rtype: bool\n        \"\"\"\n        \n\n    def insertLast(self, value):\n        \"\"\"\n        :type value: int\n        :rtype: bool\n        \"\"\"\n        \n\n    def deleteFront(self):\n        \"\"\"\n        :rtype: bool\n        \"\"\"\n        \n\n    def deleteLast(self):\n        \"\"\"\n        :rtype: bool\n        \"\"\"\n        \n\n    def getFront(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        \n\n    def getRear(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        \n\n    def isEmpty(self):\n        \"\"\"\n        :rtype: bool\n        \"\"\"\n        \n\n    def isFull(self):\n        \"\"\"\n        :rtype: bool\n        \"\"\"\n        \n\n\n# Your MyCircularDeque object will be instantiated and called as such:\n# obj = MyCircularDeque(k)\n# param_1 = obj.insertFront(value)\n# param_2 = obj.insertLast(value)\n# param_3 = obj.deleteFront()\n# param_4 = obj.deleteLast()\n# param_5 = obj.getFront()\n# param_6 = obj.getRear()\n# param_7 = obj.isEmpty()\n# param_8 = obj.isFull()",
    "python3": "class MyCircularDeque:\n\n    def __init__(self, k: int):\n        \n\n    def insertFront(self, value: int) -> bool:\n        \n\n    def insertLast(self, value: int) -> bool:\n        \n\n    def deleteFront(self) -> bool:\n        \n\n    def deleteLast(self) -> bool:\n        \n\n    def getFront(self) -> int:\n        \n\n    def getRear(self) -> int:\n        \n\n    def isEmpty(self) -> bool:\n        \n\n    def isFull(self) -> bool:\n        \n\n\n# Your MyCircularDeque object will be instantiated and called as such:\n# obj = MyCircularDeque(k)\n# param_1 = obj.insertFront(value)\n# param_2 = obj.insertLast(value)\n# param_3 = obj.deleteFront()\n# param_4 = obj.deleteLast()\n# param_5 = obj.getFront()\n# param_6 = obj.getRear()\n# param_7 = obj.isEmpty()\n# param_8 = obj.isFull()",
    "c": "\n\n\ntypedef struct {\n    \n} MyCircularDeque;\n\n\nMyCircularDeque* myCircularDequeCreate(int k) {\n    \n}\n\nbool myCircularDequeInsertFront(MyCircularDeque* obj, int value) {\n    \n}\n\nbool myCircularDequeInsertLast(MyCircularDeque* obj, int value) {\n    \n}\n\nbool myCircularDequeDeleteFront(MyCircularDeque* obj) {\n    \n}\n\nbool myCircularDequeDeleteLast(MyCircularDeque* obj) {\n    \n}\n\nint myCircularDequeGetFront(MyCircularDeque* obj) {\n    \n}\n\nint myCircularDequeGetRear(MyCircularDeque* obj) {\n    \n}\n\nbool myCircularDequeIsEmpty(MyCircularDeque* obj) {\n    \n}\n\nbool myCircularDequeIsFull(MyCircularDeque* obj) {\n    \n}\n\nvoid myCircularDequeFree(MyCircularDeque* obj) {\n    \n}\n\n/**\n * Your MyCircularDeque struct will be instantiated and called as such:\n * MyCircularDeque* obj = myCircularDequeCreate(k);\n * bool param_1 = myCircularDequeInsertFront(obj, value);\n \n * bool param_2 = myCircularDequeInsertLast(obj, value);\n \n * bool param_3 = myCircularDequeDeleteFront(obj);\n \n * bool param_4 = myCircularDequeDeleteLast(obj);\n \n * int param_5 = myCircularDequeGetFront(obj);\n \n * int param_6 = myCircularDequeGetRear(obj);\n \n * bool param_7 = myCircularDequeIsEmpty(obj);\n \n * bool param_8 = myCircularDequeIsFull(obj);\n \n * myCircularDequeFree(obj);\n*/",
    "csharp": "public class MyCircularDeque {\n\n    public MyCircularDeque(int k) {\n        \n    }\n    \n    public bool InsertFront(int value) {\n        \n    }\n    \n    public bool InsertLast(int value) {\n        \n    }\n    \n    public bool DeleteFront() {\n        \n    }\n    \n    public bool DeleteLast() {\n        \n    }\n    \n    public int GetFront() {\n        \n    }\n    \n    public int GetRear() {\n        \n    }\n    \n    public bool IsEmpty() {\n        \n    }\n    \n    public bool IsFull() {\n        \n    }\n}\n\n/**\n * Your MyCircularDeque object will be instantiated and called as such:\n * MyCircularDeque obj = new MyCircularDeque(k);\n * bool param_1 = obj.InsertFront(value);\n * bool param_2 = obj.InsertLast(value);\n * bool param_3 = obj.DeleteFront();\n * bool param_4 = obj.DeleteLast();\n * int param_5 = obj.GetFront();\n * int param_6 = obj.GetRear();\n * bool param_7 = obj.IsEmpty();\n * bool param_8 = obj.IsFull();\n */",
    "javascript": "/**\n * @param {number} k\n */\nvar MyCircularDeque = function(k) {\n    \n};\n\n/** \n * @param {number} value\n * @return {boolean}\n */\nMyCircularDeque.prototype.insertFront = function(value) {\n    \n};\n\n/** \n * @param {number} value\n * @return {boolean}\n */\nMyCircularDeque.prototype.insertLast = function(value) {\n    \n};\n\n/**\n * @return {boolean}\n */\nMyCircularDeque.prototype.deleteFront = function() {\n    \n};\n\n/**\n * @return {boolean}\n */\nMyCircularDeque.prototype.deleteLast = function() {\n    \n};\n\n/**\n * @return {number}\n */\nMyCircularDeque.prototype.getFront = function() {\n    \n};\n\n/**\n * @return {number}\n */\nMyCircularDeque.prototype.getRear = function() {\n    \n};\n\n/**\n * @return {boolean}\n */\nMyCircularDeque.prototype.isEmpty = function() {\n    \n};\n\n/**\n * @return {boolean}\n */\nMyCircularDeque.prototype.isFull = function() {\n    \n};\n\n/** \n * Your MyCircularDeque object will be instantiated and called as such:\n * var obj = new MyCircularDeque(k)\n * var param_1 = obj.insertFront(value)\n * var param_2 = obj.insertLast(value)\n * var param_3 = obj.deleteFront()\n * var param_4 = obj.deleteLast()\n * var param_5 = obj.getFront()\n * var param_6 = obj.getRear()\n * var param_7 = obj.isEmpty()\n * var param_8 = obj.isFull()\n */",
    "typescript": "class MyCircularDeque {\n    constructor(k: number) {\n        \n    }\n\n    insertFront(value: number): boolean {\n        \n    }\n\n    insertLast(value: number): boolean {\n        \n    }\n\n    deleteFront(): boolean {\n        \n    }\n\n    deleteLast(): boolean {\n        \n    }\n\n    getFront(): number {\n        \n    }\n\n    getRear(): number {\n        \n    }\n\n    isEmpty(): boolean {\n        \n    }\n\n    isFull(): boolean {\n        \n    }\n}\n\n/**\n * Your MyCircularDeque object will be instantiated and called as such:\n * var obj = new MyCircularDeque(k)\n * var param_1 = obj.insertFront(value)\n * var param_2 = obj.insertLast(value)\n * var param_3 = obj.deleteFront()\n * var param_4 = obj.deleteLast()\n * var param_5 = obj.getFront()\n * var param_6 = obj.getRear()\n * var param_7 = obj.isEmpty()\n * var param_8 = obj.isFull()\n */",
    "php": "class MyCircularDeque {\n    /**\n     * @param Integer $k\n     */\n    function __construct($k) {\n        \n    }\n  \n    /**\n     * @param Integer $value\n     * @return Boolean\n     */\n    function insertFront($value) {\n        \n    }\n  \n    /**\n     * @param Integer $value\n     * @return Boolean\n     */\n    function insertLast($value) {\n        \n    }\n  \n    /**\n     * @return Boolean\n     */\n    function deleteFront() {\n        \n    }\n  \n    /**\n     * @return Boolean\n     */\n    function deleteLast() {\n        \n    }\n  \n    /**\n     * @return Integer\n     */\n    function getFront() {\n        \n    }\n  \n    /**\n     * @return Integer\n     */\n    function getRear() {\n        \n    }\n  \n    /**\n     * @return Boolean\n     */\n    function isEmpty() {\n        \n    }\n  \n    /**\n     * @return Boolean\n     */\n    function isFull() {\n        \n    }\n}\n\n/**\n * Your MyCircularDeque object will be instantiated and called as such:\n * $obj = MyCircularDeque($k);\n * $ret_1 = $obj->insertFront($value);\n * $ret_2 = $obj->insertLast($value);\n * $ret_3 = $obj->deleteFront();\n * $ret_4 = $obj->deleteLast();\n * $ret_5 = $obj->getFront();\n * $ret_6 = $obj->getRear();\n * $ret_7 = $obj->isEmpty();\n * $ret_8 = $obj->isFull();\n */",
    "swift": "\nclass MyCircularDeque {\n\n    init(_ k: Int) {\n        \n    }\n    \n    func insertFront(_ value: Int) -> Bool {\n        \n    }\n    \n    func insertLast(_ value: Int) -> Bool {\n        \n    }\n    \n    func deleteFront() -> Bool {\n        \n    }\n    \n    func deleteLast() -> Bool {\n        \n    }\n    \n    func getFront() -> Int {\n        \n    }\n    \n    func getRear() -> Int {\n        \n    }\n    \n    func isEmpty() -> Bool {\n        \n    }\n    \n    func isFull() -> Bool {\n        \n    }\n}\n\n/**\n * Your MyCircularDeque object will be instantiated and called as such:\n * let obj = MyCircularDeque(k)\n * let ret_1: Bool = obj.insertFront(value)\n * let ret_2: Bool = obj.insertLast(value)\n * let ret_3: Bool = obj.deleteFront()\n * let ret_4: Bool = obj.deleteLast()\n * let ret_5: Int = obj.getFront()\n * let ret_6: Int = obj.getRear()\n * let ret_7: Bool = obj.isEmpty()\n * let ret_8: Bool = obj.isFull()\n */",
    "kotlin": "class MyCircularDeque(k: Int) {\n\n    fun insertFront(value: Int): Boolean {\n        \n    }\n\n    fun insertLast(value: Int): Boolean {\n        \n    }\n\n    fun deleteFront(): Boolean {\n        \n    }\n\n    fun deleteLast(): Boolean {\n        \n    }\n\n    fun getFront(): Int {\n        \n    }\n\n    fun getRear(): Int {\n        \n    }\n\n    fun isEmpty(): Boolean {\n        \n    }\n\n    fun isFull(): Boolean {\n        \n    }\n\n}\n\n/**\n * Your MyCircularDeque object will be instantiated and called as such:\n * var obj = MyCircularDeque(k)\n * var param_1 = obj.insertFront(value)\n * var param_2 = obj.insertLast(value)\n * var param_3 = obj.deleteFront()\n * var param_4 = obj.deleteLast()\n * var param_5 = obj.getFront()\n * var param_6 = obj.getRear()\n * var param_7 = obj.isEmpty()\n * var param_8 = obj.isFull()\n */",
    "dart": "class MyCircularDeque {\n\n  MyCircularDeque(int k) {\n    \n  }\n  \n  bool insertFront(int value) {\n    \n  }\n  \n  bool insertLast(int value) {\n    \n  }\n  \n  bool deleteFront() {\n    \n  }\n  \n  bool deleteLast() {\n    \n  }\n  \n  int getFront() {\n    \n  }\n  \n  int getRear() {\n    \n  }\n  \n  bool isEmpty() {\n    \n  }\n  \n  bool isFull() {\n    \n  }\n}\n\n/**\n * Your MyCircularDeque object will be instantiated and called as such:\n * MyCircularDeque obj = MyCircularDeque(k);\n * bool param1 = obj.insertFront(value);\n * bool param2 = obj.insertLast(value);\n * bool param3 = obj.deleteFront();\n * bool param4 = obj.deleteLast();\n * int param5 = obj.getFront();\n * int param6 = obj.getRear();\n * bool param7 = obj.isEmpty();\n * bool param8 = obj.isFull();\n */",
    "golang": "type MyCircularDeque struct {\n    \n}\n\n\nfunc Constructor(k int) MyCircularDeque {\n    \n}\n\n\nfunc (this *MyCircularDeque) InsertFront(value int) bool {\n    \n}\n\n\nfunc (this *MyCircularDeque) InsertLast(value int) bool {\n    \n}\n\n\nfunc (this *MyCircularDeque) DeleteFront() bool {\n    \n}\n\n\nfunc (this *MyCircularDeque) DeleteLast() bool {\n    \n}\n\n\nfunc (this *MyCircularDeque) GetFront() int {\n    \n}\n\n\nfunc (this *MyCircularDeque) GetRear() int {\n    \n}\n\n\nfunc (this *MyCircularDeque) IsEmpty() bool {\n    \n}\n\n\nfunc (this *MyCircularDeque) IsFull() bool {\n    \n}\n\n\n/**\n * Your MyCircularDeque object will be instantiated and called as such:\n * obj := Constructor(k);\n * param_1 := obj.InsertFront(value);\n * param_2 := obj.InsertLast(value);\n * param_3 := obj.DeleteFront();\n * param_4 := obj.DeleteLast();\n * param_5 := obj.GetFront();\n * param_6 := obj.GetRear();\n * param_7 := obj.IsEmpty();\n * param_8 := obj.IsFull();\n */",
    "ruby": "class MyCircularDeque\n\n=begin\n    :type k: Integer\n=end\n    def initialize(k)\n        \n    end\n\n\n=begin\n    :type value: Integer\n    :rtype: Boolean\n=end\n    def insert_front(value)\n        \n    end\n\n\n=begin\n    :type value: Integer\n    :rtype: Boolean\n=end\n    def insert_last(value)\n        \n    end\n\n\n=begin\n    :rtype: Boolean\n=end\n    def delete_front()\n        \n    end\n\n\n=begin\n    :rtype: Boolean\n=end\n    def delete_last()\n        \n    end\n\n\n=begin\n    :rtype: Integer\n=end\n    def get_front()\n        \n    end\n\n\n=begin\n    :rtype: Integer\n=end\n    def get_rear()\n        \n    end\n\n\n=begin\n    :rtype: Boolean\n=end\n    def is_empty()\n        \n    end\n\n\n=begin\n    :rtype: Boolean\n=end\n    def is_full()\n        \n    end\n\n\nend\n\n# Your MyCircularDeque object will be instantiated and called as such:\n# obj = MyCircularDeque.new(k)\n# param_1 = obj.insert_front(value)\n# param_2 = obj.insert_last(value)\n# param_3 = obj.delete_front()\n# param_4 = obj.delete_last()\n# param_5 = obj.get_front()\n# param_6 = obj.get_rear()\n# param_7 = obj.is_empty()\n# param_8 = obj.is_full()",
    "scala": "class MyCircularDeque(_k: Int) {\n\n    def insertFront(value: Int): Boolean = {\n        \n    }\n\n    def insertLast(value: Int): Boolean = {\n        \n    }\n\n    def deleteFront(): Boolean = {\n        \n    }\n\n    def deleteLast(): Boolean = {\n        \n    }\n\n    def getFront(): Int = {\n        \n    }\n\n    def getRear(): Int = {\n        \n    }\n\n    def isEmpty(): Boolean = {\n        \n    }\n\n    def isFull(): Boolean = {\n        \n    }\n\n}\n\n/**\n * Your MyCircularDeque object will be instantiated and called as such:\n * val obj = new MyCircularDeque(k)\n * val param_1 = obj.insertFront(value)\n * val param_2 = obj.insertLast(value)\n * val param_3 = obj.deleteFront()\n * val param_4 = obj.deleteLast()\n * val param_5 = obj.getFront()\n * val param_6 = obj.getRear()\n * val param_7 = obj.isEmpty()\n * val param_8 = obj.isFull()\n */",
    "rust": "struct MyCircularDeque {\n\n}\n\n\n/** \n * `&self` means the method takes an immutable reference.\n * If you need a mutable reference, change it to `&mut self` instead.\n */\nimpl MyCircularDeque {\n\n    fn new(k: i32) -> Self {\n        \n    }\n    \n    fn insert_front(&self, value: i32) -> bool {\n        \n    }\n    \n    fn insert_last(&self, value: i32) -> bool {\n        \n    }\n    \n    fn delete_front(&self) -> bool {\n        \n    }\n    \n    fn delete_last(&self) -> bool {\n        \n    }\n    \n    fn get_front(&self) -> i32 {\n        \n    }\n    \n    fn get_rear(&self) -> i32 {\n        \n    }\n    \n    fn is_empty(&self) -> bool {\n        \n    }\n    \n    fn is_full(&self) -> bool {\n        \n    }\n}\n\n/**\n * Your MyCircularDeque object will be instantiated and called as such:\n * let obj = MyCircularDeque::new(k);\n * let ret_1: bool = obj.insert_front(value);\n * let ret_2: bool = obj.insert_last(value);\n * let ret_3: bool = obj.delete_front();\n * let ret_4: bool = obj.delete_last();\n * let ret_5: i32 = obj.get_front();\n * let ret_6: i32 = obj.get_rear();\n * let ret_7: bool = obj.is_empty();\n * let ret_8: bool = obj.is_full();\n */",
    "racket": "(define my-circular-deque%\n  (class object%\n    (super-new)\n    \n    ; k : exact-integer?\n    (init-field\n      k)\n    \n    ; insert-front : exact-integer? -> boolean?\n    (define/public (insert-front value)\n      )\n    ; insert-last : exact-integer? -> boolean?\n    (define/public (insert-last value)\n      )\n    ; delete-front : -> boolean?\n    (define/public (delete-front)\n      )\n    ; delete-last : -> boolean?\n    (define/public (delete-last)\n      )\n    ; get-front : -> exact-integer?\n    (define/public (get-front)\n      )\n    ; get-rear : -> exact-integer?\n    (define/public (get-rear)\n      )\n    ; is-empty : -> boolean?\n    (define/public (is-empty)\n      )\n    ; is-full : -> boolean?\n    (define/public (is-full)\n      )))\n\n;; Your my-circular-deque% object will be instantiated and called as such:\n;; (define obj (new my-circular-deque% [k k]))\n;; (define param_1 (send obj insert-front value))\n;; (define param_2 (send obj insert-last value))\n;; (define param_3 (send obj delete-front))\n;; (define param_4 (send obj delete-last))\n;; (define param_5 (send obj get-front))\n;; (define param_6 (send obj get-rear))\n;; (define param_7 (send obj is-empty))\n;; (define param_8 (send obj is-full))",
    "erlang": "-spec my_circular_deque_init_(K :: integer()) -> any().\nmy_circular_deque_init_(K) ->\n  .\n\n-spec my_circular_deque_insert_front(Value :: integer()) -> boolean().\nmy_circular_deque_insert_front(Value) ->\n  .\n\n-spec my_circular_deque_insert_last(Value :: integer()) -> boolean().\nmy_circular_deque_insert_last(Value) ->\n  .\n\n-spec my_circular_deque_delete_front() -> boolean().\nmy_circular_deque_delete_front() ->\n  .\n\n-spec my_circular_deque_delete_last() -> boolean().\nmy_circular_deque_delete_last() ->\n  .\n\n-spec my_circular_deque_get_front() -> integer().\nmy_circular_deque_get_front() ->\n  .\n\n-spec my_circular_deque_get_rear() -> integer().\nmy_circular_deque_get_rear() ->\n  .\n\n-spec my_circular_deque_is_empty() -> boolean().\nmy_circular_deque_is_empty() ->\n  .\n\n-spec my_circular_deque_is_full() -> boolean().\nmy_circular_deque_is_full() ->\n  .\n\n\n%% Your functions will be called as such:\n%% my_circular_deque_init_(K),\n%% Param_1 = my_circular_deque_insert_front(Value),\n%% Param_2 = my_circular_deque_insert_last(Value),\n%% Param_3 = my_circular_deque_delete_front(),\n%% Param_4 = my_circular_deque_delete_last(),\n%% Param_5 = my_circular_deque_get_front(),\n%% Param_6 = my_circular_deque_get_rear(),\n%% Param_7 = my_circular_deque_is_empty(),\n%% Param_8 = my_circular_deque_is_full(),\n\n%% my_circular_deque_init_ will be called before every test case, in which you can do some necessary initializations.",
    "elixir": "defmodule MyCircularDeque do\n  @spec init_(k :: integer) :: any\n  def init_(k) do\n    \n  end\n\n  @spec insert_front(value :: integer) :: boolean\n  def insert_front(value) do\n    \n  end\n\n  @spec insert_last(value :: integer) :: boolean\n  def insert_last(value) do\n    \n  end\n\n  @spec delete_front() :: boolean\n  def delete_front() do\n    \n  end\n\n  @spec delete_last() :: boolean\n  def delete_last() do\n    \n  end\n\n  @spec get_front() :: integer\n  def get_front() do\n    \n  end\n\n  @spec get_rear() :: integer\n  def get_rear() do\n    \n  end\n\n  @spec is_empty() :: boolean\n  def is_empty() do\n    \n  end\n\n  @spec is_full() :: boolean\n  def is_full() do\n    \n  end\nend\n\n# Your functions will be called as such:\n# MyCircularDeque.init_(k)\n# param_1 = MyCircularDeque.insert_front(value)\n# param_2 = MyCircularDeque.insert_last(value)\n# param_3 = MyCircularDeque.delete_front()\n# param_4 = MyCircularDeque.delete_last()\n# param_5 = MyCircularDeque.get_front()\n# param_6 = MyCircularDeque.get_rear()\n# param_7 = MyCircularDeque.is_empty()\n# param_8 = MyCircularDeque.is_full()\n\n# MyCircularDeque.init_ will be called before every test case, in which you can do some necessary initializations."
  },
  "solution": "[TOC]\n\n## Solution\n\n---\n\n### Overview\n\nWe are asked to design a circular double-ended queue (deque) data structure. In a deque, we need to provide fast access to the first (front) and last (rear) elements, as well as an efficient way to add/remove elements at the front and rear. \n\nWe note that a circular deque is a specific implementation of a deque where the last element loops back to the first element, creating a circular assortment. Since this particular implementation is not enforced for a correct submission, we will go over two approaches: one that will satisfy the required deque operations without storing our elements in a circle, and one that will cover a more proper implementation of a circular deque.\n\n### Approach 1: Linked List \n\n### Intuition\n\nIf we aren't following the circular ordering of a circular deque, we can achieve an implementation by considering existing data structures that provide efficient ways to access the front and rear elements to add or remove elements. \n\nOne example of this is the doubly linked list data structure in which each node contains a reference to the next node as well as the previous node. The doubly linked list data structure also maintains pointers to the head (front element) as well as the rear (last element). This makes adding/removing elements to the front and rear fairly simple: \n\n* To add a new node to the front, we first instantiate the new node and have it point to the current front node as its next node. We also want to make the current front node point to the new node as its previous node. Then, we update our reference of the head to this new front node.\n* To remove the front node, we can simply advance our head pointer by one.\n* To add a new node to the rear, we instantiate the new node and have the current rear node point to it as its next node. We also want the new node to point back to the current rear node as its previous node. Then, we update our reference of the rear to this new rear node.  \n* To remove the rear node, we can simply move our rear pointer back by one node, by accessing the previous node of the rear node.\n\nWith these pointer manipulations, we can fully support the required deque operations.\n\n### Algorithm\n\n1. Create a new `Node` class where each node contains a value `val`, a reference to its next node `next`, and a reference to its previous node `prev`\n2. The given `MyCircularDeque` class will then contain two `Node` references: one for the head of the deque, and one for the rear. It will also have a `size` field and `capacity` field to keep track of the current size and maximum size of the deque, respectively.\n3. Defining constructor:\n    * Initialize `size = 0` since our deque is initially empty and `capacity = k`.\n4. Defining `insertFront(int value)`:\n    * If `isFull()` is true, we don't have room to insert a new node so we return `false`.\n    * Otherwise, we add the node:\n        * If `head == null`, this will be the first element in the list\n            * Have `head` point to a new node with value `value`\n            * Have `rear` point to the new node as well\n        * Otherwise, there already exists at least 1 element in the list:\n            * Create a new node `newHead` that points to `head` as its next node\n            * Have `head.prev` point back to `newHead` as its previous node\n            * Update `head` to point to the `newHead`\n        * Increment `size` and return `true`\n5. Defining `insertLast(int value)`:\n    * If `isFull()` is true, we don't have room to insert a new node so we return `false`\n    * Otherwise, we add the node:\n        * If `head == null`, this will be the first element in the list\n            * Have `head` point to a new node with value `value`\n            * Have `rear` point to the new node as well\n        * Otherwise, there already exists at least 1 element in the list:\n            * Have `rear.next` point to a new node with `val = value` and `prev = rear`.\n            * Update the `rear = rear.next` so it points to the new rear\n        * Increment `size` and return `true`\n6. Defining `deleteFront()`:\n    * If `isEmpty()` is true, there are no nodes to delete so we return `false`\n    * Otherwise, we delete the front element: \n        * If `size == 1`, then this deletion will make the deque empty, so make `head` and `rear` both `null`\n        * Otherwise, we can delete the existing `head` node by simply updating `head = head.next`\n        * We decrement `size` and return `true`\n7. Defining `deleteLast()`:\n    * If `isEmpty()` is true, then there are no nodes to delete so we return `false`\n    * Otherwise, we delete the rear element:\n        * If `size == 1`, then this deletion will make the deque empty, so make `head` and `rear` both `null`\n        * Otherwise, we can move `rear` back 1 node by updating `rear = rear.next` \n        * We decrement `size` and return `true`\n8. Defining `getFront()`:\n    * If `isEmpty()` there is no front node so return -1. \n    * Otherwise, return `head.val`\n9. Defining `getRear()`:\n    * If `isEmpty()` there is no rear node so return -1.\n    * Otherwise, return `rear.val`\n10. Defining `isEmpty()`:\n    * Return `size == 0` to see if there are any nodes in our deque\n11. Defining `isFull()`:\n    * Return `size == capacity` to see if our current size is the maximum size.\n\n### Implementation### Complexity Analysis \n\n* Time Complexity: $O(1)$\n\n    Because we maintain access to the front and rear elements at all times, all operations simply involve pointer manipulations that take $O(1)$ time.\n\n* Space Complexity: $O(k)$\n\n    In the worst case, there will be maximum $k$ nodes in our doubly linked list, which will involve instantiating $k$ node objects and thus take $O(k)$ space.\n\n\n### Approach 2: Fixed Array with Circular Ordering\n\n### Intuition\n\nIn Approach 1, we opted to use a doubly linked list in which the elements don't wrap around. For this approach, we will use a fixed-sized array that will have the elements placed circularly.\n\nSimilar to before, we can maintain quick access to the front and the rear of our deque. For our fixed-sized array approach, this means we will keep track of the indices of the front and rear elements via two variables `front` and `rear`. With our linked list approach, this required dynamically creating new nodes at the front and rear of our list. For this fixed-sized circular array approach, we will have to use some arithmetic and modulo operations to keep track of the `front` and `rear`. Let's dive into how to update these indices as we support the add/removal operations:\n\n* When adding a new element to the front, we know that this element must be placed in front of the existing front element. In terms of indexing, it should be placed directly to the left of the element at `front`, which would be at an index of `front - 1`. In the case that `front - 1` < 0, the index can be recalculated as `(front - 1 + k) % k)`, which will give us the index in case the front element goes beyond the first index and wraps back around to the end of the deque. Note that when `front - 1 >= 0`, `front - 1 == (front - 1 + k) % k` so it'll have no effect as expected. Now that we have updated the `front` index, we can add the element by placing it at index `front` in the array.\n* When deleting a new element at the front, we can do the opposite of adding a new element at the front: We increment `front` by 1 so that it will point to the element directly to the right of the front element, effectively deleting the original front element. Similar to before, `front + 1` can go beyond the last possible index `k - 1` and wrap around back to the first index. To cover this case, we will update `front` to `(front + 1) % k`.\n* When adding a new element to the rear, we know that this element will be added to the right of the existing rear, placing it at an index of `(rear + 1) % k`.\n* To remove the rear node, we can reverse the above operation, and update `rear = (rear - 1 + k) % k`. \n\n\n### Algorithm\n\n1. Defining constructor:\n    * We can initialize an array `array` of size `k` to represent our circular deque\n    * We initialize current `size = 0` and maximum allowed size `capacity = k`\n    * We also want to keep track of the indices of the front and rear elements so we set `front = 0` and `rear = k - 1`. Note that setting `rear = k - 1` conveniently makes `front == rear` after adding our first element to the deque. \n2. Defining `insertFront(int value)`:\n    * If `isFull()`: return `false` since there's no room to add new elements\n    * Otherwise, update our front index `front = (front - 1 + capacity) % capacity` and set `array[front] = value`\n    * Increment `size` \n3. Defining `insertLast(int value)`:\n    * If `isFull()`, return `false` since there's no room to add new elements\n    * Otherwise, update our rear index `rear = (rear + 1) % capacity` and set `array[rear] = value`\n    * Increment `size`\n4. Defining `deleteFront(int value)`:\n    * If `isEmpty()`, return `false` since there are no elements to delete\n    * Otherwise, move the front index to the right by 1: `front = (front + 1) & capacity`, decrement `size`, and return `true`\n5. Defining `deleteLast(int value)`:\n    * If `isEmpty()`, return `false` since there are no elements to delete\n    * Otherwise, move the rear index to the left by 1: `rear = (rear - 1 + capacity) % capacity`, decrement `size`, and return `true`\n6. Defining `getFront()`:\n    * If `isEmpty()`, return -1\n    * Otherwise, return `array[front]`\n7. Defining `getRear()`:\n    * If `isEmpty()`, return -1\n    * Otherwise, return `array[rear]`\n8. Defining `isEmpty()`:\n    * Return `size == 0`\n9. Defining `isFull()`:\n    * Return `size == capacity`\n    \n\n### Implementation### Complexity Analysis \n\n* Time Complexity: $O(1)$\n\n    Similar to Approach 1, we maintain the references for the front and rear elements at all times, where all operations are simply arithmetic operations that take $O(1)$ time.\n\n* Space Complexity: $O(k)$\n\n    Our fixed-sized array will always have $k$ elements and thus will take $O(k)$ space."
}