{
  "title": "Selling Pieces of Wood",
  "problem_id": "1376",
  "frontend_id": "2312",
  "difficulty": "Hard",
  "problem_slug": "selling-pieces-of-wood",
  "topics": [
    "Array",
    "Dynamic Programming",
    "Memoization"
  ],
  "description": "You are given two integers m and n that represent the height and width of a rectangular piece of wood. You are also given a 2D integer array prices, where prices[i] = [hi, wi, pricei] indicates you can sell a rectangular piece of wood of height hi and width wi for pricei dollars.\nTo cut a piece of wood, you must make a vertical or horizontal cut across the entire height or width of the piece to split it into two smaller pieces. After cutting a piece of wood into some number of smaller pieces, you can sell pieces according to prices. You may sell multiple pieces of the same shape, and you do not have to sell all the shapes. The grain of the wood makes a difference, so you cannot rotate a piece to swap its height and width.\nReturn the maximum money you can earn after cutting an m x n piece of wood.\nNote that you can cut the piece of wood as many times as you want.\nExample 1:\nExample 2:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: m = 3, n = 5, prices = [[1,4,2],[2,2,7],[2,1,3]]\nOutput: 19\nExplanation: The diagram above shows a possible scenario. It consists of:\n- 2 pieces of wood shaped 2 x 2, selling for a price of 2 * 7 = 14.\n- 1 piece of wood shaped 2 x 1, selling for a price of 1 * 3 = 3.\n- 1 piece of wood shaped 1 x 4, selling for a price of 1 * 2 = 2.\nThis obtains a total of 14 + 3 + 2 = 19 money earned.\nIt can be shown that 19 is the maximum amount of money that can be earned.",
      "images": [
        "https://assets.leetcode.com/uploads/2022/04/27/ex1.png"
      ]
    },
    {
      "example_num": 2,
      "example_text": "Input: m = 4, n = 6, prices = [[3,2,10],[1,4,2],[4,1,3]]\nOutput: 32\nExplanation: The diagram above shows a possible scenario. It consists of:\n- 3 pieces of wood shaped 3 x 2, selling for a price of 3 * 10 = 30.\n- 1 piece of wood shaped 1 x 4, selling for a price of 1 * 2 = 2.\nThis obtains a total of 30 + 2 = 32 money earned.\nIt can be shown that 32 is the maximum amount of money that can be earned.\nNotice that we cannot rotate the 1 x 4 piece of wood to obtain a 4 x 1 piece of wood.",
      "images": [
        "https://assets.leetcode.com/uploads/2022/04/27/ex2new.png"
      ]
    }
  ],
  "constraints": [
    "1 <= m, n <= 200",
    "1 <= prices.length <= 2 * 104",
    "prices[i].length == 3",
    "1 <= hi <= m",
    "1 <= wi <= n",
    "1 <= pricei <= 106",
    "All the shapes of wood (hi, wi) are pairwise distinct."
  ],
  "follow_ups": [],
  "hints": [
    "Note down the different actions that can be done on a piece of wood with dimensions m x n. What do you notice?",
    "If possible, we could sell the m x n piece. We could also cut the piece vertically creating two pieces of size m x n1 and m x n2 where n1 + n2 = n, or horizontally creating two pieces of size m1 x n and m2 x n where m1 + m2 = m.",
    "Notice that cutting a piece breaks the problem down into smaller subproblems, and selling the piece when available is also a case that terminates the process. Thus, we can use DP to efficiently solve this."
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    long long sellingWood(int m, int n, vector<vector<int>>& prices) {\n        \n    }\n};",
    "java": "class Solution {\n    public long sellingWood(int m, int n, int[][] prices) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def sellingWood(self, m, n, prices):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :type prices: List[List[int]]\n        :rtype: int\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def sellingWood(self, m: int, n: int, prices: List[List[int]]) -> int:\n        ",
    "c": "long long sellingWood(int m, int n, int** prices, int pricesSize, int* pricesColSize) {\n    \n}",
    "csharp": "public class Solution {\n    public long SellingWood(int m, int n, int[][] prices) {\n        \n    }\n}",
    "javascript": "/**\n * @param {number} m\n * @param {number} n\n * @param {number[][]} prices\n * @return {number}\n */\nvar sellingWood = function(m, n, prices) {\n    \n};",
    "typescript": "function sellingWood(m: number, n: number, prices: number[][]): number {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param Integer $m\n     * @param Integer $n\n     * @param Integer[][] $prices\n     * @return Integer\n     */\n    function sellingWood($m, $n, $prices) {\n        \n    }\n}",
    "swift": "class Solution {\n    func sellingWood(_ m: Int, _ n: Int, _ prices: [[Int]]) -> Int {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun sellingWood(m: Int, n: Int, prices: Array<IntArray>): Long {\n        \n    }\n}",
    "dart": "class Solution {\n  int sellingWood(int m, int n, List<List<int>> prices) {\n    \n  }\n}",
    "golang": "func sellingWood(m int, n int, prices [][]int) int64 {\n    \n}",
    "ruby": "# @param {Integer} m\n# @param {Integer} n\n# @param {Integer[][]} prices\n# @return {Integer}\ndef selling_wood(m, n, prices)\n    \nend",
    "scala": "object Solution {\n    def sellingWood(m: Int, n: Int, prices: Array[Array[Int]]): Long = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn selling_wood(m: i32, n: i32, prices: Vec<Vec<i32>>) -> i64 {\n        \n    }\n}",
    "racket": "(define/contract (selling-wood m n prices)\n  (-> exact-integer? exact-integer? (listof (listof exact-integer?)) exact-integer?)\n  )",
    "erlang": "-spec selling_wood(M :: integer(), N :: integer(), Prices :: [[integer()]]) -> integer().\nselling_wood(M, N, Prices) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec selling_wood(m :: integer, n :: integer, prices :: [[integer]]) :: integer\n  def selling_wood(m, n, prices) do\n    \n  end\nend"
  }
}