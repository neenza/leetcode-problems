{
  "title": "Binary Search Tree to Greater Sum Tree",
  "problem_id": "1114",
  "frontend_id": "1038",
  "difficulty": "Medium",
  "problem_slug": "binary-search-tree-to-greater-sum-tree",
  "topics": [
    "Tree",
    "Depth-First Search",
    "Binary Search Tree",
    "Binary Tree"
  ],
  "description": "Given the root of a Binary Search Tree (BST), convert it to a Greater Tree such that every key of the original BST is changed to the original key plus the sum of all keys greater than the original key in BST.\nAs a reminder, a binary search tree is a tree that satisfies these constraints:\nExample 1:\nExample 2:\nConstraints:\nNote: This question is the same as 538: https://leetcode.com/problems/convert-bst-to-greater-tree/",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: root = [4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]\nOutput: [30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]",
      "images": [
        "https://assets.leetcode.com/uploads/2019/05/02/tree.png"
      ]
    },
    {
      "example_num": 2,
      "example_text": "Input: root = [0,null,1]\nOutput: [1,null,1]",
      "images": [
        "https://assets.leetcode.com/uploads/2019/05/02/tree.png"
      ]
    }
  ],
  "constraints": [
    "The number of nodes in the tree is in the range [1, 100].",
    "0 <= Node.val <= 100",
    "All the values in the tree are unique."
  ],
  "follow_ups": [],
  "hints": [
    "What traversal method organizes all nodes in sorted order?"
  ],
  "code_snippets": {
    "cpp": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* bstToGst(TreeNode* root) {\n        \n    }\n};",
    "java": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public TreeNode bstToGst(TreeNode root) {\n        \n    }\n}",
    "python": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def bstToGst(self, root):\n        \"\"\"\n        :type root: Optional[TreeNode]\n        :rtype: Optional[TreeNode]\n        \"\"\"\n        ",
    "python3": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def bstToGst(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\n        ",
    "c": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     struct TreeNode *left;\n *     struct TreeNode *right;\n * };\n */\nstruct TreeNode* bstToGst(struct TreeNode* root) {\n    \n}",
    "csharp": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public int val;\n *     public TreeNode left;\n *     public TreeNode right;\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\npublic class Solution {\n    public TreeNode BstToGst(TreeNode root) {\n        \n    }\n}",
    "javascript": "/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {TreeNode}\n */\nvar bstToGst = function(root) {\n    \n};",
    "typescript": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nfunction bstToGst(root: TreeNode | null): TreeNode | null {\n    \n};",
    "php": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     public $val = null;\n *     public $left = null;\n *     public $right = null;\n *     function __construct($val = 0, $left = null, $right = null) {\n *         $this->val = $val;\n *         $this->left = $left;\n *         $this->right = $right;\n *     }\n * }\n */\nclass Solution {\n\n    /**\n     * @param TreeNode $root\n     * @return TreeNode\n     */\n    function bstToGst($root) {\n        \n    }\n}",
    "swift": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public var val: Int\n *     public var left: TreeNode?\n *     public var right: TreeNode?\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\n *         self.val = val\n *         self.left = left\n *         self.right = right\n *     }\n * }\n */\nclass Solution {\n    func bstToGst(_ root: TreeNode?) -> TreeNode? {\n        \n    }\n}",
    "kotlin": "/**\n * Example:\n * var ti = TreeNode(5)\n * var v = ti.`val`\n * Definition for a binary tree node.\n * class TreeNode(var `val`: Int) {\n *     var left: TreeNode? = null\n *     var right: TreeNode? = null\n * }\n */\nclass Solution {\n    fun bstToGst(root: TreeNode?): TreeNode? {\n        \n    }\n}",
    "dart": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *   int val;\n *   TreeNode? left;\n *   TreeNode? right;\n *   TreeNode([this.val = 0, this.left, this.right]);\n * }\n */\nclass Solution {\n  TreeNode? bstToGst(TreeNode? root) {\n    \n  }\n}",
    "golang": "/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\nfunc bstToGst(root *TreeNode) *TreeNode {\n    \n}",
    "ruby": "# Definition for a binary tree node.\n# class TreeNode\n#     attr_accessor :val, :left, :right\n#     def initialize(val = 0, left = nil, right = nil)\n#         @val = val\n#         @left = left\n#         @right = right\n#     end\n# end\n# @param {TreeNode} root\n# @return {TreeNode}\ndef bst_to_gst(root)\n    \nend",
    "scala": "/**\n * Definition for a binary tree node.\n * class TreeNode(_value: Int = 0, _left: TreeNode = null, _right: TreeNode = null) {\n *   var value: Int = _value\n *   var left: TreeNode = _left\n *   var right: TreeNode = _right\n * }\n */\nobject Solution {\n    def bstToGst(root: TreeNode): TreeNode = {\n        \n    }\n}",
    "rust": "// Definition for a binary tree node.\n// #[derive(Debug, PartialEq, Eq)]\n// pub struct TreeNode {\n//   pub val: i32,\n//   pub left: Option<Rc<RefCell<TreeNode>>>,\n//   pub right: Option<Rc<RefCell<TreeNode>>>,\n// }\n// \n// impl TreeNode {\n//   #[inline]\n//   pub fn new(val: i32) -> Self {\n//     TreeNode {\n//       val,\n//       left: None,\n//       right: None\n//     }\n//   }\n// }\nuse std::rc::Rc;\nuse std::cell::RefCell;\nimpl Solution {\n    pub fn bst_to_gst(root: Option<Rc<RefCell<TreeNode>>>) -> Option<Rc<RefCell<TreeNode>>> {\n        \n    }\n}",
    "racket": "; Definition for a binary tree node.\n#|\n\n; val : integer?\n; left : (or/c tree-node? #f)\n; right : (or/c tree-node? #f)\n(struct tree-node\n  (val left right) #:mutable #:transparent)\n\n; constructor\n(define (make-tree-node [val 0])\n  (tree-node val #f #f))\n\n|#\n\n(define/contract (bst-to-gst root)\n  (-> (or/c tree-node? #f) (or/c tree-node? #f))\n  )",
    "erlang": "%% Definition for a binary tree node.\n%%\n%% -record(tree_node, {val = 0 :: integer(),\n%%                     left = null  :: 'null' | #tree_node{},\n%%                     right = null :: 'null' | #tree_node{}}).\n\n-spec bst_to_gst(Root :: #tree_node{} | null) -> #tree_node{} | null.\nbst_to_gst(Root) ->\n  .",
    "elixir": "# Definition for a binary tree node.\n#\n# defmodule TreeNode do\n#   @type t :: %__MODULE__{\n#           val: integer,\n#           left: TreeNode.t() | nil,\n#           right: TreeNode.t() | nil\n#         }\n#   defstruct val: 0, left: nil, right: nil\n# end\n\ndefmodule Solution do\n  @spec bst_to_gst(root :: TreeNode.t | nil) :: TreeNode.t | nil\n  def bst_to_gst(root) do\n    \n  end\nend"
  },
  "solution": "[TOC]\n\n## Solution\n\n---\n\n### Overview\n\nThe problem requires modifying the binary search tree rooted at the `root` so that each node has a new value equal to the sum of all original tree values that are greater than or equal to `node.val`. The tree contains between 0 and 100 unique nodes.\n\nCheck out the example below to understand how the root value gets replaced by adding greater values:\n\n![figB](../Figures/1038/visual1.png)\n\n---\n\n### Approach 1: In-order Traversal (Brute-Force)\n\n#### Intuition\n\nIn a binary search tree, all nodes in the left subtree of a node have values less than the node, and all nodes in the right subtree have values greater. During an in-order traversal, we move from the left subtree to the root node, then to the right subtree. Thus, in a binary search tree, in-order traversal yields node values in ascending order.\n\nGiven that the number of nodes is small, we can consider using a brute-force approach to solve the problem.\n\nWe can store all node values in an array as we traverse the tree using in-order traversal. Now, we can traverse the tree again and modify each node's value by incrementing the original value with the sum of all the greater values in the array.\n\nSince the array is sorted in ascending order, we can start iterating from the end of the array. If we reach any value in the array less than the current node value, we can break the iteration to further optimize this approach.\n\n#### Algorithm\n\n**Main function - `bstToGst(root)`**\n\n1. Initialize an integer array `inorderTraversal`.\n2. Call `inorder(root)`.\n3. Reverse the `inorderTraversal` array.\n4. Call `replaceValues(root)`.\n5. Return `root`.\n\n**`inorder(root)`**\n\n1. If the root is `null`, return.\n2. Make a call to `inorder(root->left)`.\n3. Store the value of the current node in the `inorderTraversal` array.\n4. Make a call to `inorder(root->right)`.\n\n**`replaceValues(root)`**\n\n1. If the root is `null`, return.\n2. Make calls to the left and right child, i.e. call the `replaceValues(root->left)` and `replaceValues(root->right)`.\n3. Initialize `nodeSum` with 0.\n4. Iterate through the `inorderTraversal` array:\n    - If the current value is greater than `root->val`:\n        - Add this value to the `nodeSum`.\n5. Increment `root->val` by `nodeSum`.\n\n#### Implementation#### Complexity Analysis\n\nLet $n$ be the number of nodes in the tree rooted at `root`.\n\n- Time complexity: $O(n^2)$\n\n    The `inorder` function traverses all the nodes exactly once. All other operations in `inorder` are constant time. Therefore, the time complexity for this function is $O(n)$.\n \n    The `replaceValues` function iterates all the values in `inorderTraversal` of size `n` in each iteration. It iterates all the nodes exactly once. Therefore, the time complexity for this function is $O(n^2)$.\n\n    The time complexity for the main function is given by $O(n^2)$.\n\n- Space complexity: $O(n)$\n\n    While traversing the tree, the recursion stack in both functions stores exactly `n` nodes in the worst case. Also, the size of the `inorderTraversal` array is `n`. Therefore, the space complexity is $O(n)$.\n\n---\n\n### Approach 2: Reverse In-order Traversal\n\n#### Intuition\n\nTraversing the right subtree before the left subtree during an in-order traversal means we can visit the greater values before the smaller ones. This approach will traverse the tree so that all the nodes are visited in descending order. An example of this reverse in-order traversal is shown below:\n\n![figA](../Figures/1038/Slide1.PNG)\n\nWe use recursion to visit the right subtree first, reaching the rightmost node with the maximum value. During traversal, each node's value is updated with a running sum of all previously visited nodes. This approach works because visiting nodes in descending order allows us to accumulate and update the sum progressively.\n\nNext, we move to the left subtree and repeat the process, using the call stack to return to nodes with smaller values.\n\n#### Algorithm\n\n**Main function**\n\n1. Initialize an integer `nodeSum` with 0.\n2. Call `bstToGstHelper(root)`.\n3. Return the value of `root`.\n\n**Helper function - `bstToGstHelper(TreeNode root,int nodeSum)`**\n\n1. If the `root` is null:\n    - Return the `root` without any changes.\n2. Recursively call the right subtree of root.\n3. Increment `nodeSum` by the value of the current node and replace current node's value with `nodeSum`.\n4. Recursively call the left subtree of the root.\n5. Return `root`.\n\n!?!../Documents/1038/slideshow1.json:960,540!?!\n\n#### Implementation#### Complexity Analysis\n\nLet $n$ be the number of nodes in the tree rooted at `root`.\n\n- Time complexity: $O(n)$\n\n    The recursive function is called for every node exactly once. All the operations performed in the `bstToGst` function are constant time. Therefore, the time complexity is $O(n)$.\n\n- Space complexity: $O(n)$\n\n    The recursive function is called exactly `n` times. In the worst case where the binary search tree is skewed such that all the nodes only have the right children, the call stack size will grow up to `n`. Therefore, the space complexity is $O(n)$.\n\n---\n\n### Approach 3: Iterative Reverse In-order Traversal\n\n#### Intuition\n\nWe can perform a reverse in-order traversal by emulating the recursion call stack iteratively using a stack. \n\nWe can iterate the nodes of the tree, and push them in the stack until we reach the rightmost node of the tree, similar to the recursive process. \n\nWe need to maintain the sum while traversing in decreasing order and increment the value of the top node of the stack by this sum. Similarly, we can repeat this process for the left subtree of the current node.\n\n#### Algorithm\n\n1. Initialize integer `nodeSum` with 0 and a stack `st` to store the nodes of the tree. Create a copy of the `root` in `node`.\n2. Iterate until `st` is not empty or `node` is not `null`:\n    - While `node` is not null:\n        - Push the current node in `st`.\n        - Replace `node` with the right child of `node`.\n    - Store the top element of `st` in `node` and pop `st`.\n    - Increment `nodeSum` with the value of `node`.\n    - Replace the value of `node` with this value.\n    - Replace `node` with the left child of `node`.\n3. Return `root`.\n\n!?!../Documents/1038/slideshow2.json:960,540!?!\n\n#### Implementation#### Complexity Analysis\n\nLet $n$ be the number of nodes in the tree rooted at `root`.\n\n- Time complexity: $O(n)$\n\n Every node is pushed into the stack and popped from the stack exactly once. All the other operations performed in the loop are constant time. Therefore, the time complexity is $O(n)$.\n\n- Space complexity: $O(n)$\n\n The recursive function is called exactly `n` times. In the worst case where the binary search tree is skewed such that all the nodes only have the right children, the call stack size will grow up to `n`. Therefore, the space complexity is $O(n)$.\n\n---\n\n### Approach 4: Morris Traversal\n\n#### Intuition\n\n> This approach is very advanced and would not be expected in an interview. We have included it for completeness.\n\nWe will continue using the same idea from the previous approach. Is there a way for us to perform the inorder traversal without using any space, including the recursion call stack?\n\nMorris Traversal is an efficient algorithm used to perform in-order tree traversal without using any extra space for recursion or a stack, which is typically required in conventional tree traversal methods. The algorithm uses the concept of threaded binary trees, temporarily modifying the tree structure during traversal to avoid additional memory usage.\n\nBefore diving into Morris traversal, it's crucial to understand threaded binary trees:\n\n1. In a threaded binary tree, \"null\" right pointers are replaced with pointers to the in-order successor of the node.\n2. This threading allows for efficient traversal without recursion or a stack.\n\n\n**Note:** If you are new to the concept of Morris traversal, we recommend you first read [Threaded Binary Trees](https://en.wikipedia.org/wiki/Threaded_binary_tree) and [Working of the Morris traversal algorithm](https://stackoverflow.com/a/5506601). You can also understand the implementation of the algorithm [here](https://leetcode.com/problems/binary-tree-inorder-traversal/editorial/#approach-3-morris-traversal).\n\nTo apply the reverse in-order traversal using Morris traversal, we can swap all `left` and `right` pointer references to the BST. This would return all the nodes in the descending order of their values. \n\nCheck out the example given below to understand the conversion process:\n\n!?!../Documents/1038/slideshow3.json:960,540!?!\n\nIn the final tree obtained, if there is no right subtree, then we can visit this node and continue traversing left. If there is a right subtree, then there is at least one node that has a greater value than the current one. Therefore, we must traverse that subtree first before the current node which would help us to traverse all the node values in decreasing order.\n\n#### Algorithm\n\n**Main function - `bstToGst(root)`**\n\n1. Initialize an integer `sum` with 0 and a dummy node `node` with root.\n2. Iterate while node's value is not `null`:\n    - If node's right child is not `null`:\n      - Increment `sum` with node's value.\n      - Replace node's value with this sum and move to the left child.\n    - Otherwise, if the right child is `null`:\n      - Store the in-order successor of `node` in `succ`, calculated using `getSuccessor(node)`.\n        - If left child of `succ` is `null`:\n          - Store `node` as the left child of `succ`.\n          - Move towards the right child of `node`.\n        - Otherwise, if the left child isn't `null`:\n          - Set left child of `succ` as null.\n          - Increment `sum` with node's value.\n          - Replace node's value with this sum and move to the left child.\n3. Return `root`.  \n\n**`getSuccessor(node)`**\n\n1. Initialize `succ` with right child of `node`.\n2. Return the left-most child of `succ`.\n> Note: While this approach is space-efficient, it modifies the tree structure during traversal, which might not be suitable in all scenarios, especially if the tree is being accessed concurrently by other processes. The constant modification and restoration of tree links may have a slight impact on performance compared to straightforward recursive approaches, especially for smaller trees.\n\n#### Implementation#### Complexity Analysis\n\nLet $n$ be the number of nodes in the tree rooted at `root`.\n\n- Time complexity: $O(n)$\n\n    Note that `getSuccessor` is called at most twice per node. On the first invocation, the temporary link back to the node in question is created, and on the second invocation, the temporary link is erased. \n    \n    Then, the algorithm steps into the left subtree with no way to return to the node. Therefore, each edge can only be traversed 3 times: once when we move the node pointer, and once for each of the two calls to getSuccessor.\n\n    Therefore, the time complexity is $O(n)$.\n\n- Space complexity: $O(1)$\n\n    Because we only manipulate pointers that already exist, the Morris traversal uses constant space.\n\n---"
}