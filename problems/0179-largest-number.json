{
  "title": "Largest Number",
  "problem_id": "179",
  "frontend_id": "179",
  "difficulty": "Medium",
  "problem_slug": "largest-number",
  "topics": [
    "Array",
    "String",
    "Greedy",
    "Sorting"
  ],
  "description": "Given a list of non-negative integers nums, arrange them such that they form the largest number and return it.\nSince the result may be very large, so you need to return a string instead of an integer.\nExample 1:\nExample 2:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: nums = [10,2]\nOutput: \"210\"",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input: nums = [3,30,34,5,9]\nOutput: \"9534330\"",
      "images": []
    }
  ],
  "constraints": [
    "1 <= nums.length <= 100",
    "0 <= nums[i] <= 109"
  ],
  "follow_ups": [],
  "hints": [],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    string largestNumber(vector<int>& nums) {\n        \n    }\n};",
    "java": "class Solution {\n    public String largestNumber(int[] nums) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def largestNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: str\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def largestNumber(self, nums: List[int]) -> str:\n        ",
    "c": "char* largestNumber(int* nums, int numsSize) {\n    \n}",
    "csharp": "public class Solution {\n    public string LargestNumber(int[] nums) {\n        \n    }\n}",
    "javascript": "/**\n * @param {number[]} nums\n * @return {string}\n */\nvar largestNumber = function(nums) {\n    \n};",
    "typescript": "function largestNumber(nums: number[]): string {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @return String\n     */\n    function largestNumber($nums) {\n        \n    }\n}",
    "swift": "class Solution {\n    func largestNumber(_ nums: [Int]) -> String {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun largestNumber(nums: IntArray): String {\n        \n    }\n}",
    "dart": "class Solution {\n  String largestNumber(List<int> nums) {\n    \n  }\n}",
    "golang": "func largestNumber(nums []int) string {\n    \n}",
    "ruby": "# @param {Integer[]} nums\n# @return {String}\ndef largest_number(nums)\n    \nend",
    "scala": "object Solution {\n    def largestNumber(nums: Array[Int]): String = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn largest_number(nums: Vec<i32>) -> String {\n        \n    }\n}",
    "racket": "(define/contract (largest-number nums)\n  (-> (listof exact-integer?) string?)\n  )",
    "erlang": "-spec largest_number(Nums :: [integer()]) -> unicode:unicode_binary().\nlargest_number(Nums) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec largest_number(nums :: [integer]) :: String.t\n  def largest_number(nums) do\n    \n  end\nend"
  },
  "solution": "[TOC]\n\n## Solution\n\n---\n\n### Overview \n\nWe need to arrange a list of non-negative integers such that their concatenation results in the largest possible number. Return this largest number as a string.\n\nTo solve this, we use a custom comparator—a function or object that defines how two elements are compared for sorting. It’s used when the default comparison operations (like `<` or `>`) do not fit the requirements of a particular task. In this case, we want to compare numbers based on the result of their concatenation in two different orders.\n\nFirst, we convert each integer to a string. Then, we sort the array of strings.\n\nSorting the numbers in descending order might seem like a good idea, but it leads to issues when numbers share the same leading digit. For example, sorting `[9, 5, 34, 3, 30]` in descending order gives `\"9534303\"`, but the correct answer is `\"9534330\"`. The problem arises because `\"3\"` and `\"30\"` share the same leading digit. \n\nTo fix this, we compare the concatenated results of pairs of numbers. For example, given two numbers `a` and `b`, we compare `a + b` and `b + a` (where `+` denotes string concatenation). If `a + b` is larger, we place `a` before `b`. This ensures that the numbers are ordered correctly for the largest possible result.\n\nThe key is that this comparison ensures that the greedy approach of comparing pairs of numbers leads to the correct result. The difficult part is proving that this greedy logic always gives the correct answer.\n\n##### Proof of Correctness\n\nObjective: To ensure that our custom comparator for sorting numbers produces the largest possible concatenated number.\n\n1. Transitivity of the Comparator:\n\n    To verify the validity of the comparator, we need to prove that it is transitive. In other words, if number `A` should come before `B`, and `B` should come before `C`, then `A` must come before `C` in the final order.\n\n    We define the function:\n\n    $$\n    \\begin{aligned}\n        f(X) &= 10^{\\text{lg}(X) + 1}\n    \\end{aligned}\n    $$\n\n    where $\\text{lg}(X)$ denotes the logarithm base 10 of $X$. This function helps in determining the power of 10 needed to position `X` correctly when concatenating.\n\n2. Comparator Verification:\n\n    If concatenating `A` and `B` as `AB` is less than or equal to `BA`, we need to verify that:\n\n    $$\n    \\begin{aligned}\n        f(B)A + B &\\leq f(A)B + A \\\\\n        (f(B) - 1)A &\\leq (f(A) - 1)B \\\\\n        A &\\leq \\frac{B \\cdot (f(A) - 1)}{f(B) - 1}\n    \\end{aligned}\n    $$\n\n    Similarly, if `B` and `C` satisfy:\n\n    $$\n    \\begin{aligned}\n        BC &\\leq CB \\\\\n        (f(C) - 1)B &\\leq (f(B) - 1)C \\\\\n        B &\\leq \\frac{C \\cdot (f(B) - 1)}{f(C) - 1}\n    \\end{aligned}\n    $$\n\n3. By Combining These Inequalities:\n\n    $$\n    \\begin{aligned}\n        A &\\leq \\frac{C \\cdot (f(A) - 1)}{f(C) - 1} \\\\\n        (f(C) - 1)A &\\leq (f(A) - 1)C \\\\\n        f(C)A + C &\\leq f(A)C + A \\\\\n        AC &\\leq CA\n    \\end{aligned}\n    $$\n\n    This demonstrates that if `A` is before `B` and `B` is before `C`, then `A` must come before `C`, maintaining a consistent ordering.\n\n4. By Establishing the Consistency of the Comparator:\n\n    We confirm that sorting numbers with this comparator yields the largest concatenated number. For example, sorting `[3, 30, 34, 5, 9]` yields `[9, 5, 34, 3, 30]`, which concatenates to `\"9534330\"`, the largest possible number.\n\n---\n\n### Approach 1: Using Built-in Function  \n\n#### Intuition\n\nTo begin with, we need to determine the best order for the numbers to form the largest possible number when concatenated. We first convert each integer in the list to a string. This conversion allows us to compare different concatenated results. For instance, if we have the numbers `56` and `9`, converting them to strings allows us to compare `\"569\"` and `\"956\"`.\n\nNext, we use a custom sorting function to order these strings. This function compares two strings, `a` and `b`, by evaluating `a + b` against `b + a`. If `a + b` is greater, then `a` should come before `b` in the sorted list to maximize the final result.\n\nOnce sorted, we concatenate all the strings. If the first element in this sorted list is \"0\", it indicates that all numbers were zeros, so the largest number possible is \"0\". In this case, we return \"0\". If not, we return the concatenated result. \n\n#### Algorithm\n\n- Initialize `numStrings` as an array of strings to hold string representations of numbers.\n\n- Convert each integer in `nums` to a string and store it in `numStrings`.\n\n- Sort `numStrings` based on concatenated values:\n  - Use a lambda function to compare concatenated results (`a + b` and `b + a`).\n  - Ensure that the concatenation which forms a larger number determines the order.\n\n- Check if the largest number formed is \"0\":\n  - If the first element in `numStrings` is \"0\", return \"0\" (handles cases where all numbers are zero).\n\n- Concatenate all strings in `numStrings` to form the largest number.\n\n- Return the concatenated result as the largest number.\n\n#### Implementation#### Complexity Analysis\n\nLet $n$ be the size of the `nums` array.\n\n- Time Complexity: $O(n \\log n)$\n\n    The most time-consuming operation is the sorting step, which uses a custom comparator. The sorting algorithm has a time complexity of $O(n \\log n)$. The conversion of numbers to strings and concatenation operations are linear with respect to the number of elements.\n\n- Space Complexity: $O(n + S)$\n\n    Additional space is used for storing the string representations of the numbers and the final concatenated result, which scales linearly with the size of the input array.\n\n    Some extra space is used when we sort an array of size $n$ in place. The space complexity of the sorting algorithm ($S$) depends on the programming language. The value of $S$ depends on the programming language and the sorting algorithm being used:\n    - In Python, the sort method sorts a list using the Timsort algorithm which is a combination of Merge Sort and Insertion Sort and has a space complexity of $O(n)$\n    - In C++, the `sort()` function is implemented as a hybrid of Quick Sort, Heap Sort, and Insertion Sort, with a worst-case space complexity of $O( \\log n )$\n    - In Java, `Arrays.sort()` is implemented using a variant of the Quick Sort algorithm which has a space complexity of $O( \\log n)$\n\n    Thus, the total space complexity of the algorithm is $O(n + S)$.\n\n---\n\n### Approach 2: Quick Sort\n\n#### Intuition\n\nQuick Sort uses a divide-and-conquer method to sort the numbers. We start by selecting a pivot and partitioning the list into two parts based on how each number compares with the pivot. Specifically, we compare concatenated results like `a + pivot` with `pivot + a`.\n\nWe recursively sort the two partitions and then combine them. This recursive sorting ensures that the entire list is ordered such that concatenating all numbers results in the largest possible number.\n\nAfter sorting, we concatenate the numbers. If the final string starts with '0', it means all numbers were zeros, so we return \"0\". Otherwise, we return the concatenated result. This approach efficiently sorts and merges numbers to achieve the desired outcome.\n\nEach of these approaches aims to sort the numbers in such a way that their concatenation produces the largest possible number. By using different sorting techniques and comparison methods, we can achieve the correct order efficiently.Let’s take the list `[3, 30, 34, 5, 9]`. To apply quick sort, we first select a pivot, such as `34`. We then partition the list so that numbers that produce a larger concatenated result with the pivot come before it, and those that produce a smaller result come after it.\n\nFor each number compared to `34`:\n- Compare `\"3\"` with `\"34\"`. Concatenate as `\"34\" + \"3\" = \"343\"` and `\"3\" + \"34\" = \"334\"`. Since `\"343\"` is greater, `\"3\"` is placed after `\"34\"`.\n- Compare `\"30\"` with `\"34\"`. Concatenate as `\"34\" + \"30\" = \"3430\"` and `\"30\" + \"34\" = \"3034\"`. Since `\"3430\"` is greater, `\"30\"` is placed after `\"34\"`.\n\nThe same process applies to `\"5\"` and `\"9\"`. The result of the partitioning places `\"9\"`, `\"5\"`, and `\"34\"` correctly relative to each other, but in the final list, we sort based on which numbers yield larger concatenated results when placed in various orders.\n\nAfter applying quick sort recursively to each partition, the list gets sorted to `[9, 5, 34, 3, 30]`. Concatenating these numbers results in `\"9534330\"`, which is the largest number possible.\n\n#### Algorithm\n\n- Call `quickSort(nums, 0, nums.size() - 1)` to sort the numbers in descending order based on their concatenated values.\n\n- `quickSort` function:\n  - If `left` is greater than or equal to `right`, return (base case: the array or sub-array is already sorted).\n  - Call `partition(nums, left, right)` to partition the array around a pivot and get the pivot index.\n  - Recursively call `quickSort` on the left sub-array (`left` to `pivotIndex - 1`).\n  - Recursively call `quickSort` on the right sub-array (`pivotIndex + 1` to `right`).\n\n- `partition` function:\n  - Choose the rightmost element as the pivot.\n  - Rearrange elements so that elements that, when concatenated with the pivot, form a larger number are moved to the left.\n  - Swap elements to place the pivot in its correct position.\n  - Return the pivot index.\n\n- `compare` function:\n  - Compare the concatenated strings of `firstNum` and `secondNum` to determine their order.\n\n- Concatenate the sorted numbers into a string to form the largest number.\n\n- Handle the edge case where the largest number is zero:\n  - Return \"0\" if the first character of the concatenated string is '0'.\n  - Otherwise, return the concatenated string.\n\n#### Implementation#### Complexity Analysis\n\nLet $n$ be the size of the `nums` array.\n\n- Time Complexity: $O(n \\log n)$ on average, $O(n^2)$ in the worst case\n\n    Quick sort generally has an average time complexity of $O(n \\log n)$, though its worst-case time complexity is $O(n^2)$ if the pivot selection consistently results in unbalanced partitions. The average case is efficient due to its partitioning strategy.\n\n- Space Complexity: $O(\\log n)$ on average, $O(n)$ in the worst case\n\n    The space complexity for quick sort is $O(\\log n)$ due to the depth of the recursion stack in the average case. In the worst case, it can be $O(n)$ if the recursion depth is not balanced.\n\n---\n\n### Approach 3: Merge Sort\n\n#### Intuition\n\nMerge sort involves recursively dividing the list into smaller parts until each part contains a single number. Sorting single-number parts is straightforward, so we focus on merging these parts in the correct order.\n\nDuring the merging process, we compare numbers by concatenating their string representations. We ensure that larger concatenated results come first in the merged list. This is done by comparing combinations like `a + b` and `b + a` and placing the larger result first.\n\nAfter merging all parts, we obtain a sorted list where concatenating all numbers forms the largest number. If this result starts with '0', all numbers are zero, so we return \"0\". Otherwise, we return the concatenated result.\n\nFor example, with the list `[3, 30, 34, 5, 9]`, we first split it into `[3, 30]` and `[34, 5, 9]`.\n\nWe recursively divide these segments further until each segment contains a single number. We then merge these single-number segments, comparing concatenated results to determine the order. For example, merging `[3]` and `[30]`, we find `\"330\"` is greater than `\"303\"`, so `\"30\"` should precede `\"3\"`.\n\nMerging all segments with similar comparisons results in the list `[9, 5, 34, 3, 30]`. Concatenating these numbers gives `\"9534330\"`, the largest possible number.\n\n#### Algorithm\n\n- Sort the `nums` array using a custom merge sort to arrange numbers in a way that forms the largest possible concatenated number.\n\n- `mergeSort` function:\n  - If the range of elements to be sorted (`left` to `right`) is a single element, return it as it is already sorted.\n  - Divide the array into two halves (`left` and `right`) by finding the middle index.\n  - Recursively sort the left and right halves.\n  - Merge the sorted halves using the `merge` function.\n\n- `merge` function:\n  - Initialize two indices to iterate over the left and right halves of the array.\n  - Compare elements from the left and right halves based on custom concatenation order (using the `compare` function).\n  - Append the larger element to the sorted array and move the corresponding index.\n  - After processing all elements from one half, append the remaining elements from the other half.\n\n- `compare` function:\n  - Concatenate `firstNum` and `secondNum` in both possible orders and compare them.\n  - Return `true` if `firstNum` should appear before `secondNum` in the final sorted order based on the concatenated result.\n\n- After sorting, concatenate the sorted numbers to form the largest number.\n  - Return \"0\" if the largest number starts with '0' (handles cases where all numbers are zero); otherwise, return the concatenated result.\n\n#### Implementation#### Complexity Analysis\n\nLet $n$ be the size of the `nums` array.\n\n- Time Complexity: $O(n \\log n)$\n\n    Merge sort divides the array into halves and merges them in $O(n \\log n)$ time. Each merge operation is linear in the size of the array being merged, and the recursive divide-and-conquer approach ensures a logarithmic depth of recursion.\n\n- Space Complexity: $O(n)$\n\n    Merge sort requires additional space for the temporary arrays used during merging. For each recursive call, we use extra space proportional to the size of the array being merged.\n   \n    The depth of the recursion stack is $O(\\log n)$, and the space used per level of recursion for merging is $O(n)$. So, the total space complexity is $O(n)$.\n\n    Creating the final string involves space proportional to the size of the final string, which is $O(n)$.\n\n---\n\n### Approach 4: HeapSort\n\n#### Intuition\n\n\nHeapsort helps us find the largest concatenated number by using a priority queue, which we often call a max heap.\n\nFirst, we need to turn each number into a string. This way, we can compare different concatenations of these strings. We then insert these string representations into a max heap. The max heap will arrange these strings based on our custom comparison function and The heap uses this comparison to decide which string should come first.\n\nSay we have the numbers `[3, 30, 34, 5, 9]`. We start by converting each number to a string, resulting in `[\"3\", \"30\", \"34\", \"5\", \"9\"]`. We insert these strings into the heap. The heap sorts these strings based on which concatenation yields a larger number. \n\nFor instance, comparing `\"30\"` and `\"3\"` involves checking if `\"303\"` is larger than `\"330\"`. Since `\"330\"` is larger, `\"3\"` will be prioritized over `\"30\"` in the heap. After inserting all strings, the heap will arrange them in a way that ensures the largest number comes out first.\n\nNext, we remove elements from the heap one by one and build our result string. By concatenating these strings in the order they come out of the heap, we get the largest possible number. Finally, if the result starts with '0', we return \"0\" because this means all numbers were zeros.The algorithm is visualized below:\n\n!?!../Documents/179/heapsort.json:925,695!?!\n\n#### Algorithm\n\n- Initialize a max heap to store numbers as strings in a custom sorted order, using the `compare` function.\n\n- Initialize a variable `totalLength` to track the total length of all numbers converted to strings.\n\n- Iterate over each number `num` in `nums`:\n  - Convert the integer `num` to a string `strNum`.\n  - Add the length of `strNum` to `totalLength`.\n  - Push `strNum` into the max heap using the custom comparison function to maintain the order.\n\n- Initialize an empty string `result` and reserve space based on `totalLength` for efficiency.\n\n- While the max heap is not empty:\n  - Append the top element (largest string based on custom comparison) from the max heap to `result`.\n  - Pop the top element from the max heap.\n\n- Check if the resulting string is empty or starts with `'0'`:\n  - If true, return `\"0\"` to handle the edge case where the result might be a string of zeros.\n\n- Otherwise, return the final `result` string, which represents the largest possible number.\n\n- `compare` function:\n  - Given two strings `first` and `second`, compare them by concatenating them in two different orders (`first + second` and `second + first`).\n  - Return `true` if `(first + second)` is less than `(second + first)`, ensuring the correct order for the largest number construction.\\\n\n#### Implementation#### Complexity Analysis\n\nLet $n$ be the size of the `nums` array.\n\n- Time Complexity: $O(n \\log n)$\n\n    Converting each integer to a string takes $O(\\log k)$ time per integer, where $k$ is the integer value. If there are $n$ integers, the total time for conversion is $O(n \\log k)$.\n    \n    Inserting each string into the priority queue takes $O(\\log n)$ time per insertion. Since there are $n$ strings, this step contributes $O(n \\log n)$.\n    \n    Extracting elements from the priority queue and concatenating them into the result string takes $O(n \\log n)$ time due to the heap operations and string concatenations.\n\n    Combining these steps, the overall time complexity is dominated by the heap operations, so:\n    \n    Converting integers to strings takes $O(n \\log k)$ time, and inserting each string into the priority queue takes $O(n \\log n)$. Building the result string takes $O(n \\log n)$. Thus, the overall time complexity is $O(n \\log n)$.\n\n- Space Complexity: $O(n)$\n\n    The priority queue stores $n$ strings, each of which can be up to $O(\\log k)$ in length. Hence, the space required for the priority queue is $O(n \\log k)$.\n\n    The result string stores all $n$ integers, so its space complexity is $O(n \\log k)$. Since these are the main contributors to space complexity, the overall space complexity is $O(n \\log k) = O(n)$.\n\n---\n\n### Approach 5: TimSort \n\n#### Intuition\n\nTimSort is a sorting algorithm that combines insertion sort and merge sort.\n\nWe start by dividing the list into small segments called runs. Each run is a segment of the list that is sorted independently using insertion sort. Insertion sort is well-suited for this task because it efficiently handles small or already partially sorted segments. For instance, in our example list `[3, 30, 34, 5, 9]`, TimSort first breaks it into runs. Since the list is small, it might treat the entire list as a single run or split it into smaller manageable runs like `[3, 30]` and `[34, 5, 9]` [Usually runs are not this small but for the sake of this example lets say its 2].\n\n> Minrun is chosen from the range 32 to 64 inclusive, such that the size of the data, divided by minrun, is equal to, or slightly less than, a power of two.\n\nNext, we merge these sorted runs into larger, sorted segments. During the merging phase, we use a custom comparison function to determine the order of numbers based on which concatenated result is larger.\n\nAfter all runs are merged, we get a fully sorted list arranged to form the largest possible number. Finally, we check if the result starts with '0'. If it does, this indicates that all numbers are zeros, so we return \"0\".\n\nConsider the list `[3, 30, 34, 5, 9]`. TimSort starts by sorting small runs like `[3, 30]` and `[34, 5, 9]` using insertion sort. It then merges these runs, comparing concatenated results to determine the correct order. For instance, it would compare `\"330\"` with `\"303\"` and place `\"3\"` before `\"30\"` because `\"330\"` is larger. The final merge step sorts the list to `[9, 5, 34, 3, 30]`. Concatenating these gives us the largest number, `\"9534330\"`.\n\nTimsort aims to optimize the merging process by ensuring that the number of runs is close to a power of two. Merging is most effective when the number of runs is equal to or just under a power of two, while it becomes less efficient when the number of runs exceeds a power of two. To achieve this, Timsort selects the value of `RUN` so that the total number of runs is close to a power of two.\n\n`RUN` is chosen within the range of 32 to 64. It is set so that the total size of the data divided by `RUN` is either equal to or slightly less than a power of two. The method for determining `RUN` involves taking the six most significant bits of the array size, adding one if any of the remaining bits are set, and using this result for `RUN`. This approach accommodates all array sizes, including those smaller than 64. For arrays with 63 or fewer elements, `RUN` is set equal to the array size, effectively reducing Timsort to insertion sort for those smaller arrays.\n\n> Fun fact: Timsort is highly regarded for its efficiency and stability. It is more advanced compared to older algorithms like bubble sort or insertion sort. Invented by Tim Peters in 2002, it was named after him. Timsort is used in Python sort.\n\n#### Algorithm\n\n- Sort the `nums` array using the custom `timSort` algorithm.\n  \n- `timSort` function:\n  - For each small run of size `RUN` (32 elements), call `insertionSort` to sort the subarrays.\n  - After sorting small runs, iteratively merge them using the `merge` function until the entire array is sorted.\n\n- `insertionSort` function:\n  - Iterate through the subarray from `left + 1` to `right`.\n  - For each element, store it in a temporary variable `temp`.\n  - Compare `temp` with its previous elements (from right to left) using the `compare` function:\n    - If the comparison returns `true` (i.e., `temp` should precede the compared element), shift the previous element to the right.\n  - Insert `temp` in its correct position once all comparisons are done.\n\n- `merge` function:\n  - Split the array into two subarrays: `leftArr` (from `left` to `mid`) and `rightArr` (from `mid + 1` to `right`).\n  - Merge the two subarrays back into the original array:\n    - Compare the elements from both subarrays using the `compare` function.\n    - Insert the smaller element into the original array and proceed until both subarrays are fully merged.\n\n- `compare` function:\n  - Convert the two numbers `firstNum` and `secondNum` into strings.\n  - Concatenate them in both possible orders and return `true` if the first concatenation results in a larger number.\n\n- Once `nums` is sorted, concatenate all elements in `nums` to form the `largestNum` string.\n\n- If the first character of `largestNum` is `'0'`, return `\"0\"` to handle the case where all numbers are zero.\n\n- Otherwise, return `largestNum` as the final result.\n\n#### Implementation#### Complexity Analysis\n\nLet $n$ be the size of the `nums` array.\n\n- Time complexity: $O(n \\log n)$\n\n    The main time-consuming operation here is the sorting step using TimSort. Its time complexity is $O(n \\log n)$ in the average and worst cases. \n\n    Specifically:\n    - The insertion sort runs in $O(n^2)$ time on small segments (runs), but since it operates on a limited size of $RUN$, the total cost for insertion sorting all runs is $O(n)$ in practice.\n    - The merge step involves merging pairs of runs and is performed $\\log n$ times, leading to the overall time complexity of $O(n \\log n)$ for TimSort.\n\n    Concatenating the numbers to form the final string has a linear time complexity $O(n)$, but it doesn't affect the overall complexity since $O(n \\log n)$ dominates.\n\n- Space complexity: $O(n)$\n\n    The space complexity is dominated by the space used for temporary storage during merging:\n    - The `leftArr` and `rightArr` vectors in the merge function require $O(n)$ space in total.\n    - The extra space used for the `largestNum` string is $O(n)$.\n\n    Other auxiliary space used in the algorithm, such as variables and function call stacks, is minimal compared to the space required for arrays.\n\n    Thus, the overall space complexity is $O(n)$.\n\n---### Further Thoughts:\n\nYou might be wondering why merging is most effective when the number of runs is equal to or just below a power of two, and why it becomes less efficient when the number of runs exceeds this number.\n\nThe main reason for this is that merging is most balanced when the number of runs is a power of two. In general, if the data is randomly ordered, each run will typically be about the size of `minrun`. When the number of runs matches a power of two, merging operations can proceed in a perfectly balanced manner throughout the process. This balance minimizes the number of comparisons and data movements needed.\n\nIf the number of runs is slightly more than a power of two, the merging process becomes less balanced. This imbalance results in inefficient merges, as you end up with uneven merge sizes, leading to increased comparisons and data movement.\n\nConversely, if the number of runs is slightly fewer than a power of two, the merges remain relatively balanced, although not perfectly. This slight imbalance causes only a minor increase in inefficiency compared to the ideal scenario.\n\nFor example, if you have nine natural runs with lengths of 800, 100, 100, 100, 100, 100, 100, 100, and 100 elements, the merges will still be well-balanced, even though the number of runs is slightly above a power of two.\n\nTim Peters talks about this in his [listsort.txt](https://github.com/python/cpython/blob/main/Objects/listsort.txt) file. He points out that using a `minrun` of 32 isn't always the best choice. For example, if you have 2,112 elements, splitting them into runs of 32 means it will take 7 steps to merge everything. The first 6 runs merge smoothly, but after reaching 2,048 elements, the final merge becomes less efficient. This leads to more comparisons and extra data movement.\n\nNow, if the run size is 33, it will take 6 steps to merge everything: 33, 66(33 * 2), 132(66 * 2), 264(132 * 2), 528(264 * 2), 1,056(528 * 2) and then 2,112(1,056 * 2). But with a run size of 32, you'll need 7 steps: 32, 64, 128, 256, 512, 1,024, 2,048, and then 2,112.You can view the full implementation of TimSort, including all the detailed aspects, in the file located at [https://svn.python.org/projects/python/trunk/Objects/listobject.c](https://svn.python.org/projects/python/trunk/Objects/listobject.c). This implementation was crafted by Tim Peters.Here’s a snippet taken from `listobject.c` showing how to determine the minimum run size for a subarray in the Timsort algorithm based on the size of the initial array `n`.\n\n```c\n/* Compute a good value for the minimum run length; natural runs shorter\n * than this are boosted artificially via binary insertion.\n *\n * If n < 64, return n (it's too small to bother with fancy stuff).\n * Else if n is an exact power of 2, return 32.\n * Else return an int k, 32 <= k <= 64, such that n/k is close to, but\n * strictly less than, an exact power of 2.\n *\n * See listsort.txt for more info.\n */\nstatic Py_ssize_t\nmerge_compute_minrun(Py_ssize_t n)\n{\n    Py_ssize_t r = 0;           /* becomes 1 if any 1 bits are shifted off */\n\n    assert(n >= 0);\n    while (n >= 64) {\n        r |= n & 1;\n        n >>= 1;\n    }\n    return n + r;\n}\n```\n\n---"
}