{
  "title": "Number of Steps to Reduce a Number in Binary Representation to One",
  "problem_id": "1520",
  "frontend_id": "1404",
  "difficulty": "Medium",
  "problem_slug": "number-of-steps-to-reduce-a-number-in-binary-representation-to-one",
  "topics": [
    "String",
    "Bit Manipulation",
    "Simulation"
  ],
  "description": "Given the binary representation of an integer as a string s, return the number of steps to reduce it to 1 under the following rules:\nIt is guaranteed that you can always reach one for all test cases.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: s = \"1101\"\nOutput: 6\nExplanation: \"1101\" corressponds to number 13 in their decimal representation.\nStep 1) 13 is odd, add 1 and obtain 14. \nStep 2) 14 is even, divide by 2 and obtain 7.\nStep 3) 7 is odd, add 1 and obtain 8.\nStep 4) 8 is even, divide by 2 and obtain 4.  \nStep 5) 4 is even, divide by 2 and obtain 2. \nStep 6) 2 is even, divide by 2 and obtain 1.",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input: s = \"10\"\nOutput: 1\nExplanation: \"10\" corresponds to number 2 in their decimal representation.\nStep 1) 2 is even, divide by 2 and obtain 1.",
      "images": []
    },
    {
      "example_num": 3,
      "example_text": "Input: s = \"1\"\nOutput: 0",
      "images": []
    }
  ],
  "constraints": [
    "1 <= s.length <= 500",
    "s consists of characters '0' or '1'",
    "s[0] == '1'"
  ],
  "follow_ups": [],
  "hints": [
    "Read the string from right to left, if the string ends in '0' then the number is even otherwise it is odd.",
    "Simulate the steps described in the binary string."
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    int numSteps(string s) {\n        \n    }\n};",
    "java": "class Solution {\n    public int numSteps(String s) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def numSteps(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def numSteps(self, s: str) -> int:\n        ",
    "c": "int numSteps(char* s) {\n    \n}",
    "csharp": "public class Solution {\n    public int NumSteps(string s) {\n        \n    }\n}",
    "javascript": "/**\n * @param {string} s\n * @return {number}\n */\nvar numSteps = function(s) {\n    \n};",
    "typescript": "function numSteps(s: string): number {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param String $s\n     * @return Integer\n     */\n    function numSteps($s) {\n        \n    }\n}",
    "swift": "class Solution {\n    func numSteps(_ s: String) -> Int {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun numSteps(s: String): Int {\n        \n    }\n}",
    "dart": "class Solution {\n  int numSteps(String s) {\n    \n  }\n}",
    "golang": "func numSteps(s string) int {\n    \n}",
    "ruby": "# @param {String} s\n# @return {Integer}\ndef num_steps(s)\n    \nend",
    "scala": "object Solution {\n    def numSteps(s: String): Int = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn num_steps(s: String) -> i32 {\n        \n    }\n}",
    "racket": "(define/contract (num-steps s)\n  (-> string? exact-integer?)\n  )",
    "erlang": "-spec num_steps(S :: unicode:unicode_binary()) -> integer().\nnum_steps(S) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec num_steps(s :: String.t) :: integer\n  def num_steps(s) do\n    \n  end\nend"
  },
  "solution": "## Solution\n\n---\n\n### Approach 1: Simulation\n\n#### Intuition\n\nWe are given a string `s` which is the binary representation of an integer. At each step, we can apply one of the operations based on what the current integer is:\n\n1. If the integer is even, divide the integer by `2`.\n   > Example: If `s` is `1100`, which is `12`, we can apply this operation to make it `0110`, which represents 6.\n2. If the integer is odd, add `1` to the integer.\n   > Example: If `s` is `1101`, which is `13`, we can apply this operation to make it `1110`, which represents 14.\n\nWe can apply any number of operations. We need to return the minimum number of operations to make the integer equal to `1`. It is guaranteed that the leftmost bit in `s` (`s[0]`) will always be `1`.\n\nIn this approach, we will just simulate the steps given by the problem description to find the minimum number of steps. We cannot choose the operation we apply, i.e., if the number is even, we have to divide it by `2` and add `1` otherwise. Hence, we can just perform these operations on the given string and return the number of operations required to make it equal to `1`.\n\nTo divide the number the string represents by `2`, we will remove the rightmost bit character from the string. We can easily implement this using the right-shift operation, which shifts each bit by one place to the right, which is equivalent to dividing by two. To add one to the string, we will start from the right end and keep adding `1` while the carry doesn't become zero. We can implement this by iterating from the right end and changing each `1` to `0` until we find the first `0`. If we don't find any `0`s we will have to append a `1` at the start of the string.\n\n#### Algorithm\n\n1. Initialize the variable `operations` to `0`.\n2. Keep applying the operations while the size of the string `s` is greater than `1`:\n\n    - If the last bit of string `s` is `0`, it implies it is even; hence, apply the divide by `2` operation by removing the last bit.\n    - Otherwise, it implies that the number represented by the string is odd and hence add `1` to it as follows:\n\n        - Start from the right end of the string `s`.\n        - Keep iterating while the character is `1` and mark them all as `0`.\n        - If we passed the most significant digit in `s`, append `1` to the left; otherwise, mark the `0` as `1`.\n\n    - Increment the variable `operations`.\n3. Return `operations`.\n\n#### Implementation#### Complexity Analysis\n\nHere, $N$ is the size of the string `s`.\n\n* Time complexity: $O(N)$.\n\n  The time complexity of the `divideByTwo` method is $O(1)$. The time complexity of the method `addOne` can be up to $O(N)$, such as the case where `s = 1111`, representing `15`. In this case, after the `addOne` method is called, `s = 10000`, representing `16`. Since `16` is a power of two, each remaining step would just involve the `divideByTwo` method. Over the course of the entire algorithm, the `addOne` method will flip each bit of `s` from `1` to `0` at most once, so it is amortized $O(N)$. For each even integer, we remove a digit from the string. For each odd integer, we add one to it, which will make it even, and then we again remove one digit from it. Thus, it takes one step to remove one digit when the number is even, and it takes two steps to remove one digit when the number is odd, hence, the number of steps required would be $O(N)$. Therefore, the time complexity would be equal to $O(2N)$, which we can simplify to $O(N)$.\n\n* Space complexity: $O(1)$ (C++) or  $O(N)$ (Python3 and Java)\n\n  In Python3 and Java, strings are immutable, which means they cannot be changed once they are created. For these languages, we create a mutable representation of `s`, which requires $O(N)$ space. In the C++ implementation, we apply the operations on the given input string, and hence, no extra space is required. Generally, it is not recommended to alter the input, but given the nature of the problem here, altering the input is reasonable.\n---\n\n### Approach 2: Greedy\n\n#### Intuition\n\nIf we closely observe the previous approach, we're essentially removing one bit from the right end each time. When the number is even we are directly removing the bit at the rightmost position. In case of an odd number, adding one will make it even, and then we will remove the rightmost bit. Hence, it takes one step to remove the rightmost bit when the number is even, and it takes two steps when the number is odd.\n\nAlso, the task of making a number equal to `1` is equivalent to removing the `N - 1` last bits from the string as the most significant bit is always one. Therefore, we will iterate the string from the right end to the leftmost `1` (as the bit at index `0` is `1` and we don't want to remove it). For each bit, we will check if it's `1` or `0`, i.e., odd or even, respectively. If it's odd, we will add `2` to the answer `operations`, and if it's even, add `1` to `operations.`\n\nOne important point is that when the current bit is `1`, and we add `1` to it to make it `0` and then we divide by `2` to remove this bit, we will have an extra bit `1`. This extra bit, represented by the variable `carry`, needs to be passed one bit position to the left in the string. Hence, while checking if the next bit is even or odd we should add `carry` as well to accommodate the extra bit from previous operations. Initially, `carry` will be `0`, and we will assign the value `1` when the current bit is odd to represent the overflow of one bit.\n\nWhen we reach the leftmost bit, if `carry` is `1`, it means that we will have to add it to the bit at index `0` and then apply one operation to remove the last `0`. Hence, we will return `operations + carry` as the answer to the problem.\n\n!?!../Documents/1404_Number_of_Steps_to_Reduce_a_Number_in_Binary_Representation_to_One.json:758,368!?!\n\n#### Algorithm\n\n1. Initialize the variable `operations` and `carry` to `0`.\n2. Iterate over the characters from position `N - 1` to `1` in the string `s` and for each index `i`, do the following:\n\n    - If the bit `((s[i] - '0') + carry)` is odd, increment the `operations` by `2` and change `carry` to `1`.\n    - Else, add `1` to `operations`\n\n3. Return `operations + carry`.\n\n#### Implementation#### Complexity Analysis\n\nHere, $N$ is the size of the string `s`.\n\n* Time complexity: $O(N)$.\n\n  We are iterating over each character of the string only once and hence the time complexity is equal to $O(N)$.\n\n* Space complexity: $O(1)$\n\n  No extra space is required other than the few variables `operations` and `carry`. Hence the time complexity is constant.\n---"
}