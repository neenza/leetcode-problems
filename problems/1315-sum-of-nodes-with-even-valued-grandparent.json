{
  "title": "Sum of Nodes with Even-Valued Grandparent",
  "problem_id": "1243",
  "frontend_id": "1315",
  "difficulty": "Medium",
  "problem_slug": "sum-of-nodes-with-even-valued-grandparent",
  "topics": [
    "Tree",
    "Depth-First Search",
    "Breadth-First Search",
    "Binary Tree"
  ],
  "description": "Given the root of a binary tree, return the sum of values of nodes with an even-valued grandparent. If there are no nodes with an even-valued grandparent, return 0.\nA grandparent of a node is the parent of its parent if it exists.\nExample 1:\nExample 2:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: root = [6,7,8,2,7,1,3,9,null,1,4,null,null,null,5]\nOutput: 18\nExplanation: The red nodes are the nodes with even-value grandparent while the blue nodes are the even-value grandparents.",
      "images": [
        "https://assets.leetcode.com/uploads/2021/08/10/even1-tree.jpg"
      ]
    },
    {
      "example_num": 2,
      "example_text": "Input: root = [1]\nOutput: 0",
      "images": [
        "https://assets.leetcode.com/uploads/2021/08/10/even2-tree.jpg"
      ]
    }
  ],
  "constraints": [
    "The number of nodes in the tree is in the range [1, 104].",
    "1 <= Node.val <= 100"
  ],
  "follow_ups": [],
  "hints": [
    "Traverse the tree keeping the parent and the grandparent.",
    "If the grandparent of the current node is even-valued, add the value of this node to the answer."
  ],
  "code_snippets": {
    "cpp": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    int sumEvenGrandparent(TreeNode* root) {\n        \n    }\n};",
    "java": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public int sumEvenGrandparent(TreeNode root) {\n        \n    }\n}",
    "python": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sumEvenGrandparent(self, root):\n        \"\"\"\n        :type root: Optional[TreeNode]\n        :rtype: int\n        \"\"\"\n        ",
    "python3": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def sumEvenGrandparent(self, root: Optional[TreeNode]) -> int:\n        ",
    "c": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     struct TreeNode *left;\n *     struct TreeNode *right;\n * };\n */\nint sumEvenGrandparent(struct TreeNode* root) {\n    \n}",
    "csharp": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public int val;\n *     public TreeNode left;\n *     public TreeNode right;\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\npublic class Solution {\n    public int SumEvenGrandparent(TreeNode root) {\n        \n    }\n}",
    "javascript": "/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nvar sumEvenGrandparent = function(root) {\n    \n};",
    "typescript": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nfunction sumEvenGrandparent(root: TreeNode | null): number {\n    \n};",
    "php": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     public $val = null;\n *     public $left = null;\n *     public $right = null;\n *     function __construct($val = 0, $left = null, $right = null) {\n *         $this->val = $val;\n *         $this->left = $left;\n *         $this->right = $right;\n *     }\n * }\n */\nclass Solution {\n\n    /**\n     * @param TreeNode $root\n     * @return Integer\n     */\n    function sumEvenGrandparent($root) {\n        \n    }\n}",
    "swift": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public var val: Int\n *     public var left: TreeNode?\n *     public var right: TreeNode?\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\n *         self.val = val\n *         self.left = left\n *         self.right = right\n *     }\n * }\n */\nclass Solution {\n    func sumEvenGrandparent(_ root: TreeNode?) -> Int {\n        \n    }\n}",
    "kotlin": "/**\n * Example:\n * var ti = TreeNode(5)\n * var v = ti.`val`\n * Definition for a binary tree node.\n * class TreeNode(var `val`: Int) {\n *     var left: TreeNode? = null\n *     var right: TreeNode? = null\n * }\n */\nclass Solution {\n    fun sumEvenGrandparent(root: TreeNode?): Int {\n        \n    }\n}",
    "dart": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *   int val;\n *   TreeNode? left;\n *   TreeNode? right;\n *   TreeNode([this.val = 0, this.left, this.right]);\n * }\n */\nclass Solution {\n  int sumEvenGrandparent(TreeNode? root) {\n    \n  }\n}",
    "golang": "/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\nfunc sumEvenGrandparent(root *TreeNode) int {\n    \n}",
    "ruby": "# Definition for a binary tree node.\n# class TreeNode\n#     attr_accessor :val, :left, :right\n#     def initialize(val = 0, left = nil, right = nil)\n#         @val = val\n#         @left = left\n#         @right = right\n#     end\n# end\n# @param {TreeNode} root\n# @return {Integer}\ndef sum_even_grandparent(root)\n    \nend",
    "scala": "/**\n * Definition for a binary tree node.\n * class TreeNode(_value: Int = 0, _left: TreeNode = null, _right: TreeNode = null) {\n *   var value: Int = _value\n *   var left: TreeNode = _left\n *   var right: TreeNode = _right\n * }\n */\nobject Solution {\n    def sumEvenGrandparent(root: TreeNode): Int = {\n        \n    }\n}",
    "rust": "// Definition for a binary tree node.\n// #[derive(Debug, PartialEq, Eq)]\n// pub struct TreeNode {\n//   pub val: i32,\n//   pub left: Option<Rc<RefCell<TreeNode>>>,\n//   pub right: Option<Rc<RefCell<TreeNode>>>,\n// }\n// \n// impl TreeNode {\n//   #[inline]\n//   pub fn new(val: i32) -> Self {\n//     TreeNode {\n//       val,\n//       left: None,\n//       right: None\n//     }\n//   }\n// }\nuse std::rc::Rc;\nuse std::cell::RefCell;\nimpl Solution {\n    pub fn sum_even_grandparent(root: Option<Rc<RefCell<TreeNode>>>) -> i32 {\n        \n    }\n}",
    "racket": "; Definition for a binary tree node.\n#|\n\n; val : integer?\n; left : (or/c tree-node? #f)\n; right : (or/c tree-node? #f)\n(struct tree-node\n  (val left right) #:mutable #:transparent)\n\n; constructor\n(define (make-tree-node [val 0])\n  (tree-node val #f #f))\n\n|#\n\n(define/contract (sum-even-grandparent root)\n  (-> (or/c tree-node? #f) exact-integer?)\n  )",
    "erlang": "%% Definition for a binary tree node.\n%%\n%% -record(tree_node, {val = 0 :: integer(),\n%%                     left = null  :: 'null' | #tree_node{},\n%%                     right = null :: 'null' | #tree_node{}}).\n\n-spec sum_even_grandparent(Root :: #tree_node{} | null) -> integer().\nsum_even_grandparent(Root) ->\n  .",
    "elixir": "# Definition for a binary tree node.\n#\n# defmodule TreeNode do\n#   @type t :: %__MODULE__{\n#           val: integer,\n#           left: TreeNode.t() | nil,\n#           right: TreeNode.t() | nil\n#         }\n#   defstruct val: 0, left: nil, right: nil\n# end\n\ndefmodule Solution do\n  @spec sum_even_grandparent(root :: TreeNode.t | nil) :: integer\n  def sum_even_grandparent(root) do\n    \n  end\nend"
  },
  "solution": "[TOC]\n\n## Solution\n\n---\n\n### Approach 1: Depth-First Search (DFS)\n\n**Intuition**\n\nWe are given a binary tree, and we need to return the sum of nodes that has even values grandparent. The grandparent of a node is the parent of its immediate parent.\n\nWe need to iterate over the nodes in the binary tree in a way that we can find the value of its grandparent. We can then check if the value of its grandparent is even, and if so, add the value of that node to the answer. One way to iterate a tree is Depth-First Search, i.e., DFS. We can recursively iterate over the nodes in the tree in depth wise manner, but keeping two extra pieces of information: the value of its immediate parent, and the value of its grandparent. This enables us to decide whether the value of the current node should be added to the answer.\n\nHow will we find the value of parent and grandparent for each node? We can start with the root node and which has neither the parent nor the grandparent node. We can use arbitrary odd values to represent their values so that we don't add the root value to the answer. The value of the parent node for the child node and the value of the grandparent node can be obtained as the current node's value and the parent node's value of the current node, respectively.\n\n![fig](../Figures/1315/1315A.png)\n\n**Algorithm**\n\n1. Define the method `solve()` that takes the TreeNode `root`, the parent value `parent` and the grandparent value `gParent`. This method returns the number of nodes with even-valued grandparent under the subtree of node `root.`\n2. Call the recursive function `solve()` with the root node and `-1` as the parent value  `parent` and grandparent value `gParent`\n3. If the `root` is null, then we can return `0` as the sum.\n4. Recursively iterate over the left and right child with parent value as `root` and grandparent value as `parent`.\n5. If the value of `gParent` is even, then add the value of `root` to the answer.\n6. Return the sum for the left and right child and the value for the current node.\n\n**Implementation****Complexity Analysis**\n\nHere, $N$ is the number of nodes in the binary tree.\n\n* Time complexity: $O(N)$\n\n  We need to iterate over every node only once with parent and grandparent values in the recursive function. Hence the total time complexity is equal to $O(N)$.\n\n* Space complexity: $O(N)$\n\n  The only space required is the stack recursion calls, the maximum number of active stack calls would be equal to $O(N)$ when the tree is skewed and there is one function call for each of the nodes in the recursive stack. Hence the total space complexity is equal to $O(N)$.---\n### Approach 2:  Breadth-First Search (BFS)\n\n**Intuition**\n\nThe other way to iterate over the nodes in a binary tree is using Breadth-First Search. We will iterate over the nodes in a breadth-wise manner, and for each node, we need to find a way to determine if it has a grandparent with an even value.\n\nSince we will iterate over the nodes in an iterative manner using BFS, we have to use a different method to find the grandparent. What if, instead of checking the ancestor nodes of each node, we look for the grandchildren nodes of each node? This way, we don't have to keep the parent and grandparent values as we did before.\n\nAs shown below we will check the four grandchildren for each node which has an even value, we will add the value of all these grandchildren to the answer.\n\n![fig](../Figures/1315/1315B.png)\n\n**Algorithm**\n\n1. Initialize an empty queue `q`, and a variable `sum` to `0`.\n2. Iterate over the queue while it's not empty and for each node:\n\n    1. Pop the node from the queue as `curr`.\n    2. If the value of `curr` is even, then check the grandchildren of this node and add the values to the variable `sum`.\n    3. Add the left and right child of the node `curr` if they are not null.\n3. Return `sum`.\n\n\n**Implementation****Complexity Analysis**\n\nHere, $N$ is the number of nodes in the binary tree.\n\n* Time complexity: $O(N)$\n\n  The outer while loop continues if there are nodes in the queue. Each node will be added to the queue and popped from the queue only once. If its value is even, we will keep popping the node and check its four grandchildren. All these operations are constant in terms of time complexity. Hence the total time complexity is equal to $O(N)$.\n\n* Space complexity: $O(N)$\n\n  We need a queue to store the nodes at a particular level of the binary tree. The number of nodes in different levels of a full binary tree will be `${1, 2, 4, 8......2^{N - 1}}$`, with total nodes equal to $2^N$, therefore, the maximum number of nodes at a time in the queue will be of the order $O(N)$. Hence the total space complexity is equal to $O(N)$.---"
}