{
  "title": "Minimum Total Distance Traveled",
  "problem_id": "2554",
  "frontend_id": "2463",
  "difficulty": "Hard",
  "problem_slug": "minimum-total-distance-traveled",
  "topics": [
    "Array",
    "Dynamic Programming",
    "Sorting"
  ],
  "description": "There are some robots and factories on the X-axis. You are given an integer array robot where robot[i] is the position of the ith robot. You are also given a 2D integer array factory where factory[j] = [positionj, limitj] indicates that positionj is the position of the jth factory and that the jth factory can repair at most limitj robots.\nThe positions of each robot are unique. The positions of each factory are also unique. Note that a robot can be in the same position as a factory initially.\nAll the robots are initially broken; they keep moving in one direction. The direction could be the negative or the positive direction of the X-axis. When a robot reaches a factory that did not reach its limit, the factory repairs the robot, and it stops moving.\nAt any moment, you can set the initial direction of moving for some robot. Your target is to minimize the total distance traveled by all the robots.\nReturn the minimum total distance traveled by all the robots. The test cases are generated such that all the robots can be repaired.\nNote that\nExample 1:\nExample 2:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: robot = [0,4,6], factory = [[2,2],[6,2]]\nOutput: 4\nExplanation: As shown in the figure:\n- The first robot at position 0 moves in the positive direction. It will be repaired at the first factory.\n- The second robot at position 4 moves in the negative direction. It will be repaired at the first factory.\n- The third robot at position 6 will be repaired at the second factory. It does not need to move.\nThe limit of the first factory is 2, and it fixed 2 robots.\nThe limit of the second factory is 2, and it fixed 1 robot.\nThe total distance is |2 - 0| + |2 - 4| + |6 - 6| = 4. It can be shown that we cannot achieve a better total distance than 4.",
      "images": [
        "https://assets.leetcode.com/uploads/2022/09/15/example1.jpg"
      ]
    },
    {
      "example_num": 2,
      "example_text": "Input: robot = [1,-1], factory = [[-2,1],[2,1]]\nOutput: 2\nExplanation: As shown in the figure:\n- The first robot at position 1 moves in the positive direction. It will be repaired at the second factory.\n- The second robot at position -1 moves in the negative direction. It will be repaired at the first factory.\nThe limit of the first factory is 1, and it fixed 1 robot.\nThe limit of the second factory is 1, and it fixed 1 robot.\nThe total distance is |2 - 1| + |(-2) - (-1)| = 2. It can be shown that we cannot achieve a better total distance than 2.",
      "images": [
        "https://assets.leetcode.com/uploads/2022/09/15/example-2.jpg"
      ]
    }
  ],
  "constraints": [
    "1 <= robot.length, factory.length <= 100",
    "factory[j].length == 2",
    "-109 <= robot[i], positionj <= 109",
    "0 <= limitj <= robot.length",
    "The input will be generated such that it is always possible to repair every robot."
  ],
  "follow_ups": [],
  "hints": [
    "Sort robots and factories by their positions.",
    "After sorting, notice that each factory should repair some subsegment of robots.",
    "Find the minimum total distance to repair first i robots with first j factories."
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    long long minimumTotalDistance(vector<int>& robot, vector<vector<int>>& factory) {\n        \n    }\n};",
    "java": "class Solution {\n    public long minimumTotalDistance(List<Integer> robot, int[][] factory) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def minimumTotalDistance(self, robot, factory):\n        \"\"\"\n        :type robot: List[int]\n        :type factory: List[List[int]]\n        :rtype: int\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def minimumTotalDistance(self, robot: List[int], factory: List[List[int]]) -> int:\n        ",
    "c": "long long minimumTotalDistance(int* robot, int robotSize, int** factory, int factorySize, int* factoryColSize) {\n    \n}",
    "csharp": "public class Solution {\n    public long MinimumTotalDistance(IList<int> robot, int[][] factory) {\n        \n    }\n}",
    "javascript": "/**\n * @param {number[]} robot\n * @param {number[][]} factory\n * @return {number}\n */\nvar minimumTotalDistance = function(robot, factory) {\n    \n};",
    "typescript": "function minimumTotalDistance(robot: number[], factory: number[][]): number {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param Integer[] $robot\n     * @param Integer[][] $factory\n     * @return Integer\n     */\n    function minimumTotalDistance($robot, $factory) {\n        \n    }\n}",
    "swift": "class Solution {\n    func minimumTotalDistance(_ robot: [Int], _ factory: [[Int]]) -> Int {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun minimumTotalDistance(robot: List<Int>, factory: Array<IntArray>): Long {\n        \n    }\n}",
    "dart": "class Solution {\n  int minimumTotalDistance(List<int> robot, List<List<int>> factory) {\n    \n  }\n}",
    "golang": "func minimumTotalDistance(robot []int, factory [][]int) int64 {\n    \n}",
    "ruby": "# @param {Integer[]} robot\n# @param {Integer[][]} factory\n# @return {Integer}\ndef minimum_total_distance(robot, factory)\n    \nend",
    "scala": "object Solution {\n    def minimumTotalDistance(robot: List[Int], factory: Array[Array[Int]]): Long = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn minimum_total_distance(robot: Vec<i32>, factory: Vec<Vec<i32>>) -> i64 {\n        \n    }\n}",
    "racket": "(define/contract (minimum-total-distance robot factory)\n  (-> (listof exact-integer?) (listof (listof exact-integer?)) exact-integer?)\n  )",
    "erlang": "-spec minimum_total_distance(Robot :: [integer()], Factory :: [[integer()]]) -> integer().\nminimum_total_distance(Robot, Factory) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec minimum_total_distance(robot :: [integer], factory :: [[integer]]) :: integer\n  def minimum_total_distance(robot, factory) do\n    \n  end\nend"
  },
  "solution": "[TOC]\n\n## Solution\n\n--- \n\n### Overview\n\nThe goal is to minimize the total distance that a set of robots must travel to reach factories for repairs. We are given:\n\n1. An integer array `robot`, with unique starting positions of robots on the X-axis.\n2. A 2D integer array `factory`, where each sub-array $[position_j, limit_j]$ represents the position of the `j`-th factory and its maximum repair capacity.\n\nThe robots, initially non-operational, move along the X-axis until reaching a factory capable of repairing them. To minimize the total travel distance, we need to set their initial movement direction strategically.\n\nImportant rules:\n- Robots move at the same speed and will not collide, regardless of direction.\n- Robots bypass factories that have reached their repair limit.\n- Distance is measured as the absolute difference between each robot's starting and final positions.\n\n---\n\n### Approach 1: Recursion (Time Limit Exceeded)\n\n#### Intuition\n\nTo minimize the total distance traveled by robots assigned to factories, we should aim to pair each robot with a nearby factory. Sorting both robots and factories by position lets us efficiently match each robot to a close factory.Analysis of the Optimal Solution for Assigning Robots to Factories: Why Does Sorting Always Work? (Click Here)Many solutions use sorting, but we found that the explanations for why sorting leads to an optimal solution werenâ€™t convincing. Some explanations seemed to assume that the optimal solution naturally emerges from sorting, which felt like circular reasoning to me.\n\n  The core question is why, in an optimal solution, a contiguous sequence of robots must be assigned to a given factory, and the next sequence of robots should be assigned to the following factory, rather than looping back to the previous one. To explore this, we used a case study with a simplified scenario: only two robots and two factories, with each factory capable of repairing only one robot. And We are taking the base as this for Sorting.\n \n  **Terminologies**\n  - `r1`, `r2`: robot locations, where `r1 < r2`\n  - `f1`, `f2`: factory locations, where `f1 < f2`\n  - **distance 1**: distance by assigning `r1` to `f1` and `r2` to `f2`\n  - **distance 2**: distance by assigning `r1` to `f2` and `r2` to `f1`\n\n  **Case Study**\n\n  In this setup, we consider 6 cases based on the relative positions of robots and factories:\n\n  1. **Case 1**\n     - **Locations**:\n       ```\n       r1    r2\n       f1    f2\n       ```\n     - **distance 1**: `r1 - f1 + r2 - f2`\n     - **distance 2**: `f2 - r1 + r2 - f1`\n     - **Result**: `distance 1 < distance 2`\n\n  2. **Case 2**\n     - **Locations**:\n       ```\n       r1    r2\n       f1          f2\n       ```\n     - **distance 1**: `r1 - f1 + f2 - r2`\n     - **distance 2**: `f2 - r1 + r2 - f1`\n     - **Result**: `distance 1 < distance 2`\n\n  3. **Case 3**\n     - **Locations**:\n       ```\n       r1    r2\n          f1    f2\n       ```\n     - **distance 1**: `f1 - r1 + f2 - r2`\n     - **distance 2**: `f2 - r1 + r2 - f1`\n     - **Result**: `distance 1 < distance 2`\n\n  4. **Case 4**\n     - **Locations**:\n       ```\n                     r1    r2\n       f1    f2\n       ```\n     - **distance 1**: `r1 - f1 + r2 - f2`\n     - **distance 2**: `r1 - f2 + r2 - f1`\n     - **Result**: `distance 1 == distance 2`\n\n  5. **Case 5**\n     - **Locations**:\n       ```\n       r1        r2\n          f1  f2\n       ```\n     - **distance 1**: `f1 - r1 + r2 - f2`\n     - **distance 2**: `f2 - r1 + r2 - f1`\n     - **Result**: `distance 1 < distance 2`\n\n  6. **Case 6**\n     - **Locations**:\n       ```\n       r1    r2\n                 f1    f2\n       ```\n     - **distance 1**: `f1 - r1 + f2 - r2`\n     - **distance 2**: `f2 - r1 + f1 - r2`\n     - **Result**: `distance 1 == distance 2`\n\n  In all cases, assigning `r1` to `f1` and `r2` to `f2` yields a distance that is either shorter or equal to the distance of assigning `r1` to `f2` and `r2` to `f1`. In cases 4 and 6, the distances are the same, meaning we can assign `r1` to `f1` and `r2` to `f2` without affecting optimality.\n\n  This outcome implies that if `r1` is assigned to `f1`, then `r2` should consider only `f1` or the next factories, not any factory before `f1`. This supports why sorting works as an effective strategy for this problem.\n\nThis case study forms the foundation of the entire editorial and all the approaches that follow.Once sorted, we use a recursive approach to define a function `minDistance(robotIdx, factoryIdx)`, which calculates the minimum distance for assigning robots starting from `robotIdx` to factories starting from `factoryIdx`.\n\nFor each robot-factory pair, we have two options:\n  - Assign the robot to the current factory and move to the next robot `(robotIdx + 1, factoryIdx + 1, robot, factoryPositions)`.\n  - Skip the current factory and try the next one `(robotIdx, factoryIdx + 1, robot, factoryPositions)`.\n\nThe base case occurs when we run out of robots, yielding a distance of zero since all robots are assigned, or when we run out of factories, where we return a large number (e.g., $1e12$) to indicate an impossible assignment.\n\nWhile this approach is simple, it recalculates the same assignments for similar pairs, resulting in unnecessary repetition and potentially causing a Time Limit Exceeded (TLE) error.\n\n#### Algorithm\n\n- Sort the `robot` array and the `factory` array by their positions to facilitate the assignment process.\n\n- Flatten the `factory` array into `factoryPositions` based on their capacities:\n  - For each factory, repeat its position according to its capacity, resulting in a list of positions where robots can be assigned.\n\n- Call the `calculateMinDistance` function recursively to compute the minimum total distance:\n  - Pass the current indices of the robot (`robotIdx`) and factory positions (`factoryIdx`).\n\n- In the `calculateMinDistance` function:\n  - Check if all robots are assigned:\n    - If yes, return `0` since thereâ€™s no distance left to calculate.\n  \n  - Check if there are no factories left to assign:\n    - If yes, return a large value (`1e12`) to signify an impossible assignment.\n  \n  - Option 1: Assign the current robot to the current factory:\n    - Calculate the distance as the absolute difference between the current robot and factory positions, then add the result of the recursive call for the next robot and the next factory.\n  \n  - Option 2: Skip the current factory for the current robot:\n    - Recursively call `calculateMinDistance` for the same robot but the next factory.\n  \n  - Return the minimum of the two options (assign or skip) to ensure the minimum total distance is calculated.\n\n#### Implementation#### Complexity Analysis\n\nLet $n$ be the number of robots and $m$ be the number of factories.\n\n- Time complexity: $O(n^2 \\cdot m)$\n\n    The main function `minimumTotalDistance` involves sorting the `robot` array and the `factory` array. Sorting each of these arrays has a time complexity of $O(n \\log n)$ and $O(m \\log m)$, respectively.\n\n    The nested loops that flatten the factory positions contribute an additional $O(k)$ for pushing the factory positions into the `factoryPositions` array. If every factory has a capacity of $k$, the overall number of positions pushed could be $O(k \\cdot m)$. In the worst case, this could lead to $O(n \\cdot m)$ positions if we consider $k$ to be on the order of $n$.\n\n    The recursive function `calculateMinDistance` is called for each robot and factory position. This results in up to $O(n \\cdot k)$ recursive calls, where $k$ can be up to $n \\cdot m$ in the extreme case. Thus, the recursive calls lead to $O(n^2 \\cdot m)$.\n\n    Therefore, the dominant factor is the recursive calls, leading to the overall time complexity being $O(n^2 \\cdot m)$.\n\n- Space complexity: $O(n + m)$\n\n    - The space complexity arises from:\n        - The recursion stack used in `calculateMinDistance`, which can go as deep as $O(n + m)$ in the worst case if all robots and factories are utilized.\n        - The `factoryPositions` array, which can store up to $O(k \\cdot m)$ positions, where $k$ is the maximum capacity across all factories. However, this is not strictly dependent on $n$ or $m$, but it's still reasonable to consider it as contributing to the overall space used.\n\n    The space taken by the sorting algorithm depends on the language of implementation:\n      In Java, `Arrays.sort()` is implemented using a variant of the Quick Sort algorithm which has a space complexity of $O( \\log n)$.\n      In C++, the `sort()` function is implemented as a hybrid of Quick Sort, Heap Sort, and Insertion Sort, with a worst-case space complexity of $O(\\log n)$.\n      In Python, the `sort()` method sorts a list using the Timsort algorithm which is a combination of Merge Sort and Insertion Sort and has a space complexity of $O(n)$.\n\n    Therefore, the total space complexity can be considered $O(n + m)$ due to the recursive stack and the additional storage used for `factoryPositions`.\n\n---\n\n### Approach 2: Memoization\n\n#### Intuition \n\nSeeing the redundancy in our recursive approach, we can optimize it using memoization. Memoization lets us store previously computed results, avoiding recalculating distances for the same robot-factory pairs:\n\nWe introduce a table (or cache) that stores results for each combination of `robotIdx` and `factoryIdx`. Every time `minDistance(robotIdx, factoryIdx)` is called, we first check the memoization table. If weâ€™ve already calculated the result for this combination, we simply return it.\n\nThe approach is still recursive but much faster because it avoids revisiting the same subproblems multiple times.\n\n#### Algorithm\n\n- Sort the `robot` and `factory` arrays by their positions to facilitate optimal assignment.\n  \n- Create a `factoryPositions` array:\n  - Flatten the factory positions based on their capacities, where each factory contributes its position as many times as its capacity.\n\n- Initialize `robotCount` as the number of robots and `factoryCount` as the number of factory positions.\n  \n- Create a 2D memoization table `memo` with dimensions `[robotCount][factoryCount]` initialized to `-1`.\n\n- Call the recursive function `calculateMinDistance(0, 0, robot, factoryPositions, memo)` to compute the minimum total distance.\n\n- In the `calculateMinDistance` function:\n  - Check if all robots are assigned (`robotIdx == robot.size()`):\n    - If true, return `0` since no distance is needed.\n    \n  - Check if there are no factories left to assign (`factoryIdx == factoryPositions.size()`):\n    - If true, return a large value (e.g., `1e12`) to indicate an infeasible path.\n\n  - Check the memoization table to see if the result is already computed (`memo[robotIdx][factoryIdx] != -1`):\n    - If true, return the memoized value.\n  \n  - Calculate the cost for two options:\n    - Option 1: Assign the current robot to the current factory:\n      - Compute the distance as `abs(robot[robotIdx] - factoryPositions[factoryIdx])` plus the result of recursively calling `calculateMinDistance` for the next robot and the next factory.\n      \n    - Option 2: Skip the current factory for the current robot:\n      - Call `calculateMinDistance` with the same robot but the next factory.\n      \n  - Store the minimum of the two options in `memo[robotIdx][factoryIdx]` and return this minimum value.\n\n- The function returns the minimum total distance to assign all robots to factories efficiently.\n\n#### Implementation#### Complexity Analysis\n\nLet $n$ be the number of robots and $m$ be the number of factories.\n\n- Time complexity: $O(n^2 \\cdot m)$\n\n    Similar to the previous analysis, the function `minimumTotalDistance` involves sorting the `robot` and `factory` arrays, which has a time complexity of $O(n \\log n)$ and $O(m \\log m)$, respectively.\n\n    The nested loops that flatten the factory positions can create up to $O(n \\cdot m)$ positions in the worst case, where $n$ is the number of robots and $m$ is the number of original factories. If each factory has a maximum capacity equal to $n$, we could end up with $O(n^2)$ factory positions in total.\n\n    The recursive function `calculateMinDistance` now uses memoization to store results for each combination of `robotIdx` and `factoryIdx`. Since each robot can potentially pair with each factory position, the number of unique state combinations is now $O(n \\cdot m)$. However, the recursive calls can lead to up to $O(n)$ depth due to each robot potentially iterating through all factory positions.\n\n    Therefore, the overall time complexity is more accurately represented as $O(n^2 \\cdot m)$, as the flattening of factory positions majorily influences the complexity.\n\n- Space complexity: $O(n \\cdot m)$\n\n    - The space complexity consists of:\n        - The `memo` table, which is a 2D array of size $n \\times m$. Thus, the space used for memoization is $O(n \\cdot m)$.\n        - The recursion stack used in `calculateMinDistance`, which can go as deep as $O(n + m)$ in the worst case if all robots and factories are utilized.\n        - The `factoryPositions` array, which can store up to $O(k \\cdot m)$ positions, though it is less critical for the overall complexity assessment.\n\n    The space taken by the sorting algorithm depends on the language of implementation:\n      In Java, `Arrays.sort()` is implemented using a variant of the Quick Sort algorithm which has a space complexity of $O( \\log n)$.\n      In C++, the `sort()` function is implemented as a hybrid of Quick Sort, Heap Sort, and Insertion Sort, with a worst-case space complexity of $O(\\log n)$.\n      In Python, the `sort()` method sorts a list using the Timsort algorithm which is a combination of Merge Sort and Insertion Sort and has a space complexity of $O(n)$.\n\n    The dominant space usage comes from the `memo` table, leading to a total space complexity of $O(n \\cdot m)$.\n\n---\n\n### Approach 3: Tabulation\n\n#### Intuition\n\nWhile recursive memoization optimizes by caching results, it still incurs overhead from recursive calls. To further improve, we can switch to a bottom-up tabulation approach, filling a 2D DP table iteratively to store results for each subproblem.\n\nEach robot has two options: go to the current factory or skip it. For each robot-factory pairing, we need the robotâ€™s and factoryâ€™s positions to calculate the distance and then find the minimum distance if the robot is assigned to this factory or skips to the next.\n\nUsing a 2D DP table, let `dp[i][j]` represent the minimum distance to assign robots starting from `i` to factories starting from `j`. We fill this table from the last robot and factory backward to ensure all future-dependent choices are precomputed.\n\nThe base case is when there are no robots left (`i` exceeds the last robot index), giving a minimum distance of `0`.\n\nFor each `dp[i][j]`, we choose the minimum of:\n  - Assigning robot `i` to factory `j`, moving to `dp[i + 1][j]`,\n  - Or skipping this factory, moving to `dp[i][j + 1]`.\n\nThus, $dp[i][j] = \\min(|robot[i] - factory[j]| + dp[i + 1][j+1], dp[i][j + 1])$.\n\nAfter filling the table, `dp[0][0]` holds the minimum distance to assign all robots from the first factory onward.\n\n#### Algorithm\n\n- Sort the `robot` array and the `factory` array based on their positions to ensure efficient matching.\n\n- Flatten the factory positions into a single array `factoryPositions` according to their capacities, where each factory's position is repeated as many times as its capacity allows.\n\n- Initialize `robotCount` to the number of robots and `factoryCount` to the number of factory positions.\n\n- Create a 2D dynamic programming (DP) table `dp` of size `(robotCount + 1) x (factoryCount + 1)` initialized to zero, where `dp[i][j]` represents the minimum total distance for assigning robots from `i` to `robotCount - 1` using factories from `j` to `factoryCount - 1`.\n\n- Set base cases:\n  - For each robot `i`, set `dp[i][factoryCount]` to a large value (`1e12`) to represent that there are no factories left for assignment.\n\n- Fill the DP table using a bottom-up approach:\n  - Iterate backward through each robot `i` from `robotCount - 1` to `0`.\n  - For each robot, iterate backward through each factory `j` from `factoryCount - 1` to `0`:\n    - Calculate the distance for the current robot to the current factory and add the result of assigning the next robot to the next factory:  \n      `assign = abs(robot[i] - factoryPositions[j]) + dp[i + 1][j + 1]`\n    \n    - Also consider skipping the current factory for the current robot:  \n      `skip = dp[i][j + 1]`\n    \n    - Update `dp[i][j]` with the minimum of the two options:  \n      `dp[i][j] = min(assign, skip)`\n\n- Return the value at `dp[0][0]`, which represents the minimum total distance starting from the first robot and the first factory.\n\n#### Implementation#### Complexity Analysis\n\nLet $n$ be the number of robots and $m$ be the number of factories.\n\n- Time complexity: $O(m \\cdot n^2)$\n\n    The function `minimumTotalDistance` starts by sorting the `robot` and `factory` arrays, which takes $O(n \\log n)$ and $O(m \\log m)$ respectively.\n    \n    Flattening the factories based on their capacities can result in up to $O(m \\cdot n)$ factory positions if each factory has a capacity up to $n$. This flattening step requires $O(m \\cdot n)$ time.\n\n    After flattening, the DP table is filled in a bottom-up manner. The tableâ€™s size is $O(n \\cdot (m \\cdot n))$, where each entry depends on evaluating two options for each pair of robots and factory positions. This makes the overall time complexity of filling the DP table $O(m \\cdot n^2)$.\n\n- Space complexity: $O(n \\cdot m)$\n\n    The space complexity is primarily determined by the DP table, which is a 2D array of size $(n + 1) \\times (m + 1)$. This leads to a space complexity of $O(n \\cdot m)$.\n    \n    The space taken by the sorting algorithm depends on the language of implementation:\n      In Java, `Arrays.sort()` is implemented using a variant of the Quick Sort algorithm which has a space complexity of $O( \\log n)$.\n      In C++, the `sort()` function is implemented as a hybrid of Quick Sort, Heap Sort, and Insertion Sort, with a worst-case space complexity of $O(\\log n)$.\n      In Python, the `sort()` method sorts a list using the Timsort algorithm which is a combination of Merge Sort and Insertion Sort and has a space complexity of $O(n)$.\n\n    Although additional space is used for storing the `factoryPositions` array, it is not as significant in terms of complexity compared to the DP table.\n\n    Thus, the total space complexity remains $O(n \\cdot m)$.\n\n---\n\n### Approach 4: Space Optimized Tabulation\n\n#### Intuition\n\nThe 2D table approach uses more space than necessary. We can reduce space complexity from $O(n \\cdot m)$ to $O(m)$ by using a 1D DP array.\n\nSince calculating `current[i][j]` only requires values from the next row (`current[i + 1][...]`), we can maintain only two rows: one for the current state weâ€™re filling and one for the next state holding results from the previous robot in the iteration.\n\nBy iterating backwards over robots and factories, we can use a single array, `current`, of size equal to the number of factories. Starting from the last robot, we iterate over factories in reverse, updating `current[j]` in place using `current[j + 1]` (for skipping the factory) and `current[j + 1] + |robot[i] - factoryPositions[j]|` (for assigning this factory).\n\nThis ensures `current[j]` holds the minimum distance for that subproblem. After finishing the iteration, `current[0]` will contain the minimum distance for assigning all robots to factories.\n\nThe algorithm is visualized below:\n\n!?!../Documents/2463/approach4.json:845,950!?!\n\n#### Algorithm\n\n- Sort the `robots` array and the `factories` array by their positions to facilitate distance calculations.\n\n- Flatten the `factories` into a `factoryPositions` array based on their capacities:\n  - For each factory in `factories`, add its position to `factoryPositions` as many times as its capacity allows.\n\n- Initialize variables:\n  - `robotCount` to store the number of robots.\n  - `factoryCount` to store the number of factory positions.\n  - Two arrays, `next` and `current`, both of size `factoryCount + 1`, initialized to 0. These will be used for dynamic programming.\n\n- Initialize `current[factoryCount]` to a large value (1e12) for the current robot's calculations.\n\n- Fill the dynamic programming (DP) table using two rows for optimization:\n  - Iterate over the robots in reverse order:    \n    - For each factory position (also iterated in reverse):\n      - Calculate the distance if the current robot is assigned to the current factory:\n        - Use `assign = abs(robots[i] - factoryPositions[j]) + next[j + 1]`.\n      - Calculate the distance if the current factory is skipped for this robot:\n        - Use `skip = current[j + 1]`.\n      - Store the minimum of `assign` and `skip` in `current[j]`.\n\n    - Move to the next robot by updating `next` to be equal to `current`.\n\n- After processing all robots, return `current[0]`, which contains the minimum total distance for assigning all robots to factories.\n\n#### Implementation#### Complexity Analysis\n\nLet $n$ be the number of robots and $m$ be the number of factories.\n\n- Time complexity: $O(m \\cdot n^2)$\n\n    The function `minimumTotalDistance` begins by sorting the `robots` and `factories` arrays, which have a time complexity of $O(n \\log n)$ and $O(m \\log m)$ respectively.\n\n    The nested loops that flatten the factory positions based on each factory's capacity have a time complexity of $O(m \\cdot n)$, as each factory can contribute up to $n$ positions. In the worst case, this results in a flattened `factoryPositions` array with $O(m \\cdot n)$ items.\n\n    The DP table is then filled using two rows to optimize space. The outer loop iterates through each robot, running $n$ times, and the inner loop iterates through the flattened factory positions, running $m \\cdot n$ times. Thus, filling the DP table has a time complexity of $O(n \\cdot (m \\cdot n)) = O(m \\cdot n^2)$.\n\n- Space complexity: $O(m + S)$\n\n    The space complexity is determined by the two 1D arrays: `next` and `current`, each of size $m + 1$. This gives a space complexity of $O(m)$.\n\n    The space taken by the sorting algorithm depends ($S$) on the language of implementation:\n      In Java, `Arrays.sort()` is implemented using a variant of the Quick Sort algorithm which has a space complexity of $O( \\log S)$.\n      In C++, the `sort()` function is implemented as a hybrid of Quick Sort, Heap Sort, and Insertion Sort, with a worst-case space complexity of $O(\\log S)$.\n      In Python, the `sort()` method sorts a list using the Timsort algorithm which is a combination of Merge Sort and Insertion Sort and has a space complexity of $O(S)$.\n\n    Although the approach also uses the `factoryPositions` array to store factory positions, its impact on the overall complexity assessment is less compared to the other factors.\n\n    Therefore, the total space complexity is primarily driven by the two rows used in the DP calculation and sorting, leading to a space complexity of $O(m + S)$.\n\n---"
}