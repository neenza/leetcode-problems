{
  "title": "Maximum Value Sum by Placing Three Rooks II",
  "problem_id": "3542",
  "frontend_id": "3257",
  "difficulty": "Hard",
  "problem_slug": "maximum-value-sum-by-placing-three-rooks-ii",
  "topics": [
    "Array",
    "Dynamic Programming",
    "Matrix",
    "Enumeration"
  ],
  "description": "You are given a m x n 2D array board representing a chessboard, where board[i][j] represents the value of the cell (i, j).\nRooks in the same row or column attack each other. You need to place three rooks on the chessboard such that the rooks do not attack each other.\nReturn the maximum sum of the cell values on which the rooks are placed.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: board = [[-3,1,1,1],[-3,1,-3,1],[-3,2,1,1]]\nOutput: 4\nExplanation:\n\nWe can place the rooks in the cells (0, 2) , (1, 3) , and (2, 1) for a sum of 1 + 1 + 2 = 4 .",
      "images": [
        "https://assets.leetcode.com/uploads/2024/08/08/rooks2.png"
      ]
    },
    {
      "example_num": 2,
      "example_text": "Input: board = [[1,2,3],[4,5,6],[7,8,9]]\nOutput: 15\nExplanation:\nWe can place the rooks in the cells (0, 0) , (1, 1) , and (2, 2) for a sum of 1 + 5 + 9 = 15 .",
      "images": []
    },
    {
      "example_num": 3,
      "example_text": "Input: board = [[1,1,1],[1,1,1],[1,1,1]]\nOutput: 3\nExplanation:\nWe can place the rooks in the cells (0, 2) , (1, 1) , and (2, 0) for a sum of 1 + 1 + 1 = 3 .",
      "images": []
    }
  ],
  "constraints": [
    "3 <= m == board.length <= 500",
    "3 <= n == board[i].length <= 500",
    "-109 <= board[i][j] <= 109"
  ],
  "follow_ups": [],
  "hints": [
    "Save the top 3 largest values in each row.",
    "Select any row, and select any of the three values stored in it.",
    "Get the top 4 values from all of the other 3 largest values of the other rows, which do not share the same column as the selected value.",
    "Brute force the selection of 2 positions from the top 4 now."
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    long long maximumValueSum(vector<vector<int>>& board) {\n        \n    }\n};",
    "java": "class Solution {\n    public long maximumValueSum(int[][] board) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def maximumValueSum(self, board):\n        \"\"\"\n        :type board: List[List[int]]\n        :rtype: int\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def maximumValueSum(self, board: List[List[int]]) -> int:\n        ",
    "c": "long long maximumValueSum(int** board, int boardSize, int* boardColSize) {\n    \n}",
    "csharp": "public class Solution {\n    public long MaximumValueSum(int[][] board) {\n        \n    }\n}",
    "javascript": "/**\n * @param {number[][]} board\n * @return {number}\n */\nvar maximumValueSum = function(board) {\n    \n};",
    "typescript": "function maximumValueSum(board: number[][]): number {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param Integer[][] $board\n     * @return Integer\n     */\n    function maximumValueSum($board) {\n        \n    }\n}",
    "swift": "class Solution {\n    func maximumValueSum(_ board: [[Int]]) -> Int {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun maximumValueSum(board: Array<IntArray>): Long {\n        \n    }\n}",
    "dart": "class Solution {\n  int maximumValueSum(List<List<int>> board) {\n    \n  }\n}",
    "golang": "func maximumValueSum(board [][]int) int64 {\n    \n}",
    "ruby": "# @param {Integer[][]} board\n# @return {Integer}\ndef maximum_value_sum(board)\n    \nend",
    "scala": "object Solution {\n    def maximumValueSum(board: Array[Array[Int]]): Long = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn maximum_value_sum(board: Vec<Vec<i32>>) -> i64 {\n        \n    }\n}",
    "racket": "(define/contract (maximum-value-sum board)\n  (-> (listof (listof exact-integer?)) exact-integer?)\n  )",
    "erlang": "-spec maximum_value_sum(Board :: [[integer()]]) -> integer().\nmaximum_value_sum(Board) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec maximum_value_sum(board :: [[integer]]) :: integer\n  def maximum_value_sum(board) do\n    \n  end\nend"
  }
}