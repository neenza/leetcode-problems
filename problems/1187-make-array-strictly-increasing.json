{
  "title": "Make Array Strictly Increasing",
  "problem_id": "1290",
  "frontend_id": "1187",
  "difficulty": "Hard",
  "problem_slug": "make-array-strictly-increasing",
  "topics": [
    "Array",
    "Binary Search",
    "Dynamic Programming",
    "Sorting"
  ],
  "description": "Given two integer arrays arr1 and arr2, return the minimum number of operations (possibly zero) needed to make arr1 strictly increasing.\nIn one operation, you can choose two indices 0 <= i < arr1.length and 0 <= j < arr2.length and do the assignment arr1[i] = arr2[j].\nIf there is no way to make arr1 strictly increasing, return -1.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: arr1 = [1,5,3,6,7], arr2 = [1,3,2,4]\nOutput: 1\nExplanation: Replace 5 with 2, then arr1 = [1, 2, 3, 6, 7].",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input: arr1 = [1,5,3,6,7], arr2 = [4,3,1]\nOutput: 2\nExplanation: Replace 5 with 3 and then replace 3 with 4. arr1 = [1, 3, 4, 6, 7].",
      "images": []
    },
    {
      "example_num": 3,
      "example_text": "Input: arr1 = [1,5,3,6,7], arr2 = [1,6,3,3]\nOutput: -1\nExplanation: You can't make arr1 strictly increasing.",
      "images": []
    }
  ],
  "constraints": [
    "1 <= arr1.length, arr2.length <= 2000",
    "0 <= arr1[i], arr2[i] <= 10^9"
  ],
  "follow_ups": [],
  "hints": [
    "Use dynamic programming.",
    "The state would be the index in arr1 and the index of the previous element in arr2 after sorting it and removing duplicates."
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    int makeArrayIncreasing(vector<int>& arr1, vector<int>& arr2) {\n        \n    }\n};",
    "java": "class Solution {\n    public int makeArrayIncreasing(int[] arr1, int[] arr2) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def makeArrayIncreasing(self, arr1, arr2):\n        \"\"\"\n        :type arr1: List[int]\n        :type arr2: List[int]\n        :rtype: int\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def makeArrayIncreasing(self, arr1: List[int], arr2: List[int]) -> int:\n        ",
    "c": "int makeArrayIncreasing(int* arr1, int arr1Size, int* arr2, int arr2Size) {\n    \n}",
    "csharp": "public class Solution {\n    public int MakeArrayIncreasing(int[] arr1, int[] arr2) {\n        \n    }\n}",
    "javascript": "/**\n * @param {number[]} arr1\n * @param {number[]} arr2\n * @return {number}\n */\nvar makeArrayIncreasing = function(arr1, arr2) {\n    \n};",
    "typescript": "function makeArrayIncreasing(arr1: number[], arr2: number[]): number {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param Integer[] $arr1\n     * @param Integer[] $arr2\n     * @return Integer\n     */\n    function makeArrayIncreasing($arr1, $arr2) {\n        \n    }\n}",
    "swift": "class Solution {\n    func makeArrayIncreasing(_ arr1: [Int], _ arr2: [Int]) -> Int {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun makeArrayIncreasing(arr1: IntArray, arr2: IntArray): Int {\n        \n    }\n}",
    "dart": "class Solution {\n  int makeArrayIncreasing(List<int> arr1, List<int> arr2) {\n    \n  }\n}",
    "golang": "func makeArrayIncreasing(arr1 []int, arr2 []int) int {\n    \n}",
    "ruby": "# @param {Integer[]} arr1\n# @param {Integer[]} arr2\n# @return {Integer}\ndef make_array_increasing(arr1, arr2)\n    \nend",
    "scala": "object Solution {\n    def makeArrayIncreasing(arr1: Array[Int], arr2: Array[Int]): Int = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn make_array_increasing(arr1: Vec<i32>, arr2: Vec<i32>) -> i32 {\n        \n    }\n}",
    "racket": "(define/contract (make-array-increasing arr1 arr2)\n  (-> (listof exact-integer?) (listof exact-integer?) exact-integer?)\n  )",
    "erlang": "-spec make_array_increasing(Arr1 :: [integer()], Arr2 :: [integer()]) -> integer().\nmake_array_increasing(Arr1, Arr2) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec make_array_increasing(arr1 :: [integer], arr2 :: [integer]) :: integer\n  def make_array_increasing(arr1, arr2) do\n    \n  end\nend"
  },
  "solution": "[TOC]\n\n## Solution\n\n--- \n\n### Overview\n\nWe will iterate over `arr1` and at each index `i`, we aim to make the prefix `arr1[0 ~ i]` sorted. In case `arr1[i]` requires replacement with a value from `arr2`, the smallest element in `arr2` that will maintain increasing order is always preferred. Hence, by sorting `arr2`, we can efficiently identify the smallest element that meets this criterion using binary search, which takes logarithmic time. If `arr2` is not sorted, we would have to search the entire array to find the smallest element that meets this requirement, leading to a linear time complexity for each operation.\n\n\n![img](../Figures/1187/1.png)\n\nTherefore, all subsequent solutions are based on the sorted `arr2`.\n\n---\n\n### Approach 1: Top-down Dynamic Programming\n\n#### Intuition   \n\n> If you are not familiar with dynamic programming, please refer to our explore cards [Dynamic Programming Explore Card](https://leetcode.com/explore/featured/card/dynamic-programming/). We will focus on the usage in this article and not the underlying principles or implementation details.\n\n\nAs we update `arr1` from left to right, each element `arr1[i]` can be subjected to several potential operations:\n\n- If `arr1[i]` is less than or equal to `arr1[i - 1]`, we **must** replace `arr1[i]` with the smallest value in `arr2`that is greater than `arr1[i - 1]`,  which we can identify using binary search. Otherwise, we can't make `arr1` sorted.\n\n\n![img](../Figures/1187/2.png)\n\n- If `arr1[i]` is greater than `arr1[i - 1]`, we have two possible options:\n\n    - Leave it unchanged and continue with the next index. No changes need to be made as `arr1[i]` is already greater than `arr1[i - 1]`.\n    - Replace it with a smaller value (as doing so may make it easier to ensure that subsequent numbers are greater than `arr1[i]`). We will use binary search to locate the smallest value greater than `arr1[i - 1]` in `arr2`.\n\n![img](../Figures/1187/3.png)\n\nIn summary:\n\n![img](../Figures/1187/4.png)We utilize a recursive approach named `dfs(i)` to determine the minimum number of operations needed to make the subarray `arr1[i:]` sorted. Given that we modify `arr1[i]` based on the value of `arr[i - 1]`, `dfs` requires an additional parameter called `prev`, which represents the value of `arr1[i - 1]`. Hence, the complete function is defined as `dfs(i, prev)`.\n\nSince there is no preceding element for the first element of `arr1`, we can assign an imaginary value of `-1` before `arr1[0]`. This allows `dfs` to operate on the first element with `prev = -1`.\n\nConsider the following figure, which illustrates the recursive steps of `dfs(i = 0, prev = -1)`:\n\n![img](../Figures/1187/5.png)\n\nStarting from the first element of `arr1`, we compare `arr1[0]` to `prev = -1`. Since `arr1[0]` is greater than `prev`, we do not need to make any changes and call `dfs` recursively on the next index by passing the current value `1` as `prev`, which is `dfs(0, -1)` = `dfs(1, 1)`.\n\n![img](../Figures/1187/6.png)\n\nMoving on to the next element `arr1[1]`, we compare it to `prev = 1` (which is the value of the previous element `arr1[0]`).\n\n![img](../Figures/1187/7.png)\n\n\nAs `arr1[1] = 5` is larger than `prev = 1`, there are two options in `dfs(1, 1)`:\n- Leave `arr1[1]` unchanged and continue with the next index, requiring no operation: `dfs(1, 1) = dfs(2, 5)`.\n- Find the smallest value in `arr2` that is greater than `prev` by binary search (which is `2`), since `2` is smaller than `arr[1]`, we can replace `arr1[1]` with `2`, and recursively call `dfs` on the next index, which is `dfs(1, 1) = 1 + dfs(2, 2)`.\n\n![img](../Figures/1187/8.png)\n\nTherefore, `dfs(1, 1)` can be obtained by taking the minimum value between `dfs(1, 1) = min(dfs(2, 5), 1 + dfs(2, 2))`.If `arr1[i]` cannot be replaced with any valid value in `arr2` when it needs to be changed, `dfs` returns a large number such as `inf` to indicate that it is impossible to make `arr1` sorted.\n\nWe use memoization to store the minimum number of operations to reach each state `(i, prev)`, which improves the efficiency of the algorithm. This helps us avoid re-solving the same subproblems multiple times and significantly reduces the time complexity.\n\nFinally, we call `dfs(0, -1)` and examine the value it returns. If the value is reasonable and smaller than the large one we assigned to impossible moves, we return the result of `dfs(0, -1)`. Otherwise, we return `-1`.#### Algorithm\n\n1) Sort `arr2`.\n\n2) Initialize a hash map `dp` as memory.\n\n3) Define a function `dfs(i, prev)` as the minimum number of operations to make `arr[i:]` sorted when `arr[i - 1] = prev`.\n\n    - Check if `(i, prev)` exists in `dp`, and if so, return `dp[(i, prev)]`\n    - Initialize `cost` to `float('inf')`\n    - If `arr1[i] > prev`, set `cost` to `dfs(i+1, arr1[i])`\n    - Find the index `idx` of the smallest value in `arr2` that is greater than `prev` using binary search. If `idx < len(arr2)`, set `cost` to `min(cost, 1 + dfs(i+1, arr2[idx]))`\n\n    - Update `dp[(i, prev)]` as `cost`\n    - Return `cost`\n\n4) Return the value of `dfs(0, -1)` if it is not equal to `float('inf')`, otherwise, return `-1`.\n\n#### Implementation#### Complexity Analysis\n\nLet $$m, n$$ be the length of `arr1` and `arr2`.\n\n* Time complexity: $$O(m \\cdot n \\cdot\\log n)$$\n\n    - Sorting `arr2` takes $$O(n \\log n)$$ time.\n    - To improve the efficiency of the algorithm, we use memoization and store the minimum number of operations to reach each state `(i, prev)` in a hash map `dp`. There are $$m$$ indices and at most $$n + 1$$ possible `prev` as we might replace `arr[i]` with any value in `arr2`. Each state is computed with a binary search over `arr2`, which takes $$O(\\log n)$$. \n    \n\n* Space complexity: $$O(m \\cdot n)$$\n\n    - The maximum number of distinct states in `dp` is $$m \\cdot n$$.---\n\n### Approach 2: Bottom-up Dynamic Programming\n\n#### Intuition   \n\nInstead of using recursion, we can also solve this problem iteratively. We start by initializing a hash map `dp` that stores each state we can reach for index `i`. Each state is represented as `{prev: count}`, where `prev` is the previous value and `count` is the minimum number of operations needed to reach this state.\n\nSimilar to the recursive solution, we set an imaginary value `-1` before `arr1[0]` and add an initial key-value pair of `{-1: 0}` to `dp`, indicating that reaching `prev = -1` takes no operations. \n\n![img](../Figures/1187/9.png)\n\nWe then iterate over `arr1` and for each index `i`, we initialize an empty dictionary `new_dp` to store the states we can reach for index `i`.\n\nLoop through all the states in `dp` and for each state `{prev: count}`: \n\n- If `arr1[i]` is less than or equal to `prev`, we **must** replace `arr1[i]` with the smallest value `arr2[index]` in `arr2` that is greater than `prev`, which we can identify using binary search. \n\n    - Create a new state `{arr2[index]: count + 1}`.\n    - Otherwise, we can't update this state at `i`.\n\n\n- If `arr1[i]` is greater than `prev`, there are two possible options:\n    - Leave it unchanged by creating state `{arr1[i]: count}` in `new_dp`.\n    - Replace `arr[i]` with a smaller value in `arr2` that is larger than `prev`. Once again, we will use binary search to locate the smallest value `arr2[index]` that is greater than `arr1[i - 1]` in `arr2`, create a state `{arr2[index]: count + 1}`.\n\n![img](../Figures/1187/13.png)\n\nAfter looping through all the keys in `dp`, we set `dp` to `new_dp` so it represents all reachable states at index `i`.Please refer to the following example:\n\nFor `i = 0`, `dp` has one state: `{-1: 0}`, since `arr[0] > prev`, we can leave `arr[0]` unchanged, thus we can reach a new state of `{1: 0}`, store it in `new_dp`.\n\n![img](../Figures/1187/10.png)\n\nContinue with `i = 1` by setting `dp` as `new_dp` and resetting `new_dp`. `dp` has one state `{1: 0}`, since `arr[1] > prev`, we can either:\n\n- Leave `arr[1]` unchanged and reach a new state `{5: 0}`.\n- Replace it with `arr2[1] = 2` with 1 operation, and reach another new state `{2: 1}`.\n\nTherefore, we have created two states `new_dp = {2: 1, 5: 0}` for index `1`. \n\n![img](../Figures/1187/11.png)\n\nDuring each iteration, `new_dp` stores the **minimum** number of operations needed to reach each state from the previous index. We can achieve this by initializing the value of each key in `new_dp` to a large number like `inf` and updating it as the minimum value we encounter.\n\nAfter iterating over `arr1`, we return the smallest value in `dp` as the minimum number of operations required to reach the last index and make the entire `arr1` sorted. If the value is `inf`, it indicates that there is no way to reach any states at the last index, and we return `-1`.#### Algorithm\n\n1) Sort `arr2`.\n\n2) Create a hash map `dp` with an initial key-value pair of `{-1: 0}`.\n\n3) Iterate over `arr1`, for each index `i`, create a new hash map `new_dp` with default value of `float('inf')` and do the following:\n\n4) Iterate over each key `prev` in `dp`:\n    - If `arr1[i]` is greater than `prev`, update `new_dp[arr1[i]]` as `min(new_dp[arr1[i]], dp[prev])`. \n    - Otherwise, find the index `idx` of the smallest value in `arr2` that is greater than `prev`. If such a value exists, update `new_dp[arr2[idx]]` as `min(new_dp[arr2[idx]], 1 + dp[prev])`.\n\nLet `dp = new_dp`, and repeat from step 3.\n\n5) When the iteration is complete, return the minimum value in `dp` if it is less than `float('inf')`, otherwise return `-1`.\n\n\n#### Implementation#### Complexity Analysis\n\nLet $$m, n$$ be the length of `arr1` and `arr2`.\n\n* Time complexity: $$O(m \\cdot n \\cdot\\log n)$$\n\n    - Sorting `arr2` takes $$O(n \\log n)$$ time.\n    - We update `dp` by $$m$$ rounds. In each round at index `i`, there are at most $$n + 1$$ possible `prev` as we might replace `arr[i]` with any of the $$n$$ values in `arr2` or leave it unchanged. Each state is computed with a binary search over all start times, which takes $$O(\\log n)$$. \n    \n\n* Space complexity: $$O(n)$$\n\n    - We keep track of all states `(i, prev)` of two latest indices in `dp` and `new_dp`, respectively. At each index, the number of possible distinct states is at most $$n + 1$$."
}