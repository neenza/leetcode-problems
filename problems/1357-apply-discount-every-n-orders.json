{
  "title": "Apply Discount Every n Orders",
  "problem_id": "1459",
  "frontend_id": "1357",
  "difficulty": "Medium",
  "problem_slug": "apply-discount-every-n-orders",
  "topics": [
    "Array",
    "Hash Table",
    "Design"
  ],
  "description": "There is a supermarket that is frequented by many customers. The products sold at the supermarket are represented as two parallel integer arrays products and prices, where the ith product has an ID of products[i] and a price of prices[i].\nWhen a customer is paying, their bill is represented as two parallel integer arrays product and amount, where the jth product they purchased has an ID of product[j], and amount[j] is how much of the product they bought. Their subtotal is calculated as the sum of each amount[j] * (price of the jth product).\nThe supermarket decided to have a sale. Every nth customer paying for their groceries will be given a percentage discount. The discount amount is given by discount, where they will be given discount percent off their subtotal. More formally, if their subtotal is bill, then they would actually pay bill * ((100 - discount) / 100).\nImplement the Cashier class:\nExample 1:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input\n[\"Cashier\",\"getBill\",\"getBill\",\"getBill\",\"getBill\",\"getBill\",\"getBill\",\"getBill\"]\n[[3,50,[1,2,3,4,5,6,7],[100,200,300,400,300,200,100]],[[1,2],[1,2]],[[3,7],[10,10]],[[1,2,3,4,5,6,7],[1,1,1,1,1,1,1]],[[4],[10]],[[7,3],[10,10]],[[7,5,3,1,6,4,2],[10,10,10,9,9,9,7]],[[2,3,5],[5,3,2]]]\nOutput\n[null,500.0,4000.0,800.0,4000.0,4000.0,7350.0,2500.0]\nExplanation\nCashier cashier = new Cashier(3,50,[1,2,3,4,5,6,7],[100,200,300,400,300,200,100]);\ncashier.getBill([1,2],[1,2]);                        // return 500.0. 1st customer, no discount.\n                                                     // bill = 1 * 100 + 2 * 200 = 500.\ncashier.getBill([3,7],[10,10]);                      // return 4000.0. 2nd customer, no discount.\n                                                     // bill = 10 * 300 + 10 * 100 = 4000.\ncashier.getBill([1,2,3,4,5,6,7],[1,1,1,1,1,1,1]);    // return 800.0. 3rd customer, 50% discount.\n                                                     // Original bill = 1600\n                                                     // Actual bill = 1600 * ((100 - 50) / 100) = 800.\ncashier.getBill([4],[10]);                           // return 4000.0. 4th customer, no discount.\ncashier.getBill([7,3],[10,10]);                      // return 4000.0. 5th customer, no discount.\ncashier.getBill([7,5,3,1,6,4,2],[10,10,10,9,9,9,7]); // return 7350.0. 6th customer, 50% discount.\n                                                     // Original bill = 14700, but with\n                                                     // Actual bill = 14700 * ((100 - 50) / 100) = 7350.\ncashier.getBill([2,3,5],[5,3,2]);                    // return 2500.0.  7th customer, no discount.",
      "images": []
    }
  ],
  "constraints": [
    "1 <= n <= 104",
    "0 <= discount <= 100",
    "1 <= products.length <= 200",
    "prices.length == products.length",
    "1 <= products[i] <= 200",
    "1 <= prices[i] <= 1000",
    "The elements in products are unique.",
    "1 <= product.length <= products.length",
    "amount.length == product.length",
    "product[j] exists in products.",
    "1 <= amount[j] <= 1000",
    "The elements of product are unique.",
    "At most 1000 calls will be made to getBill.",
    "Answers within 10-5 of the actual value will be accepted."
  ],
  "follow_ups": [],
  "hints": [
    "Keep track of the count of the customers.",
    "Check if the count of the customers is divisible by n then apply the discount formula."
  ],
  "code_snippets": {
    "cpp": "class Cashier {\npublic:\n    Cashier(int n, int discount, vector<int>& products, vector<int>& prices) {\n        \n    }\n    \n    double getBill(vector<int> product, vector<int> amount) {\n        \n    }\n};\n\n/**\n * Your Cashier object will be instantiated and called as such:\n * Cashier* obj = new Cashier(n, discount, products, prices);\n * double param_1 = obj->getBill(product,amount);\n */",
    "java": "class Cashier {\n\n    public Cashier(int n, int discount, int[] products, int[] prices) {\n        \n    }\n    \n    public double getBill(int[] product, int[] amount) {\n        \n    }\n}\n\n/**\n * Your Cashier object will be instantiated and called as such:\n * Cashier obj = new Cashier(n, discount, products, prices);\n * double param_1 = obj.getBill(product,amount);\n */",
    "python": "class Cashier(object):\n\n    def __init__(self, n, discount, products, prices):\n        \"\"\"\n        :type n: int\n        :type discount: int\n        :type products: List[int]\n        :type prices: List[int]\n        \"\"\"\n        \n\n    def getBill(self, product, amount):\n        \"\"\"\n        :type product: List[int]\n        :type amount: List[int]\n        :rtype: float\n        \"\"\"\n        \n\n\n# Your Cashier object will be instantiated and called as such:\n# obj = Cashier(n, discount, products, prices)\n# param_1 = obj.getBill(product,amount)",
    "python3": "class Cashier:\n\n    def __init__(self, n: int, discount: int, products: List[int], prices: List[int]):\n        \n\n    def getBill(self, product: List[int], amount: List[int]) -> float:\n        \n\n\n# Your Cashier object will be instantiated and called as such:\n# obj = Cashier(n, discount, products, prices)\n# param_1 = obj.getBill(product,amount)",
    "c": "\n\n\ntypedef struct {\n    \n} Cashier;\n\n\nCashier* cashierCreate(int n, int discount, int* products, int productsSize, int* prices, int pricesSize) {\n    \n}\n\ndouble cashierGetBill(Cashier* obj, int* product, int productSize, int* amount, int amountSize) {\n    \n}\n\nvoid cashierFree(Cashier* obj) {\n    \n}\n\n/**\n * Your Cashier struct will be instantiated and called as such:\n * Cashier* obj = cashierCreate(n, discount, products, productsSize, prices, pricesSize);\n * double param_1 = cashierGetBill(obj, product, productSize, amount, amountSize);\n \n * cashierFree(obj);\n*/",
    "csharp": "public class Cashier {\n\n    public Cashier(int n, int discount, int[] products, int[] prices) {\n        \n    }\n    \n    public double GetBill(int[] product, int[] amount) {\n        \n    }\n}\n\n/**\n * Your Cashier object will be instantiated and called as such:\n * Cashier obj = new Cashier(n, discount, products, prices);\n * double param_1 = obj.GetBill(product,amount);\n */",
    "javascript": "/**\n * @param {number} n\n * @param {number} discount\n * @param {number[]} products\n * @param {number[]} prices\n */\nvar Cashier = function(n, discount, products, prices) {\n    \n};\n\n/** \n * @param {number[]} product \n * @param {number[]} amount\n * @return {number}\n */\nCashier.prototype.getBill = function(product, amount) {\n    \n};\n\n/** \n * Your Cashier object will be instantiated and called as such:\n * var obj = new Cashier(n, discount, products, prices)\n * var param_1 = obj.getBill(product,amount)\n */",
    "typescript": "class Cashier {\n    constructor(n: number, discount: number, products: number[], prices: number[]) {\n        \n    }\n\n    getBill(product: number[], amount: number[]): number {\n        \n    }\n}\n\n/**\n * Your Cashier object will be instantiated and called as such:\n * var obj = new Cashier(n, discount, products, prices)\n * var param_1 = obj.getBill(product,amount)\n */",
    "php": "class Cashier {\n    /**\n     * @param Integer $n\n     * @param Integer $discount\n     * @param Integer[] $products\n     * @param Integer[] $prices\n     */\n    function __construct($n, $discount, $products, $prices) {\n        \n    }\n  \n    /**\n     * @param Integer[] $product\n     * @param Integer[] $amount\n     * @return Float\n     */\n    function getBill($product, $amount) {\n        \n    }\n}\n\n/**\n * Your Cashier object will be instantiated and called as such:\n * $obj = Cashier($n, $discount, $products, $prices);\n * $ret_1 = $obj->getBill($product, $amount);\n */",
    "swift": "\nclass Cashier {\n\n    init(_ n: Int, _ discount: Int, _ products: [Int], _ prices: [Int]) {\n        \n    }\n    \n    func getBill(_ product: [Int], _ amount: [Int]) -> Double {\n        \n    }\n}\n\n/**\n * Your Cashier object will be instantiated and called as such:\n * let obj = Cashier(n, discount, products, prices)\n * let ret_1: Double = obj.getBill(product, amount)\n */",
    "kotlin": "class Cashier(n: Int, discount: Int, products: IntArray, prices: IntArray) {\n\n    fun getBill(product: IntArray, amount: IntArray): Double {\n        \n    }\n\n}\n\n/**\n * Your Cashier object will be instantiated and called as such:\n * var obj = Cashier(n, discount, products, prices)\n * var param_1 = obj.getBill(product,amount)\n */",
    "dart": "class Cashier {\n\n  Cashier(int n, int discount, List<int> products, List<int> prices) {\n    \n  }\n  \n  double getBill(List<int> product, List<int> amount) {\n    \n  }\n}\n\n/**\n * Your Cashier object will be instantiated and called as such:\n * Cashier obj = Cashier(n, discount, products, prices);\n * double param1 = obj.getBill(product,amount);\n */",
    "golang": "type Cashier struct {\n    \n}\n\n\nfunc Constructor(n int, discount int, products []int, prices []int) Cashier {\n    \n}\n\n\nfunc (this *Cashier) GetBill(product []int, amount []int) float64 {\n    \n}\n\n\n/**\n * Your Cashier object will be instantiated and called as such:\n * obj := Constructor(n, discount, products, prices);\n * param_1 := obj.GetBill(product,amount);\n */",
    "ruby": "class Cashier\n\n=begin\n    :type n: Integer\n    :type discount: Integer\n    :type products: Integer[]\n    :type prices: Integer[]\n=end\n    def initialize(n, discount, products, prices)\n        \n    end\n\n\n=begin\n    :type product: Integer[]\n    :type amount: Integer[]\n    :rtype: Float\n=end\n    def get_bill(product, amount)\n        \n    end\n\n\nend\n\n# Your Cashier object will be instantiated and called as such:\n# obj = Cashier.new(n, discount, products, prices)\n# param_1 = obj.get_bill(product, amount)",
    "scala": "class Cashier(_n: Int, _discount: Int, _products: Array[Int], _prices: Array[Int]) {\n\n    def getBill(product: Array[Int], amount: Array[Int]): Double = {\n        \n    }\n\n}\n\n/**\n * Your Cashier object will be instantiated and called as such:\n * val obj = new Cashier(n, discount, products, prices)\n * val param_1 = obj.getBill(product,amount)\n */",
    "rust": "struct Cashier {\n\n}\n\n\n/** \n * `&self` means the method takes an immutable reference.\n * If you need a mutable reference, change it to `&mut self` instead.\n */\nimpl Cashier {\n\n    fn new(n: i32, discount: i32, products: Vec<i32>, prices: Vec<i32>) -> Self {\n        \n    }\n    \n    fn get_bill(&self, product: Vec<i32>, amount: Vec<i32>) -> f64 {\n        \n    }\n}\n\n/**\n * Your Cashier object will be instantiated and called as such:\n * let obj = Cashier::new(n, discount, products, prices);\n * let ret_1: f64 = obj.get_bill(product, amount);\n */",
    "racket": "(define cashier%\n  (class object%\n    (super-new)\n    \n    ; n : exact-integer?\n    ; discount : exact-integer?\n    ; products : (listof exact-integer?)\n    ; prices : (listof exact-integer?)\n    (init-field\n      n\n      discount\n      products\n      prices)\n    \n    ; get-bill : (listof exact-integer?) (listof exact-integer?) -> flonum?\n    (define/public (get-bill product amount)\n      )))\n\n;; Your cashier% object will be instantiated and called as such:\n;; (define obj (new cashier% [n n] [discount discount] [products products] [prices prices]))\n;; (define param_1 (send obj get-bill product amount))",
    "erlang": "-spec cashier_init_(N :: integer(), Discount :: integer(), Products :: [integer()], Prices :: [integer()]) -> any().\ncashier_init_(N, Discount, Products, Prices) ->\n  .\n\n-spec cashier_get_bill(Product :: [integer()], Amount :: [integer()]) -> float().\ncashier_get_bill(Product, Amount) ->\n  .\n\n\n%% Your functions will be called as such:\n%% cashier_init_(N, Discount, Products, Prices),\n%% Param_1 = cashier_get_bill(Product, Amount),\n\n%% cashier_init_ will be called before every test case, in which you can do some necessary initializations.",
    "elixir": "defmodule Cashier do\n  @spec init_(n :: integer, discount :: integer, products :: [integer], prices :: [integer]) :: any\n  def init_(n, discount, products, prices) do\n    \n  end\n\n  @spec get_bill(product :: [integer], amount :: [integer]) :: float\n  def get_bill(product, amount) do\n    \n  end\nend\n\n# Your functions will be called as such:\n# Cashier.init_(n, discount, products, prices)\n# param_1 = Cashier.get_bill(product, amount)\n\n# Cashier.init_ will be called before every test case, in which you can do some necessary initializations."
  }
}