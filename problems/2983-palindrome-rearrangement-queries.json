{
  "title": "Palindrome Rearrangement Queries",
  "problem_id": "3203",
  "frontend_id": "2983",
  "difficulty": "Hard",
  "problem_slug": "palindrome-rearrangement-queries",
  "topics": [
    "Hash Table",
    "String",
    "Prefix Sum"
  ],
  "description": "You are given a 0-indexed string s having an even length n.\nYou are also given a 0-indexed 2D integer array, queries, where queries[i] = [ai, bi, ci, di].\nFor each query i, you are allowed to perform the following operations:\nFor each query, your task is to determine whether it is possible to make s a palindrome by performing the operations.\nEach query is answered independently of the others.\nReturn a 0-indexed array answer, where answer[i] == true if it is possible to make s a palindrome by performing operations specified by the ith query, and false otherwise.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: s = \"abcabc\", queries = [[1,1,3,5],[0,2,5,5]]\nOutput: [true,true]\nExplanation: In this example, there are two queries:\nIn the first query:\n- a0 = 1, b0 = 1, c0 = 3, d0 = 5.\n- So, you are allowed to rearrange s[1:1] => abcabc and s[3:5] => abcabc.\n- To make s a palindrome, s[3:5] can be rearranged to become => abccba.\n- Now, s is a palindrome. So, answer[0] = true.\nIn the second query:\n- a1 = 0, b1 = 2, c1 = 5, d1 = 5.\n- So, you are allowed to rearrange s[0:2] => abcabc and s[5:5] => abcabc.\n- To make s a palindrome, s[0:2] can be rearranged to become => cbaabc.\n- Now, s is a palindrome. So, answer[1] = true.",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input: s = \"abbcdecbba\", queries = [[0,2,7,9]]\nOutput: [false]\nExplanation: In this example, there is only one query.\na0 = 0, b0 = 2, c0 = 7, d0 = 9.\nSo, you are allowed to rearrange s[0:2] => abbcdecbba and s[7:9] => abbcdecbba.\nIt is not possible to make s a palindrome by rearranging these substrings because s[3:6] is not a palindrome.\nSo, answer[0] = false.",
      "images": []
    },
    {
      "example_num": 3,
      "example_text": "Input: s = \"acbcab\", queries = [[1,2,4,5]]\nOutput: [true]\nExplanation: In this example, there is only one query.\na0 = 1, b0 = 2, c0 = 4, d0 = 5.\nSo, you are allowed to rearrange s[1:2] => acbcab and s[4:5] => acbcab.\nTo make s a palindrome s[1:2] can be rearranged to become abccab.\nThen, s[4:5] can be rearranged to become abccba.\nNow, s is a palindrome. So, answer[0] = true.",
      "images": []
    }
  ],
  "constraints": [
    "2 <= n == s.length <= 105",
    "1 <= queries.length <= 105",
    "queries[i].length == 4",
    "ai == queries[i][0], bi == queries[i][1]",
    "ci == queries[i][2], di == queries[i][3]",
    "0 <= ai <= bi < n / 2",
    "n / 2 <= ci <= di < n",
    "n is even.",
    "s consists of only lowercase English letters."
  ],
  "follow_ups": [],
  "hints": [
    "Consider two indices, <code>x</code> on the left side and its symmetrical index <code>y</code> on the right side.",
    "Store the frequencies of all of the letters in both intervals <code>[a<sub>i</sub>, b<sub>i</sub>]</code> and <code>[c<sub>i</sub>, d<sub>i</sub>]</code> in a query.",
    "If <code>x</code> is not in <code>[a<sub>i</sub>, b<sub>i</sub>]</code> and <code>y</code> is not in <code>[c<sub>i</sub>, d<sub>i</sub>]</code>, they must be the same.",
    "If <code>x</code> is in <code>[a<sub>i</sub>, b<sub>i</sub>]</code> and <code>y</code> is not in <code>[c<sub>i</sub>, d<sub>i</sub>]</code>, remove one occurrence of the character at index <code>y</code> from the frequency array on the left side.",
    "Similarly, if <code>x</code> is not in <code>[a<sub>i</sub>, b<sub>i</sub>]</code> and <code>y</code> is in <code>[c<sub>i</sub>, d<sub>i</sub>]</code>, remove one occurrence of the character at index <code>x</code> from the frequency array on the right side.",
    "Finally, check whether the two frequency arrays are the same, and the indices that don't fall into any of the intervals are the same as well.",
    "Use prefix-sum + hashing to improve the time complexity."
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    vector<bool> canMakePalindromeQueries(string s, vector<vector<int>>& queries) {\n        \n    }\n};",
    "java": "class Solution {\n    public boolean[] canMakePalindromeQueries(String s, int[][] queries) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def canMakePalindromeQueries(self, s, queries):\n        \"\"\"\n        :type s: str\n        :type queries: List[List[int]]\n        :rtype: List[bool]\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def canMakePalindromeQueries(self, s: str, queries: List[List[int]]) -> List[bool]:\n        ",
    "c": "/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nbool* canMakePalindromeQueries(char* s, int** queries, int queriesSize, int* queriesColSize, int* returnSize) {\n    \n}",
    "csharp": "public class Solution {\n    public bool[] CanMakePalindromeQueries(string s, int[][] queries) {\n        \n    }\n}",
    "javascript": "/**\n * @param {string} s\n * @param {number[][]} queries\n * @return {boolean[]}\n */\nvar canMakePalindromeQueries = function(s, queries) {\n    \n};",
    "typescript": "function canMakePalindromeQueries(s: string, queries: number[][]): boolean[] {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param String $s\n     * @param Integer[][] $queries\n     * @return Boolean[]\n     */\n    function canMakePalindromeQueries($s, $queries) {\n        \n    }\n}",
    "swift": "class Solution {\n    func canMakePalindromeQueries(_ s: String, _ queries: [[Int]]) -> [Bool] {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun canMakePalindromeQueries(s: String, queries: Array<IntArray>): BooleanArray {\n        \n    }\n}",
    "dart": "class Solution {\n  List<bool> canMakePalindromeQueries(String s, List<List<int>> queries) {\n    \n  }\n}",
    "golang": "func canMakePalindromeQueries(s string, queries [][]int) []bool {\n    \n}",
    "ruby": "# @param {String} s\n# @param {Integer[][]} queries\n# @return {Boolean[]}\ndef can_make_palindrome_queries(s, queries)\n    \nend",
    "scala": "object Solution {\n    def canMakePalindromeQueries(s: String, queries: Array[Array[Int]]): Array[Boolean] = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn can_make_palindrome_queries(s: String, queries: Vec<Vec<i32>>) -> Vec<bool> {\n        \n    }\n}",
    "racket": "(define/contract (can-make-palindrome-queries s queries)\n  (-> string? (listof (listof exact-integer?)) (listof boolean?))\n  )",
    "erlang": "-spec can_make_palindrome_queries(S :: unicode:unicode_binary(), Queries :: [[integer()]]) -> [boolean()].\ncan_make_palindrome_queries(S, Queries) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec can_make_palindrome_queries(s :: String.t, queries :: [[integer]]) :: [boolean]\n  def can_make_palindrome_queries(s, queries) do\n    \n  end\nend"
  }
}