{
  "title": "Department Top Three Salaries",
  "problem_id": "185",
  "frontend_id": "185",
  "difficulty": "Hard",
  "problem_slug": "department-top-three-salaries",
  "topics": [
    "Database"
  ],
  "description": "Table: Employee\nTable: Department\nA company's executives are interested in seeing who earns the most money in each of the company's departments. A high earner in a department is an employee who has a salary in the top three unique salaries for that department.\nWrite a solution to find the employees who are high earners in each of the departments.\nReturn the result table in any order.\nThe result format is in the following example.\nExample 1:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "+--------------+---------+\n| Column Name  | Type    |\n+--------------+---------+\n| id           | int     |\n| name         | varchar |\n| salary       | int     |\n| departmentId | int     |\n+--------------+---------+\nid is the primary key (column with unique values) for this table.\ndepartmentId is a foreign key (reference column) of the ID from the Department table.\nEach row of this table indicates the ID, name, and salary of an employee. It also contains the ID of their department.",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| id          | int     |\n| name        | varchar |\n+-------------+---------+\nid is the primary key (column with unique values) for this table.\nEach row of this table indicates the ID of a department and its name.",
      "images": []
    },
    {
      "example_num": 3,
      "example_text": "Input: \nEmployee table:\n+----+-------+--------+--------------+\n| id | name  | salary | departmentId |\n+----+-------+--------+--------------+\n| 1  | Joe   | 85000  | 1            |\n| 2  | Henry | 80000  | 2            |\n| 3  | Sam   | 60000  | 2            |\n| 4  | Max   | 90000  | 1            |\n| 5  | Janet | 69000  | 1            |\n| 6  | Randy | 85000  | 1            |\n| 7  | Will  | 70000  | 1            |\n+----+-------+--------+--------------+\nDepartment table:\n+----+-------+\n| id | name  |\n+----+-------+\n| 1  | IT    |\n| 2  | Sales |\n+----+-------+\nOutput: \n+------------+----------+--------+\n| Department | Employee | Salary |\n+------------+----------+--------+\n| IT         | Max      | 90000  |\n| IT         | Joe      | 85000  |\n| IT         | Randy    | 85000  |\n| IT         | Will     | 70000  |\n| Sales      | Henry    | 80000  |\n| Sales      | Sam      | 60000  |\n+------------+----------+--------+\nExplanation: \nIn the IT department:\n- Max earns the highest unique salary\n- Both Randy and Joe earn the second-highest unique salary\n- Will earns the third-highest unique salary\n\nIn the Sales department:\n- Henry earns the highest salary\n- Sam earns the second-highest salary\n- There is no third-highest salary as there are only two employees",
      "images": []
    }
  ],
  "constraints": [
    "There are no employees with the exact same name, salary and department."
  ],
  "follow_ups": [],
  "hints": [],
  "code_snippets": {
    "mysql": "# Write your MySQL query statement below\n",
    "mssql": "/* Write your T-SQL query statement below */\n",
    "oraclesql": "/* Write your PL/SQL query statement below */\n",
    "pythondata": "import pandas as pd\n\ndef top_three_salaries(employee: pd.DataFrame, department: pd.DataFrame) -> pd.DataFrame:\n    ",
    "postgresql": "-- Write your PostgreSQL query statement below\n"
  },
  "solution": "​[TOC]\n​\n# Solution\n​\n---\n​\n## pandas### Approach 1: Return the First n Rows Using nlargest()#### AlgorithmFor this problem, we can either identify the top earners first using DataFrame `employee` and then join the DataFrame `department` to get the department name, or join the DataFrame `department` first to get the department name before identifying the top earners. In this approach, we use the latter logic. \n\nIn this step, we can also update the column name in the DataFrame `department` from `name` to `Department` as requested by the final output.\n\n```python\nEmployee_Department = employee.merge(department, left_on='departmentId', right_on='id').rename(columns = {'name_y': 'Department'})\n```\n\nNow we have the employee and department information stored in the same DataFrame: \n\n| id_x | name_x | salary | departmentId | id_y | Department |\n| ---- | ------ | ------ | ------------ | ---- | ---------- |\n| 1    | Joe    | 85000  | 1            | 1    | IT         |\n| 4    | Max    | 90000  | 1            | 1    | IT         |\n| 5    | Janet  | 69000  | 1            | 1    | IT         |\n| 6    | Randy  | 85000  | 1            | 1    | IT         |\n| 7    | Will   | 70000  | 1            | 1    | IT         |\n| 2    | Henry  | 80000  | 2            | 2    | Sales      |\n| 3    | Sam    | 60000  | 2            | 2    | Sales      |\n\nSince the definition of a **high earner** is an employee who has a salary in the top three **unique** salaries for the department, we want to make sure the salary is unique at the department level for later calculation. To do this, we select only the department and salary from the DataFrame created in the last step and drop any duplicated records if existed. \n\n```python\nEmployee_Department = Employee_Department[['Department', 'departmentId', 'salary']].drop_duplicates()\n```\n\nHere's the output after this step:\n\n| Department | departmentId | salary |\n| ---------- | ------------ | ------ |\n| IT         | 1            | 85000  |\n| IT         | 1            | 90000  |\n| IT         | 1            | 69000  |\n| IT         | 1            | 70000  |\n| Sales      | 2            | 80000  |\n| Sales      | 2            | 60000  |\n\nNow we can identify the top 3 unique salaries for each department. We use the function [`nlargest()`](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.nlargest.html) to get this value. The parameter '3' is passed to the function as it defines the number of rows to return. \n\n```python\ntop_salary = Employee_Department.groupby(['Department', 'departmentId']).salary.nlargest(3).reset_index()\n```\n\n| Department | departmentId | level_2 | salary |\n| ---------- | ------------ | ------- | ------ |\n| IT         | 1            | 1       | 90000  |\n| IT         | 1            | 0       | 85000  |\n| IT         | 1            | 4       | 70000  |\n| Sales      | 2            | 5       | 80000  |\n| Sales      | 2            | 6       | 60000  |\n\n\nNow we only need to identify the employees are in these departments and making the same amount of salary. To do this, we can merge the DataFrame `top_salary`, which contains the top three unique salary for each department, to the DataFrame `employee` on `departmentId` and `salary`, so only the employees that match both criteria will be retained. \n\n```python\ndf = top_salary.merge(employee, on=['departmentId', 'salary'])\n```\n\n| Department | departmentId | level_2 | salary | id | name  |\n| ---------- | ------------ | ------- | ------ | -- | ----- |\n| IT         | 1            | 1       | 90000  | 4  | Max   |\n| IT         | 1            | 0       | 85000  | 1  | Joe   |\n| IT         | 1            | 0       | 85000  | 6  | Randy |\n| IT         | 1            | 4       | 70000  | 7  | Will  |\n| Sales      | 2            | 5       | 80000  | 2  | Henry |\n| Sales      | 2            | 6       | 60000  | 3  | Sam   |\n\nLastly, we clean the DataFrame as per requested by the final output. We keep only the columns needed and rename the columns accordingly.\n\n```python\ndf[['Department', 'name', 'salary']].rename(columns = {'name': 'Employee', 'salary': 'Salary'})\n```#### Implementation\n​### Approach 2: Return the First n Rows Using rank()#### AlgorithmFor this approach, we first identify the top earners from the DataFrame `employee` and then join the DataFrame `department` to get the department name. \n\nTo identify the high earners for each department, we use the function [`rank()`](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.rank.html) to apply dense rank on the column `salary` so we can get the top three **unique** salaries. The parameter `ascending=False` is passed so the salary is sorted from the maximum to the minimum. Within the same step, we can also add the filter to keep only the records with a rank smaller than or equal to 3. \n\n```python\ntop_salary = employee[employee.groupby('departmentId').salary.rank(method='dense', ascending=False) <= 3]\n```\n\nOnly employees who are `high earners` retained in the new DataFrame:\n\n| id | name  | salary | departmentId |\n| -- | ----- | ------ | ------------ |\n| 1  | Joe   | 85000  | 1            |\n| 2  | Henry | 80000  | 2            |\n| 3  | Sam   | 60000  | 2            |\n| 4  | Max   | 90000  | 1            |\n| 6  | Randy | 85000  | 1            |\n| 7  | Will  | 70000  | 1            |\n\nNow we want to `merge` to the DataFrame `department` to get the `name` of the department. In the same step, we can also select only the columns needed for the final output. \n\n```python\nemployee_department = top_salary.merge(department, left_on='departmentId', right_on='id')[['name_y', 'name_x', 'salary']]\n```\n| name_y | name_x | salary |\n| ------ | ------ | ------ |\n| IT     | Joe    | 85000  |\n| IT     | Max    | 90000  |\n| IT     | Randy  | 85000  |\n| IT     | Will   | 70000  |\n| Sales  | Henry  | 80000  |\n| Sales  | Sam    | 60000  |\n\n\nWe are almost there! To get the final output, we need to update the column name as per requested.\n\n```python\nreturn employee_department.rename(columns = {'name_y': 'Department', 'name_x': 'Employee', 'salary': 'Salary'})\n```#### Implementation---\n\n## Database\n\n### Approach 1: Return the First n Rows Using Correlated Subquery#### Algorithm\n​We can build a [correlated subquery](https://dev.mysql.com/doc/refman/8.0/en/correlated-subqueries.html) to identify the top N records from more than one category. Since the correlated subquery is dependent on the main query, the idea behind this approach is to compare the values between the main query and the subquery, so that in the subquery, at most N-1 salaries can be greater than each selected salary from the main query.\n\nTo do this, we first build the main query. In the main query, we can also join the table `Employee` to the table `Department` on `departmentId` to get the `name` of the departments and rename the columns as requested by the final output. \n\n```sql\nSELECT d.name AS 'Department', \n       e1.name AS 'Employee', \n       e1.salary AS 'Salary' \nFROM Employee e1\nJOIN Department d\nON e1.departmentId = d.id \n```\n\nIn the correlated subquery, we select the number of salaries from the same table `Employee`. To compare the salaries between the main query and the subquery, we make sure the department is the same from both queries, but the salary from the subquery is always bigger than the salary from the main query. \n\n```sql\n(\n    SELECT COUNT(DISTINCT e2.salary)\n    FROM Employee e2\n    WHERE e2.salary > e1.salary AND e1.departmentId = e2.departmentId\n)\n```\n\nSince we need to identify the top three high earners in the main query, and the subquery always has larger salaries than the salaries from the main query, the maximum count of the larger salaries in the subquery is two. We add this criteria as a filter to the main query.#### Implementation\n\n```sql\nSELECT d.name AS 'Department', \n       e1.name AS 'Employee', \n       e1.salary AS 'Salary' \nFROM Employee e1\nJOIN Department d\nON e1.departmentId = d.id \nWHERE\n    3 > (SELECT COUNT(DISTINCT e2.salary)\n        FROM Employee e2\n        WHERE e2.salary > e1.salary AND e1.departmentId = e2.departmentId);\n```\n​### Approach 2: Return the First n Rows Using DENSE_RANK()#### Algorithm\n​Unlike the previous approach that utilized a correlated subquery, in this approach, we sorted the salaries in descending order, ranked employees based on their salaries within the department, and selected only the first 3 employees for the final output.\n\nWe first create a subquery or CTE to rank the employees. Since the definition of a high earner is the employee who has a salary in the top three **unique** salaries for the department, we can use the function `DENSE_RANK()` to avoid the scenario that employees from the same department make the same amount of salary. In this step, we can also join the table `Department` on `departmentId` to get the `name` of the departments and rename the columns for the final output. \n\n```sql\nWITH employee_department AS\n    (\n    SELECT d.id, \n        d.name AS Department, \n        salary AS Salary, \n        e.name AS Employee, \n        DENSE_RANK()OVER(PARTITION BY d.id ORDER BY salary DESC) AS rnk\n    FROM Department d\n    JOIN Employee e\n    ON d.id = e.departmentId\n    )\n```\n\nNow, each employee has a rank based on the `salary` in a descending order for each department. \n\n| id | Department | Salary | Employee | rnk |\n| -- | ---------- | ------ | -------- | --- |\n| 1  | IT         | 90000  | Max      | 1   |\n| 1  | IT         | 85000  | Joe      | 2   |\n| 1  | IT         | 85000  | Randy    | 2   |\n| 1  | IT         | 70000  | Will     | 3   |\n| 1  | IT         | 69000  | Janet    | 4   |\n| 2  | Sales      | 80000  | Henry    | 1   |\n| 2  | Sales      | 60000  | Sam      | 2   |\n\nWith the rank, we can select the high earners. We can add the filter to select employees that have a rank smaller than or equal to 3 in the main query. \n\n```sql\nSELECT Department, Employee, Salary\nFROM employee_department\nWHERE rnk <= 3\n```#### Implementation\n\n```mysql []\nWITH employee_department AS\n    (\n    SELECT d.id, \n        d.name AS Department, \n        salary AS Salary, \n        e.name AS Employee, \n        DENSE_RANK()OVER(PARTITION BY d.id ORDER BY salary DESC) AS rnk\n    FROM Department d\n    JOIN Employee e\n    ON d.id = e.departmentId\n    )\nSELECT Department, Employee, Salary\nFROM employee_department\nWHERE rnk <= 3\n```\n​\n----"
}