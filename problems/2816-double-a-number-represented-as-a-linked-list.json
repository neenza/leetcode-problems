{
  "title": "Double a Number Represented as a Linked List",
  "problem_id": "2871",
  "frontend_id": "2816",
  "difficulty": "Medium",
  "problem_slug": "double-a-number-represented-as-a-linked-list",
  "topics": [
    "Linked List",
    "Math",
    "Stack"
  ],
  "description": "You are given the head of a non-empty linked list representing a non-negative integer without leading zeroes.\nReturn the head of the linked list after doubling it.\nExample 1:\nExample 2:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: head = [1,8,9]\nOutput: [3,7,8]\nExplanation: The figure above corresponds to the given linked list which represents the number 189. Hence, the returned linked list represents the number 189 * 2 = 378.",
      "images": [
        "https://assets.leetcode.com/uploads/2023/05/28/example.png"
      ]
    },
    {
      "example_num": 2,
      "example_text": "Input: head = [9,9,9]\nOutput: [1,9,9,8]\nExplanation: The figure above corresponds to the given linked list which represents the number 999. Hence, the returned linked list reprersents the number 999 * 2 = 1998.",
      "images": [
        "https://assets.leetcode.com/uploads/2023/05/28/example2.png"
      ]
    }
  ],
  "constraints": [
    "The number of nodes in the list is in the range [1, 104]",
    "0 <= Node.val <= 9",
    "The input is generated such that the list represents a number that does not have leading zeros, except the number 0 itself."
  ],
  "follow_ups": [],
  "hints": [
    "Traverse the linked list from the least significant digit to the most significant digit and multiply each node's value by 2",
    "Handle any carry-over digits that may arise during the doubling process.",
    "If there is a carry-over digit on the most significant digit, create a new node with that value and point it to the start of the given linked list and return it."
  ],
  "code_snippets": {
    "cpp": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* doubleIt(ListNode* head) {\n        \n    }\n};",
    "java": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode doubleIt(ListNode head) {\n        \n    }\n}",
    "python": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def doubleIt(self, head):\n        \"\"\"\n        :type head: Optional[ListNode]\n        :rtype: Optional[ListNode]\n        \"\"\"\n        ",
    "python3": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def doubleIt(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        ",
    "c": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     struct ListNode *next;\n * };\n */\nstruct ListNode* doubleIt(struct ListNode* head) {\n    \n}",
    "csharp": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     public int val;\n *     public ListNode next;\n *     public ListNode(int val=0, ListNode next=null) {\n *         this.val = val;\n *         this.next = next;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode DoubleIt(ListNode head) {\n        \n    }\n}",
    "javascript": "/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar doubleIt = function(head) {\n    \n};",
    "typescript": "/**\n * Definition for singly-linked list.\n * class ListNode {\n *     val: number\n *     next: ListNode | null\n *     constructor(val?: number, next?: ListNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.next = (next===undefined ? null : next)\n *     }\n * }\n */\n\nfunction doubleIt(head: ListNode | null): ListNode | null {\n    \n};",
    "php": "/**\n * Definition for a singly-linked list.\n * class ListNode {\n *     public $val = 0;\n *     public $next = null;\n *     function __construct($val = 0, $next = null) {\n *         $this->val = $val;\n *         $this->next = $next;\n *     }\n * }\n */\nclass Solution {\n\n    /**\n     * @param ListNode $head\n     * @return ListNode\n     */\n    function doubleIt($head) {\n        \n    }\n}",
    "swift": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     public var val: Int\n *     public var next: ListNode?\n *     public init() { self.val = 0; self.next = nil; }\n *     public init(_ val: Int) { self.val = val; self.next = nil; }\n *     public init(_ val: Int, _ next: ListNode?) { self.val = val; self.next = next; }\n * }\n */\nclass Solution {\n    func doubleIt(_ head: ListNode?) -> ListNode? {\n        \n    }\n}",
    "kotlin": "/**\n * Example:\n * var li = ListNode(5)\n * var v = li.`val`\n * Definition for singly-linked list.\n * class ListNode(var `val`: Int) {\n *     var next: ListNode? = null\n * }\n */\nclass Solution {\n    fun doubleIt(head: ListNode?): ListNode? {\n        \n    }\n}",
    "dart": "/**\n * Definition for singly-linked list.\n * class ListNode {\n *   int val;\n *   ListNode? next;\n *   ListNode([this.val = 0, this.next]);\n * }\n */\nclass Solution {\n  ListNode? doubleIt(ListNode? head) {\n    \n  }\n}",
    "golang": "/**\n * Definition for singly-linked list.\n * type ListNode struct {\n *     Val int\n *     Next *ListNode\n * }\n */\nfunc doubleIt(head *ListNode) *ListNode {\n    \n}",
    "ruby": "# Definition for singly-linked list.\n# class ListNode\n#     attr_accessor :val, :next\n#     def initialize(val = 0, _next = nil)\n#         @val = val\n#         @next = _next\n#     end\n# end\n# @param {ListNode} head\n# @return {ListNode}\ndef double_it(head)\n    \nend",
    "scala": "/**\n * Definition for singly-linked list.\n * class ListNode(_x: Int = 0, _next: ListNode = null) {\n *   var next: ListNode = _next\n *   var x: Int = _x\n * }\n */\nobject Solution {\n    def doubleIt(head: ListNode): ListNode = {\n        \n    }\n}",
    "rust": "// Definition for singly-linked list.\n// #[derive(PartialEq, Eq, Clone, Debug)]\n// pub struct ListNode {\n//   pub val: i32,\n//   pub next: Option<Box<ListNode>>\n// }\n// \n// impl ListNode {\n//   #[inline]\n//   fn new(val: i32) -> Self {\n//     ListNode {\n//       next: None,\n//       val\n//     }\n//   }\n// }\nimpl Solution {\n    pub fn double_it(head: Option<Box<ListNode>>) -> Option<Box<ListNode>> {\n        \n    }\n}",
    "racket": "; Definition for singly-linked list:\n#|\n\n; val : integer?\n; next : (or/c list-node? #f)\n(struct list-node\n  (val next) #:mutable #:transparent)\n\n; constructor\n(define (make-list-node [val 0])\n  (list-node val #f))\n\n|#\n\n(define/contract (double-it head)\n  (-> (or/c list-node? #f) (or/c list-node? #f))\n  )",
    "erlang": "%% Definition for singly-linked list.\n%%\n%% -record(list_node, {val = 0 :: integer(),\n%%                     next = null :: 'null' | #list_node{}}).\n\n-spec double_it(Head :: #list_node{} | null) -> #list_node{} | null.\ndouble_it(Head) ->\n  .",
    "elixir": "# Definition for singly-linked list.\n#\n# defmodule ListNode do\n#   @type t :: %__MODULE__{\n#           val: integer,\n#           next: ListNode.t() | nil\n#         }\n#   defstruct val: 0, next: nil\n# end\n\ndefmodule Solution do\n  @spec double_it(head :: ListNode.t | nil) :: ListNode.t | nil\n  def double_it(head) do\n    \n  end\nend"
  },
  "solution": "[TOC]\n\n## Solution\n\n---\n\n### Overview\n\nWe are given a singly linked list representing a non-negative integer and we need to return a linked list that represents the result of doubling the original number.\n\n**Key Observations:**\n1. The linked list does not contain any negative integers nor any leading zeros.\n2. The result of doubling a digit can be greater than 9. In such cases, we need to carry over the extra digit to the next node and accommodate it in the answer.\n\n---\n\n### Approach 1: Reversing the List\n\n#### Intuition\n\nDoubling a number can be performed by adding a number to itself. We can develop a solution by following the steps of addition, which are performed from the least significant to the most significant digit. Reversing the order of the nodes in the list would allow us to traverse the list starting with the least significant digit. Then, we double each digit and perform the carry to double the number.\n\nThe idea of reversing the list seems promising, as it would allow us to process the nodes in the opposite order, starting from the least significant digit. This could make the logic for handling the carry much easier to implement.\n\nWhy would this make the logic for handling the carry much easier?\n\nLet's consider the example from the problem statement:\n```\nInput: head = [1,8,9]\nOutput: [3,7,8]\n```\n\nNow, let's think about how we would typically process this number to double each digit and handle the carry.\n\nIf we were to process the digits from the most significant to the least significant, it would look like this:\n\n- Double the most significant digit (1): 2\n- Handle the carry (2): The carry is 0, so we don't need to do anything.\n- Double the next digit (8): 16\n- Handle the carry (16): The carry is 1, which needs to be added to the previous digit.\n- Double the least significant digit (9): 18\n- Handle the carry (18): The carry is 1, which needs to be added to the previous digit.\n\nAs we can see, handling the carry becomes more complicated as we move from the most significant digit to the least significant digit. We need to keep track of the carry and propagate it to the previous digit, which can become cumbersome, especially for longer numbers.\n\nHowever, if we reverse the list, the problem becomes much simpler:\n\n- Reverse the list: [9, 8, 1]\n- Double the least significant digit (9): 18\n- Handle the carry (18): The carry is 1, which can be easily added to the next digit.\n- Double the next digit (8): 16\n- Handle the carry (16): The carry is 1, which can be easily added to the next digit.\n- Double the most significant digit (1): 2\n- Handle the carry (2): The carry is 0, so we don't need to do anything.\n\nBy reversing the list, we're effectively processing the digits from the least significant to the most significant. This simplifies the carry handling logic because the carry only depends on the current digit and the previous carry, rather than having to consider the entire number.\n\nOnce the list is reversed, we can iterate through the nodes and perform the following steps for each node:\n- Double the value of the current node.\n- Add the carry (if any) from the previous operation.\n- Replace the data of the current node with the result modulo 10 (to handle values greater than 9).\n- Compute the new carry by integer division (to handle values greater than 9).\n\nAfter processing all the nodes, if there is any remaining carry, we create a new node with the carry value and append it to the list.\n\nFinally, we reverse the list one more time to restore the original order of the nodes.\n\nThe following is an illustration demonstrating the reversing the list approach:\n\n!?!../Documents/2816/brute_reversing.json:977,301!?!\n\n#### Algorithm\n\n1. `doubleIt(head)` function:\n  - Call the `reverseList(head)` helper function to reverse the input linked list and store it in `reversedList`.\n  - Initialize two pointers, `current` and `previous`, to keep track of the current node and the previous node, respectively. Also, initialize a `carry` variable to `0`.\n  - Traverse the reversed linked list:\n    - For each node in the reversed list:\n      - Calculate the new value for the current node by doubling the current value and adding the carry.\n      - Update the current node's value with the new value modulo `10`.\n      - Update the `carry` variable based on the new value (`1` if the new value is greater than `9`, `0` otherwise).\n      - Move the `previous` and `current` pointers to the next nodes.\n  - If there's a non-zero carry left after the loop, create a new node with the carry value and attach it to the end of the list.\n  - Reverse the list back to its original order: Call the `reverseList(reversedList)` function to reverse the list back to its original order and store the result in `result`.\n  - Return the `result` list.\n\n2. `reverseList(node)` function:\n  - Initialize three pointers `previous` (initially `NULL`), `current` (initially `node`), and `nextNode` (to temporarily store the next node).\n  - Traverse the list and reverse the links:\n    - While the `current` pointer is not `NULL`:\n      - Store the next node in `nextNode`.\n      - Reverse the link by setting `current->next` to `previous`.\n      - Move the `previous` and `current` pointers to the next nodes.\n  - After the loop, `previous` will be the new head of the reversed list, so return `previous`.\n\n#### Implementation#### Complexity Analysis\n\nLet $n$ be the number of nodes in the linked list.\n\n- Time complexity: $O(n)$\n\n    The algorithm involves traversing the linked list once to double the values and handle carry, performing constant-time operations for each node. So, it takes $O(n)$ time.\n\n    Reversing the list also takes $O(n)$ time.\n\n    Thus, the overall time complexity of the algorithm is $O(n)$.\n\n- Space complexity: $O(1)$\n\n    In-place reversal is performed, so it doesn't incur significant extra space usage. Thus, the space complexity remains $O(1)$.\n\n---\n\n### Approach 2: Using Stack\n\n#### Intuition\n\nWhile the first approach works, it might not be suitable in situations where integer overflow is a concern, such as in languages with fixed-size integer data types. Additionally, the previous approach made three passes through the linked list, which can be inefficient. In this case, we can consider an alternative approach using a stack to manage carry values for generating the new head. This approach ensures that we handle integer overflow concerns efficiently while also reducing the number of passes through the linked list.\n\nThe stack-based approach involves traversing the list from head to tail and pushing each node's value onto a stack. This effectively reverses the order of the digits since the stack operates on the Last In, First Out (LIFO) principle. This reversal makes it easier to handle the carry. Instead of modifying the linked list in place, we build a new linked list to store the result. We build this list from tail to head, which eliminates the need for an additional reversal compared to the previous approach. \n\n> Learn more about stacks by reading our [Stack Explore Card](https://leetcode.com/explore/learn/card/queue-stack/230/usage-stack/).\n\nWe then start popping values from the stack and perform the necessary doubling and carry-handling operations. If there is any carry left after processing the stack, we create a new node with the carry value and prepend it to the result linked list.\n\n#### Algorithm\n \n- Initialize an empty stack `values` to store the values of the linked list nodes.\n- Initialize a variable `val` to hold the carryover value when doubling digits.\n- Traverse the linked list and push the values of the nodes onto the stack.\n- Initialize the tail of the new linked list as `null`.\n- Iterate over the stack of values:\n  - Create a new `ListNode` with value `0` and the previous tail as its next node.\n  - If the stack is not empty, pop the top value, double it, and add it to the `val`.\n  - Set the value of the new node to the units digit of the new value.\n  - Update the `val` to hold the carryover value for the next iteration.\n- Return the tail of the new linked list.\n\n#### Implementation#### Complexity Analysis\n\nLet $n$ be the number of nodes in the linked list.\n\n* Time complexity: $O(n)$\n\n  The algorithm traverses the linked list once to push its values onto the stack, which takes $O(n)$ time. Then, it iterates over the stack and performs operations to create the new linked list, which also takes $O(n)$ time, as the stack contains $n$ elements.\n  \n  Therefore, the overall time complexity of the algorithm is $O(n)$.\n\n* Space complexity: $O(n)$\n\n  The space complexity mainly depends on the additional space used by the stack to store the values of the linked list, which takes $O(n)$ space.\n  \n  Additionally, the space used for the new linked list is also $O(n)$ since we are creating a new node for each element in the original linked list.\n  \n  Therefore, the overall space complexity of the algorithm is $O(n)$.\n\n---\n\n### Approach 3: Recursion\n\n#### Intuition\n\nThe previous approach used a stack. If a problem can be solved using stack, we can often implement a similar solution using recursion, which utilizes the recursive call stack instead of a stack data structure.\n\nThe idea here is to recursively traverse the list until we reach the end, doubling the value of each node and propagating the carry value back up the recursive calls.\n\nOnce the recursion unwinds, we check if there is any non-zero carry left. If so, we create a new node with the carry value and add it to the beginning of the result linked list.\n\n#### Algorithm\n \n- Define a helper function `twiceOfVal(head)` that recursively computes twice each node's value and propagates the carry.\n - Base case: If `head` is `null`, return `0`.\n - Compute twice the value of the current node and add the result of the next node.\n - Update the current node's value with the units digit of the result.\n - Return the `carry` (tens digit of the result).\n\n- In the main `doubleIt(head)` function, call the `twiceOfVal(head)` helper function to compute the carry and store it in a variable `carry`.\n- If the most significant digit has a `carry` value, insert a new node at the beginning with the `carry` value.\n- Return the `head` of the updated linked list.\n\n#### Implementation#### Complexity Analysis\n\nLet $n$ be the number of nodes in the linked list.\n \n* Time complexity: $O(n)$\n\n  The `twiceOfVal` function recursively traverses the entire linked list once, performing constant-time operations at each node. Therefore, the time complexity of the `twiceOfVal` function is $O(n)$.\n\n  The `doubleIt` function calls the `twiceOfVal` function once, which has a time complexity of $O(n)$. Additionally, inserting a new node at the beginning of the linked list takes constant time. Hence, the overall time complexity of the `doubleIt` function is $O(n)$.\n\n  Therefore, the overall time complexity of the algorithm is $O(n)$.\n\n* Space complexity: $O(n)$\n  \n    The `twiceOfVal` function is tail-recursive, meaning it should typically use $O(1)$ space on the call stack due to the recursive calls in C++ and Java. However, in languages like Python, which don't optimize tail recursion, each recursive call consumes additional space on the call stack. Therefore, the space complexity of `twiceOfVal` is $O(n)$ due to the recursive call stack.\n\n    The `doubleIt` function uses no additional space apart from the space required for the input linked list. Hence, its space complexity is $O(1)$.\n\n    Therefore, the overall space complexity of the algorithm is dominated by the recursive call stack, making it $O(n)$.\n\n---\n\n### Approach 4: Two Pointers\n\n#### Intuition\n\nOne of the main challenges in the problem is dealing with the carry when doubling the values of the nodes. The previous approaches handled this by either reversing the list or using a stack to reverse the order of the digits, which introduced linear auxiliary space and/or multiple passes through the linked list. Now, let's consider a more efficient approach that aims to update the list in-place without reversing it.\n\nThe insight here is that to handle the carry efficiently, we need to maintain some context about the previous node's value. This would allow us to update the previous node's value if the current node's doubled value resulted in a carry. It's like preserving the state of the carry.\n\nTo maintain the necessary context, we can use two pointers: \"previous\" and \"current\". The \"previous\" pointer keeps track of the previous node, while the \"current\" pointer points to the node being processed.\n\nBy using the two pointers, we can iterate through the list and process the nodes. For each node, we can double the value and handle the carry by updating the previous node's value if necessary.\n\nWhen processing each node in the linked list, there are three distinct cases to consider:\n\n1. If the doubled value is less than `10`:\n\n    In this case, the value of the current node is simply replaced with its doubled value.\n\n2. If the doubled value is greater than or equal to `10`:\n\n    Here, the value of the current node is replaced with the remainder (modulo `10`) of its doubled value, and the previous node's value is updated to reflect the carry.\n\n3. If the first node's value needs to be updated with a carry:\n\n    If the doubled value of the first node is greater than or equal to `10`, a new node is created with a value of `1`, and it becomes the new head of the list.\n\nThis structured approach ensures proper handling of each node in the linked list while accounting for carry values when necessary.\n\nThe following is an illustration demonstrating the two pointer approach:\n\n!?!../Documents/2816/twopointer.json:976,302!?!\n\n#### Algorithm\n \n- Initialize `current` and `previous` pointers to traverse the linked list.\n- For each node:\n - Compute twice the value of the current node.\n - If the doubled value is less than 10, update the current node's value.\n - If the doubled value is 10 or greater:\n   - Update the current node's value with the units digit of the doubled value.\n   - If the `previous` pointer is not `null` (not the first node), update the previous node's value to add the carry.\n - If it's the first node and the doubled value is 10 or greater, create a new node with the carry value and link it to the current node, updating the `head` pointer.\n- Update the `previous` and `current` pointers to the next nodes.\n- Return the `head` of the modified linked list.\n\n#### Implementation#### Complexity Analysis\n\nLet $n$ be the number of nodes in the linked list.\n \n* Time complexity: $O(n)$\n\n  The algorithm traverses the entire linked list once. Within the loop, each operation (including arithmetic operations and pointer manipulations) takes constant time. \n  \n  Therefore, the time complexity of the algorithm is $O(n)$.\n\n* Space complexity: $O(1)$\n\n  The algorithm uses only a constant amount of additional space for storing pointers and temporary variables, regardless of the size of the input linked list. \n  \n  Therefore, the space complexity is $O(1)$.\n\n---\n\n### Approach 5: Single Pointer\n\n#### Intuition\n\nA key goal of the two-pointer approach was to reduce the memory footprint of the solution. While efficient, this approach still required maintaining two separate pointers (`prev` and `curr`).\n\nWe found that updating the previous node's value was only necessary when there was a carry from the current node. This insight will become the foundation for the single-pointer approach.\n\nBy focusing on where the previous node's value needed to be updated, we could simplify the logic and eliminate the need for the previous pointer.\n\nWe can achieve this using a single pointer to traverse the list. For each node, we will double the value and check if there was a carry from the next node. Since each node's value can range from `0` to `9`, doubling it could result in values from 0 to 18.\n\nIf the doubled value exceeds `9`, it indicates a carry to the previous digit place. However, since we are doubling each digit, a carry would occur when the doubled value is greater than or equal to `10`. We check if the value of the next node (i.e., `current.next.val`) is greater than `4`, because if it's greater than `4`, it implies that its doubled value is at least `10`. Therefore, we can handle the carry by adding one to the current node's doubled value, which calculates the correct final value for the current node.\n\nThe following is an illustration demonstrating the single pointer approach:\n\n!?!../Documents/2816/singlepointer.json:980,308!?!\n\n#### Algorithm\n \n- If the value of the `head` node is greater than `4`, insert a new node with the value `0` at the beginning of the list.\n- Traverse the linked list using a single `node` pointer:\n - Double the value of the current node and update it with the units digit.\n - If the current node has a next node and the next node's value is greater than `4`, increment the current node's value to handle the carry.\n- Return the `head` of the updated linked list.\n\n#### Implementation#### Complexity Analysis\n\nLet $n$ be the number of nodes in the linked list.\n\n* Time complexity: $O(n)$\n  \n  The algorithm traverses the entire linked list once, visiting each node. Within the loop, each operation (including arithmetic operations and pointer manipulations) takes constant time. \n  \n  Therefore, the time complexity of the algorithm is $O(n)$.\n\n* Space complexity: $O(1)$\n\n  The algorithm uses only a constant amount of additional space for storing pointers and temporary variables, regardless of the size of the input linked list.\n \n  Therefore, the space complexity is $O(1)$. \n\n---"
}