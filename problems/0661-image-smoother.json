{
  "title": "Image Smoother",
  "problem_id": "661",
  "frontend_id": "661",
  "difficulty": "Easy",
  "problem_slug": "image-smoother",
  "topics": [
    "Array",
    "Matrix"
  ],
  "description": "An image smoother is a filter of the size 3 x 3 that can be applied to each cell of an image by rounding down the average of the cell and the eight surrounding cells (i.e., the average of the nine cells in the blue smoother). If one or more of the surrounding cells of a cell is not present, we do not consider it in the average (i.e., the average of the four cells in the red smoother).\nGiven an m x n integer matrix img representing the grayscale of an image, return the image after applying the smoother on each cell of it.\nExample 1:\nExample 2:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: img = [[1,1,1],[1,0,1],[1,1,1]]\nOutput: [[0,0,0],[0,0,0],[0,0,0]]\nExplanation:\nFor the points (0,0), (0,2), (2,0), (2,2): floor(3/4) = floor(0.75) = 0\nFor the points (0,1), (1,0), (1,2), (2,1): floor(5/6) = floor(0.83333333) = 0\nFor the point (1,1): floor(8/9) = floor(0.88888889) = 0",
      "images": [
        "https://assets.leetcode.com/uploads/2021/05/03/smooth-grid.jpg"
      ]
    },
    {
      "example_num": 2,
      "example_text": "Input: img = [[100,200,100],[200,50,200],[100,200,100]]\nOutput: [[137,141,137],[141,138,141],[137,141,137]]\nExplanation:\nFor the points (0,0), (0,2), (2,0), (2,2): floor((100+200+200+50)/4) = floor(137.5) = 137\nFor the points (0,1), (1,0), (1,2), (2,1): floor((200+200+50+200+100+100)/6) = floor(141.666667) = 141\nFor the point (1,1): floor((50+200+200+200+200+100+100+100+100)/9) = floor(138.888889) = 138",
      "images": [
        "https://assets.leetcode.com/uploads/2021/05/03/smooth2-grid.jpg"
      ]
    }
  ],
  "constraints": [
    "m == img.length",
    "n == img[i].length",
    "1 <= m, n <= 200",
    "0 <= img[i][j] <= 255"
  ],
  "follow_ups": [],
  "hints": [],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    vector<vector<int>> imageSmoother(vector<vector<int>>& img) {\n        \n    }\n};",
    "java": "class Solution {\n    public int[][] imageSmoother(int[][] img) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def imageSmoother(self, img):\n        \"\"\"\n        :type img: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def imageSmoother(self, img: List[List[int]]) -> List[List[int]]:\n        ",
    "c": "/**\n * Return an array of arrays of size *returnSize.\n * The sizes of the arrays are returned as *returnColumnSizes array.\n * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().\n */\nint** imageSmoother(int** img, int imgSize, int* imgColSize, int* returnSize, int** returnColumnSizes) {\n    \n}",
    "csharp": "public class Solution {\n    public int[][] ImageSmoother(int[][] img) {\n        \n    }\n}",
    "javascript": "/**\n * @param {number[][]} img\n * @return {number[][]}\n */\nvar imageSmoother = function(img) {\n    \n};",
    "typescript": "function imageSmoother(img: number[][]): number[][] {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param Integer[][] $img\n     * @return Integer[][]\n     */\n    function imageSmoother($img) {\n        \n    }\n}",
    "swift": "class Solution {\n    func imageSmoother(_ img: [[Int]]) -> [[Int]] {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun imageSmoother(img: Array<IntArray>): Array<IntArray> {\n        \n    }\n}",
    "dart": "class Solution {\n  List<List<int>> imageSmoother(List<List<int>> img) {\n    \n  }\n}",
    "golang": "func imageSmoother(img [][]int) [][]int {\n    \n}",
    "ruby": "# @param {Integer[][]} img\n# @return {Integer[][]}\ndef image_smoother(img)\n    \nend",
    "scala": "object Solution {\n    def imageSmoother(img: Array[Array[Int]]): Array[Array[Int]] = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn image_smoother(img: Vec<Vec<i32>>) -> Vec<Vec<i32>> {\n        \n    }\n}",
    "racket": "(define/contract (image-smoother img)\n  (-> (listof (listof exact-integer?)) (listof (listof exact-integer?)))\n  )",
    "erlang": "-spec image_smoother(Img :: [[integer()]]) -> [[integer()]].\nimage_smoother(Img) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec image_smoother(img :: [[integer]]) :: [[integer]]\n  def image_smoother(img) do\n    \n  end\nend"
  },
  "solution": "[TOC]\n\n## Solution\n\n--- \n\n### Overview\n\nIn this problem, we are given an `m x n` integer matrix `img`. \n\nWe need to return a matrix of dimension `m x n` where each cell is obtained by applying **smoother** on the corresponding cell of the `img` matrix.\n\nNow, **smoother**, as given in the problem statement, can be thought of as an operator that takes as an input a cell. It then returns the *average* of the values of the \"cell and its *neighbors*\".\n\n- *average*: the average of a list of integers is the sum of the integers divided by the number of integers in the list. The average can be a floating point number, and in that case, the smoother should round down the result to the nearest integer.\n\n- *neighbors*: a cell is called a neighbor of another cell if they share a common edge or a common corner.\n\nNow, based on the different numbers of neighbors, let's see how we can apply the **smoother** operator on a cell.\n\n- A cell can have at most 8 neighbors. 4 of these share a common edge, and the remaining 4 share a common corner. \n  \n   ![8_neighbors](../Figures/661/661_slide_images_used/Slide1.PNG)\n\n   To apply smoother on the central cell, colored in yellow, we need to find the average of the values of the cell and its 8 neighbors. It is worth noting that for computing the average, we need to consider the value of the cell itself as well.\n\n   - The sum of the values of the cell and its 8 neighbors is `24 + 4 + 56 + 8 + 78 + 2 + 23 + 8 + 69`, which adds up to `272`.\n\n   - The number of cells we are using to compute the average is `9`.\n\n   - Hence, the average is `272 / 9`, which is `30.22`, rounded down to `30`.\n\n- If there is only one cell in the matrix, then it has no neighbors.\n\n    ![no_neighbors](../Figures/661/661_slide_images_used/Slide2_1.PNG)\n\n    To apply smoother on this cell, we need to find the average of the values of the cell and its (non-existent) neighbors.\n\n    - The sum of the values of the cell and its 0 neighbors is the value present in the cell itself, which is `68`.\n\n    - The number of cells we are using to compute the average is `1` only since there were no neighbors.\n\n    - Hence, the average is `68 / 1`, which is the same as the value of the cell itself, which is `68`.\n\n- If there is more than one cell in the matrix, then each cell has at least one neighbor.\n\n    ![1neighbors](../Figures/661/661_slide_images_used/Slide2_2.PNG)\n\n- If the matrix has more than one row, and more than one column, then each cell has at least 3 neighbors. \n\n    ![3neighbors](../Figures/661/661_slide_images_used/Slide3.PNG)\n\n    To apply smoother on the corner cell, colored in yellow, we need to find the average of the values of the cell and its 3 neighbors.\n\n    - The sum of the values of the cell and its 3 neighbors is `42 + 59 + 23 + 75`, which adds up to `199`.\n\n    - The number of cells we are using to compute the average is `4`.  \n\n    - Hence, the average is `199 / 4`, which is `49.75`, rounded down to `49`.\n\nThus, using this way, we need to apply the **smoother** operator on each cell of the `img`, and return the resultant matrix.Why it is called a smoother?Click to find out!> Grayscale images are nothing but a matrix (two-dimensional array) of integers. Each integer represents a pixel, the smallest unit of a digital image. The value of the integer represents the intensity of the pixel. The higher the value, the more intense the pixel is. The intensity of the pixel ranges from `0` to `255`. The value `0` represents black, and the value `255` represents white. The values in between represent different shades of gray.\n>\n> Here is a grayscale image of size `400 px x 400 px`.\n> \n> ![gray_image](../Figures/661/661_code_images/gray_image.png)\n>\n> One pixel represents one cell, hence the dimension of the corresponding matrix will be `400 x 400`. Here is what a part of the matrix looks like.\n>\n> ![gray_image_matrix](../Figures/661/661_code_images/matrix_gray_image.png)\n> \n> On applying the **smoother** operator on each cell of the matrix, the same part of the matrix will look like this.\n>\n> ![gray_image_matrix_smoother](../Figures/661/661_code_images/matrix_smooth_image1.png)\n> \n> Let's convert the smoothened matrix back to the grayscale image, and compare it with the original image.\n>\n> ![comparison](../Figures/661/661_code_images/compare1.png)\n>\n> Readers can observe that the image after applying the **smoother** operator is blurr than the original image with sharp and fine details chopped off. If we again and again apply the **smoother** operator on the image, the image will become more and more blurred. Here are a few rounds of repeated application of the **smoother** operator on the image.\n>\n> ![repeated_application](../Figures/661/661_code_images/compare2.png)\n\n> As **trivia**, it is worth knowing that a grayscale image is a two-dimensional array of integers, but a colored image is a three-dimensional array of integers. It has three dimensions because each pixel has three components: red, green, and blue. The value of each component ranges from `0` to `255`. The value `0` represents the absence of the component, and the value `255` represents the presence of the component in its full intensity. The values in between represent different shades of the component. The three components together represent the color of the pixel.Let's see how we can solve this problem with different approaches.\n\n---\n\n\n### Approach 1: Create a New Smoothened Image\n\n#### Intuition\n\nWe know that for applying the **smoother** operator, we need to consider the neighbors in the original `img` matrix, not the neighbors in the resultant matrix. Hence, we cannot overwrite the values of the `img` matrix with the result of the **smoother** operator. \n\nThe following example illustrates this point.\n\n> Let our `img` be `[[100, 0, 10], [0, 0, 25], [10, 10, 10]]`. The output should be `[[25, 22, 8], [20, 18, 9], [5, 9, 11]]`\n>\n> ![img-out](../Figures/661/661_slide_images_used/Slide4.PNG)\n>\n> Assume that we have applied the smooth operator on the first cell, and overwritten the value of the cell with the result. The `img` now will become `[[25, 0, 10], [0, 0, 25], [10, 10, 10]]`.\n>\n> ![overwrite](../Figures/661/661_slide_images_used/Slide5_1.PNG)\n>\n> Now if we use this matrix to apply the smooth operator on the second cell of the first row, we will get the value `10` instead of the expected value `22`.\n> \n> ![wrong](../Figures/661/661_slide_images_used/Slide5_2.PNG)\n\nFor this reason, we will not overwrite the values of the `img` matrix with the result of the **smoother** operator. This, thus calls for an extra space to store the result of the **smoother** operator for each cell of the `img` matrix.\n\nThe dimension of the input `img` matrix is `m x n`. Thus, let's create smoothened image in a new matrix `smooth_img` of dimension `m x n`.\n\nNow to compute individual cells of the `smooth_img`, we need to read the corresponding cell and its (valid) neighbors from the `img` matrix. \n\nThus, to compute the `smooth_img[i][j]`, we may need to read the following cells from the `img` matrix.\n- `img[i][j]`, the cell itself.\n- `img[i - 1][j - 1]`, the cell that shares the top-left corner with this cell. \n- `img[i - 1][j]`, the cell that shares the top edge with this cell.\n- `img[i - 1][j + 1]`, the cell that shares the top-right corner with this cell.\n- `img[i][j - 1]`, the cell that shares the left edge with this cell.\n- `img[i][j + 1]`, the cell that shares the right edge with this cell.\n- `img[i + 1][j - 1]`, the cell that shares the bottom-left corner with this cell.\n- `img[i + 1][j]`, the cell that shares the bottom edge with this cell.\n- `img[i + 1][j + 1]`, the cell that shares the bottom-right corner with this cell.\n\nHowever, not all of these cells are necessarily valid. \n\n> If `i = 0`, then `img[i - 1][j - 1]`, `img[i - 1][j]`, and `img[i - 1][j + 1]` are invalid, because they are above the top most row of the `img` matrix.\n\nA cell will be valid only if it is within the bounds of the `img` matrix.\n- The row index of the cell should be greater than or equal to `0`, and less than `m`.\n- The column index of the cell should be greater than or equal to `0`, and less than `n`.\n\nThus, in general, a neighbor with row index `x`, and column index `y` will be valid if `0 <= x < m`, and `0 <= y < n`. Both of these conditions should be true.\n\nNow we need to compute the average of the values of the valid neighbors of the cell, and the value of the cell itself. For this, we need the sum of these values and the count of these values. \n\nHence, to compute `smooth_img[i][j]`\n- Use two variables, `sum` and `count`, to store the sum and count of the values of the valid neighbors of the cell, and the value of the cell itself.\n- Iterate over all plausible nine indices, if the indices form a valid neighbor, then add the value of the cell at that index to `sum`, and increment `count` by `1`.\n- Compute the average by `sum / count`, and store the rounded down value in `smooth_img[i][j]`.\n\nReaders are encouraged to implement this algorithm on their own.\n\n\n#### Algorithm\n\n1. Save the dimensions of the image. Store the number of rows in `m`, and the number of columns in `n`, as convention used in the problem statement as well.\n\n2. Create a new image of the same dimension as the input image. Let's call this new image `smooth_img`. Initialize all the cells of the `smooth_img` with `0`.\n\n3. Iterate over the cells of the image. Let's call the current cell `img[i][j]`.\n    \n    - Initialize two integer variables `sum` and `count` to `0`.\n\n    - Iterate over all plausible nine indices `(x, y)`. The `(x, y)` are\n      - `(i - 1, j - 1)`\n\n      - `(i - 1, j)`\n      - `(i - 1, j + 1)`\n      - `(i, j - 1)`\n      - `(i, j)`\n      - `(i, j + 1)`\n      - `(i + 1, j - 1)`\n      - `(i + 1, j)`\n      - `(i + 1, j + 1)` \n\n      If index `(x, y)` is valid, then add the value of `img[x][y]` to `sum`, and increment `count` by `1`.\n    \n    - In `smooth_img[i][j]`, store the rounded down value of `sum / count`.\n\n4. Return the `smooth_img`. \n\n#### Implementation**Implementation Note:** For iterating the nine neighbors, we have used constant time nested for loops, which list the nine neighbors.\n\nThe other approach to achieving this is using the `DIRECTION` array, which lists the change in the neighbor's position. A typical `DIRECTION` array will look like this\n\n```DIRECTION []\n[\n    (-1, -1), (-1, 0), (-1, 1),\n    (0, -1), (0, 0), (0, 1),\n    (1, -1), (1, 0), (1, 1)\n]\n```\n\nReaders are encouraged to implement this approach as well to widen their implementation skills.\n\n#### Complexity Analysis\n\nLet $m$ be the number of rows in the `img` matrix, and $n$ be the number of columns in the `img` matrix.\n\n* Time complexity: $O(m \\cdot n)$\n\n    We are computing the value of each cell of the `smooth_img` matrix. There are $m \\cdot n$ cells in the `smooth_img` matrix. \n    \n    For each cell, we are iterating over all plausible nine indices. There are at most nine indices for each cell. \n    \n    Hence, the time complexity of the algorithm is $O(m \\cdot n \\cdot 9)$, which is $O(m \\cdot n)$.\n\n* Space complexity: $O(m \\cdot n)$\n\n    We are creating a new matrix of dimension $m \\cdot n$ to store the result. Hence, the space complexity of the algorithm is $O(m \\cdot n)$.  \n        \n---\n\n### Approach 2: Space-Optimized Smoothened Image\n\n#### Intuition\n\nIn the previous approach, we created a new matrix of dimension `m x n` to store the result. Moreover, we have seen that we can't overwrite the values of the `img` matrix with the result of the **smoother** operator. If we modify `img[i][j]` in place, we won't be able to use the original `img[i][j]` in subsequent calculations because the value at this position has already been overwritten.\n\nLet's take a closer look at why we can't overwrite these values.\n\nWe were moving row-by-row, and in each row, we were moving column-by-column. Assume we are overwriting the cells *(with somehow correct smoothened value)* as we move on. \n\nLet's call the current cell `img[i][j]`. To compute `smooth_img[i][j]`, we need to read the value of `img[i][j]`, and its neighbors.\n\n![neighbors](../Figures/661/661_slide_images_used/Slide6.PNG)\n\nHowever, because of our order of traversal, out of these 8 neighbors, the top 3 neighbors (which are in the row `img[i - 1]`), and the left neighbor (which is in cell `img[i][j - 1]`) have already been overwritten. Hence, we don't have access to the original values of these neighbors.\n\n![no_access](../Figures/661/661_slide_images_used/Slide7.PNG)\n\nIn summary, for calculating `smooth_img[i]`\n- We need to save the original values of two rows `img[i]` and `img[i - 1]`.\n- Rows before `img[i - 1]`, such as `img[i - 2]` or `img[i - 3]`, are no longer needed and need not be saved. \n- The next row `img[i + 1]` has not been overwritten yet, and hence, we can use it as is it.\n\nTo achieve this, we can proceed by saving all original values of two rows in two temporary arrays. The previous row is saved as `prev` and the current row is saved as `curr`.\n\nNow, for computing `img[i][j]`\n - All three neighbors of the previous row will be saved in the `prev` array. The stored values in `img[i - 1]` will be the smoothed value as we are supposed to overwrite as we proceed.\n - The original value of `img[i][j - 1]` will be saved in `curr` array. The presently stored value of `img[i][j - 1]` is the smoothed value of `img[i][j - 1]`, and not the original value.\n - The original value of `img[i][j]` is in `img` itself, because it has not been overwritten yet.\n - The original value of `img[i][j + 1]` is in `img` itself, because it has not been overwritten yet.\n - All three neighbors of the next row will be saved in `img` itself.\n\nHence, by using this approach, we can overwrite the values of the `img` matrix. The `curr` can be filled on the fly before overwriting, and will be given the name of `prev` after the iteration is over. \n\nReaders are encouraged to implement this approach where we need not construct a new matrix to store the result. However, there are a few more optimizations that can be done.\n\nLet's brainstorm further to use only one array `temp` instead of two arrays. The idea is that if we are on `img[i][j]` \n- The indices `temp[j]`, `temp[j + 1]`, `temp[j + 2]` ... represent the value of the `prev` array, or in other terms, original values of `img[i - 1]`\n- The indices ... `temp[j - 3]`, `temp[j - 2]`, `temp[j - 1]` represent the value of the `curr` array, or in other terms, original values of `img[i]`\n\nThis construction overwrites *previous row values* in `temp` with *current row values* as we traverse along the row. However, it has one major flaw. Let's enlist to see what it is by focusing on cell `img[i][j]`.\n\n- The neighbors in next row `img[i + 1]` are in `img` only.\n- The next neighbor in same row `img[i][j + 1]` is in `img` only.\n- The current value of `img[i][j]` is also not overwritten yet.\n- The previous neighbor in same row `img[i][j - 1]` is in `temp`.\n- The two of neighbors in previous row `img[i - 1]` are in `temp`. Precisely original value of `img[i - 1][j]` is in `temp[j]`, and original value of `img[i - 1][j + 1]` is in `temp[j + 1]`.\n\nThe only missing piece is the original value of `img[i - 1][j - 1]`. The value there now is smoothed value of `img[i - 1][j - 1]`, and `temp[j - 1]` stores `curr[j - 1]`, and not `prev[j - 1]`. \n\nWhat if before writing original `img[i][j - 1]` into `temp[j - 1]` *(which before writing stores `img[i - 1][j - 1]`)*, we store its original value in an integer variable `prev_val`? Turns out this will work, and the missing piece will be filled.\n\nWe have reduced the space used from $m \\cdot n$ to $2n$, then to $n$.Any further optimization? Click to find out!What if we have $n \\gg m$? In this case, we would prefer to store one column *(which will have elements from $m$ rows)* in an array, and not one row *(which will have elements from $n$ columns)* in an array. This will reduce the space used from $n$ to $m$, or precisely to $\\min(m,n)$. \n\nThere are two ways of achieving this.\n\n1. [Transpose the matrix](https://leetcode.com/problems/transpose-matrix/description/), and then use row-order traversal. After obtaining the result, transpose the matrix again to get the original matrix. \n\n    However, \n    \n    - Transposing a non-square matrix in $O(m \\cdot n)$ time takes $O(m \\cdot n)$ space. We aimed to reduce from $O(n)$ to $O(\\min(m,n))$. This indeed has increased space utilization.\n    \n    - The [in-place transpose](https://en.wikipedia.org/wiki/In-place_matrix_transposition) will increase the time complexity from $O(m \\cdot n)$ to $O(m \\cdot n \\cdot \\log(mn))$. This is because the in-place transpose is done by swapping the elements of the matrix. The swapping is done in a cycle. The number of cycles is $O(m \\cdot n)$. The length of each cycle is $O(\\log(m  n))$. Hence, the time complexity of the in-place transpose is $O(m \\cdot n \\cdot \\log(m  n))$.\n\n    Hence, transposing the matrix is not a good idea. Let's see what's the other way.\n\n2. Use column-order traversal instead of row-order traversal. The `temp` will store values of one column and not one row. The `prev_val` will store the original value of the cell in the same column but in the previous row. \n\n    However, two-dimension arrays in most of the programming languages are **[row-major](https://en.wikipedia.org/wiki/Row-_and_column-major_order)**, and not **column-major**. *The consecutive elements of a row are contiguous in memory*. Reading memory in contiguous locations is faster than jumping around among locations. Hence, column order traversal will be slower than row order traversal. However, asymptotically both will have the same time complexity.\n\nThus all two ways of reducing space complexity from $O(n)$ to $O(\\min(m,n))$ have their downsides. Hence, we will stick with the space complexity of $O(n)$.$\\downarrow_{\\text{Portion after realizing that sticking with space complexity of } O(n) \\text{ is better, at least in this approach}}$\n\nWith all the details being discussed minutely, let's see how we can implement this approach.\n\n\n#### Algorithm\n\n1. Save the dimensions of the image. Store the number of rows in `m`, and the number of columns in `n`, as convention used in the problem statement as well.\n\n2. Create an array of size `n`. Let's call this array `temp`.\n\n3. Declare an integer variable `prev_val`, and initialize it with `0`.\n\n4. Iterate over the cells of the image. Let's call the current cell `img[i][j]`.\n    \n    - Initialize two integer variables `sum` and `count` to `0`.\n\n    - If there exists the next row, that is, `i + 1 < m`, then we have to consider all the bottom neighbors.\n      - If there exists the left-bottom neighbor, that is, `j - 1 >= 0`, then add the value of `img[i + 1][j - 1]` to `sum`, and increment `count` by `1`.\n\n      - Add the value of `img[i + 1][j]` to `sum`, and increment `count` by `1`.\n      - If there exists the right-bottom neighbor, that is, `j + 1 < n`, then add the value of `img[i + 1][j + 1]` to `sum`, and increment `count` by `1`.\n\n    - If there exists the next neighbor, that is, `j + 1 < n`, then add the value of `img[i][j + 1]` to `sum`, and increment `count` by `1`.\n\n    - Add the value of `img[i][j]` to `sum`, and increment `count` by `1`.\n\n    - If there exists the previous neighbor, that is, `j - 1 >= 0`, then add the value of `temp[j - 1]` to `sum`, and increment `count` by `1`. The `temp` till index `j - 1` stores the original values of the current row `img[i]` only.\n\n    - If there exists the previous row, that is, `i - 1 >= 0`, then we have to consider all the top neighbors.\n\n      - If there exists the left-top neighbor, that is, `j - 1 >= 0`, then add the value of `prev_val` to `sum`, and increment `count` by `1`. The `prev_val` stores original value of `img[i - 1][j - 1]`.\n\n      - Add the value of `temp[j]` to `sum`, and increment `count` by `1`. The `temp` at index `j` stores the original value of `img[i - 1][j]`.\n      - If there exists the right-top neighbor, that is, `j + 1 < n`, then add the value of `temp[j + 1]` to `sum`, and increment `count` by `1`. The `temp` at index `j + 1` stores original value of `img[i - 1][j + 1]`.\n\n    - Now comes the overwriting part.\n\n    - If there exists the previous row, that is, `i - 1 >= 0`, then the value at `temp[j]` will serve the purpose of the top-left corner sharing neighbor of the next location in iteration, that is, of `img[i][j + 1]`. Hence, store `temp[j]` in `prev_val`.\n\n    - Store the value of `img[i][j]` in `temp[j]`. This will maintain the loop invariant of the definition of `temp`.\n\n    - Overwrite the value of `img[i][j]` with the rounded down value of `sum / count`.\n\n5. Return the `img`.\n\n#### Implementation#### Complexity Analysis\n\nLet $m$ be the number of rows in the `img` matrix, and $n$ be the number of columns in the `img` matrix.\n\n* Time complexity: $O(m \\cdot n)$\n\n    We are traversing every cell of the `img` matrix. There are $m \\cdot n$ cells in the `img` matrix.\n\n    In every traversal, we are doing constant time work of computing the smoothed value, overwriting, and updating the `temp` array. \n    \n    Hence, the time complexity of the algorithm is $O(m \\cdot n)$.\n\n* Space complexity: $O(n)$\n\n    The array `temp` is of size $n$. The remaining variables are of constant size. Hence, the space complexity of the algorithm is $O(n)$.\n        \n---\n\n### Approach 3: Constant Space Smoothened Image\n\n#### Intuition\n\nBased on the previous algorithms, we know that if we modify `img[i][j]` in place, we won't be able to use the original `img[i][j]` in subsequent calculations because the value at this position has already been overwritten. Can we somehow store both the pre-modified and post-modified `img[i][j]` values in the same cell? Ideally speaking, it's possible. \n\nConsidering the data structure of `img`, we cannot store two separate numbers in one cell. However, we can represent two independent numbers using a single number.\n\nAssume we have two independent numbers, $p$ and $r$. Let's define another number $Y$ as   \n$Y = p \\cdot X + r$  \nwhere $X$ is a constant.\n\n- To extract $p$ from $Y$, we can do $Y / X$.\n- To extract $r$ from $Y$, we can do $Y \\% X$.\n\nHence, the encoded $Y$ indeed stores two integers of our interest, $p$ and $r$.   \n\nLet's focus more on $X$. What should be the value of $X$? It turns out it depends on $r$. The $r$ is the remainder when we divide $Y$ by $X$. Hence, $r$ can take values from $0$ to $X - 1$.\n>\n> If we divide an integer by $X$, the remainder will be in the range $0$ to $X - 1$. For example, when divided by $8$, the remainder will be in the range $0$ to $7$.\n\nThus our $r$ varies from $0$ to $X - 1$. \n\nNow, let's look at the constraints given in the problem statement.\n\n> `0 <= img[i][j] <= 255`\n\nThus, every cell of the `img` matrix can take values from `0` to `255`. Thus, we can have correspondence between $r$ and `img[i][j]`. To limit the remainder $r$ to `255`, we can choose $X$ to be `256`.\n\nLet's now find out the value of $p$. In a single integer, we wish to store the original value of `img[i][j]`, and the smoothed value of `img[i][j]`. \n\n- The task of storing original value of `img[i][j]` is done by $r$.\n- We can allot $p$ to store the smoothed value of `img[i][j]`.\n\nHence, the summarized correspondence is\n- $Y$ represents two integers encoded in one integer. The two integers are the original value of `img[i][j]`, and smoothed value of `img[i][j]`.\n- $X$ is `256`, the carefully chosen constant.\n- $r$ is the remainder when we divide $Y$ by $X$. The remainder $r$ is the original value of `img[i][j]`.\n- $p$ is the quotient when we divide $Y$ by $X$. The quotient $p$ is the smoothed value of `img[i][j]`.\n\nHence, our algorithm will be \n- For every cell, assume it stores $Y$ (and not $r$)\n- Extract $r$, the original value of `img[i][j]`, from $Y$ using $Y \\% 256$\n- Compute smoothened value using neighbors of `img[i][j]`. For computing a smoothened value, we need the original value of neighbors as well, which will be extracted using the same logic. The smoothened value will be stored in $p$.\n- Encode the smoothened value in $Y$ itself by updating it as $Y = p \\cdot 256 + r$. \n- Once every $Y$ of the matrix is encoded with smoothened value, from it extract smoothened value $p$ by doing $Y / 256$. \n\nHence, the algorithm sounds simple. However, there is a word of caution. Multiplying integers may cause overflow if multiplication exceeds the range of integers. For this, let's find the minimum and maximum value our encoded $Y$ can take.\n\n$\\boxed{Y = p \\cdot 256 + r}$\n\n- $p$ is the smoothened value which is an average of at most nine values ranging from $0$ to $255$. Hence, the average $p$ will also lie between $0$ to $255$.\n\n- $r$ also lies between $0$ to $255$.\n\n- The minimum value of $Y$ is $0 \\cdot 256 + 0 = 0$.\n- The maximum value of $Y$ is $255 \\cdot 256 + 255 = 65535$ represented as $2^{16} - 1$, which is reasonably less than the maximum value of an integer, which is $2^{31} - 1$.\n\nHence, we need not to worry about overflow in this particular problem.\n\nWith all the details being discussed minutely, let's see how we can implement this approach.\n\n#### Algorithm\n\n1. Save the dimensions of the image. Store the number of rows in `m`, and the number of columns in `n`, as convention used in the problem statement as well.\n\n2. Iterate over the cells of the image. Let's call the current cell `img[i][j]`.\n    \n    - Initialize two integer variables `sum` and `count` to `0`.\n\n    - Iterate over all plausible nine indices `(x, y)`. The `(x, y)` are\n      - `(i - 1, j - 1)`\n\n      - `(i - 1, j)`\n      - `(i - 1, j + 1)`\n      - `(i, j - 1)`\n      - `(i, j)`\n      - `(i, j + 1)`\n      - `(i + 1, j - 1)`\n      - `(i + 1, j)`\n      - `(i + 1, j + 1)` \n        \n      If the indices form a valid neighbor, then extract the original value of `img[x][y]` using `img[x][y] % 256`, and add it to `sum`. Increment `count` by `1`.\n    \n    - Encode the smoothed value in `img[i][j]` as `img[i][j] += (sum / count) * 256 `.\n\n3. Traverse again over the cells of the image. Let's call the current cell `img[i][j]`. Extract the smoothed value from `img[i][j]` using `img[i][j] / 256`, and store it in `img[i][j]`.\n\n4. Return the `img`.\n\n#### Implementation**Point to Ponder:** With the number `256`, we are doing three operations\n- Taking modulo\n- Multiplying\n- Dividing\n\nNow, `256` is special in the sense that it is a power of two. Is there a faster way to do these three operations? Readers are encouraged to think about it.\n\n#### Complexity Analysis\n\nLet $m$ be the number of rows in the `img` matrix, and $n$ be the number of columns in the `img` matrix.\n\n* Time complexity: $O(m \\cdot n)$\n\n    We are traversing every cell of the `img` matrix. There are $m \\cdot n$ cells in the `img` matrix.\n    \n    For each cell, we are iterating over all plausible nine indices. There are at most nine indices for each cell. At each index, we are doing constant time arithmetic operations.\n\n    Again, we are traversing over all the cells of the `img` matrix to extract the smoothed value from the encoded value. \n    \n    Hence, the time complexity of the algorithm is $O((m \\cdot n \\cdot 9) + (m \\cdot n))$, which is $O(m \\cdot n)$.\n    \n* Space complexity: $O(1)$\n\n    We are not using any extra space. Smoothened Values are encoded and extracted in the existing integer value of `img`. Hence, the space complexity of the algorithm is $O(1)$.\n        \n---\n\n### Approach 4: Bit Manipulation\n\n#### Intuition\n\nLet's again analyze the constraints given in the problem statement.\n\n> `0 <= img[i][j] <= 255`\n\nAn integer, in most of the programming languages, is represented using 32 bits. The `255` is `11111111` in binary. All numbers from `0` to `255` require at most 8 bits to represent them. \n\nHence, out of these 32 bits, only the least significant 8 bits are used to represent the value of `img[i][j]`. We, to avoid any inconsistency, won't alter the most significant bit, as it is often used to represent the sign of the integer. Hence, the 23 bits are free to use.\n\n![unused](../Figures/661/661_slide_images_used/Slide8.PNG)\n\nThis suggests the idea that in these 23 unused bits, we can store the smoothed value of `img[i][j]`. This we can achieve by using bit-manipulation. In bit manipulation, we use the bit-wise operators.For quick review of bit-wise operators, click here- **NOT:** Bitwise NOT is a unary operator that flips the bits of the integer. If the current bit is $0$, it will change it to $1$ and vice versa. The symbol of the bitwise NOT operator is tilde (`~`).\n\n    ```\n    N = 5 = 101 (in binary)\n    ~N = ~(101) = 010 = 2 (in decimal)\n    ```\n\n- **AND:** If both bits in the compared position of the operand are $1$, the bit in the resulting bit pattern is $1$, otherwise $0$. The symbol of the bitwise AND operator is ampersand (`&`).\n\n    ```\n    A = 5 = 101 (in binary) \n    B = 1 = 001 (in binary) \n    A & B = 101 & 001 = 001 = 1 (in decimal)\n    ```\n\n- **OR:** If both bits in the compared position of the operand are $0$, the bit in the resulting bit pattern is $0$, otherwise $1$. The symbol of the bitwise OR operator is pipe (`|`).\n\n    ```\n    A = 5 = 101 (in binary) \n    B = 1 = 001 (in binary) \n    A | B = 101 | 001 = 101 = 5 (in decimal)\n    ```\n\n- **XOR:** In bitwise XOR if both bits are the same, the result will be $0$, otherwise $1$. The symbol of the bitwise XOR operator is caret (`^`).\n\n    ```\n    A = 5 = 101 (in binary) \n    B = 1 = 001 (in binary) \n    A ^ B = 101 ^ 001 = 100 = 4 (in decimal)\n    ```\n\n- **Left Shift:** The Left shift operator is a binary operator that shifts bits to the left by a certain number of positions and appends `0` at the right side. One left shift is equivalent to multiplying the bit pattern with $2$. The symbol of the left shift operator is `<<`.\n\n  `x << y` means left shift `x` by `y` bits, which is equivalent to multiplying `x` with $2^y$.\n\n    ```\n    A = 1 = 001 (in binary) \n    A << 1 = 001 << 1 = 010 = 2 (in decimal)\n    A << 2 = 001 << 2 = 100 = 4 (in decimal)\n    \n    B = 5 = 00101 (in binary)\n    B << 1 = 00101 << 1 = 01010 = 10 (in decimal)\n    B << 2 = 00101 << 2 = 10100 = 20 (in decimal)\n    ```\n\n- **Right Shift:** The Right shift operator is a binary operator that shifts bits to the right by a certain number of positions and appends `0` at the left side. One right shift is equivalent to dividing the bit pattern with $2$. The symbol of the right shift operator is `>>`.\n\n  `x >> y` means right shift `x` by `y` bits, which is equivalent to dividing `x` with $2^y$.\n\n    ```\n    A = 4 = 100 (in binary) \n    A >> 1 = 100 >> 1 = 010 = 2 (in decimal)\n    A >> 2 = 100 >> 2 = 001 = 1 (in decimal)\n    A >> 3 = 100 >> 3 = 000 = 0 (in decimal)\n    \n    B = 5 = 00101 (in binary)\n    B >> 1 = 00101 >> 1 = 00010 = 2 (in decimal)\n    ```$\\downarrow_{\\text{Portion After Review}}$\n\n\nNow the smoothed value is an average of nine values ranging from `0` to `255`. Hence, the average will also lie between `0` to `255`. Thus, the smoothed value will also require at most 8 bits to represent it. This we can store together as follows.\n\n![two_store](../Figures/661/661_slide_images_used/Slide9.PNG)\n\n**How do we store smoothened corresponding values?** Let's see.\n\nInitially, the smoothened corresponding value was a separate integer, as shown in the figure below.   \n![separate](../Figures/661/661_slide_images_used/Slide10.PNG)\n\nWe can left shift (using the `<<` operator ) the integer so that the orientation now looks like as follows.\n![left_shift](../Figures/661/661_slide_images_used/Slide11.PNG)\n\nNow there is a property of bitwise OR (`|`) operator. `x | 0 = x`. In the context of the diagram, doing bitwise OR of both these separate integers\n- The most significant 16 bits will remain 0 because both integers have 0 in those bits.\n- The least significant 8 bits will store the values of `img[i][j]` \n- The remaining 8 bits will store the values of the smoothened corresponding value.   \n\n![or](../Figures/661/661_slide_images_used/Slide12.PNG)\n\n**How can we extract the original value of `img[i][j]` from this mixed integer?** \n\nIn other words, \n\n- We wish to set all except the least significant 8 bits to 0. \n    \n    The bitwise AND (`&`) operator has property of `x & 0 = 0`. Thus to set the first 24 bits to `0`, we can do bitwise AND with an integer that has the first 24 bits as `0`\n    \n- We wish to retain the least significant 8 bits as it is.  \n\n    The bitwise AND (`&`) operator has property of `x & 1 = x`. Thus to retain the last 8 bits as it is, we can do bitwise AND with an integer that has the last 8 bits as `1`.\n\nThus, the integer with which we can do bitwise AND (`&`) to extract the original value of `img[i][j]` is `00000000000000000000000011111111`, which is `255` in decimal, and `11111111` in binary.\n\n![and](../Figures/661/661_slide_images_used/Slide13.PNG)\n\n\n**How can we extract the smoothened value from this mixed integer, after we are done with computing all the smoothened values?**\n\nAs done above, we perhaps can do bitwise AND (`&`) with `00000000000000001111111100000000`, which is `65280` in decimal, and `1111111100000000` in binary. This will retain the smoothened value bits as it is, turning off all other bits.\n\nAfter that, to get the smoothened value, we can right shift (using the`>>` operator ) the integer by 8 bits (To encode, we did a left shift by 8 bits). This will bring the smoothened value to the least significant 8 bits.\n\nHowever, readers can appreciate that only the right shift is sufficient to extract the smoothened value. \n\n![right_shift](../Figures/661/661_slide_images_used/Slide14.PNG)\n\nHence, our algorithm will be\n- For every cell, assume it stores the mixed-integer.\n- Extract the original value of `img[i][j]` using bitwise AND (`&`) with `255`.\n- Compute smoothened value using neighbors of `img[i][j]`. For computing the smoothened value, we need the original value of neighbors as well, which will be extracted using the same logic.\n- Left shift (`<<`) the smoothened value by 8 bits, and encode it in the mixed integer using bitwise OR (`|`) operator.\n- Once every mixed integer of the matrix is encoded with the smoothened value, extract the smoothened value using the right shift (`>>`) operator.\n\n> The bit manipulation works because we have only 8 bits per pixel (abbreviated as \"bpp\"). The \"bpp\" is the number of bits used to represent the color of a single pixel in a bitmapped image or video frame buffer. Hence, we can use the remaining bits to store the smoothened value.\n\nReaders can appreciate the one-to-one correspondence in this approach and [previous approach](#approach-3-constant-space-smoothened-image)\n\n- Bitwise AND (`&`) with `255` $\\equiv$ modulo by `256`\n\n- Left shift (`<<`) by 8 bits $\\equiv$ multiply by `256`\n\n- Bitwise OR (`|`) of smoothened value with `img[i][j]` provided least significant 8 bits of the left-shifted smoothened value are `0` $\\equiv$ add `img[i][j]`\n\n- Right shift (`>>`) by 8 bits $\\equiv$ divide by `256`\n\nThis was hinted at **[Point to Ponder](#implementation-2)** in previous approach.\n\nThe bit-wise operators are faster than arithmetic operators. Hence, this approach is faster than the [previous approach](#approach-3-constant-space-smoothened-image).\n\n#### Algorithm\n\n1. Save the dimensions of the image. Store the number of rows in `m`, and the number of columns in `n`, as convention used in the problem statement as well.\n\n2. Iterate over the cells of the image. Let's call the current cell `img[i][j]`.\n    \n    - Initialize two integer variables `sum` and `count` to `0`.\n\n    - Iterate over all plausible nine indices `(x, y)`. The `(x, y)` are\n      - `(i - 1, j - 1)`\n\n      - `(i - 1, j)`\n      - `(i - 1, j + 1)`\n      - `(i, j - 1)`\n      - `(i, j)`\n      - `(i, j + 1)`\n      - `(i + 1, j - 1)`\n      - `(i + 1, j)`\n      - `(i + 1, j + 1)` \n        \n      If the indices form a valid neighbor, then extract the original value of `img[x][y]` using `img[x][y] & 255`, and add it to `sum`. Increment `count` by `1`.\n            \n    - Encode the smoothed value in `img[i][j]` as `img[i][j] |= (sum / count) << 8 `.\n\n3. Traverse again over the cells of the image. Let's call the current cell `img[i][j]`. Extract the smoothed value from `img[i][j]` using `img[i][j] >> 8`, and store it in `img[i][j]`\n\n4. Return the `img`.\n\n#### Implementation**Implementation Notes:** Different programming languages have different notations of bitwise operators. For example, for the bitwise NOT operator, we have the following notations:  \n- [C++](https://en.cppreference.com/w/cpp/language/operator_arithmetic) uses `~` \n- [Go](https://go.dev/ref/spec) uses unary `^` operator\n- [Elixir](https://hexdocs.pm/elixir/1.13.0/Bitwise.html) uses `~~~`, or `bnot`\n- [Rust](https://doc.rust-lang.org/book/appendix-02-operators.html) uses `!`\n- In [Kotlin](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/inv.html), we can use `inv()` function\n\n\n#### Complexity Analysis\n\nLet $m$ be the number of rows in the `img` matrix, and $n$ be the number of columns in the `img` matrix.\n\n* Time complexity: $O(m \\cdot n)$\n\n    We are traversing every cell of the `img` matrix. There are $m \\cdot n$ cells in the `img` matrix.\n    \n    For each cell, we are iterating over all plausible nine indices. There are at most nine indices for each cell. At each index, we are doing constant time bitwise operations.\n\n    > We are taking bitwise AND (`&`) of `sum` and `255`. Now there can be at most $32$ (or any other constant number) bits in an integer. Hence, the `&` operator will be done at most $32$ times. Thus, the time complexity of the bitwise AND (`&`) operator is $O(32)$, which is $O(1)$.\n\n    > We are left shifting (`<<`) an integer (`sum / count`) by `8` bits.   \n    > \n    > Left shifting $1$ bit in a signed integer is done by \n    > - Assigning to every non-signed bit the value of the bit to its right side\n    >\n    > - The LSB doesn't have any bit to its right side, so it is assigned `0`\n    > \n    > Hence, there will be at most $31$ such assignments in one left shift, since in a signed integer, the MSB is used to represent the sign of the integer, and it is retained as it is in the left shift. \n    >\n    > Hence, number of assignments in one left shift is $31$, and in $8$ left shifts, it is $31 \\cdot 8 = 248$. Thus, the time complexity of the left shift (`<<`) operator is $O(248)$, which is $O(1)$.\n    \n    > We are also doing bitwise OR (`|`) of two integers `img[i][j]` and `(sum / count) << 8`. Now there can be at most $32$ (or any other constant number) bits in an integer. Hence, the `|` operator will be done at most $32$ times. Thus, the time complexity of the bitwise OR (`|`) operator is $O(32)$, which is $O(1)$.\n\n    Again, we are traversing over all the cells of the `img` matrix to extract the smoothed value from the encoded value using the bitwise operator. \n\n    > We are right shifting (`>>`) an integer (`img[i][j]`) by `8` bits.\n    > \n    > Right shifting $1$ bit in a signed integer is done by\n    > - Assigning to every non-signed bit the value of the bit to its left side, except for the *second most significant bit*\n    > \n    > - The *second most significant bit* has to its left side the *most significant bit*, which is used to represent the sign of the integer. Hence, the *second most significant bit* is assigned the value of `0`\n    > \n    > Hence, there will be at most $31$ such assignments in one right shift, since in a signed integer, the MSB is used to represent the sign of the integer, and it is retained as it is in the right shift.\n    >\n    > Hence, number of assignments in one right shift is $31$, and in $8$ right shifts, it is $31 \\cdot 8 = 248$. Thus, the time complexity of the right shift (`>>`) operator is $O(248)$, which is $O(1)$.\n    \n    Hence, the time complexity of the algorithm is $O((m \\cdot n \\cdot 9) + (m \\cdot n))$, which is $O(m \\cdot n)$.\n    \n* Space complexity: $O(1)$\n\n    We are not using any extra space. Smoothened values are encoded and extracted in the existing integer value of `img`. Hence, the space complexity of the algorithm is $O(1)$.\n        \n---"
}