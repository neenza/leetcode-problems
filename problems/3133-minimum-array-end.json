{
  "title": "Minimum Array End",
  "problem_id": "3394",
  "frontend_id": "3133",
  "difficulty": "Medium",
  "problem_slug": "minimum-array-end",
  "topics": [
    "Bit Manipulation"
  ],
  "description": "You are given two integers n and x. You have to construct an array of positive integers nums of size n where for every 0 <= i < n - 1, nums[i + 1] is greater than nums[i], and the result of the bitwise AND operation between all elements of nums is x.\nReturn the minimum possible value of nums[n - 1].\nExample 1:\nExample 2:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: n = 3, x = 4\nOutput: 6\nExplanation:\nnums can be [4,5,6] and its last element is 6.",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input: n = 2, x = 7\nOutput: 15\nExplanation:\nnums can be [7,15] and its last element is 15.",
      "images": []
    }
  ],
  "constraints": [
    "1 <= n, x <= 108"
  ],
  "follow_ups": [],
  "hints": [
    "Each element of the array should be obtained by “merging” <code>x</code> and <code>v</code> where <code>v = 0, 1, 2, …(n - 1)</code>.",
    "To merge <code>x</code> with another number <code>v</code>, keep the set bits of <code>x</code> untouched, for all the other bits, fill the set bits of <code>v</code> from right to left in order one by one.",
    "So the final answer is the “merge” of <code>x</code> and <code>n - 1</code>."
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    long long minEnd(int n, int x) {\n        \n    }\n};",
    "java": "class Solution {\n    public long minEnd(int n, int x) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def minEnd(self, n, x):\n        \"\"\"\n        :type n: int\n        :type x: int\n        :rtype: int\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def minEnd(self, n: int, x: int) -> int:\n        ",
    "c": "long long minEnd(int n, int x) {\n    \n}",
    "csharp": "public class Solution {\n    public long MinEnd(int n, int x) {\n        \n    }\n}",
    "javascript": "/**\n * @param {number} n\n * @param {number} x\n * @return {number}\n */\nvar minEnd = function(n, x) {\n    \n};",
    "typescript": "function minEnd(n: number, x: number): number {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param Integer $n\n     * @param Integer $x\n     * @return Integer\n     */\n    function minEnd($n, $x) {\n        \n    }\n}",
    "swift": "class Solution {\n    func minEnd(_ n: Int, _ x: Int) -> Int {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun minEnd(n: Int, x: Int): Long {\n        \n    }\n}",
    "dart": "class Solution {\n  int minEnd(int n, int x) {\n    \n  }\n}",
    "golang": "func minEnd(n int, x int) int64 {\n    \n}",
    "ruby": "# @param {Integer} n\n# @param {Integer} x\n# @return {Integer}\ndef min_end(n, x)\n    \nend",
    "scala": "object Solution {\n    def minEnd(n: Int, x: Int): Long = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn min_end(n: i32, x: i32) -> i64 {\n        \n    }\n}",
    "racket": "(define/contract (min-end n x)\n  (-> exact-integer? exact-integer? exact-integer?)\n  )",
    "erlang": "-spec min_end(N :: integer(), X :: integer()) -> integer().\nmin_end(N, X) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec min_end(n :: integer, x :: integer) :: integer\n  def min_end(n, x) do\n    \n  end\nend"
  },
  "solution": "[TOC]\n\n## Solution\n\n---\n\n### Approach 1: Consecutive ORing  \n\n#### Intuition\n\nThe challenge is that the array must be strictly increasing, at the same time, we need to ensure that the AND of all the numbers stays as `x`.\n\nThe first thing that comes to mind is that, for the AND of all numbers to remain `x`, every number in the array needs to include at least the same bits as `x`. This means that the numbers in the array must retain the bitwise characteristics of `x` as we move from one element to the next.\n\nNow, the smallest valid number we can start with is `x` itself, since including anything smaller would lose the bit pattern that defines `x`. From there, we need to build up the next elements while keeping the numbers strictly increasing. The key idea is that as long as the new number has the same relevant bits as `x`, the AND result will remain unchanged.\n\nTo achieve this, we take the current number and increment it. But after incrementing, we force the new number to keep the bit pattern of `x` by applying a bitwise OR with `x`. This ensures that no bits from `x` are lost in the process, and we continue this until the last element is constructed. The result is the smallest last element that satisfies both conditions: strictly increasing order and preserving the AND operation result as `x`.\n\nFor example, take `n = 3` and `x = 4`:\n\nStarting with $x = 4$ (binary: $100$), we need to find the smallest integer $y$ such that $y > 4$ and the bitwise AND of $4$ and $y$ remains $4$. We apply the expression:\n\n$\\text{result} = (\\text{result} + 1) | x$\n\n1. First Step:\n\n   $\\text{result} = 4 \\implies \\text{result} = (4 + 1) | 4 \\implies \\text{result} = 5 | 4 = 5$\n   \n   Confirming the AND condition: \n\n   $4 \\& 5 = 4$\n\n2. Second Step:\n\n   $\\text{result} = 5 \\implies \\text{result} = (5 + 1) | 4 \\implies \\text{result} = 6 | 4 = 6$\n\n   Confirming the AND condition:\n\n   $4 \\& 5 \\& 6 = 4$\n\nThus, $6$ is the smallest valid last element, ensuring that the array satisfies both the increasing order and the required AND condition.\n\n#### Algorithm\n\n- Initialize `result` with the value of `x`.\n\n- Iterate `n - 1` times (since `result` is already initialized with `x`):\n  - Increment `result` by `1`.\n  - Perform a bitwise OR operation between `result` and `x`, and store the result back in `result`.\n\n- After completing the iterations, return `result`.\n\n#### Implementation\n\n> Note: The Python’s handling of arbitrarily large integers and loop overhead causes slower performance, leading to TLE for large inputs.#### Complexity Analysis\n\nLet $n$ be the number of iterations required, which is determined by the input size of `n`.\n\n- Time complexity: $O(n)$\n\n    The `while` loop runs $n - 1$ times because the loop starts with `n` reduced by 1(because of x), and each iteration performs a constant number of operations:\n\n    Therefore, the time complexity is linear in terms of $n$, so the overall time complexity is $O(n)$.\n\n- Space complexity: $O(1)$\n\n    The space complexity remains constant since only a few variables (`result`, `n`, and `x`) are used, and no additional data structures or recursive calls are involved.\n\n---\n\n### Approach 2: Bit Manipulation and Binary Construction\n\n#### Intuition\n\nHere we dig deeper into the bit-level structure of the numbers. We begin by converting both `x` and `n-1` (the difference between the first and last elements) into their binary forms.\n \nThe intuition here is that the binary representation of `x` tells us which bits we need to preserve across all numbers, while the binary form of `n-1` gives us the flexibility to fill in the gaps between consecutive numbers. We essentially want to merge the bit structures of `x` and `n-1` in a way that allows us to build the smallest valid number that still retains the necessary bits from `x`.\n\nWe loop through the binary bits of `x`, identifying the positions where bits can be set to create valid numbers. At the same time, we insert bits from `n-1` where allowed, making sure that this bit manipulation still results in numbers that are strictly larger than the previous ones. The final number is constructed by combining the bits from both `x` and `n-1` in a way that keeps the AND result consistent.\n\nFor example, take `n = 3` and `x = 4`:\n\nWe start with `x = 4` (binary: $100$) and check the bits of $n-1 = 2$ (binary: $010$).\n\n- At position 2, $x$ has a $1$, meaning we must preserve this bit.\n- At position 1, $x$ has a $0$, allowing us to use the bit from $n-1$, which is $1$.\n- At position 0, both $x$ and $n-1$ have $0$, so we keep it unset.\n\nThus, the combined binary result is $110$ (which is $6$ in decimal).\n\n\n![DetailedBinaryOperationAnalysis](../Figures/3133/3133_Approach2.png)\n\n#### Algorithm\n\n- Initialize `result` as 0 to store the final result, and `bit` for bit manipulation.\n\n- Decrease `n` by 1 to exclude `x` from the iteration (`--n`).\n\n- Initialize two arrays, `binaryX` and `binaryN`, each of size 64 to hold the binary representation of `x` and `n-1`, respectively.\n\n- Convert `x` and `n-1` to `long long` for 64-bit manipulation.\n\n- Build the binary representations for both `x` and `n-1`:\n  - For each bit position `i` from 0 to 63:\n    - Extract the `i`-th bit of `x` and store it in `binaryX[i]`.\n    - Extract the `i`-th bit of `n-1` and store it in `binaryN[i]`.\n\n- Initialize two pointers, `posX` and `posN`, to 0 to keep track of the current bit positions in `binaryX` and `binaryN`.\n\n- Traverse the binary representation of `x` (`binaryX`):\n  - Move `posX` forward until a `0` bit is found in `binaryX`.\n  - Copy the corresponding bit from `binaryN[posN]` into `binaryX[posX]`.\n  - Increment both `posX` and `posN` to continue the traversal.\n\n- Rebuild the final result from the combined binary representation:\n  - For each bit `i` from 0 to 63:\n    - If `binaryX[i]` is `1`, convert the bit back to its decimal value using `2^i` and add it to `result`.\n\n- Return `result`, which is the combined binary representation as a decimal number.\n\n#### Implementation#### Complexity Analysis\n\n- Time Complexity: $O(\\log n)$\n\n    The algorithm performs operations based on the number of bits in `n`. On a 64-bit system, this translates to at most 64 bits, but theoretically, the number of bits scales with the input size, leading to $O(\\log n)$ complexity.\n    \n    Constructing the binary representation of both `x` and `n-1` involves extracting each bit. For a 64-bit integer, this requires at most 64 iterations, but for an arbitrary integer, it would take $O(\\log n)$ time.\n    \n    The second loop traverses the bits of `x` to locate the first zero bit and replace it with the corresponding bit from `n-1`, requiring up to $\\log n$ iterations.\n    \n    Converting the modified binary representation back to a decimal requires $O(\\log n)$ operations.\n    \n    Thus, the theoretical time complexity is $O(\\log n)$, although for 64-bit systems, it effectively operates within a constant bound of 64 iterations.\n\n- Space Complexity: $O(\\log n)$\n\n    The algorithm utilizes two arrays, `binaryX` and `binaryN`, each with a size of $O(\\log n)$ to store the bit representations of `x` and `n-1`.\n    \n    A constant number of scalar variables (`result`, `bit`, `posX`, `posN`) are also used, which take up $O(1)$ space.\n    \n    Thus, the space complexity is $O(\\log n)$, which reflects the storage required for the bitwise representation of `n`.\n\n> Both the time complexity (TC) and space complexity (SC) are $O(\\log n)$. However, on 64-bit systems, they effectively operate within a constant bound of 64 iterations. Thus, it can sometimes be argued that the complexity is $O(1)$ as well.\n\n---\n\n### Approach 3: Bitmasking with Logical Operations\n\n#### Intuition\n\nWe can refine the logic further by focusing directly on manipulating the bits.\n\nFirst, we reduce `n` by 1, since we’re constructing a list that has `n` gaps between the first and last elements. Then, starting from `x`, we look at each bit and decide if adding a new bit will help us meet the condition. If a bit isn’t already set in `x`, we check whether setting that bit from `n` will help. We do this bit by bit, using a mask to check and adjust each position.\n\nBy carefully adding only the bits we need from `n`, we can ensure that the final number is as small as possible while keeping overall AND equal to `x`. \n\n#### Algorithm\n\n- Initialize `result` to `x` and define a `mask` variable for bit manipulation.\n\n- Decrement `n` by 1 to exclude `x` from the iteration.\n\n- Iterate over each bit position with `mask`, starting from 1 and shifting left in each iteration:\n  - If the corresponding bit in `x` is 0 (`(mask & x) == 0`):\n    - Update `result` by setting the bit based on the least significant bit of `n`.\n    - Right shift `n` by 1 to process the next bit.\n\n- Continue this process until `n` becomes 0.\n\n- Return `result` as the final computed value.\n\n#### Implementation#### Complexity Analysis\n\nLet $b$ be the number of bits in the binary representation of `n`\n\n- Time complexity: $O(\\log n)$\n\n    The loop iterates over the bits of `n` and `x` using the mask, checking each bit of `x` to see if it's 0. The loop condition is driven by `n > 0`, meaning it will terminate when all bits of `n` have been processed.\n\n    The number of iterations of the `for` loop depends on the number of bits in `x` where `mask & x == 0`. In the worst case, this could be up to $\\log n$.\n\n    For each iteration, we perform constant-time operations like bitwise AND, shifting, and OR. Thus, the overall time complexity is $O(\\log n)$, which for a fixed size (like 64 bits) could be considered $O(1)$ in practical terms.\n    \n- Space complexity: $O(1)$\n\n    The space complexity is constant because the algorithm uses a fixed number of variables (`result`, `mask`, and `n`) and no additional data structures that grow with input size.\n\n---"
}