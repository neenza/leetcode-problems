{
  "title": "Find the Number of Distinct Colors Among the Balls",
  "problem_id": "3434",
  "frontend_id": "3160",
  "difficulty": "Medium",
  "problem_slug": "find-the-number-of-distinct-colors-among-the-balls",
  "topics": [
    "Array",
    "Hash Table",
    "Simulation"
  ],
  "description": "You are given an integer limit and a 2D array queries of size n x 2.\nThere are limit + 1 balls with distinct labels in the range [0, limit]. Initially, all balls are uncolored. For every query in queries that is of the form [x, y], you mark ball x with the color y. After each query, you need to find the number of colors among the balls.\nReturn an array result of length n, where result[i] denotes the number of colors after ith query.\nNote that when answering a query, lack of a color will not be considered as a color.\nExample 1:\nExample 2:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: limit = 4, queries = [[1,4],[2,5],[1,3],[3,4]]\nOutput: [1,2,2,3]\nExplanation:\n",
      "images": [
        "https://assets.leetcode.com/uploads/2024/04/17/ezgifcom-crop.gif"
      ]
    },
    {
      "example_num": 2,
      "example_text": "Input: limit = 4, queries = [[0,1],[1,2],[2,2],[3,4],[4,5]]\nOutput: [1,2,2,3,4]\nExplanation:\n",
      "images": [
        "https://assets.leetcode.com/uploads/2024/04/17/ezgifcom-crop2.gif"
      ]
    }
  ],
  "constraints": [
    "1 <= limit <= 109",
    "1 <= n == queries.length <= 105",
    "queries[i].length == 2",
    "0 <= queries[i][0] <= limit",
    "1 <= queries[i][1] <= 109"
  ],
  "follow_ups": [],
  "hints": [
    "Use two HashMaps to maintain the color of each ball and the set of balls with each color."
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    vector<int> queryResults(int limit, vector<vector<int>>& queries) {\n        \n    }\n};",
    "java": "class Solution {\n    public int[] queryResults(int limit, int[][] queries) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def queryResults(self, limit, queries):\n        \"\"\"\n        :type limit: int\n        :type queries: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def queryResults(self, limit: int, queries: List[List[int]]) -> List[int]:\n        ",
    "c": "/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nint* queryResults(int limit, int** queries, int queriesSize, int* queriesColSize, int* returnSize) {\n    \n}",
    "csharp": "public class Solution {\n    public int[] QueryResults(int limit, int[][] queries) {\n        \n    }\n}",
    "javascript": "/**\n * @param {number} limit\n * @param {number[][]} queries\n * @return {number[]}\n */\nvar queryResults = function(limit, queries) {\n    \n};",
    "typescript": "function queryResults(limit: number, queries: number[][]): number[] {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param Integer $limit\n     * @param Integer[][] $queries\n     * @return Integer[]\n     */\n    function queryResults($limit, $queries) {\n        \n    }\n}",
    "swift": "class Solution {\n    func queryResults(_ limit: Int, _ queries: [[Int]]) -> [Int] {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun queryResults(limit: Int, queries: Array<IntArray>): IntArray {\n        \n    }\n}",
    "dart": "class Solution {\n  List<int> queryResults(int limit, List<List<int>> queries) {\n    \n  }\n}",
    "golang": "func queryResults(limit int, queries [][]int) []int {\n    \n}",
    "ruby": "# @param {Integer} limit\n# @param {Integer[][]} queries\n# @return {Integer[]}\ndef query_results(limit, queries)\n    \nend",
    "scala": "object Solution {\n    def queryResults(limit: Int, queries: Array[Array[Int]]): Array[Int] = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn query_results(limit: i32, queries: Vec<Vec<i32>>) -> Vec<i32> {\n        \n    }\n}",
    "racket": "(define/contract (query-results limit queries)\n  (-> exact-integer? (listof (listof exact-integer?)) (listof exact-integer?))\n  )",
    "erlang": "-spec query_results(Limit :: integer(), Queries :: [[integer()]]) -> [integer()].\nquery_results(Limit, Queries) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec query_results(limit :: integer, queries :: [[integer]]) :: [integer]\n  def query_results(limit, queries) do\n    \n  end\nend"
  },
  "solution": "[TOC]\n\n## Solution\n\n---\n\n### Overview\n\nOur task is to return an array listing the number of distinct colors after each query. Note that in this case, distinct means the number of total colors. It does not mean that the color only appears one time. \n\nLet's look at an example of a potential set of queries:\n\n!?!../Documents/3160_fix/slideshow1_fix.json:960,540!?!\n\nIn this problem, two main scenarios can occur at each query:\n1. **Uncolored Ball** - adding a color to a ball that did not already have a color\n2. **Colored Ball** - adding a color to an already colored ball, replacing the previous color on the ball with the new color\n\n---\n\n### Approach 1: Hashmap and Array (MLE)\n\n#### Intuition\n\nWhen approaching this problem, the main challenge is efficiently tracking and updating the colors of the balls after each query.\n\nTo solve this problem, we'll need to track both the number of times each color appears, and the number of distinct colors. \n\nLet's consider the two different scenarios that occur when a query is applied to a ball. If the ball is:\n1. Uncolored: the count of the newly assigned color is increased. \n2. Colored: the count of the new color is increased and the count of the previously assigned color decreases. \n\nWhether or not the number of distinct colors is impacted will depend on the total number of balls of that color already present. \n\nA **hashmap** can be used for this purpose since it efficiently associates counts with specific colors.\n\nWe also need to track the current color of each ball because the problem involves overwriting existing colors. A straightforward solution is to use an **array** to store the color of each ball, where the index represents the ball and the value at that index represents the current color of the ball.\n\nWith these data structures in place, we can now proceed to process the queries. For each query, we update the color of the ball and adjust the count of distinct colors accordingly. As we process each query, we maintain the color count and track the balls' colors.\n\nHowever, this solution ultimately fails due to exceeding the memory limit allowed for this problem.\n\n#### Algorithm\n\n1. Initialize:\n   * an integer `n`, equal to the length of `queries`.\n   * an array `result` of length `n`, where `result[i]` denotes the number of distinct colors after the `ith` query.\n   * an array `ballArray`, which stores the distinct ball labels found when traversing `queries` and the current colors associated with them.\n   * A hash map `colorMap`, which stores the number of distinct colors after processing the current query.\n2. Iterate from index `0` to `n - 1` to traverse the queries. For each query, `query[i]`:\n   * Initialize:\n       * an integer `ball` equal to `query[i][0]`, denoting the current ball that will be colored.\n       * an integer `color` equal to `query[i][1]`, denoting the color that the ball will be colored.\n   * If `ballArray[ball]` is not `0`, meaning the ball is already colored:\n       * Check the existing color of `ball`, which will be labeled `prevColor`.\n       * Decrement the count of `prevColor` in `colorMap`.\n       * If the count becomes `0`, remove `prevColor` from `colorMap`.\n   * Update `ballArray[ball]` to color.\n   * Increase the count of `color` in `colorMap` by one.\n   * Set `result[i]` to the size of `colorMap`.\n3. Return the `result` array.\n\n#### Implementation#### Complexity Analysis\n\nLet $n$ be the number of `queries` and $m$ be the `limit`.\n\n* Time Complexity: $O(n)$\n\n   The algorithm iterates through each query exactly once, performing constant-time operations for each query. \n   \n   Specifically, for each query, it checks and updates the `ballArray` and colorMap, both of which are $O(1)$ operations due to the use of a hash map (`colorMap`) and an array (`ballArray`). \n   \n   Therefore, the overall time complexity is linear in the number of queries, $O(n)$.\n\n   Note: The operations on the `colorMap` (such as get, put, and remove) are considered $O(1)$ on average due to the nature of hash maps.\n\n* Space Complexity: $O(m + n)$\n\n   The space complexity is determined by the `ballArray` and the `colorMap`. The `ballArray` has a size of $m + 1$ (since it stores the color of each ball up to the limit $m$), and the `colorMap` can store up to $n$ distinct colors in the worst case (if all queries introduce a new color). Therefore, the space complexity is $O(m + n)$.\n   \n   Note: The `result` array also contributes $O(n)$ space, but since it is part of the output, it is typically not counted in the auxiliary space complexity. However, if we include it, the space complexity remains $O(m + n)$.\n\n---\n\n### Approach 2: Two Hash Maps\n\n#### Intuition\n\nThe main challenge from the previous solution is identifying and addressing areas where large amounts of memory are used.\n\nA significant portion of our memory usage comes from the array of size `limit + 1`. When we look at the constraints, we can see that the value of `limit` can be extremely large, with the range `1 <= limit <= 10^9`. Contrarily, the queries only range from `1 <= n <= 10^5`, where `n` is the length of `queries`. As we navigate through the queries, we can see that not all of the ball labels are guaranteed to be accessed by the queries, leading to unnecessary memory usage.\n\nWe can improve our storage efficiency by eliminating wasted space. Here, we need to choose a data structure that only allocates space as needed. Similar to how the colors are stored, we can utilize a **hash map** to store only the necessary labels accessed by the queries. By doing so, we can optimize the space complexity and prevent memory overuse.\n\nAfter making this adjustment, we can apply the same logic and procedure as the previous solution. With this space optimization, we can process and track the results from the queries while staying within the memory limit.\n\n#### Algorithm\n\n1. Initialize:\n   * an integer `n`, equal to the length of `queries`.\n   * an array `result` of length `n`, where `result[i]` denotes the number of distinct colors after the `ith` query.\n   * two hash maps:\n       1. `colorMap`, which stores the number of distinct colors after processing current query.\n       2. `ballMap`, which stores the distinct ball labels found when traversing `queries` and the current colors associated with them.\n2. Iterate from index `0` to `n-1` to traverse the queries. For each query, `query[i]`:\n   * Initialize:\n       * an integer `ball` equal to `query[i][0]`, denoting the current ball that will be colored.\n       * an integer `color` equal to `query[i][1]`, denoting the color that the ball will be colored.\n   * If `ball` already exists in `ballMap`, meaning it is already colored:\n       * Check the existing color of `ball`, which will be labeled `prevColor`.\n       * Decrement the count of `prevColor` in `colorMap`.\n       * If the count becomes `0`, remove `prevColor` from `colorMap`.\n   * Update `ballMap[ball]` to `color`.\n   * Increase the count of `color` in `colorMap` by one.\n   * Set `result[i]` to the current size of `colorMap`.\n3. Return the `result` array.\n\n#### Implementation#### Complexity Analysis\n\nLet $n$ be the size of `queries`.\n\n* Time Complexity: $O(n)$\n\n   The algorithm iterates through each query exactly once, performing constant-time operations for each query. \n   \n   Specifically, for each query, it checks and updates the `ballMap` and `colorMap`, both of which are $O(1)$ operations on average due to the use of hash maps. \n   \n   Therefore, the overall time complexity is linear in the number of queries, $O(n)$.\n   \n   Note: The operations on the `ballMap` and `colorMap` (such as `get`, `put`, and `remove`) are considered $O(1)$ on average due to the nature of hash maps.\n\n* Space Complexity: $O(n)$\n\n   The space complexity is determined by the `ballMap` and the `colorMap`. \n   \n   In the worst case, `ballMap` can store up to $n$ distinct colors (if all queries introduce a new ball label), and the `colorMap` can store up to $n$ distinct colors (if all queries introduce a new color). Therefore, the space complexity is $O(2n)$, which simplifies to $O(n)$.\n   \n   Note: The `result` array also contributes $O(n)$ space, but since it is part of the output, it is typically not counted in the auxiliary space complexity. However, if we include it, the space complexity remains $O(n)$.\n\n---"
}