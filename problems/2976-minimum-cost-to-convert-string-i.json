{
  "title": "Minimum Cost to Convert String I",
  "problem_id": "3235",
  "frontend_id": "2976",
  "difficulty": "Medium",
  "problem_slug": "minimum-cost-to-convert-string-i",
  "topics": [
    "Array",
    "String",
    "Graph",
    "Shortest Path"
  ],
  "description": "You are given two 0-indexed strings source and target, both of length n and consisting of lowercase English letters. You are also given two 0-indexed character arrays original and changed, and an integer array cost, where cost[i] represents the cost of changing the character original[i] to the character changed[i].\nYou start with the string source. In one operation, you can pick a character x from the string and change it to the character y at a cost of z if there exists any index j such that cost[j] == z, original[j] == x, and changed[j] == y.\nReturn the minimum cost to convert the string source to the string target using any number of operations. If it is impossible to convert source to target, return -1.\nNote that there may exist indices i, j such that original[j] == original[i] and changed[j] == changed[i].\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: source = \"abcd\", target = \"acbe\", original = [\"a\",\"b\",\"c\",\"c\",\"e\",\"d\"], changed = [\"b\",\"c\",\"b\",\"e\",\"b\",\"e\"], cost = [2,5,5,1,2,20]\nOutput: 28\nExplanation: To convert the string \"abcd\" to string \"acbe\":\n- Change value at index 1 from 'b' to 'c' at a cost of 5.\n- Change value at index 2 from 'c' to 'e' at a cost of 1.\n- Change value at index 2 from 'e' to 'b' at a cost of 2.\n- Change value at index 3 from 'd' to 'e' at a cost of 20.\nThe total cost incurred is 5 + 1 + 2 + 20 = 28.\nIt can be shown that this is the minimum possible cost.",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input: source = \"aaaa\", target = \"bbbb\", original = [\"a\",\"c\"], changed = [\"c\",\"b\"], cost = [1,2]\nOutput: 12\nExplanation: To change the character 'a' to 'b' change the character 'a' to 'c' at a cost of 1, followed by changing the character 'c' to 'b' at a cost of 2, for a total cost of 1 + 2 = 3. To change all occurrences of 'a' to 'b', a total cost of 3 * 4 = 12 is incurred.",
      "images": []
    },
    {
      "example_num": 3,
      "example_text": "Input: source = \"abcd\", target = \"abce\", original = [\"a\"], changed = [\"e\"], cost = [10000]\nOutput: -1\nExplanation: It is impossible to convert source to target because the value at index 3 cannot be changed from 'd' to 'e'.",
      "images": []
    }
  ],
  "constraints": [
    "1 <= source.length == target.length <= 105",
    "source, target consist of lowercase English letters.",
    "1 <= cost.length == original.length == changed.length <= 2000",
    "original[i], changed[i] are lowercase English letters.",
    "1 <= cost[i] <= 106",
    "original[i] != changed[i]"
  ],
  "follow_ups": [],
  "hints": [
    "Construct a graph with each letter as a node, and construct an edge <code>(a, b)</code> with weight <code>c</code> if we can change from character <code>a</code> to letter <code>b</code> with cost <code>c</code>. (Keep the one with the smallest cost in case there are multiple edges between <code>a</code> and <code>b</code>).",
    "Calculate the shortest path for each pair of characters <code>(source[i], target[i])</code>. The sum of cost over all <code>i</code> in the range <code>[0, source.length - 1]</code>. If there is no path between <code>source[i]</code> and <code>target[i]</code>, the answer is <code>-1</code>.",
    "Any shortest path algorithms will work since we only have <code>26</code> nodes. Since we only have at most <code>26 * 26</code> pairs, we can save the result to avoid re-calculation.",
    "We can also use Floyd Warshall's algorithm to precompute all the results."
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    long long minimumCost(string source, string target, vector<char>& original, vector<char>& changed, vector<int>& cost) {\n        \n    }\n};",
    "java": "class Solution {\n    public long minimumCost(String source, String target, char[] original, char[] changed, int[] cost) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def minimumCost(self, source, target, original, changed, cost):\n        \"\"\"\n        :type source: str\n        :type target: str\n        :type original: List[str]\n        :type changed: List[str]\n        :type cost: List[int]\n        :rtype: int\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def minimumCost(self, source: str, target: str, original: List[str], changed: List[str], cost: List[int]) -> int:\n        ",
    "c": "long long minimumCost(char* source, char* target, char* original, int originalSize, char* changed, int changedSize, int* cost, int costSize) {\n    \n}",
    "csharp": "public class Solution {\n    public long MinimumCost(string source, string target, char[] original, char[] changed, int[] cost) {\n        \n    }\n}",
    "javascript": "/**\n * @param {string} source\n * @param {string} target\n * @param {character[]} original\n * @param {character[]} changed\n * @param {number[]} cost\n * @return {number}\n */\nvar minimumCost = function(source, target, original, changed, cost) {\n    \n};",
    "typescript": "function minimumCost(source: string, target: string, original: string[], changed: string[], cost: number[]): number {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param String $source\n     * @param String $target\n     * @param String[] $original\n     * @param String[] $changed\n     * @param Integer[] $cost\n     * @return Integer\n     */\n    function minimumCost($source, $target, $original, $changed, $cost) {\n        \n    }\n}",
    "swift": "class Solution {\n    func minimumCost(_ source: String, _ target: String, _ original: [Character], _ changed: [Character], _ cost: [Int]) -> Int {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun minimumCost(source: String, target: String, original: CharArray, changed: CharArray, cost: IntArray): Long {\n        \n    }\n}",
    "dart": "class Solution {\n  int minimumCost(String source, String target, List<String> original, List<String> changed, List<int> cost) {\n    \n  }\n}",
    "golang": "func minimumCost(source string, target string, original []byte, changed []byte, cost []int) int64 {\n    \n}",
    "ruby": "# @param {String} source\n# @param {String} target\n# @param {Character[]} original\n# @param {Character[]} changed\n# @param {Integer[]} cost\n# @return {Integer}\ndef minimum_cost(source, target, original, changed, cost)\n    \nend",
    "scala": "object Solution {\n    def minimumCost(source: String, target: String, original: Array[Char], changed: Array[Char], cost: Array[Int]): Long = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn minimum_cost(source: String, target: String, original: Vec<char>, changed: Vec<char>, cost: Vec<i32>) -> i64 {\n        \n    }\n}",
    "racket": "(define/contract (minimum-cost source target original changed cost)\n  (-> string? string? (listof char?) (listof char?) (listof exact-integer?) exact-integer?)\n  )",
    "erlang": "-spec minimum_cost(Source :: unicode:unicode_binary(), Target :: unicode:unicode_binary(), Original :: [char()], Changed :: [char()], Cost :: [integer()]) -> integer().\nminimum_cost(Source, Target, Original, Changed, Cost) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec minimum_cost(source :: String.t, target :: String.t, original :: [char], changed :: [char], cost :: [integer]) :: integer\n  def minimum_cost(source, target, original, changed, cost) do\n    \n  end\nend"
  },
  "solution": "[TOC]\n\n## Solution\n\n---\n\n### Overview\n\nWe have two strings, `source` and `target`, both of the same length. Additionally, we have three arrays: `original`, `changed`, and `cost`, each also of the same length. \n\nOur task is to transform the `source` text into the `target` text using a series of character conversions. Each conversion works as follows:\n\n1. Identify a character in `source` that does not match the corresponding character in `target`.\n2. Find this mismatched character in the `original` array.\n3. Replace it with the corresponding character from the `changed` array.\n4. Each conversion has a cost specified in the `cost` array.\n\nThe goal is to determine the minimum total cost required to transform `source` into `target`.\n\n---\n\n### Approach 1: Dijkstra's Algorithm\n\n#### Intuition\n\nOur task is to convert each mismatched character at the lowest possible cost. To tackle this, we can model each character as a node in a graph, with transformations represented as directed edges between nodes, each with a specific cost. The problem then becomes finding the minimum cost path from each character in `source` to the corresponding character in `target`.\n\nConsider Example 1 from the problem description visualized as a graph:\n\n![Graph Representation](../Figures/2976/graph.png)\n\nTo find the minimum cost path between nodes, Dijkstra's Single Source Shortest Path algorithm is useful. It efficiently calculates the shortest path in a directed graph with non-negative edge weights. For more information, refer to this LeetCode [Explore Card](https://leetcode.com/explore/learn/card/graph/622/single-source-shortest-path-algorithm/3862/).\n\nFirst, create a graph structure using an adjacency list to represent all possible character conversions. For each index `i`:\n- The character in `original[i]` is the starting point.\n- The character in `changed[i]` is the destination.\n- The value in `cost[i]` denotes the conversion cost.\n\nEach conversion is an edge in our graph, mapping potential character transformations and their costs. Instead of running Dijkstra's algorithm for every differing character, precompute the shortest path from every character to every other character. This reduces the need to execute the algorithm multiple times, leveraging the fact that there are only $26$ possible characters.\n\nFinally, calculate the total minimum cost by summing the precomputed costs for each differing character in `source` and `target`.\n\n#### Algorithm\n\nMain method `minimumCost`:\n\n- Create an `adjacencyList` with 26 entries (one for each lowercase letter).\n- Iterate through the `original` array: For each index `i`:\n  - Add an edge to `adjacencyList` from `original[i]` to `changed[i]`, with the corresponding `cost[i]`.\n- For each of the $26$ characters, call `dijkstra` to find the shortest path from this character to all other characters.\n- Store the results in a 2D array `minConversionCosts` of size $26 \\times 26$.\n- Initialize a variable `totalCost` to `0`.\n- Iterate through the length of `source`:\n  - If the character at the current position differs from `target`:\n    - Look up the conversion cost in `minConversionCosts`:\n      - If the conversion is impossible (cost is `-1`), return `-1`.\n      - Else, add the cost to `totalCost`.\n- Return `totalCost` as the answer.\n\nHelper method `dijkstra`:\n\n- Define a method `dijkstra` with parameters: `startChar` and `adjacencyList`.\n- Create a priority queue `priorityQueue` with each element as a pair of (cost, character). Sort the queue by cost (lowest first).\n- Initialize an array `minCosts` of size $26$ with all values set to `-1` (representing unreachable positions).\n- Add `startChar` to `priorityQueue` with a cost of `0`.\n- While `priorityQueue` is not empty:\n  - Poll a pair (`currentCost`, `currentChar`) from the queue.\n  - Loop over all possible conversions from `currentChar` using the `adjacencyList`. For each `conversion` to `targetChar`:\n    - Find the `newTotalCost` to do the conversion as `currentCost + conversionCost`.\n    - If the conversion hasn't been reached yet `minCosts[targetChar] == -1`, or `newTotalCost` is less than the previous cost in `minCosts[targetChar]`:\n      - Set `minCosts[targetChar]` as `newTotalCost`.\n      - Add the pair `(newTotalCost, targetChar)` to the priority queue.\n- Return `minCosts`.\n\n#### Implementation#### Complexity Analysis\n\nLet $n$ be the length of `source` and $m$ be the length of the `original` array.\n\n- Time complexity: $O(m + n)$\n\n    Creating the adjacency list requires $O(m)$ time as the algorithm loops over the contents of the `original`, `changed`, and `cost` array simultaneously.\n\n    In our algorithm, the number of vertices is $26$ and the number of edges is $m$, which makes the time complexity of Dijkstra's algorithm $O((26 + m) \\log 26)$. We call `dijkstra` for each of the $26$ characters. Thus, the total time complexity is $O(26 \\cdot (26 + m) \\log 26)$, which can be simplified to $O(m)$.\n\n    To calculate the `totalCost`, we iterate over the `source` string, which has a time complexity of $O(n)$.\n\n    The total time complexity is the addition of all these elements, i.e., $O(m) + O(n) = O(m + n)$.\n\n- Space complexity: $O(m)$\n\n    The `adjacencyList` stores all possible conversions, requiring a space complexity of $O(m)$. `minConversionCosts` uses $O(26 \\times 26)$ space, which simplifies to $O(1)$.\n\n    The `dijkstra` method uses a priority queue that can store at most $m$ elements in the worst case. The array `minCosts` has a fixed size of $26$. Thus, the total space used by the method is $O(m)$.\n\n    The total space required by the algorithm is $O(m) + O(1) + O(m)$, which simplifies to $O(m)$.\n\n---\n\n### Approach 2: Floyd-Warshall Algorithm\n\n#### Intuition\n\nIn the previous approach, we used Dijkstra's algorithm to find the minimum cost of converting each of the 26 lowercase characters to every other character, effectively applying a single-source shortest path algorithm multiple times. Instead, we can use a multi-source shortest-path algorithm.\n\n[Floyd-Warshall's All Pairs Shortest Path](https://en.wikipedia.org/wiki/Floyd%E2%80%93Warshall_algorithm) algorithm, an effective dynamic programming technique, calculates the minimum cost path between all pairs of vertices in a directed graph. This fits our needs perfectly since we require the minimum traversal cost between every pair of lowercase characters.\n\nThe Floyd-Warshall algorithm works by iterating through each vertex as a potential intermediate point for all pairs of vertices. We create a matrix `minCost`, where `minCost[i][j]` represents the minimum cost to travel from vertex `i` to `j`. The algorithm involves three nested loops to update `minCost[i][j]` by considering whether a shorter path exists through an intermediate vertex `k`. After completing these iterations, `minCost` will hold the minimum costs for all character pairs.\n\nWe then iterate through the `source` and `target` strings, comparing characters at each position. For differing characters, we look up the minimum conversion cost in the `minCost` matrix. If any transformation is impossible, we return `-1`; otherwise, we sum the costs to get the total minimum conversion cost.\n\n#### Algorithm\n \n- Initialize:\n  - `totalCost` to store the total minimum cost.\n  - a 2D array `minCost` to store the minimum transformation cost between any two characters. \n- Initialize each entry in `minCost` to the maximum integer value to represent initial conversion costs.\n- Using `original`, `changed`, and `cost`, update the `minCost` array with the minimum cost for each given conversion.\n- Utilize three loops. The outermost loop runs `k` from `0` to `25`, where `k` is the character being considered as an intermediate node.\n  - For each fixed k, the inner loops iterate over all pairs of characters `(i, j)`, where `i` and `j` are the source and destination characters respectively. For each `(i, j)`:\n    - We check whether the current known minimum cost `minCost[i][j]` can be improved by going through the intermediate character `k`. If it can, we update `minCost[i][j]`.\n- Iterate through each character of `source`:\n  - If the character matches with `target`, continue with the next iteration.\n  - Else, check `minCost` for the conversion cost:\n    - If the conversion cost is greater than or equal to the max integer value, return `-1`.\n    - Else, add the cost to `totalCost`.\n- Return `totalCost`.\n\n#### Implementation#### Complexity Analysis\n\nLet $n$ be the length of `source` and $m$ be the length of the `original` array.\n\n* Time complexity: $O(m + n)$\n\n    Populating `minCosts` with the initial conversion costs takes $O(m)$ time. \n\n    Each of the three nested loops runs $26$ times. Thus, the overall time taken is $O(26^3) = O(1)$.\n\n    To calculate the `totalCost`, the algorithm loops over the `source` string, which takes linear time.\n\n    Thus, the time complexity of the algorithm is $O(m) + O(1) + O(n)$, which simplifies to $O(m + n)$.\n\n* Space complexity: $O(1)$\n\n    The `minCost` array has a fixed size of $26 \\times 26$. We do not use any other data structures dependent on the length of the input space. Thus, the algorithm has a constant space complexity.\n\n---"
}