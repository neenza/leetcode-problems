{
  "title": "Human Traffic of Stadium",
  "problem_id": "601",
  "frontend_id": "601",
  "difficulty": "Hard",
  "problem_slug": "human-traffic-of-stadium",
  "topics": [
    "Database"
  ],
  "description": "Table: Stadium\nWrite a solution to display the records with three or more rows with consecutive id's, and the number of people is greater than or equal to 100 for each.\nReturn the result table ordered by visit_date in ascending order.\nThe result format is in the following example.\nExample 1:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "+---------------+---------+\n| Column Name   | Type    |\n+---------------+---------+\n| id            | int     |\n| visit_date    | date    |\n| people        | int     |\n+---------------+---------+\nvisit_date is the column with unique values for this table.\nEach row of this table contains the visit date and visit id to the stadium with the number of people during the visit.\nAs the id increases, the date increases as well.",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input: \nStadium table:\n+------+------------+-----------+\n| id   | visit_date | people    |\n+------+------------+-----------+\n| 1    | 2017-01-01 | 10        |\n| 2    | 2017-01-02 | 109       |\n| 3    | 2017-01-03 | 150       |\n| 4    | 2017-01-04 | 99        |\n| 5    | 2017-01-05 | 145       |\n| 6    | 2017-01-06 | 1455      |\n| 7    | 2017-01-07 | 199       |\n| 8    | 2017-01-09 | 188       |\n+------+------------+-----------+\nOutput: \n+------+------------+-----------+\n| id   | visit_date | people    |\n+------+------------+-----------+\n| 5    | 2017-01-05 | 145       |\n| 6    | 2017-01-06 | 1455      |\n| 7    | 2017-01-07 | 199       |\n| 8    | 2017-01-09 | 188       |\n+------+------------+-----------+\nExplanation: \nThe four rows with ids 5, 6, 7, and 8 have consecutive ids and each of them has >= 100 people attended. Note that row 8 was included even though the visit_date was not the next day after row 7.\nThe rows with ids 2 and 3 are not included because we need at least three consecutive ids.",
      "images": []
    }
  ],
  "constraints": [],
  "follow_ups": [],
  "hints": [],
  "code_snippets": {
    "mysql": "# Write your MySQL query statement below\n",
    "mssql": "/* Write your T-SQL query statement below */\n",
    "oraclesql": "/* Write your PL/SQL query statement below */\n",
    "pythondata": "import pandas as pd\n\ndef human_traffic(stadium: pd.DataFrame) -> pd.DataFrame:\n    ",
    "postgresql": "-- Write your PostgreSQL query statement below\n"
  },
  "solution": "​[TOC]\n​\n# Solution\n​\n---\n​\n## pandas\n​\nWe offer two ways to approach this problem of finding consecutive values. One way is to use the functions [`shift()`](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.shift.html) and [`diff()`](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.diff.html) to compare the values between the current row and the previous rows. Another way, inspired by the idea of 'gaps and islands', is to find the islands (consecutive values) from all rows. You can learn more about this [concept](https://www.mssqltips.com/sqlservertutorial/9130/sql-server-window-functions-gaps-and-islands-problem/) if you are interested in this idea.### Approach 1: Examine Previous Rows Using shift() and diff()#### AlgorithmFor this approach, we find the consecutive `id`s by calculating 1) the differences between the current `id` and the last `id` and 2) the differences between the last `id` and the `id` before the last `id`. If both differences are equal to 1, we find the 3rd  `id` in the three consecutive `id`s.\n\nWe start with creating a new DataFrame to store only the records with `people` larger than or equal to 100 from the DataFrame `stadium` since we only need to find consecutive `id`s from these records. \n\n```python\ndf = stadium[stadium['people'] >= 100]\n```\n\nThe new DataFrame is as follows: \n\n| id | visit_date | people |\n| -- | ---------- | ------ |\n| 2  | 2017-01-02 | 109    |\n| 3  | 2017-01-03 | 150    |\n| 5  | 2017-01-05 | 145    |\n| 6  | 2017-01-06 | 1455   |\n| 7  | 2017-01-07 | 199    |\n| 8  | 2017-01-09 | 188    |\n\nNow we can start to identify the consecutive `id`s. For the difference between the current `id` and the `id` of the previous row, we can simply find the difference using `diff()`; for the difference between the `id` of the previous row and the `id` before the previous row, we can use both `diff()` and `shift(1)`. If both differences are equal to 1, the `id` of the current row is the third ID in the three consecutive `id`s, and the new column `flag` created will mark these rows that contain the valid third ID as `True`.\n\n```python\ndf['flag'] = ((df['id'].diff() == 1) & (df['id'].diff().shift(1) == 1))\n```\n\nHere is what the output looks like: \n\n| id | visit_date | people | flag  |\n| -- | ---------- | ------ | ----- |\n| 2  | 2017-01-02 | 109    | null  |\n| 3  | 2017-01-03 | 150    | null  |\n| 5  | 2017-01-05 | 145    | false |\n| 6  | 2017-01-06 | 1455   | false |\n| 7  | 2017-01-07 | 199    | true  |\n| 8  | 2017-01-09 | 188    | true  |\n\nSince the row with `flag` equal to `True` is always the 3rd `id` in any three or more consecutive `id`s group, we only need to figure out how to select not only the rows with `flag` equal to `True`, but also their previous two rows.\n\n```python\ndf = df[(df['flag'] == True)| (df['flag'].shift(-1) == True) | (df['flag'].shift(-2) == True)]\n```\n\nBelow are all the records with three or more consecutive `id`s.\n\n| id | visit_date | people | flag  |\n| -- | ---------- | ------ | ----- |\n| 5  | 2017-01-05 | 145    | false |\n| 6  | 2017-01-06 | 1455   | false |\n| 7  | 2017-01-07 | 199    | true  |\n| 8  | 2017-01-09 | 188    | true  |\n\n\nSo close! We want to clean the output as requested by the problem: we remove the column `flag` from the output, and order the result by the column `visit_date`. \n\n```python\nreturn df.loc[:, df.columns != 'flag'].sort_values(by='visit_date')\n```#### Implementation\n​​### Approach 2: Finding the Islands#### Algorithm\n​The key to identifying the islands (consecutive values) from a column is to calculate the difference between the column (in this problem, it is the column `id`) and a new rank (looks like an index id) we append to all rows. Any islands will be some consecutive rows that share the same result from this calculation. If all `id`s are consecutive, the differences between this new rank and the `id` will be the same for all rows, in other words, all rows belong to this one island. If no `id`s are consecutive, every row will return a different value from this calculation, and no island is identified.\n\nTo begin with, we update the original DataFrame to get only the records with `people` larger than or equal to 100 since we only need to find consecutive `id`s from these records.\n\n```python\nstadium = stadium[stadium['people'] >= 100]\n```\n| id | visit_date | people |\n| -- | ---------- | ------ |\n| 2  | 2017-01-02 | 109    |\n| 3  | 2017-01-03 | 150    |\n| 5  | 2017-01-05 | 145    |\n| 6  | 2017-01-06 | 1455   |\n| 7  | 2017-01-07 | 199    |\n| 8  | 2017-01-09 | 188    |\n\nNow we can start to identify the islands (consecutive values). To do this, we first create our rank of the records and store it in a separate column `rnk` for future calculations. \n\n```python\nstadium['rnk'] = range(len(stadium))\n```\n| id | visit_date | people | rnk |\n| -- | ---------- | ------ | --- |\n| 2  | 2017-01-02 | 109    | 0   |\n| 3  | 2017-01-03 | 150    | 1   |\n| 5  | 2017-01-05 | 145    | 2   |\n| 6  | 2017-01-06 | 1455   | 3   |\n| 7  | 2017-01-07 | 199    | 4   |\n| 8  | 2017-01-09 | 188    | 5   |\n\nThen we calculate the difference between the column `rnk` and the original column `id`, and save this result in a new column `island`.\n\n```python\nstadium['island'] = stadium.id - stadium.rnk\n```\n\nWe can see from the output that two islands are discovered from the records (the islands are the rows sharing the same values in the new column `island`). \n\n| id | visit_date | people | rnk | island |\n| -- | ---------- | ------ | --- | ------ |\n| 2  | 2017-01-02 | 109    | 0   | 2      |\n| 3  | 2017-01-03 | 150    | 1   | 2      |\n| 5  | 2017-01-05 | 145    | 2   | 3      |\n| 6  | 2017-01-06 | 1455   | 3   | 3      |\n| 7  | 2017-01-07 | 199    | 4   | 3      |\n| 8  | 2017-01-09 | 188    | 5   | 3      |\n\nHowever, not all islands are qualified for this problem. We want to make sure the island contains three or more rows since we are looking for three or more consecutive `id`s. To get this count, we group the rows by the column `island` and count how many `id`s are contained in each group. We store this aggregated count along with each row in a separate column called `island_cnt`. \n\n```python\nstadium['island_cnt'] = stadium.groupby(['island'], as_index=False).id.transform('count')\n```\n\nThe output looks like this: \n\n| id | visit_date | people | rnk | island | island_cnt |\n| -- | ---------- | ------ | --- | ------ | ---------- |\n| 2  | 2017-01-02 | 109    | 0   | 2      | 2          |\n| 3  | 2017-01-03 | 150    | 1   | 2      | 2          |\n| 5  | 2017-01-05 | 145    | 2   | 3      | 4          |\n| 6  | 2017-01-06 | 1455   | 3   | 3      | 4          |\n| 7  | 2017-01-07 | 199    | 4   | 3      | 4          |\n| 8  | 2017-01-09 | 188    | 5   | 3      | 4          |\n\n​\nNow we can identify the qualified islands, which are records in an island and with a count (`island_cnt`) larger than or equal to 3. \n\n```python\nreturn stadium[stadium['island_cnt'] >= 3]\n```\n\nLast but not least, we select only the needed columns and sort the result by `visit_date` as the problem requested. We can add these steps to the previous step.\n\n```python\nreturn stadium[stadium['island_cnt'] >= 3][['id', 'visit_date', 'people']].sort_values(by='visit_date')\n```#### Implementation\n​---\n​\n​\n## Database\nWe provide three different ways to solve this problem of identifying consecutive values. If the problem doesn't require too many consecutive rows (say, 5?), we can create table aliases and manually compare the differences from the rows of each table alias. For better performance, or if the problem is looking for too many consecutive rows, we can use window functions `LEAD()` or `LAG()` to append values from the previous and next rows and calculate the differences between them. If you are interested in a more graceful way to approach this problem, you probably want to learn a bit more about the idea of ['gap and island'](https://www.mssqltips.com/sqlservertutorial/9130/sql-server-window-functions-gaps-and-islands-problem/), and we will also provide an approach using this concept.\n\nThere are some similar questions you can practice once you have mastered the methodologies: [180](https://leetcode.com/problems/consecutive-numbers/), [603](https://leetcode.com/problems/consecutive-available-seats/), [1454](https://leetcode.com/problems/active-users/)### Approach 1: Using Self-Join#### AlgorithmThe number of consecutive values we need to identify decides how many table aliases we need to create. For this problem, the number is three. Since we are only interested in the records with people greater than or equal to 100, we can also add the filter to all three table aliases in this step. \n\n```sql\nSELECT \n    *\nFROM \n    stadium AS a, stadium AS b, stadium AS c\nWHERE\n    a.people >= 100 AND b.people >= 100 AND c.people >= 100\n```\n​\nNow we can identify the consecutive `id`s by calculating the differences between `id`s from each table alias. \n\nIf the three `id`s are consecutive from table a, b, and c, which means the difference between the two `id`s are 1, we can add filters like below: \n\n```sql\nWHERE (a.id - b.id = 1 AND b.id - c.id = 1)\n```\n\nBut how can we select all three `id`s from three table aliases and put these `id`s into one column instead of multiple columns? A workaround is to put one table alias, in this approach we select table a, in all possible positions of the three consecutive `id`s. \n\nWhen a.`id` is the **minimum** `id` in the three consecutive `id`s (c.`id` > b.`id` > a.`id`):\n```sql\n(c.id - b.id = 1 AND b.id - a.id = 1)\n```\n\nWhen a.`id` is in the **middle** of the three consecutive `id`s (b.`id` > a.`id` > c.`id`):\n```sql\n(b.id - a.id = 1 AND a.id - c.id = 1)\n```\n\nNow we can just `SELECT` records from table a and `ORDER` the results by `visit_date` as requested.#### Implementation\n\n```mysql []\nSELECT \n    DISTINCT a.*\nFROM \n    stadium AS a, stadium AS b, stadium AS c\nWHERE\n     a.people >= 100 AND b.people >= 100 AND c.people >= 100\nAND \n    (\n       (a.id - b.id = 1 AND b.id - c.id = 1)\n    OR (c.id - b.id = 1 AND b.id - a.id = 1)\n    OR (b.id - a.id = 1 AND a.id - c.id = 1)\n    )\nORDER BY visit_date\n```### Approach 2: Using Window Functions#### AlgorithmFor this approach, we append the values from the previous and next rows by using `LEAD()` and `LAG()` and then compare the differences to find the consecutive values. We can also apply the filter to identify only the records with people greater than or equal to 100 in this step. The output will be stored in a CTE for future use.  \n\n```sql\nWITH base AS (\n        SELECT *,\n            LEAD(id, 1) OVER(ORDER BY id) AS next_id,\n            LEAD(id, 2) OVER(ORDER BY id) AS second_next_id,\n            LAG(id, 1) OVER(ORDER BY id) AS last_id,\n            LAG(id, 2) OVER(ORDER BY id) AS second_last_id\n        FROM stadium\n        WHERE people >= 100 \n        )\n```\n\nBelow is what the CTE `base` looks like. Notice the new `id` columns created by `LEAD()` and `LAG()` do not include the records that are filtered out, which is exactly what we are looking for. \n\n| id | visit_date | people | next_id | second_next_id | last_id | second_last_id |\n| -- | ---------- | ------ | ------- | -------------- | ------- | -------------- |\n| 2  | 2017-01-02 | 109    | 3       | 5              | null    | null           |\n| 3  | 2017-01-03 | 150    | 5       | 6              | 2       | null           |\n| 5  | 2017-01-05 | 145    | 6       | 7              | 3       | 2              |\n| 6  | 2017-01-06 | 1455   | 7       | 8              | 5       | 3              |\n\n\n\nNow we can start to identify the consecutive `id`s. Since we want to return all the records with three or more consecutive `id`s, we want to make sure the `id` from the current is in any of the possible positions within the three consecutive `id`s. \n\nWhen `id` is in the **middle** of the three consecutive `id`s and the order is `next_id` > `id` > `last_id`:\n```sql\nWHERE (next_id - id = 1 AND id - last_id = 1)\n```\n\nWhen `id` is the **minimum** `id` of the three consecutive `id`s and the order is `second_next_id` > `next_id` > `id`:\n```sql\nOR (second_next_id - next_id = 1 AND next_id - id = 1)\n```\n\nWhen `id` is the **maximum** `id` of the three consecutive `id`s and the order is `id` > `last_id` > `second_last_id`: \n```sql\nOR (id - last_id = 1 AND last_id - second_last_id = 1)\n```\n\nNow the only thing left us to do is to update the output by selecting the required columns and order the result by `visit_date` in the main query.\n\n```sql\nSELECT DISTINCT id, visit_date, people\nFROM base \nWHERE (next_id - id = 1 AND id - last_id = 1)\n    OR (second_next_id - next_id = 1 AND next_id - id = 1)\n    OR (id - last_id = 1 AND last_id - second_last_id = 1)\nORDER BY visit_date\n```#### Implementation\n\n```mysql []\nWITH base AS (\n        SELECT *,\n            LEAD(id, 1) OVER(ORDER BY id) AS next_id,\n            LEAD(id, 2) OVER(ORDER BY id) AS second_next_id,\n            LAG(id, 1) OVER(ORDER BY id) AS last_id,\n            LAG(id, 2) OVER(ORDER BY id) AS second_last_id\n        FROM stadium\n        WHERE people >= 100 \n        )\nSELECT DISTINCT id, visit_date, people\nFROM base \nWHERE (next_id - id = 1 AND id - last_id = 1)\n    OR (second_next_id - next_id = 1 AND next_id - id = 1)\n    OR (id - last_id = 1 AND last_id - second_last_id = 1)\nORDER BY visit_date\n```### Approach 3: Finding the Islands#### AlgorithmThe key to identifying the islands (consecutive values) from a column is to calculate the difference between the column (in this problem, it is the column `id`) and a new rank (looks like an index id) we append to all rows. Any islands will be the rows that share the same result from this calculation. If all `id`s are consecutive, the differences between this new rank and the `id` will be the same for all rows, in other words, all rows belong to this one island. If no `id`s are consecutive, every row will return a different value from this calculation, and no island is identified.\n\nFor this problem, we want to identify the islands (consecutive values) from all the records. To do this, we need to create a new rank for all the qualified records, which are the records of people greater than or equal to 100. Either `RANK()` or `ROW_NUMBER()` works for this purpose. \n\n```sql\nSELECT id, visit_date, people, RANK()OVER(ORDER BY id) AS rnk\nFROM Stadium\nWHERE people >= 100\n```\n\nNow we have a new column, `rnk`, in addition to the original `id`:\n\n| id | visit_date | people | rnk |\n| -- | ---------- | ------ | --- |\n| 2  | 2017-01-02 | 109    | 1   |\n| 3  | 2017-01-03 | 150    | 2   |\n| 5  | 2017-01-05 | 145    | 3   |\n\n​\nWith these new ranks for the records, we can identify the islands by calculating the differences between `id` and `rnk`. We store the result of this calculation in a new column called `island` and save the output in a CTE, `stadium with rnk`, for future use. \n\n```sql\nWITH stadium_with_rnk AS\n(\n    SELECT id, visit_date, people, rnk, (id - rnk) AS island\n    FROM (\n        SELECT id, visit_date, people, RANK() OVER(ORDER BY id) AS rnk\n        FROM Stadium\n        WHERE people >= 100) AS t0\n)\n```\n\nThe records sharing the same value in the column `island` are the ones with consecutive `id`s:\n\n| id | visit_date | people | rnk | island |\n| -- | ---------- | ------ | --- | ------ |\n| 2  | 2017-01-02 | 109    | 1   | 1      |\n| 3  | 2017-01-03 | 150    | 2   | 1      |\n| 5  | 2017-01-05 | 145    | 3   | 2      |\n| 6  | 2017-01-06 | 1455   | 4   | 2      |\n| 7  | 2017-01-07 | 199    | 5   | 2      |\n| 8  | 2017-01-09 | 188    | 6   | 2      |\n\n\nHowever, we only want islands with three or more consecutive `id`s. To identify these islands, we group the record by the column `island`, and filter the aggregated groups to get the qualified islands.  \n\n```sql\nSELECT island \nFROM stadium_with_rnk\nGROUP BY island\nHAVING COUNT(*) >= 3\n```\n\n| island |\n| ------ |\n| 2      |\n\nNow With the qualified islands identified, we can select all records associated with these islands. We put the previous step in a subquery and use it as a filter. In the main query, we only select the requested columns from the island and sort the result by `visit_date`. \n\n```sql\nSELECT id, visit_date, people \nFROM stadium_with_rnk\nWHERE island IN (SELECT island \n                 FROM stadium_with_rnk \n                 GROUP BY island \n                 HAVING COUNT(*) >= 3)\nORDER BY visit_date\n```#### Implementation\n\n```mysql []\nWITH stadium_with_rnk AS\n(\n    SELECT id, visit_date, people, rnk, (id - rnk) AS island\n    FROM (\n        SELECT id, visit_date, people, RANK() OVER(ORDER BY id) AS rnk\n        FROM Stadium\n        WHERE people >= 100) AS t0\n)\nSELECT id, visit_date, people \nFROM stadium_with_rnk\nWHERE island IN (SELECT island \n                 FROM stadium_with_rnk \n                 GROUP BY island \n                 HAVING COUNT(*) >= 3)\nORDER BY visit_date\n```"
}