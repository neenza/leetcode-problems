{
  "title": "Find the Winner of the Circular Game",
  "problem_id": "1951",
  "frontend_id": "1823",
  "difficulty": "Medium",
  "problem_slug": "find-the-winner-of-the-circular-game",
  "topics": [
    "Array",
    "Math",
    "Recursion",
    "Queue",
    "Simulation"
  ],
  "description": "There are n friends that are playing a game. The friends are sitting in a circle and are numbered from 1 to n in clockwise order. More formally, moving clockwise from the ith friend brings you to the (i+1)th friend for 1 <= i < n, and moving clockwise from the nth friend brings you to the 1st friend.\nThe rules of the game are as follows:\nGiven the number of friends, n, and an integer k, return the winner of the game.\nExample 1:\nExample 2:\nConstraints:\nFollow up:\nCould you solve this problem in linear time with constant space?",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: n = 5, k = 2\nOutput: 3\nExplanation: Here are the steps of the game:\n1) Start at friend 1.\n2) Count 2 friends clockwise, which are friends 1 and 2.\n3) Friend 2 leaves the circle. Next start is friend 3.\n4) Count 2 friends clockwise, which are friends 3 and 4.\n5) Friend 4 leaves the circle. Next start is friend 5.\n6) Count 2 friends clockwise, which are friends 5 and 1.\n7) Friend 1 leaves the circle. Next start is friend 3.\n8) Count 2 friends clockwise, which are friends 3 and 5.\n9) Friend 5 leaves the circle. Only friend 3 is left, so they are the winner.",
      "images": [
        "https://assets.leetcode.com/uploads/2021/03/25/ic234-q2-ex11.png"
      ]
    },
    {
      "example_num": 2,
      "example_text": "Input: n = 6, k = 5\nOutput: 1\nExplanation: The friends leave in this order: 5, 4, 6, 2, 3. The winner is friend 1.",
      "images": [
        "https://assets.leetcode.com/uploads/2021/03/25/ic234-q2-ex11.png"
      ]
    }
  ],
  "constraints": [
    "1 <= k <= n <= 500"
  ],
  "follow_ups": [],
  "hints": [
    "Simulate the process.",
    "Maintain in a circular list the people who are still in the circle and the current person you are standing at.",
    "In each turn, count k people and remove the last person from the list."
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    int findTheWinner(int n, int k) {\n        \n    }\n};",
    "java": "class Solution {\n    public int findTheWinner(int n, int k) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def findTheWinner(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def findTheWinner(self, n: int, k: int) -> int:\n        ",
    "c": "int findTheWinner(int n, int k) {\n    \n}",
    "csharp": "public class Solution {\n    public int FindTheWinner(int n, int k) {\n        \n    }\n}",
    "javascript": "/**\n * @param {number} n\n * @param {number} k\n * @return {number}\n */\nvar findTheWinner = function(n, k) {\n    \n};",
    "typescript": "function findTheWinner(n: number, k: number): number {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param Integer $n\n     * @param Integer $k\n     * @return Integer\n     */\n    function findTheWinner($n, $k) {\n        \n    }\n}",
    "swift": "class Solution {\n    func findTheWinner(_ n: Int, _ k: Int) -> Int {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun findTheWinner(n: Int, k: Int): Int {\n        \n    }\n}",
    "dart": "class Solution {\n  int findTheWinner(int n, int k) {\n    \n  }\n}",
    "golang": "func findTheWinner(n int, k int) int {\n    \n}",
    "ruby": "# @param {Integer} n\n# @param {Integer} k\n# @return {Integer}\ndef find_the_winner(n, k)\n    \nend",
    "scala": "object Solution {\n    def findTheWinner(n: Int, k: Int): Int = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn find_the_winner(n: i32, k: i32) -> i32 {\n        \n    }\n}",
    "racket": "(define/contract (find-the-winner n k)\n  (-> exact-integer? exact-integer? exact-integer?)\n  )",
    "erlang": "-spec find_the_winner(N :: integer(), K :: integer()) -> integer().\nfind_the_winner(N, K) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec find_the_winner(n :: integer, k :: integer) :: integer\n  def find_the_winner(n, k) do\n    \n  end\nend"
  },
  "solution": "[TOC]\n\n## Solution\n\n---\n\n### Overview\n\nIn this circular game, `n` friends numbered from `1` to `n` stand in a circle. In the first round, we start counting from friend 1 and eliminate the `k`-th friend. In each subsequent round, counting starts from the friend immediately clockwise to the one just eliminated, and the `k`-th friend is eliminated again. This process repeats until only one person remains.\n\nA straightforward approach for turn-based games can be to simulate the game's rules. Here, our algorithm can eliminate the `k`-th friend in each iteration. However, optimizations are often possible, as in this problem, where we can reduce space and time complexity. \n\nWe will start with a simulation approach and then explore more efficient methods that avoid manually following the game's rules.\n\n> Note: This is famously known as the Josephus Problem.\n\n---\n\n### Approach 1: Simulation with List\n\n### Intuition\n\nTo simulate this elimination game, we can start by representing the `n` friends using a list data structure. Initially, this list contains all the friends labeled from `1` to `n`. The idea is to repeatedly count to the `k`-th friend in the list and remove them from the game. By continually removing every `k`-th friend and adjusting our starting point after each removal, we can narrow down the group until only one friend remains. This final remaining friend is the winner of the game.\n\n### Algorithm\n\n1. Initialize a list of size `n`, representing `n` friends labeled from `1` to `n`\n2. Maintain a `startIndex` variable that keeps track of the position from where counting begins, initially set to 0.\n3. While more than 1 friend is remaining:\n    * Calculate the new index of the next friend to remove as `(startIndex + k - 1) % numFriendsRemaining`. We apply the modulus operator to ensure counting wraps around the circle.\n    * Remove the friend at the calculated index\n    * Update `startIndex` to the removed index\n4. Return the label of the last remaining friend \n\n### Implementation### Complexity Analysis\n\nLet $n$ be the initial size of the friend circle.\n\n* Time Complexity: $O(n^2)$\n\n    Considering the `pop` operation inside the loop, the time complexity for each iteration can be $O(n)$ in the worst case (when `pop` shifts all subsequent elements). Since we might potentially perform $n-1$ `pop` operations (removing `n-1` friends), the overall worst-case time complexity is $O(n^2)$.\n\n* Space Complexity: $O(n)$\n\n    The space complexity of the algorithm is primarily dominated by the `circle` list, which stores `n` integers representing the friends. Therefore, the space complexity is $O(n)$. Other variables like `startIndex` and `removalIndex` are integers and require constant additional space, $O(1)$.\n\n### Approach 2: Simulation with Queue\n\n### Intuition\n\nInstead of using a list to manage eliminations (which can be a costly $O(n)$ operation), we can optimize the elimination process by using a queue. In a queue, removing the first element is done in $O(1)$ time. Initially, we fill the queue with friends labeled from `1` to `n`. The key insight is how eliminations can be handled at each round. In each round, we simulate the process by rotating the queue `k-1` times. This action effectively moves the `k`-th friend to the front of the queue, ready for removal. Once positioned, removing this front element simulates eliminating that friend from the game. This rotation and removal process continues until only one friend remains in the queue, who is then declared the winner of the game.\n\nWith the use of a queue, the cost of the pop operation, which was $O(n)$ in the list approach, is now reduced to $O(1)$. The traversal operation remains the only operation with linear time complexity.\n\n### Algorithm\n\n1. Initialize a queue of size `n`, where the elements are labeled 1 to `n`.\n2. While more than 1 friend is remaining\n    - Remove the next `k-1` friends and re-add them to the queue.\n    - Remove the next friend (the `k`-th friend that should be eliminated in the game)\n3. Return the value of the last friend remaining \n\n### Implementation### Complexity Analysis\n\nLet $n$ be the number of friends and $k$ be the step count for elimination.\n\n* Time Complexity: $O(n \\cdot k)$\n\n    The time complexity is $O(n \\cdot k)$ because each elimination cycle involves rotating the queue $k-1$ times, and this happens $n-1$ times.\n\n* Space Complexity: $O(n)$\n\n    The space complexity is $O(n)$ due to the queue storing all $n$ friends initially.\n\n### Approach 3: Recursion\n\n### Intuition\n\nThe game involves repetitively eliminating the `k`-th friend from a circle, shrinking the size of the circle at every turn. This suggests that we can break down the problem into smaller, similar subproblems.\n\nLetâ€™s look at a smaller instance of the problem where n=4 and k=2. We'll track both the number and index of each friend in the circle.\n\nAt the start of the game, friend 0 is at the beginning of the circle, and each friend's number corresponds to their index (we'll use zero-based indexing for now and adjust to one-based indexing later as required by the problem):\n\n![Beginning of first turn](../Figures/1823/first_turn_start.png)\n\nIn the first round, we start our count at friend 0 and eliminate the k-th friend. With k=2, we eliminate friend 1 at index 1, leaving three friends in the circle. \n\n![First elimination](../Figures/1823/first_turn_elimination.png)\n\nFor the second round, we treat the friend immediately after friend 1 (friend 2) as the new starting point. The updated indices now appear as follows:\n\n![Beginning of second turn](../Figures/1823/second_turn_start.png)\n\nFrom this process, there are two key insights:\n\n1. The problem, initially dealing with a circle of `n` friends, now reduces to a subproblem with `n-1` friends\n2. In the new subproblem, friend indices shift by `-k`. For instance, friend 3 moves from index `3` to index `1` in the new circle.\n\nThese observations suggest a recurrence relation for a recursive solution. Let's define $f(n,k)$ as function that returns the index of the winning friend with a game of `n` friends and a step size of `k`. In our example above, $f(4,2)$ would yield the final answer.\n\nWe observed that after the first turn/elimination, our problem reduces to a smaller subproblem of $f(n-1, k)$. Accounting for the indexing offset discussed above, we can form the following relationship between $f(n,k)$ and $f(n-1,k)$:\n\n$$f(n, k) = (f(n-1, k) + k) \\bmod n$$\n\nWe add k to $f(n-1, k)$ to convert back to the original indexing of the circle of size `n` (we saw above how the new indexing on a circle of size `n-1` shifts the original indexing by `-k`). Like before, we mod this value by the size of the circle to account for cases where the offset wraps around to the start of the circle.\n\nThe base case is $f(1, k) = 0$, as the last remaining friend will always be at index `0`\n\n### Algorithm\n\n1. Define a `winnerHelper(int n, int k)` function where:\n    - If the base case is reached (`n == 1`), return `0`.\n    - Otherwise, return the recurrence relation expression: $(\\text{winnerHelper}(n-1, k) + k)  \\bmod  n$.\n2. Return the value of the last friend remaining.\n\n### Implementation### Complexity Analysis\n\nLet $n$ be the initial size of the friend circle.\n\n* Time Complexity: $O(n)$\n\n    The function makes $n$ recursive calls, each performing $O(1)$ operations (modulo and addition).\n\n* Space Complexity: $O(n)$\n\n    The space complexity is determined by the maximum depth of the recursion stack, which is $n$.\n\n### Approach 4: Iterative\n\n### Intuition\n\nWe can further leverage the recurrence relation we found earlier, but optimize it by eliminating the extra space overhead incurred by the recursive calls. To achieve this, we can start by solving the base case where `n = 1` and iteratively compute the position of the winner, building up to solving the solution for `n = N`. This iteration will efficiently compute the solution with no extra space needed.\n\n### Algorithm\n\n1. Initialize `ans` to 0, representing the answer for the base case `n = 1`\n2. Iterate through values of `n` from 2 to `N`:\n    - Compute the answer for the current `n` using the recurrence relation: `ans = (ans + k) % n`\n3. Return `ans + 1`\n\n\n### Implementation### Complexity Analysis\n\nLet $n$ be the initial size of the friend circle.\n\n* Time Complexity: $O(n)$\n\n    The loop runs $O(n)$ times, where each iteration involves a constant time calculation. Thus, the total time complexity is $O(n)$.\n\n* Space Complexity: $O(1)$\n\n    Unlike the recursive approach, no extra memory is needed to maintain a call stack. Furthermore, no auxiliary data structures are used. Thus, the space complexity is constant."
}