{
  "title": "Widest Vertical Area Between Two Points Containing No Points",
  "problem_id": "1742",
  "frontend_id": "1637",
  "difficulty": "Easy",
  "problem_slug": "widest-vertical-area-between-two-points-containing-no-points",
  "topics": [
    "Array",
    "Sorting"
  ],
  "description": "Given n points on a 2D plane where points[i] = [xi, yi], Return the widest vertical area between two points such that no points are inside the area.\nA vertical area is an area of fixed-width extending infinitely along the y-axis (i.e., infinite height). The widest vertical area is the one with the maximum width.\nNote that points on the edge of a vertical area are not considered included in the area.\nExample 1:\nExample 2:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: points = [[8,7],[9,9],[7,4],[9,7]]\nOutput: 1\nExplanation: Both the red and the blue area are optimal.",
      "images": [
        "https://assets.leetcode.com/uploads/2020/09/19/points3.png"
      ]
    },
    {
      "example_num": 2,
      "example_text": "Input: points = [[3,1],[9,0],[1,0],[1,4],[5,3],[8,8]]\nOutput: 3",
      "images": [
        "https://assets.leetcode.com/uploads/2020/09/19/points3.png"
      ]
    }
  ],
  "constraints": [
    "n == points.length",
    "2 <= n <= 105",
    "points[i].length == 2",
    "0 <= xi, yi <= 109"
  ],
  "follow_ups": [],
  "hints": [
    "Try sorting the points",
    "Think whether the y-axis of a point is relevant"
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    int maxWidthOfVerticalArea(vector<vector<int>>& points) {\n        \n    }\n};",
    "java": "class Solution {\n    public int maxWidthOfVerticalArea(int[][] points) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def maxWidthOfVerticalArea(self, points):\n        \"\"\"\n        :type points: List[List[int]]\n        :rtype: int\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def maxWidthOfVerticalArea(self, points: List[List[int]]) -> int:\n        ",
    "c": "int maxWidthOfVerticalArea(int** points, int pointsSize, int* pointsColSize) {\n    \n}",
    "csharp": "public class Solution {\n    public int MaxWidthOfVerticalArea(int[][] points) {\n        \n    }\n}",
    "javascript": "/**\n * @param {number[][]} points\n * @return {number}\n */\nvar maxWidthOfVerticalArea = function(points) {\n    \n};",
    "typescript": "function maxWidthOfVerticalArea(points: number[][]): number {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param Integer[][] $points\n     * @return Integer\n     */\n    function maxWidthOfVerticalArea($points) {\n        \n    }\n}",
    "swift": "class Solution {\n    func maxWidthOfVerticalArea(_ points: [[Int]]) -> Int {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun maxWidthOfVerticalArea(points: Array<IntArray>): Int {\n        \n    }\n}",
    "dart": "class Solution {\n  int maxWidthOfVerticalArea(List<List<int>> points) {\n    \n  }\n}",
    "golang": "func maxWidthOfVerticalArea(points [][]int) int {\n    \n}",
    "ruby": "# @param {Integer[][]} points\n# @return {Integer}\ndef max_width_of_vertical_area(points)\n    \nend",
    "scala": "object Solution {\n    def maxWidthOfVerticalArea(points: Array[Array[Int]]): Int = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn max_width_of_vertical_area(points: Vec<Vec<i32>>) -> i32 {\n        \n    }\n}",
    "racket": "(define/contract (max-width-of-vertical-area points)\n  (-> (listof (listof exact-integer?)) exact-integer?)\n  )",
    "erlang": "-spec max_width_of_vertical_area(Points :: [[integer()]]) -> integer().\nmax_width_of_vertical_area(Points) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec max_width_of_vertical_area(points :: [[integer]]) :: integer\n  def max_width_of_vertical_area(points) do\n    \n  end\nend"
  },
  "solution": "[TOC]\n\n## Solution\n\n---\n\n### Approach: Sorting\n\n**Intuition**\n\nWe have $N$ points on a 2D plane. The problem is to find the widest vertical area between any two points without having any other point in between. Vertical area implies that the area can have an infinite length over the y-axis. This means that the y-coordinate doesn't affect the result and we shall focus on the distance along the x-axis.\n\nTherefore, we only need to find the width between every two adjacent points based on x-coordinates and the maximum width among these would be the answer. Note that there can be multiple points with the same x-coordinate but that won't affect the answer as the points on the edges can be included in the area.\n\nSince the points do not have a specific order, we will need to sort the points in ascending order of x-coordinates first. Then we need to find the difference in x-coordinates between every two neighboring points, and their maximum value is the result we want, as shown in the picture below.\n\n![fig](../Figures/1637/1637A.png)\n\n**Algorithm**\n\n1. Sort the array `points` in ascending order of x-coordinates.\n2. Initialize the variable `ans` to `0`, this will store the widest vertical area which is the answer to the problem.\n3. Iterate over `points` from index `1` and store the maximum of `points[i][0] - points[i - 1][0]` in `ans`.\n4. Return `ans`.\n\n**Implementation****Complexity Analysis**\n\nHere, $N$ is the number of points in the array `points`.\n\n* Time complexity: $O(N \\log N)$\n\n  Sorting the array will take $O(N \\log N)$ time. Then iterating over it to find the value for `ans` needs $O(N)$. Hence the total time complexity is equal to $O(N \\log N)$.\n\n* Space complexity: $O(\\log N)$\n\n  We don't need any extra space other than the variable `ans`. However, there will be some space required for sorting. The space complexity of the sorting algorithm is language-specific. For instance, in Java, the Arrays.sort() for primitives is implemented as a variant of the quicksort algorithm whose space complexity is $$O(\\log N)$$. In C++ sort() function provided by STL is a hybrid of Quick Sort, Heap Sort, and Insertion Sort and has a worst-case space complexity of $$O(\\log N)$$. Thus, using the inbuilt sort() function might add up to $$O(\\log N)$$ to space complexity.---"
}