{
  "title": "Buy Two Chocolates",
  "problem_id": "2756",
  "frontend_id": "2706",
  "difficulty": "Easy",
  "problem_slug": "buy-two-chocolates",
  "topics": [
    "Array",
    "Greedy",
    "Sorting"
  ],
  "description": "You are given an integer array prices representing the prices of various chocolates in a store. You are also given a single integer money, which represents your initial amount of money.\nYou must buy exactly two chocolates in such a way that you still have some non-negative leftover money. You would like to minimize the sum of the prices of the two chocolates you buy.\nReturn the amount of money you will have leftover after buying the two chocolates. If there is no way for you to buy two chocolates without ending up in debt, return money. Note that the leftover must be non-negative.\nExample 1:\nExample 2:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: prices = [1,2,2], money = 3\nOutput: 0\nExplanation: Purchase the chocolates priced at 1 and 2 units respectively. You will have 3 - 3 = 0 units of money afterwards. Thus, we return 0.",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input: prices = [3,2,3], money = 3\nOutput: 3\nExplanation: You cannot buy 2 chocolates without going in debt, so we return 3.",
      "images": []
    }
  ],
  "constraints": [
    "2 <= prices.length <= 50",
    "1 <= prices[i] <= 100",
    "1 <= money <= 100"
  ],
  "follow_ups": [],
  "hints": [
    "Sort the array and check if the money is more than or equal to the sum of the two cheapest elements."
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    int buyChoco(vector<int>& prices, int money) {\n        \n    }\n};",
    "java": "class Solution {\n    public int buyChoco(int[] prices, int money) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def buyChoco(self, prices, money):\n        \"\"\"\n        :type prices: List[int]\n        :type money: int\n        :rtype: int\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def buyChoco(self, prices: List[int], money: int) -> int:\n        ",
    "c": "int buyChoco(int* prices, int pricesSize, int money) {\n    \n}",
    "csharp": "public class Solution {\n    public int BuyChoco(int[] prices, int money) {\n        \n    }\n}",
    "javascript": "/**\n * @param {number[]} prices\n * @param {number} money\n * @return {number}\n */\nvar buyChoco = function(prices, money) {\n    \n};",
    "typescript": "function buyChoco(prices: number[], money: number): number {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param Integer[] $prices\n     * @param Integer $money\n     * @return Integer\n     */\n    function buyChoco($prices, $money) {\n        \n    }\n}",
    "swift": "class Solution {\n    func buyChoco(_ prices: [Int], _ money: Int) -> Int {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun buyChoco(prices: IntArray, money: Int): Int {\n        \n    }\n}",
    "dart": "class Solution {\n  int buyChoco(List<int> prices, int money) {\n    \n  }\n}",
    "golang": "func buyChoco(prices []int, money int) int {\n    \n}",
    "ruby": "# @param {Integer[]} prices\n# @param {Integer} money\n# @return {Integer}\ndef buy_choco(prices, money)\n    \nend",
    "scala": "object Solution {\n    def buyChoco(prices: Array[Int], money: Int): Int = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn buy_choco(prices: Vec<i32>, money: i32) -> i32 {\n        \n    }\n}",
    "racket": "(define/contract (buy-choco prices money)\n  (-> (listof exact-integer?) exact-integer? exact-integer?)\n  )",
    "erlang": "-spec buy_choco(Prices :: [integer()], Money :: integer()) -> integer().\nbuy_choco(Prices, Money) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec buy_choco(prices :: [integer], money :: integer) :: integer\n  def buy_choco(prices, money) do\n    \n  end\nend"
  },
  "solution": "[TOC]\n\n## Solution\n\n--- \n\n### Overview\n\nWe have been given `prices` of chocolates. Initially, we have a `money` amount of money. We need to buy **exactly** two chocolates such that we spend the minimum on them, leaving us with the maximum amount of leftover money. \n\nIf we don't have enough money to buy two chocolates, we are supposed to return the initial amount of `money`. Otherwise, we should return the (maximum) amount of money left after buying two chocolates.\n\n---\n\n### Approach 1: Check Every Pair of Chocolate\n\n#### Intuition\n\nWe need to buy **exactly** two chocolates. A collection of two is a pair. \n\nHence, we can check every pair of chocolates and select the pair with minimum cost.\n\n> We need to minimize the sum of the prices of the two chocolates we buy.\n>\n> Initially, we will assume the minimum cost to be some very large integer, say infinity. \n> \n> Then for every pair of chocolates, we will check if the sum of their prices is less than the minimum cost. If it is, then we will update the minimum cost to be the sum of their prices. \n\nNote that pairs are commutative. That is, the order of chocolates in a pair does not matter. If we have two chocolates, `a` and `b`, then the pair `(a, b)` is the same as the pair `(b, a)`, because the money spent on both pairs is the same, that is, `a + b`. The addition of two integers is commutative.\n\n#### Algorithm\n\n1. Initialize the minimum cost variable `min_cost` to be infinity or some very large integer, that is at least greater than the sum of the prices of any two chocolates.\n\n    > On observing constraint `1 <= prices[i] <= 100`, we can see that the sum of the prices of any two chocolates will be at most `200`. Hence, `201` is also a good choice for initializing `min_cost`.\n\n2. Save the number of chocolates in a variable `n`. It is equal to the length of the array `prices`. It is often a good practice to save the length of an array in a variable if it is used multiple times in the code.\n\n3. Check every pair of chocolates using two nested loops. \n\n    - Using the iterator variable `first_choco`, we will iterate over the array `prices` from `0` to `n - 1`.\n\n    - Using the nested iterator variable `second_choco`, we will iterate over the array `prices` from `first_choco + 1` to `n - 1`.\n        \n        For every possible value of `first_choco`, we will check every possible value of `second_choco`.\n    \n    - For every pair of chocolates, we will calculate the sum of their prices and save it in a variable `cost`. It will be equal to `prices[first_choco] + prices[second_choco]`.\n\n    - If the sum of the prices of the two chocolates is less than the minimum cost, then we will update the minimum cost to be the sum of the prices of the two chocolates. The condition for this is `cost < min_cost`. On being true, we will assign `min_cost` to be `cost`, that is, `min_cost = cost`.\n\n4. If the minimum cost is less than or equal to the amount of money we have, then we can buy two chocolates. In this case, we will return the amount of money left after buying two chocolates. It will be equal to `money - min_cost`. This we will return if `min_cost <= money`.\n\n    Otherwise, we cannot buy two chocolates. In this case, we will return the initial amount of money, that is, `money`. \n\n#### Implementation**Implementation Note:** It is often a good practice to use relevant variable names. \n\n#### Complexity Analysis\n\nLet $n$ be the number of chocolates, computed as the length of the array `prices`.\n\n* Time complexity: $O(n^2)$ \n\n    - Initializing the `min_cost` variable, and saving the length of the array `prices` in a variable `n` takes constant time, that is, $O(1)$.\n\n    - Now, we are checking every pair of chocolates. There will be [${}^{n}C_{2}$](https://en.wikipedia.org/wiki/Combination) such pairs. This is equal to $\\frac{n(n - 1)}{2}$. \n        \n        For every pair, we are computing `cost`, comparing it with `min_cost`, and updating `min_cost` if necessary. This takes constant time, that is, $O(1)$.\n\n        This we are doing for $\\frac{n(n - 1)}{2}$ pairs. Hence, the time complexity is $O(\\frac{n(n - 1)}{2})$, which is equal to $O(n^2)$.\n    \n    - Finally, we are checking if `min_cost` is less than or equal to `money`, and returning the appropriate value. This takes constant time, that is, $O(1)$.\n\n    Thus, the total time complexity is $O(1) + O(n^2) + O(1)$, which is equal to $O(n^2)$.\n        \n* Space complexity: $O(1)$\n\n    We are using a handful of variables, and none of them is a function of the size of the input.\n\n    - the `min_cost` variable, which is an integer, hence takes constant space, that is, $O(1)$.\n\n    - the `n` variable, which is an integer, hence takes constant space, that is, $O(1)$. Whatever may be the size of the array `prices`, the size of `n` will remain constant, although its value may change.\n\n    - the iterator variables `first_choco` and `second_choco` are integers, hence taking constant space, that is, $O(1)$.\n\n    - the `cost` variable, which is an integer, hence takes constant space, that is, $O(1)$.\n\n    Hence, the total space complexity is $O(1) + O(1) + O(1) + O(1) + O(1)$, which is equal to $O(1)$.\n        \n---\n\n### Approach 2: Greedy\n\n#### Intuition\n\nAs given in the problem statement\n\n> minimize the sum of the *prices of the* two *chocolates* you buy\n\nNow, the *prices of the chocolates* are integers. In other words, we need to **minimize the sum of two integers**.\n\nTo minimize the sum of two integers, we need to minimize each of the two integers to the extent possible.\n\n- to minimize the price of the first chocolate, we can choose the most inexpensive chocolate, the one with the minimum price. The price of this chocolate will be the minimum of the `prices` array.\n\n- to minimize the price of the second chocolate, we can't choose the most inexpensive chocolate, because we have already chosen it for the first chocolate. Hence, we can choose the second most inexpensive chocolate, the one with the second minimum price. The price of this chocolate will be the second minimum of the `prices` array.\n\nHence, in the entire array of `prices`, we need to find the minimum and the second minimum prices. We can then buy the chocolates at these prices if we have enough money. \n\n> Notice that while selecting our chocolates, we were being greedy. Isn't it? \n> \n> It is worth noting that **Greedy** is an algorithmic paradigm as well. It is a way of solving problems by making the locally optimal choice at every step, hoping that it will lead to a globally optimal solution. It is used for optimization problems. Although, it may not always lead to the optimal solution.\n> \n> Readers can find problems with Greedy Tag **[here](https://leetcode.com/tag/greedy/)**\n\nHow we can find the minimum and the second minimum prices in the array `prices`? What if we were given `prices` of chocolates in increasing order? The first two elements of the array `prices` would be the minimum and the second minimum prices.\n\nHowever, we aren't given `prices` in increasing order. Nevertheless, we can sort the array `prices` in increasing order and then compute the minimum possible cost.\n\n> Sorting is a common operation in programming. It is used to arrange the elements of a collection in a particular order. There are various sorting algorithms with different time and space complexities. Readers can deep dive into the topic using **[Sorting Explore Card](https://leetcode.com/explore/learn/card/sorting/)**.\n\n> At this stage, it would be appreciated if readers observe that there are two broad categories of sorting algorithms, namely, \n> - comparison based sorting algorithms, and\n> - non-comparison based sorting algorithms.\n\nReaders are encouraged to implement this approach. For sorting, they should find the inbuilt sorting function in their language of choice, and use it to sort the array `prices` in increasing order.\n\n#### Algorithm\n\n1. Sort the array `prices` in increasing order. This can be done using the inbuilt sorting function in the language of choice. Make sure that the sorted array is assigned the variable name `prices` itself.\n\n2. In a variable `min_cost`, save the sum of the first two elements of the array `prices`. These are the minimum and the second minimum prices in the array `prices`. \n\n    In code, this can be done as `min_cost = prices[0] + prices[1]`.\n\n3. If the minimum cost is less than or equal to the amount of money we have, then we can buy two chocolates. In this case, we will return the amount of money left after buying two chocolates. It will be equal to `money - min_cost`. This we will return if `min_cost <= money`.\n\n    Otherwise, we cannot buy two chocolates. In this case, we will return the initial amount of money, that is, `money`.\n\n#### Implementation**Implementation Note:** We would like to point out that the `else` is not required. The falsification of `if` itself is enough to return the initial amount of money. Hence following piece of (no comment) code is also correct.#### Complexity Analysis\n\nLet $n$ be the number of chocolates, computed as the length of the array `prices`.\n\n* Time complexity: $O(n \\log n)$\n\n    - Sorting the array `prices` in increasing order takes $O(n \\log n)$ time. This may vary depending on the implementation of the sorting algorithm in the programming language.\n       \n       - In Python, the `sort` method sorts a list using the Timsort algorithm, which is a combination of Merge Sort and Insertion Sort and takes $O(n \\log n)$ time.\n \n       - In C++, the `sort()` function is implemented as a hybrid of Quick Sort, Heap Sort, and Insertion Sort, with worst-case time complexity of $O(n \\log n)$.\n        \n    - Computing the `min_cost` takes constant time, that is, $O(1)$. It is equal to `prices[0] + prices[1]`. \n\n    - Finally, we are checking if `min_cost` is less than or equal to `money`, and returning the appropriate value. This takes constant time, that is, $O(1)$.\n\n    Hence, the total time complexity is $O(n \\log n) + O(1) + O(1)$, which is equal to $O(n \\log n)$.\n\n* Space complexity: $O(n)$ or $O(\\log n)$\n\n    - We are sorting the `prices` array in place. When we sort an array in place, some extra space is used. The space complexity depends on the implementation of the sorting algorithm in the programming language.\n     \n      - In Python, the `sort` method sorts a list using the Timsort algorithm, which is a combination of Merge Sort and Insertion Sort and uses $O(n)$ additional space.\n         \n      - In C++, the `sort()` function is implemented as a hybrid of Quick Sort, Heap Sort, and Insertion Sort, with worst-case space complexity of $O(\\log n)$.\n      \n      - In Java, `Arrays.sort()` is implemented using a variant of the Quick Sort algorithm which has a space complexity of $O(\\log n)$.\n\n    - Apart from these space complexities, we are using the constant size variable `min_cost`.\n\n    Hence, the worst-case space complexity is $O(n) + O(1)$, which is equal to $O(n)$. \n        \n---\n\n### Approach 3: Counting Sort\n\n#### Intuition\n\nAs pointed out in [previous approach](#approach-2-greedy), we need to find the minimum and the second minimum value in the array `prices`.\n\nFor finding, the minimum and the second minimum, we take the help of [sorting](https://leetcode.com/explore/learn/card/sorting/). As also mentioned in [complexity analysis](#complexity-analysis-1), sorting an array of size $n$ using comparison based sorting algorithms takes $O(n \\log n)$ time. This is also the best possible time complexity for [comparison based sorting algorithms](https://leetcode.com/explore/learn/card/sorting/694/comparison-based-sorts/4432/).\n\n> There are fundamental limits on the **[performance of comparison sorts](https://en.wikipedia.org/wiki/Comparison_sort)**. A comparison sort must have an average-case lower bound of $\\Omega(n \\log n)$ comparisons. This is because there are $n!$ possible orderings of the input, and a comparison sort must be able to distinguish between each one in the worst case. This means that any comparison sort must have a worst-case lower bound of $\\Omega(n \\log n)$ comparisons.\n\n\nHowever, there exists another class of sorting algorithms, called [non-comparison based sorting algorithms](https://leetcode.com/explore/learn/card/sorting/695/non-comparison-based-sorts/)\n\nBefore drawing intuition of this, readers should note the following constraint, given in the problem statement.\n\n> `1 <= prices[i] <= 100`\n\nNow let us observe the following fact\n\n> Consider following the `prices` array\n>\n> ![Array](../Figures/2706/2706_slide_images_used/Slide2_1.PNG)\n>\n> What is already sorted in this array? \n>\n> .  \n> .  \n> .  \n>\n> If unable to figure it out, see the following image.\n>\n> ![Indices](../Figures/2706/2706_slide_images_used/Slide2_2.PNG)\n>\n> What do these numbers below the array represent? Indices of the array. Isn't it? Moreover, they are already sorted! Let's save this as a fact.\n\nNow for sorting, we usually compare the elements. What if someone provided us with the following information about the `prices` array?\n\n- 42 occurs *three* times\n- 100 occurs *two* times\n- 69 occurs *one* time\n- 2 occurs *three* times\n- 8 occurs *five* times\n- 3 occurs *one* time\n- All other integers from 1 to 100 which aren't listed above, occur *zero* times.\n\nWe then can construct the sorted array as follows.\n\n- Take 2 and give it the first *three* positions in the array. We have taken 2 first because it is the smallest of all the numbers which is present in the array. Thus, it will be the first element of the sorted array.\n- Take 3 and give it the next *one* position in the array. \n- Take 8 and give it the next *five* positions in the array.\n- Take 42 and give it the next *three* positions in the array.\n- Take 69 and give it the next *one* position in the array.\n- Take 100 and give it the next *two* positions in the array.\n\nThere is a catch. How will we get to know that we have to process 2 first? Then 3? Then 8, and so on.\n\nInstead of sorting the entire array, sorting unique elements and then replicating them as per their frequency may sound like a good idea. What if every element occurs exactly once? Then it will be the same as sorting the entire array.\n\nCan we do better? Yes, we can. The hint lies in the fact that the indices of the array are already sorted. Hence, we can use them to our advantage.\n\nWe can store the frequency of integer `i` at index `i` of an array `freq`. This can be summarised as `freq[i] = prices.count(i)`. It is the brief idea of [counting sort](https://leetcode.com/explore/learn/card/sorting/695/non-comparison-based-sorts/4437/)\n\n![freq](../Figures/2706/2706_slide_images_used/Slide2_3.PNG)\n\nNow to construct the sorted array, we can iterate over the `freq` array. For every index `i` of `freq`, we can replicate `i` exactly `freq[i]` times in the sorted array. \n\n![reconstruct](../Figures/2706/2706_slide_images_used/Slide3.PNG)\n\n> **Word of Caution:** What we are doing here isn't the standard Counting Sort.\n>\n> In standard counting sort, we use another array `starting_indices` to make the counting sort **stable**. More about this can be read **[here](https://leetcode.com/explore/learn/card/sorting/695/non-comparison-based-sorts/4437/)**\n>\n> A **stable** sort is one that preserves the relative order of elements with equal keys. More precisely, a sorting algorithm is stable if whenever there are two records $R$ and $S$ with the same key and with $R$ appearing before $S$ in the original list, $R$ will appear before $S$ in the sorted list. \n>\n> We haven't used the `starting_indices` array here, and hence our sort is not stable. However, it is not required to be stable for our problem because we just need to find the minimum and the second minimum prices. We don't need to preserve the relative order of elements with equal keys. \n\nFor `freq`, we need a new array. The indices of the new array represent the `prices[i]`. Since `1 <= prices[i] <= 100`, the index `100` should be valid. Hence, we need an array of size `101`.\n\n> In general, if $a \\leq arr[i] \\leq b$, then we need an array of size $b - a + 1$.\n>\n> We need to scale down the indices of the frequency array by $a$ units. \n>\n> Here, `freq[i]` represent frequency of `i + a` in the array. Particularly, index 0 will represent frequency of `a` in the array.\n\nHowever, we need not to create a new array for sorted order reconstruction. We can overwrite the same array `prices` to construct the sorted array.\n\nTherefore, after sorting (*differently*), we can proceed in the *same* manner as we did in [previous approach](#approach-2-greedy), to minimize the sum of the prices of two chocolates. \n\nHowever, there is a catch. After creating the `freq` array do we need to create/overwrite the sorted array? Turns out no. We can just iterate over the `freq` array and find the minimum and the second minimum prices?\n\n- the index `i` with the first non-zero frequency will be the minimum price.\n- if the `freq[i] > 1`, then there are at least two chocolates with price `i`. Hence, `i` will be the second minimum price as well. Otherwise, we need to find the index `j` with the first non-zero frequency, such that `j > i`. This will be the second minimum price.\n\nAlthough it is not required to complete the entire process of counting sort, readers are strongly encouraged to implement it to sharpen their skills. Make sure to go through the [complexity analysis](#complexity-analysis-2) as well to avoid making wrong conclusions about non-comparison based sorting algorithms. \n\n#### Algorithm\n\n1. Initialize an array `freq` of size `101` with all elements as `0`. This array will store the frequency of prices. \n\n    > In general, the size of `freq` should be `max(prices) - min(prices) + 1`. However, since `1 <= prices[i] <= 100`, we can take `freq` of size `101`.  \n\n2. For every price `p` in the array `prices`, increment the value at index `p` in the array `freq`. This can be done as `freq[p] += 1`.\n\n3. Initialize two integer variables `minimum` and `second_minimum` to `0`. They represent the chocolates with minimum and second minimum prices respectively. \n\n    > Since prices cannot be `0`, the value `0` implies that they haven't been computed yet.\n\n4. For every value of `price` ranging from `1` to `100`, check its frequency in the array `freq`. \n\n    - If the frequency of `price` is greater than `1`, then `price` is the minimum and the second minimum price. Hence, assign `price` to `minimum` and `second_minimum`. Break out of the loop.\n\n    - If the frequency of `price` is equal to `1`, then `price` is the minimum price. Hence, assign `price` to `minimum`. Break out of the loop. We will find the second minimum price in the next step.\n\n5. If the second minimum price is not found, that is, if `second_minimum` is still `0`, then find it. For every value of `price` ranging from `minimum + 1` to `100`, check its frequency in the array `freq`. \n\n    If the frequency of `price` is greater than `0`, then `price` is the second minimum price. Hence, assign `price` to `second_minimum`. Break out of the loop.\n\n6. Compute the minimum cost `min_cost` as `minimum + second_minimum`.\n\n7. If the minimum cost is less than or equal to the amount of money we have, then we can buy two chocolates. In this case, we will return the amount of money left after buying two chocolates. It will be equal to `money - min_cost`. This we will return if `min_cost <= money`.\n\n    Otherwise, we cannot buy two chocolates. In this case, we will return the initial amount of money, that is, `money`.\n\n#### Implementation#### Complexity Analysis\n\nLet $n$ be the number of chocolates, computed as the length of the array `prices`.   \nLet $k$ be the range of the `prices`. In the worst case, due to constraint, it will be $100$. However, in general, it will be $\\max(prices) - \\min(prices) + 1$.\n\n* Time complexity: $O(n + k)$\n\n    - We are traversing the array `prices` once to compute the frequency of prices. This takes $O(n)$ time.\n\n    - then we are traversing the `freq` array once to find the minimum and the second minimum prices. This takes $O(k)$ time.\n\n    Hence, the total time complexity is $O(n) + O(k)$, which is equal to $O(n + k)$.\n\n    **Note:** We are given constraints as\n    - `2 <= n <= 50`\n    \n    - `1 <= prices[i] <= 100`\n\n    Because of this constraint, $O(n \\log n)$ is better than $O(n + k)$. However, if $n$ was as high as $10^6$, then $O(n + k)$ would be better than $O(n \\log n)$.\n     \n* Space complexity: $O(k)$\n\n    We are using an array `freq` of size $k$ to store the frequency of prices. All other variables are of constant size.\n    \n    Hence, the space complexity is $O(k)$\n        \n---\n\n### Approach 4: Two Passes\n\n#### Intuition\n\nHow can we find **minimum** in an array? \n\n- If we have only one element in the array, then that element is the minimum.\n\n- If we have two elements in the array, then again we can assume the first element to be the minimum.\n    \n    Then we can compare the second element with the assumed minimum. If the second element is less than the assumed minimum, then the second element is the minimum. \n\n- What if we have $n$ elements? Then again we can assume the first element to be the minimum.\n\n    After that, we can compare all the elements with the assumed minimum so far. If any element is less than the assumed minimum, then that element is the minimum.\n\nThus, finding the minimum is not a difficult task. However, we need to find the **second minimum**.\n\nWhat if we remove the **first minimum** from the array? What will happen to the *previous second minimum*?\n\n![remove](../Figures/2706/2706_slide_images_used/Slide1_1.PNG)\n\nIt will become the **new first minimum**. \n\n![new](../Figures/2706/2706_slide_images_used/Slide1_2.PNG)\n\nHence, we can find that element again using our algorithm to find the minimum.\n\nOnce both the original minimum and the second minimum are found, we can compute the minimum cost and proceed as in [previous approaches](#approach-2-greedy). \n\n\n#### Algorithm\n\n1. Define a function `indexMinimum`. It takes as an argument an array `arr` and returns the index of the minimum element in the array `arr`. \n\n    - Assume the first element of the array `arr` to be the minimum. Save its index in a variable `min_index`. Thus, `min_index = 0`.\n\n    - Compare the *assumed minimum* with the remaining elements of the array `arr`. If any element is less than the *assumed minimum*, then update the *assumed minimum* to be that element. Make sure to update the index of the *assumed minimum* to be the index of that element.\n\n    - Return the index of the minimum element.\n\n2. Find the index of the minimum price in the array `prices`. Save it in a variable `min_index`.\n\n3. Remove the minimum price from the array `prices`. Save the minimum price in a variable `min_cost`. \n\n    > We are removing the minimum price from the array `prices` because we don't want to consider it while finding the second minimum price.\n\n    If the programming language of choice doesn't have a function to remove an element from an array, then we can assign the minimum price to be some very large integer, say infinity. This will ensure that the minimum price is not considered while finding the second minimum price.\n\n4. Again find the index of the minimum price in the array `prices`. It is indeed the second minimum from the original array. Hence, save it in a variable `second_min_index`.\n\n5. Add the price at index `second_min_index` to `min_cost`. This will give us the minimum cost.\n\n6. If the minimum cost is less than or equal to the amount of money we have, then we can buy two chocolates. In this case, we will return the amount of money left after buying two chocolates. It will be equal to `money - min_cost`. This we will return if `min_cost <= money`.\n\n    Otherwise, we cannot buy two chocolates. In this case, we will return the initial amount of money, that is, `money`.\n\n#### Implementation**Implementation Note:** We have modified the input array `prices` in the code, the number of elements in the array `prices` is reduced by one. Readers should note that this is not a good practice.\n\nMoreover, there are many built-in functions to find the minimum in an array. Readers are encouraged to find out more about them in their language of choice.\n\n#### Complexity Analysis\n\nLet $n$ be the number of chocolates, computed as the length of the array `prices`.\n\n* Time complexity: $O(n)$\n\n    - Finding the index of the minimum price in the array `prices` takes $O(n)$ time. This is because we are traversing the array `prices` once to find the minimum price.\n\n    - Removing the minimum price from the array `prices` takes $O(n)$ time because we need to shift the elements of the array `prices` to the left by one position.\n\n    - Finding the index of the second minimum price in the array `prices` takes $O(n)$ time. This is because we are traversing the modified array to find the minimum price, which was originally the second minimum price.\n\n    Hence, the total time complexity is $O(n) + O(n) + O(n)$, which is equal to $O(n)$.\n\n* Space complexity: $O(1)$\n\n    We are using a handful of variables, and none of them is a function of the size of the input.\n\n    Hence, the space complexity is $O(1)$.\n        \n---\n\n### Approach 5: One Pass\n\n#### Intuition\n\nIn [previous approach](#approach-4-two-passes), we assumed the first element to be the minimum, then we updated the assumed minimum by comparing it with all remaining elements. Thus finding the minimum in one pass was possible. Similarly, we don't need to traverse twice to get the two smallest numbers, it can be achieved with a single traversal.\n\nIn this approach, let's assume the \n- smaller of `prices[0]` and `prices[1]` to be the *minimum*, and\n- larger of `prices[0]` and `prices[1]` to be the *second minimum*.\n\nWe can safely assume because there will be at least two elements in the array `prices`. Hence, `prices[0]` and `prices[1]` will be valid.\n\n![general](../Figures/2706/2706_slide_images_used/Slide4_1.PNG)\n\nNow let us see what happens when we encounter a new element represented by the red square.\n\n1. If the new element is less than the *minimum*, then it will also be less than the *second minimum*. In this case,    \n   - the previous minimum will become the *second minimum*, and\n   - the new element will become the *minimum*.\n\n    ![less](../Figures/2706/2706_slide_images_used/Slide5_1.PNG)\n\n2. If the new element is less than the *second minimum*, but greater than the *minimum*, then \n   - the *minimum* will remain unchanged, and\n   - the new element will become the *second minimum*.\n\n    ![between](../Figures/2706/2706_slide_images_used/Slide5_2.PNG) \n\n3. If the new element is greater than the *second minimum*, then it will also be greater than the *minimum*. In this case, the *minimum* and the *second minimum* will remain unchanged.\n\n    ![greater](../Figures/2706/2706_slide_images_used/Slide6.PNG)\n\nHence by first assuming the *minimum* and the *second minimum*, and then updating them as we encounter new elements, we can find the minimum and the second minimum in one pass.\n\nAfter finding the minimum and the second minimum, we can compute the minimum cost and proceed as in [previous approaches](#approach-2-greedy).\n\n#### Algorithm\n\n1. Assume the smaller of `prices[0]` and `prices[1]` to be the *minimum*, and the larger of `prices[0]` and `prices[1]` to be the *second minimum*.\n\n2. For every **remaining** element `price` in the array `prices`, do the following.\n\n    - If `price` is less than the *minimum*, then it will also be less than the *second minimum*. In this case, \n        - the previous minimum will become the *second minimum*, and\n        - `price` will become the *minimum*.\n\n    - If `price` is less than the *second minimum*, but greater than the *minimum*, then \n        - the *minimum* will remain unchanged, and\n        - `price` will become the *second minimum*.\n\n    - If `price` is greater than the *second minimum*, then it will also be greater than the *minimum*. In this case, the *minimum* and the *second minimum* will remain unchanged.\n\n3. Compute the minimum cost `min_cost` as `minimum + second_minimum`.\n\n4. If the minimum cost is less than or equal to the amount of money we have, then we can buy two chocolates. In this case, we will return the amount of money left after buying two chocolates. It will be equal to `money - min_cost`. This we will return if `min_cost <= money`.\n\n    Otherwise, we cannot buy two chocolates. In this case, we will return the initial amount of money, that is, `money`.\n\n#### Implementation#### Complexity Analysis\n\nLet $n$ be the number of chocolates, computed as the length of the array `prices`.\n\n* Time complexity: $O(n)$\n\n    We are traversing the array `prices` once to find the minimum and the second minimum prices. This takes $O(n)$ time.\n\n    All other assignment and comparison operations take constant time, that is, $O(1)$.\n\n    Hence, the total time complexity is $O(n) + O(1) + O(1)$, which is equal to $O(n)$.\n\n* Space complexity: $O(1)$\n\n    We are using a handful of variables, and none of them is a function of the size of the input.\n\n    Hence, the space complexity is $O(1)$.\n        \n---"
}