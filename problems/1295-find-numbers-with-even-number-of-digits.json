{
  "title": "Find Numbers with Even Number of Digits",
  "problem_id": "1421",
  "frontend_id": "1295",
  "difficulty": "Easy",
  "problem_slug": "find-numbers-with-even-number-of-digits",
  "topics": [
    "Array",
    "Math"
  ],
  "description": "Given an array nums of integers, return how many of them contain an even number of digits.\nExample 1:\nExample 2:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: nums = [12,345,2,6,7896]\nOutput: 2\nExplanation: \n12 contains 2 digits (even number of digits). \n345 contains 3 digits (odd number of digits). \n2 contains 1 digit (odd number of digits). \n6 contains 1 digit (odd number of digits). \n7896 contains 4 digits (even number of digits). \nTherefore only 12 and 7896 contain an even number of digits.",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input: nums = [555,901,482,1771]\nOutput: 1 \nExplanation: \nOnly 1771 contains an even number of digits.",
      "images": []
    }
  ],
  "constraints": [
    "1 <= nums.length <= 500",
    "1 <= nums[i] <= 105"
  ],
  "follow_ups": [],
  "hints": [
    "How to compute the number of digits of a number ?",
    "Divide the number by 10 again and again to get the number of digits."
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    int findNumbers(vector<int>& nums) {\n        \n    }\n};",
    "java": "class Solution {\n    public int findNumbers(int[] nums) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def findNumbers(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def findNumbers(self, nums: List[int]) -> int:\n        ",
    "c": "int findNumbers(int* nums, int numsSize) {\n    \n}",
    "csharp": "public class Solution {\n    public int FindNumbers(int[] nums) {\n        \n    }\n}",
    "javascript": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar findNumbers = function(nums) {\n    \n};",
    "typescript": "function findNumbers(nums: number[]): number {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @return Integer\n     */\n    function findNumbers($nums) {\n        \n    }\n}",
    "swift": "class Solution {\n    func findNumbers(_ nums: [Int]) -> Int {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun findNumbers(nums: IntArray): Int {\n        \n    }\n}",
    "dart": "class Solution {\n  int findNumbers(List<int> nums) {\n    \n  }\n}",
    "golang": "func findNumbers(nums []int) int {\n    \n}",
    "ruby": "# @param {Integer[]} nums\n# @return {Integer}\ndef find_numbers(nums)\n    \nend",
    "scala": "object Solution {\n    def findNumbers(nums: Array[Int]): Int = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn find_numbers(nums: Vec<i32>) -> i32 {\n        \n    }\n}",
    "racket": "(define/contract (find-numbers nums)\n  (-> (listof exact-integer?) exact-integer?)\n  )",
    "erlang": "-spec find_numbers(Nums :: [integer()]) -> integer().\nfind_numbers(Nums) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec find_numbers(nums :: [integer]) :: integer\n  def find_numbers(nums) do\n    \n  end\nend"
  },
  "solution": "[TOC]\n\n## Solution\n\n--- \n\n### Overview\n\nWe want to find the count of integers in an array `nums` which have an even number of digits.    \n\n> On looking constraint, we can say that $1 \\leq nums[i] \\leq 10^5$. Hence, we need not worry about non-positive integers. Readers can take the task of handling negative integers as a **follow-up** of this problem.  \n\nThe editorial presents different methods by which we can validate that a given integer has an even number of digits. We will discuss them one by one.\n\n---\n\n### Approach 1: Extract Digits\n\n#### Intuition\n\nIn this approach, we will be using arithmetic operators to validate if a given integer has an even number of digits or not. \n\nWhat we can do is extract the digits from the integer and count them. If the number of digits is even, then we will increment the counter.\n\nLet's see how to extract the digits from an integer using $37$ as an example. It can be written as\n\n$37 = 3 \\cdot 10^1 + 7 \\cdot 10^0$, or    \n$37 = 3 \\cdot 10 + 7 $\n\nWe can say that to extract $7$ from $37$, we have to divide $37$ by $10$ and take the remainder.\n\n**Which operator can we use to obtain the remainder?**  \nWe can use [modulo operator](https://en.wikipedia.org/wiki/Modulo_operation) to obtain the remainder.   \n\n> In Java, Python3, C++, C, Javascript, and many other languages, the modulo operator is `%`.\n\nIn this way, we have extracted the last digit from an integer. How we can extract the second last digit? We can shift the integer by one place to the right to make the current second last digit the last digit, and then extract it again using the modulo operator.\n\nNow,   \n$37 = 3 \\cdot 10^1 + 7 \\cdot 10^0$\n\nThe required $3$ can be written as\n$3 = 0 \\cdot 10^1 + 3 \\cdot 10^0$\n\nThus, the weight of each digit is reduced by $10$ times. Hence, we can divide the integer by $10$ to obtain the second last digit.\n\n> We can take large integers as an example to convince ourselves. Let's take $7329$. Now, we can write it as\n>\n> $7329 = 7 \\cdot 10^3 + 3 \\cdot 10^2 + 2 \\cdot 10^1 + 9 \\cdot 10^0$\n>\n> To shift right and obtain $732$, we can divide it by $10$ and obtain the **quotient** as $732$.     \n> $7329 = 732 \\cdot 10 + 9$\n\n**Which operator can we use to obtain the quotient?**   \nWe can use the [integer division](https://en.wikipedia.org/wiki/Remainder#Integer_division) operator to obtain the quotient.\n\n> - In Java, C++, C, and many other languages, we can use the `/` operator to obtain the quotient.\n> - In Python3, we can use `//` operator to obtain the quotient.\n\nNow, we have extracted the last digit and the second last digit. We can repeat the process to extract all the digits. Since we are only interested in the number of digits, we can use a counter to record its value.\n\nBefore proceeding further, when should we stop extracting digits? Is there any programmatic way to know when to stop?\n\nAt every iteration, our integer reduces by $10$ times. Hence, we can stop when our integer becomes $0$.\n\n> If after reducing we get a single-digit integer, then as per our algorithm, we will again divide it by $10$. Now, any single-digit integer divided by $10$ will give $0$ as the quotient. Hence, we can stop when our integer becomes $0$.\n\nHere is the animation explaining the digit extraction process\n\n!?!../Documents/1295/1295_digits.json:960,540!?!We need to do this process for all integer `num` present in the array `nums`. Therefore, we can have a boolean function `hasEvenDigits` which takes integer `num` as input and returns `true` if the number of digits is even, otherwise returns `false`.\n\n```pseudocode []\nfunction hasEvenDigits(num)\n{    \n    digitCount = 0\n    while num is not 0\n    {\n        digit = num % 10\n        digitCount = digitCount + 1\n        num = num / 10\n    }\n\n    if digitCount % 2 == 0\n        return true\n    else\n        return false\n}\n```\n\nLet's do some minor optimizations\n\n1. The variable `digit` inside the `while` loop is not required. The digits themselves are not of interest to us. We are only interested in the number of digits. Hence, we can remove the variable `digit`.\n\n2. For incrementing the counter, we can use `digitCount += 1` or `digitCount++` as well.\n\n3. Similarly `num = num / 10` can be written as `num /= 10`.\n\n4. The condition of the while loop is `while num is not 0`. Now, whenever `num` becomes `0`, the truth value of the variable will become `false`. Hence, we can write `while num` as well.\n\n    > The truth value of a variable is `true` if it is non-zero, otherwise, it is `false`. The truth value depends on the language. \n    > - In C, C++, Java, and many other languages, the truth value of a variable is `true` if it is non-zero, otherwise it is `false`. \n    > - In Python3, the truth value of a variable is `true` only if it is non-zero, non-empty and not equal to `None`, otherwise it is `false`.\n\n5. For checking the parity (odd/even) of a number, instead of the modulo operator, we can use bitwise operators as well. The \"bitwise AND\" operator `&` can be used to check parity. If the least significant bit of a number is `1`, then the number is odd, otherwise, it is even. \n\n    > The least significant bit can be extracted by bitwise AND-ing integer with 1 \n    > In C, C++, Java, Python3 and many other languages, we can use the `&` operator for bitwise AND.\n\n    Thus, `digitCount % 2 == 0` can be written as `digitCount & 1 == 0`.\n\n    Moreover, instead of using `if`-`else` duo, we can smartly `return digitCount & 1 == 0` which means that return `true` if the number of digits is even, otherwise return `false`.\n\nHence, the modified helper function `hasEvenDigits` can be written as\n\n```pseudocode []\nfunction hasEvenDigits(num)\n{    \n    digitCount = 0\n    while num\n    {\n        digitCount ++\n        num /= 10\n    }\n\n    return digitCount & 1 == 0\n}\n```\n\nIn our `findNumbers`, we can call `hasEvenDigits` for each `num` in `nums` and increment the counter if `hasEvenDigits` returns `true`.\n\n```pseudocode []\nfunction findNumbers(nums)\n{\n    evenDigitCount = 0\n    for num in nums\n    {\n        if hasEvenDigits(num)\n            evenDigitCount ++\n    }\n\n    return evenDigitCount\n}\n```\n\nReaders are encouraged to implement the solution on their own.\n\n\n#### Algorithm\n\n1. Define a helper function `hasEvenDigits` which takes `num` as input and returns `true` if the number of digits is even, otherwise returns `false`.\n\n    - Initialize `digitCount` to `0`.\n\n    - While `num` is non-zero     \n      - Increment `digitCount` by `1`.\n       \n      - Divide `num` by `10`.\n    \n    - Return `digitCount & 1 == 0`.\n\n2. In the function `findNumbers`, initialize `evenDigitCount` to `0`.\n\n3. For each `num` in `nums`, check if `hasEvenDigits(num)` returns `true`. If it does, increment `evenDigitCount` by `1`.\n\n4. Return `evenDigitCount`.\n\n#### Implementation#### Complexity Analysis\n\nLet $N$ be the length of `nums`, which represents the number of integers for which we have to check.   \nLet $M$ be the maximum integer in `nums`.\n\n* Time complexity: $O(N \\cdot \\log M)$\n\n    - For `hasEvenDigits`, we have a `while` loops which will iterate the number of times equal to the number of digits in `num`.\n        \n        > **When dividing an integer $ x $ by $ y $, there can be at most $O( \\log_y(x) )$ divisions.**    \n        >        \n        > Assume we perform the division by $10$ for $K$ times. Then, we can say that the integer $\\text{num}$ is at least $10^K$, which means $10^K \\leq \\text{num}$. Therefore $K \\leq \\log_{10} \\text{num}$.\n\n        Thus, the time complexity of `hasEvenDigits` is $O(\\log (\\text{num}))$. The maximum number of digits will be in the maximum integer in `nums`. Hence, the time complexity of `hasEvenDigits` is $O(\\log M)$.\n\n    - Now, we have a `for` loop which checks if there are even digits in each `num` in `nums`. There are $N$ such integers, and each integer takes $O(\\log M)$ time to process. \n    \n    Hence, the time complexity of `findNumbers` is $O(N \\cdot \\log M)$.   \n\n* Space complexity: $O(1)$\n    \n    We are using constant extra space. Hence, the space complexity is $O(1)$.\n     \n---\n\n\n### Approach 2: Convert to String\n\n#### Intuition\n\nGiven an integer, to find the number of digits in it, we need to extract them and count them since there is no concept of **length** in integers.\n\nHowever, given a string, we can find its length by using the `length()` *(or equivalent counterpart)* function. \n\nThus, what we can do is convert our integer to a string and then find its length. Its length will be the number of characters in it, which are nothing but the number of digits in it.\n\nAs discussed in [overview](#overview) as well, we need not worry about non-positive integers because of the constraint $1 \\leq nums[i] \\leq 10^5$. However, readers can appreciate that it would be just one more step to handle negative integers as well.\n\nDifferent programming languages have different ways to convert integers to strings. Readers are encouraged to find a way to convert integers to strings in their language.\n\n#### Algorithm\n\n1. Initialize a counter `evenDigitCount` to `0`.\n\n2. For every `num` in `nums`, convert it to string and find its length. If the length is even, increment `evenDigitCount` by `1`.\n\n3. Return `evenDigitCount`.\n\n\n#### Implementation#### Complexity Analysis\n\nLet $N$ be the length of `nums`, which represents the number of integers for which we have to check.   \nLet $M$ be the maximum integer in `nums`.\n\n* Time complexity: $O(N \\cdot \\log M)$\n\n    We have a `for` loop which converts each `num` to a string and finds its length. Now, the time complexity of converting an integer to a string will depend on the language. However, it will be $O(\\log (\\text{num}))$ at most. Hence, the time complexity of converting an integer to a string will be $O(\\log M)$. Checking its length will take $O(1)$ time. We do this for $N$ integers. \n    \n    Hence, the time complexity of `findNumbers` is $O(N \\cdot \\log M)$.\n\n\n* Space complexity: $O(\\log M)$\n    \n    We are temporarily storing the string representation of `num`. The maximum length of the string will be of the maximum integer in `nums`. Hence, the space complexity is $O(\\log M)$.\n    \n---\n\n\n### Approach 3: Using Logarithm\n\n#### Intuition\n\nThe etymological analysis of the word \"digits\" reveals that it is derived from the Latin word \"digitus\" which means \"finger\", and the reason is that earlier we used our fingers to count, and the number of fingers is fixed, i.e. $10$.\n\nThus, the word \"digits\" has strong ties with the number $10$.  \n\n> **Trivia:** Bits (0 and 1) are the portmanteau of BInary digiTS. \n\nLet's see a few power of our protagonist $10$.\n- $10^0$ is 1. It contains $0$ number of zeroes, and the total number of digits is one more than, i.e. 1.\n- $10^1$ is 10. It contains $1$ number of zeroes, and the total number of digits is one more than, i.e. 2.\n- $10^2$ is 100. It contains $2$ number of zeroes, and the total number of digits is one more than, i.e. 3.  \n.  \n.  \n.  \n- $10^5$ is 100000. It contains $5$ number of zeroes, and the total number of digits is one more than, i.e. 6.\n\n\nLet's narrow down our focus between $10^1$ and $10^2$. \n\n- $10^1$ is the smallest integer with two digits.\n- $10^2$ is the smallest integer with three digits.\n\nIn general, we can say that\n\n> $10^k$ is the smallest positive integer with $k+1$ digits where $k \\geq 0$.\n\nNow, what about $10^{1.5}$, an exponent between $10^1$ and $10^2$? It is approximately $31.62$, rounded down to $31$, an integer between $10^1$ and $10^2$ having two digits. \n\nIn general, we can say that\n\n> All $x$ such that $10^k \\leq x < 10^{k+1}$ have $k+1$ digits where $k \\geq 0$.\n\nNow, our interest is in the number of digits that are present as the exponent in this inequality. Let's bring it down by taking the logarithm of both sides, and the base of our logarithm will be $10$.\n\nThe inequality was  \n$10^k \\leq x < 10^{k+1}$   \n\nTaking the logarithm of both sides, we get   \n$k \\leq \\log_{10} x < k+1$  \n\nThe number of digits of all $x$ satisfying this inequality is $k+1$.\n\nNow, we want a mathematical operator so that $\\log_{10} x$ is rounded to the integer $k+1$. Two functions that round a real number to an integer are $\\lfloor x \\rfloor$ and $\\lceil x \\rceil$. The former is called the **floor** function and the latter is called the **ceiling** function.\n\n- $\\lfloor x \\rfloor$ is the largest integer less than or equal to $x$. In simpler terms, it rounds down $x$ to the nearest integer. If $x$ is an integer, then $\\lfloor x \\rfloor = x$.    \n\n- $\\lceil x \\rceil$ is the smallest integer greater than or equal to $x$. In simpler terms, it rounds up $x$ to the nearest integer. If $x$ is an integer, then $\\lceil x \\rceil = x$.\n\nNow,\n\n- if we take $\\lfloor \\log_{10} x \\rfloor$, then it will round down $\\log_{10} x$ to the nearest integer. Hence, it will be $k$. We then add $1$ to it to get $k+1$.\n\n- if we take $\\lceil \\log_{10} x \\rceil$, then it will round up all $\\log_{10} x$ to $k+1$, with exception when $\\log_{10} x$ is $k$. In that case, even after taking the `ceil`, it will remain $k$. \n\n    Note that the slack inequality and strict inequality in $k \\leq \\log_{10} x < k+1$. The former is inclusive and the latter is exclusive. Hence, if $\\log_{10} x$ is $k$, then it ceil will be $k$ only.\n\n    For all other values of $\\log_{10} x$, it will be $k+1$. \n\n    Therefore, when using `ceil`, there are two potential outcomes: either $k$ or $k+1$.\n\nThus, we can conclude that taking the `floor` and adding 1 is a better idea than taking `ceil` and handling two cases.\n\nHence, here is **theorem**\n\n> Given a positive integer $x$, the number of digits in $x$ is $\\lfloor \\log_{10} x \\rfloor + 1$.\n\nMany programming languages have a built-in function to compute logarithms and floors. \n\nAccordingly, by employing this formula, we can calculate the count of digits in an integer. If the count of digits is even, we can then increment the counter.\n\n#### Algorithm\n\n1. Initialize a counter `evenDigitCount` to `0`.\n\n2. For every `num` in `nums`, compute $\\lfloor \\log_{10} \\text{num} \\rfloor + 1$. If the value is even, increment `evenDigitCount` by `1`.\n\n3. Return `evenDigitCount`.\n\n#### Implementation#### Complexity Analysis\n\nLet $N$ be the length of `nums`, which represents the number of integers for which we have to check.   \nLet $M$ be the maximum integer in `nums`.\n\n* Time complexity: $O(N \\cdot \\log M)$\n\n    We have a `for` loop which computes the number of digits in each `num` in `nums`. \n    \n    Now, the time complexity of computing the number of digits in an integer depends on the time complexity of computing the logarithm and floor. \n\n    - The time complexity of computing logarithm depends on the language and algorithm used. In the worst case, it will be $O(\\log (\\text{num}))$. Hence, the time complexity of computing logarithm will be $O(\\log M)$.\n\n    - The time complexity of the computing floor depends on the language and algorithm used. However, it will be $O(1)$ at most. Hence, the time complexity of the computing floor will be $O(1)$.\n\n    Thus, for each integer, we do $O(\\log M)$ work. We do this for $N$ integers. \n    \n    Hence, the time complexity of `findNumbers` is $O(N \\cdot \\log M)$.\n    \n* Space complexity: $O(1)$\n    \n    We are using constant extra space. Hence, the space complexity is $O(1)$.\n     \n---\n\n### Approach 4: Constraint Analysis\n\n#### Intuition\n\nAnalyzing constraints helped us to not worry about negative integers. Can we use constraint to our advantage in some other way?\n\nLet's take a look at the constraint again.\n\n> $1 \\leq nums[i] \\leq 10^5$\n\nOR\n\n> $1 \\leq nums[i] \\leq 100000$\n\nLet's take a look at the integers in the range $[1, 100000]$.\n- $1 \\rightsquigarrow 9$ have 1, hence an odd number of digits.\n- $10 \\rightsquigarrow 99$ have 2, hence an even number of digits.\n- $100 \\rightsquigarrow 999$ have 3, hence an odd number of digits.\n- $1000 \\rightsquigarrow 9999$ have 4, hence an even number of digits.\n- $10000 \\rightsquigarrow 99999$ have 5, hence an odd number of digits.\n- $100000$ has 6, hence an even number of digits.\n\nThus, if an integer $nums[i]$ has an even number of digits, then it will be in the range of $[10, 99]$ or $[1000, 9999]$, or will be $100000$. Hence, we can use this fact to check if an integer has an even number of digits. Due to the constraint promise, we won't be missing any integer.\n\n\n#### Algorithm\n\n1. Initialize a counter `evenDigitCount` to `0`.\n\n2. For every `num` in `nums`, check if it is in the range of $[10, 99]$ or $[1000, 9999]$, or is $100000$. If it is, increment `evenDigitCount` by `1`.\n\n3. Return `evenDigitCount`.\n\n#### Implementation#### Complexity Analysis\n\nLet $N$ be the length of `nums`, which represents the number of integers for which we have to check.\n\n* Time complexity: $O(N)$\n\n    We have a `for` loop which checks if each `num` is in the range of $[10, 99]$ or $[1000, 9999]$, or is $100000$. We do this for $N$ integers. Now, checking and incrementing (if required) will take $O(1)$ time.\n\n    Hence, for $N$ integers, the time complexity of `findNumbers` is $O(N)$.\n\n* Space complexity: $O(1)$\n    \n    We are using constant extra space. Hence, the space complexity is $O(1)$.\n     \n---"
}