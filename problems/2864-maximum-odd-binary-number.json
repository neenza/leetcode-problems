{
  "title": "Maximum Odd Binary Number",
  "problem_id": "3055",
  "frontend_id": "2864",
  "difficulty": "Easy",
  "problem_slug": "maximum-odd-binary-number",
  "topics": [
    "Math",
    "String",
    "Greedy"
  ],
  "description": "You are given a binary string s that contains at least one '1'.\nYou have to rearrange the bits in such a way that the resulting binary number is the maximum odd binary number that can be created from this combination.\nReturn a string representing the maximum odd binary number that can be created from the given combination.\nNote that the resulting string can have leading zeros.\nExample 1:\nExample 2:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: s = \"010\"\nOutput: \"001\"\nExplanation: Because there is just one '1', it must be in the last position. So the answer is \"001\".",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input: s = \"0101\"\nOutput: \"1001\"\nExplanation: One of the '1's must be in the last position. The maximum number that can be made with the remaining digits is \"100\". So the answer is \"1001\".",
      "images": []
    }
  ],
  "constraints": [
    "1 <= s.length <= 100",
    "s consists only of '0' and '1'.",
    "s contains at least one '1'."
  ],
  "follow_ups": [],
  "hints": [
    "The binary representation of an odd number contains <code>'1'</code> in the least significant place."
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    string maximumOddBinaryNumber(string s) {\n        \n    }\n};",
    "java": "class Solution {\n    public String maximumOddBinaryNumber(String s) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def maximumOddBinaryNumber(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def maximumOddBinaryNumber(self, s: str) -> str:\n        ",
    "c": "char* maximumOddBinaryNumber(char* s) {\n    \n}",
    "csharp": "public class Solution {\n    public string MaximumOddBinaryNumber(string s) {\n        \n    }\n}",
    "javascript": "/**\n * @param {string} s\n * @return {string}\n */\nvar maximumOddBinaryNumber = function(s) {\n    \n};",
    "typescript": "function maximumOddBinaryNumber(s: string): string {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param String $s\n     * @return String\n     */\n    function maximumOddBinaryNumber($s) {\n        \n    }\n}",
    "swift": "class Solution {\n    func maximumOddBinaryNumber(_ s: String) -> String {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun maximumOddBinaryNumber(s: String): String {\n        \n    }\n}",
    "dart": "class Solution {\n  String maximumOddBinaryNumber(String s) {\n    \n  }\n}",
    "golang": "func maximumOddBinaryNumber(s string) string {\n    \n}",
    "ruby": "# @param {String} s\n# @return {String}\ndef maximum_odd_binary_number(s)\n    \nend",
    "scala": "object Solution {\n    def maximumOddBinaryNumber(s: String): String = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn maximum_odd_binary_number(s: String) -> String {\n        \n    }\n}",
    "racket": "(define/contract (maximum-odd-binary-number s)\n  (-> string? string?)\n  )",
    "erlang": "-spec maximum_odd_binary_number(S :: unicode:unicode_binary()) -> unicode:unicode_binary().\nmaximum_odd_binary_number(S) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec maximum_odd_binary_number(s :: String.t) :: String.t\n  def maximum_odd_binary_number(s) do\n    \n  end\nend"
  },
  "solution": "[TOC]\n\n## Solution\n\n--- \n\n### Overview\nA binary string is odd if and only if the last bit (i.e. the one's place) equals `1`. Consider an integer in its base-2 representation. Most of its bits will not affect the integer's divisibility by $2$ since $2^b$ is always even for any $b \\geq 1$. Therefore, it is required that the bit corresponding to $2^0$ (the rightmost bit) is equal to `1` in any odd number, and equal to `0` in any even number.\n\nTo rearrange bits in such a way as to maximize the value of the binary number, we should opt to swap as many `1` bits to the left as we can. This is because the more left a digit is, the more value it holds. A similar conclusion can be reached if we think about how the base-10 number system works.\n\nWe can combine these ideas into a strategy for building the maximum odd binary number! Place all but one `1` bit to the most significant places (i.e. leftmost bits), place a `1` in the one's place, and fill the rest of the string with $0$ bits (if any). Note that at least one `1` is guaranteed to be present in the string, which ensures that the resulting number is always odd.\n\n> The maximum odd binary number will have this format: \"111...111000...0001\".\n\n### Approach 1: Greedy Bit Manipulation (Sorting and Swapping)\n\n#### Intuition\nOne approach for implementing the above strategy is to sort all the bits first, and then reverse the elements from the first index to the second to last index. This works because the initial sort will guarantee the resulting string is odd, and reversing the rest of the characters will maximize the string's value.\n\n#### Algorithm\n\n1. Sort the input string `s` in ascending order.\n2. Reverse the bits in substring $[0, N-2]$.\n3. Return the resulting string.\n\n#### Implementation#### Complexity Analysis\n\n* Time complexity: $O(n \\log n)$.\n\nSorting input string `s` takes $O(n \\log n)$. We also iterate through $s$ which takes $O(n)$. $O(n \\log n)$ is the dominating term, which is the final time complexity.\n\n* Space complexity: $O(n)$ \n    - We create an auxillary array to process the string, requiring $O(n)$ space.\n    - Some extra space is used when we sort $s$ in place. The space complexity of the sorting algorithm depends on the programming language.\n        - In Python, the `sort` method sorts a list using the Timesort algorithm which is a combination of Merge Sort and Insertion Sort and has $$O(n)$$ additional space. No additional space is needed for the algorithm.\n        - In Java, Arrays.sort() is implemented using a variant of the Quick Sort algorithm which has a space complexity of $$O(\\log n)$$ for sorting two arrays. \n        - In C++, the sort() function is implemented as a hybrid of Quick Sort, Heap Sort, and Insertion Sort, with a worse-case space complexity of $O(\\log n )$. \n    - The space required for the array is the dominating term, so the overall space complexity is $O(n)$.\n\n---\n\n### Approach 2: Greedy Bit Manipulation (Counting Ones)\n\n#### Intuition\nThe answer depends only on the length of the input $n$ and the number of times `1` appears in the input. This means we can construct the answer directly by counting the number of ones and building a string with `ones_cnt - 1` occurrences of `1`, followed by `n - ones_cnt` occurrences of `0`, and a single occurrence of `1` at the end to ensure the final string is odd.\n\n#### Algorithm\n\n1. Count the number of occurrences of `1` in input `s`; let this count be `ones_cnt`.\n2. Take bit `1` and append it `ones_cnt - 1` times. This ensures we maximize the value of the result, but we save a bit at the end to ensure the result is odd.\n3. Take bit `0` and append it `n - ones_cnt` times. These are the `0` bits that we must include.\n4. Append a single `1` bit. This keeps the result string an odd number.\n5. Return the resulting string.\n\n#### Implementation#### Complexity Analysis\n\n* Time complexity: $O(n)$.\n\nFinding `ones_cnt` requires one pass through `s`, and concatenating the result string with length $n$ can also be done in linear time. Therefore, the final time complexity is $O(n)$.\n\n* Space complexity: $O(n)$ \n\nThe result string of length $n$ needs to be created, which implies a space complexity of $O(n)$.\n\n---\n\n### Approach 3: Greedy Bit Manipulation (One Pass with Two Pointers)\n\n#### Intuition\nTo solve this problem with only one $O(n)$ pass, let's first focus on rearranging all bits such that all `1` bits come before all `0` bits in string `s`. Consider the two ends of string `s`, referenced by the pointers `left` and `right`. Keep moving the left pointer to the right until it reaches a `0` bit, and keep moving the right pointer to the left until it reaches a `1` bit. If both conditions are met when the left pointer is less than the right pointer, we can swap these two bits and continue with the two pointers process.\n\nThis works because the left pointer will only move when all bits that precede it are all `1` bits, and similarly for the right pointer. This algorithm is also guaranteed to terminate, since at every step, at least one pointer will iterate.\n\nWhen this two pointers process is done, the left pointer is next to the rightmost occurence of a `1` bit in the rearranged `s`. The last step is to swap this `1` bit with the last position in `s` to ensure the resulting string is odd.\n\n#### Algorithm\n\n1. Initialize two pointers `left` at the beginning of `s` and `right` at the end of `s`.\n2. Increment `left` if $s_{left} = 1$.\n3. Decrement `right` if $s_{right} = 0$.\n4. If $s_{left} = 0$, $s_{right} = 1$, and `left` <= `right`, swap these two bits.\n5. Repeat steps 2-4 until `left` is greater than `right`.\n6. Swap the rightmost 1 bit to the end to ensure the result is odd.\n7. Return the resulting string.\n\n#### Implementation#### Complexity Analysis\n\n* Time complexity: $O(n)$.\n\nEach pointer will pass through input `s` once, hence the $O(n)$ time complexity.\n\n* Space complexity: $O(n)$ \n\nBecause strings are immutable, a copy of `s` must be created in order to modify the string during the two pointer algorithm. This means there is an $O(n)$ additional space complexity in this solution.\n\n---"
}