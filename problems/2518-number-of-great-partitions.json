{
  "title": "Number of Great Partitions",
  "problem_id": "2601",
  "frontend_id": "2518",
  "difficulty": "Hard",
  "problem_slug": "number-of-great-partitions",
  "topics": [
    "Array",
    "Dynamic Programming"
  ],
  "description": "You are given an array nums consisting of positive integers and an integer k.\nPartition the array into two ordered groups such that each element is in exactly one group. A partition is called great if the sum of elements of each group is greater than or equal to k.\nReturn the number of distinct great partitions. Since the answer may be too large, return it modulo 109 + 7.\nTwo partitions are considered distinct if some element nums[i] is in different groups in the two partitions.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: nums = [1,2,3,4], k = 4\nOutput: 6\nExplanation: The great partitions are: ([1,2,3], [4]), ([1,3], [2,4]), ([1,4], [2,3]), ([2,3], [1,4]), ([2,4], [1,3]) and ([4], [1,2,3]).",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input: nums = [3,3,3], k = 4\nOutput: 0\nExplanation: There are no great partitions for this array.",
      "images": []
    },
    {
      "example_num": 3,
      "example_text": "Input: nums = [6,6], k = 2\nOutput: 2\nExplanation: We can either put nums[0] in the first partition or in the second partition.\nThe great partitions will be ([6], [6]) and ([6], [6]).",
      "images": []
    }
  ],
  "constraints": [
    "1 <= nums.length, k <= 1000",
    "1 <= nums[i] <= 109"
  ],
  "follow_ups": [],
  "hints": [
    "If the sum of the array is smaller than 2*k, then it is impossible to find a great partition.",
    "Solve the reverse problem, that is, find the number of partitions where the sum of elements of at least one of the two groups is smaller than k."
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    int countPartitions(vector<int>& nums, int k) {\n        \n    }\n};",
    "java": "class Solution {\n    public int countPartitions(int[] nums, int k) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def countPartitions(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def countPartitions(self, nums: List[int], k: int) -> int:\n        ",
    "c": "int countPartitions(int* nums, int numsSize, int k) {\n    \n}",
    "csharp": "public class Solution {\n    public int CountPartitions(int[] nums, int k) {\n        \n    }\n}",
    "javascript": "/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number}\n */\nvar countPartitions = function(nums, k) {\n    \n};",
    "typescript": "function countPartitions(nums: number[], k: number): number {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @param Integer $k\n     * @return Integer\n     */\n    function countPartitions($nums, $k) {\n        \n    }\n}",
    "swift": "class Solution {\n    func countPartitions(_ nums: [Int], _ k: Int) -> Int {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun countPartitions(nums: IntArray, k: Int): Int {\n        \n    }\n}",
    "dart": "class Solution {\n  int countPartitions(List<int> nums, int k) {\n    \n  }\n}",
    "golang": "func countPartitions(nums []int, k int) int {\n    \n}",
    "ruby": "# @param {Integer[]} nums\n# @param {Integer} k\n# @return {Integer}\ndef count_partitions(nums, k)\n    \nend",
    "scala": "object Solution {\n    def countPartitions(nums: Array[Int], k: Int): Int = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn count_partitions(nums: Vec<i32>, k: i32) -> i32 {\n        \n    }\n}",
    "racket": "(define/contract (count-partitions nums k)\n  (-> (listof exact-integer?) exact-integer? exact-integer?)\n  )",
    "erlang": "-spec count_partitions(Nums :: [integer()], K :: integer()) -> integer().\ncount_partitions(Nums, K) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec count_partitions(nums :: [integer], k :: integer) :: integer\n  def count_partitions(nums, k) do\n    \n  end\nend"
  }
}