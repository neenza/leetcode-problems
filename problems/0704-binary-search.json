{
  "title": "Binary Search",
  "problem_id": "792",
  "frontend_id": "704",
  "difficulty": "Easy",
  "problem_slug": "binary-search",
  "topics": [
    "Array",
    "Binary Search"
  ],
  "description": "Given an array of integers nums which is sorted in ascending order, and an integer target, write a function to search target in nums. If target exists, then return its index. Otherwise, return -1.\nYou must write an algorithm with O(log n) runtime complexity.\nExample 1:\nExample 2:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: nums = [-1,0,3,5,9,12], target = 9\nOutput: 4\nExplanation: 9 exists in nums and its index is 4",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input: nums = [-1,0,3,5,9,12], target = 2\nOutput: -1\nExplanation: 2 does not exist in nums so return -1",
      "images": []
    }
  ],
  "constraints": [
    "1 <= nums.length <= 104",
    "-104 < nums[i], target < 104",
    "All the integers in nums are unique.",
    "nums is sorted in ascending order."
  ],
  "follow_ups": [],
  "hints": [],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    int search(vector<int>& nums, int target) {\n        \n    }\n};",
    "java": "class Solution {\n    public int search(int[] nums, int target) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def search(self, nums: List[int], target: int) -> int:\n        ",
    "c": "int search(int* nums, int numsSize, int target) {\n    \n}",
    "csharp": "public class Solution {\n    public int Search(int[] nums, int target) {\n        \n    }\n}",
    "javascript": "/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number}\n */\nvar search = function(nums, target) {\n    \n};",
    "typescript": "function search(nums: number[], target: number): number {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @param Integer $target\n     * @return Integer\n     */\n    function search($nums, $target) {\n        \n    }\n}",
    "swift": "class Solution {\n    func search(_ nums: [Int], _ target: Int) -> Int {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun search(nums: IntArray, target: Int): Int {\n        \n    }\n}",
    "dart": "class Solution {\n  int search(List<int> nums, int target) {\n    \n  }\n}",
    "golang": "func search(nums []int, target int) int {\n    \n}",
    "ruby": "# @param {Integer[]} nums\n# @param {Integer} target\n# @return {Integer}\ndef search(nums, target)\n    \nend",
    "scala": "object Solution {\n    def search(nums: Array[Int], target: Int): Int = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn search(nums: Vec<i32>, target: i32) -> i32 {\n        \n    }\n}",
    "racket": "(define/contract (search nums target)\n  (-> (listof exact-integer?) exact-integer? exact-integer?)\n  )",
    "erlang": "-spec search(Nums :: [integer()], Target :: integer()) -> integer().\nsearch(Nums, Target) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec search(nums :: [integer], target :: integer) :: integer\n  def search(nums, target) do\n    \n  end\nend"
  },
  "solution": "[TOC]\n\n## Solution\n \n--- \n\n### Overview\n\n\nIf you don't have much experience with binary-search-related problems, we strongly suggest you read this [LeetCode Explore Card](https://leetcode.com/explore/learn/card/binary-search/), our explore card for binary search! We'll cover four methods, the first three of which are closely related to those presented in this card, so it's helpful to look ahead! \n\n---\n\n### Approach 1: Find the Exact Value\n\n#### Intuition   \n\nWe start from the most basic and elementary template.\n\nFirst, we define the search space using two boundary indexes, `left` and `right`, all possible indexes are within the inclusive range `[left, right]`. We shall continue searching over the search space as long as it is not empty. A general way is to use a while loop with the condition `left <= right`, so we can break out of this loop if we empty the range or trigger other conditions which we will discuss later.\n\n![alt text](../Figures/704_fix/b1_fix.png)\n\nThe next step is to find the 'pivot point', the middle index that divides the search space into two halves. We need to compare the value at the middle index `nums[mid]` with `target`, the purpose of this step is to cut one half that is guaranteed not to contain `target`. \n\n- If `nums[mid] = target`, it means we find `target`, and the job is done! We can break the loop by returning `mid`.\n- If `nums[mid] < target`, combined with the array is sorted, we know that all values in the left half are smaller than `target`, so we can safely cut this half by letting `left = mid + 1`.  \n- If `nums[mid] > target`, it means all values in the right half are larger than `target` and can be cut safely!\n\n![alt text](../Figures/704_fix/b2_fix.png)\n\nDoes this loop ever stop? Yes, take the following picture as an example, suppose we are searching over an array of size 1, in this case, `left`, `right`, and `mid` all stand for the only index in the array. In any of the three conditions, we trigger one of the break statements and stop the loop. \n\n![alt text](../Figures/704_fix/b3_fix.png)#### Algorithm\n\n1) Initialize the boundaries of the search space as `left = 0` and `right = nums.size - 1`.\n2) If there are elements in the range `[left, right]`, we find the middle index `mid = (left + right) / 2` and compare the middle value `nums[mid]` with `target`:\n    - If `nums[mid] = target`, return `mid`.\n    - If `nums[mid] < target`, let `left = mid + 1` and repeat step 2.\n    - If `nums[mid] > target`, let `right = mid - 1` and repeat step 2.\n3) We finish the loop without finding `target`, return `-1`.\n\n\n#### Implementation#### Complexity Analysis\n\nLet $$n$$ be the size of the input array `nums`.\n\n* Time complexity: $$O(\\log n)$$\n\n    - `nums` is divided into half each time. In the worst-case scenario, we need to cut `nums` until the range has no element, and it takes logarithmic time to reach this break condition.\n    \n\n* Space complexity: $$O(1)$$\n\n    - During the loop, we only need to record three indexes, `left`, `right`, and `mid`, they take constant space.---\n\n### Approach 2: Find Upper bound\n\n#### Intuition   \n\nHere we introduce an alternative way to implement binary search: instead of looking for `target` in the array `nums`, we look for the insert position where we can put `target` in without disrupting the order.\n\n![alt text](../Figures/704_fix/u1_fix.png)\n\nGenerally, we have two inserting ways, insert into the rightmost possible position which we called finding the **upper bound**, and insert into the leftmost possible position which we called finding the **lower bound**. We will implement them in the following approaches.\n\nTake the picture below as an example. Assume that we want to insert `9` into array `A`. If we look for the **upper bound**, we have to insert `9` to the right of all existing `9`s in the array. Similarly, if we look for the **lower bound**, we have to insert `9` to the left of all existing `9`s. (Although we don't have duplicate elements in this problem, having duplicate elements is more common in problems so we would better know this concept in advance!)\n\n![alt text](../Figures/704_fix/u3_fix.png)\n\n\nNow we start the binary search. Similar to the previous approach, we still use `left` and `right` as two boundary indexes. The question is, what is the next step after we find the middle index `mid`?\n\n![alt text](../Figures/704_fix/upper2_fix.png)\n\n- If `nums[mid] < target`, the insert position is on `mid`'s right, so we let `left = mid + 1` to discard the left half and `mid`.\n\n- If `nums[mid] = target`, the insert position is on `mid`'s right, so we let `left = mid + 1` to discard the left half and `mid`.\n\n![alt text](../Figures/704_fix/u4_fix.png)\n\n- If `nums[mid] > target`, `mid` can also be the insert position. So we let `right = mid` to discard the right half while keeping `mid`.\n\n\nTherefore, we merged the two conditions `nums[mid] = target` and `nums[mid] < target` and there are only two conditions in the `if-else` statement!\n\n![alt text](../Figures/704_fix/upper5_fix.png)\n\nOnce the loop stops, `left` stands for the insert position and `left - 1` is the largest element that is no larger than `target`. We just need to check if `nums[left - 1]` equals `target`. Note this boundary condition where `left = 0`, which means all elements in `nums` are larger than `target`, so there is no `target` in `nums`.#### Algorithm\n\n1) Initialize the boundaries of the search space as `left = 0` and `right = nums.size` (Note that the maximum insert position can be `nums.size`)\n2) If there are elements in the range `[left, right]`, we find the middle index `mid = (left + right) / 2` and compare the middle value `nums[mid]` with `target`:\n    - If `nums[mid] <= target`, let `left = mid + 1` and repeat step 2.\n    - If `nums[mid] > target`, let `right = mid` and repeat step 2.\n3) We finish the loop and `left` stands for the insert position:\n    - If `left > 0` and `nums[left - 1] = target`, return `left - 1`.\n    - Otherwise, return `-1`.\n\n\n#### Implementation#### Complexity Analysis\n\nLet $$n$$ be the size of the input array `nums`.\n\n* Time complexity: $$O(\\log n)$$\n\n    - `nums` is divided into half each time. In the worst-case scenario, we need to cut `nums` until the range has no element, it takes logarithmic time to reach this break condition.\n    \n\n* Space complexity: $$O(1)$$\n\n    - During the loop, we only need to record three indexes, `left`, `right`, and `mid`, they take constant space.---\n\n### Approach 3: Find Lower bound\n\n#### Intuition   \n\nDifferent from the previous method, here we are looking for the **leftmost** insert position. Therefore, we will make the following changes to the judgment condition:\n\n\n- If `nums[mid] < target`, `mid` can also be the insertion position. So we let `left = mid + 1`, that is, discard the left half while keeping `mid`.\n\n- If `nums[mid] = target`, the insert position is on `mid`'s left, so we let `right = mid` to discard both the right half and `mid`.\n\n![alt text](../Figures/704_fix/lower1_fix.png)\n\n- If `nums[mid] > target`, the insert position is on `mid`'s left, so we let `right = mid` to discard both the right half and `mid`.\n\n\nTherefore, we merged the two conditions `nums[mid] = target` and `nums[mid] > target` and there are only two conditions in the `if-else` statement!\n\n![alt text](../Figures/704_fix/lower2_fix.png)\n\nOnce the loop stops, `left` stands for the insert position and `nums[left]` is the smallest element that is no less than `target`. We just need to check if `nums[left]` equals `target`. Note this boundary condition `left = nums.size`, which means all elements in `nums` are smaller than `target`, so there is no `target` in `nums`.#### Algorithm\n\n1) Initialize the boundaries of the search space as `left = 0` and `right = nums.size` (Note that the maximum insert position can be `nums.size`)\n2) If there are elements in the range `[left, right]`, we find the middle index `mid = (left + right) / 2` and compare the middle value `nums[mid]` with `target`:\n    - If `nums[mid] >= target`, let `right = mid` and repeat step 2.\n    - If `nums[mid] < target`, let `left = mid + 1` and repeat step 2.\n3) We finish the loop and `left` stands for the insert position:\n    - If `left < nums.size` and `nums[left] = target`, return `left`.\n    - Otherwise, return `-1`.\n\n#### Implementation#### Complexity Analysis\n\nLet $$n$$ be the size of the input array `nums`.\n\n* Time complexity: $$O(\\log n)$$\n\n    - `nums` is divided into half each time. In the worst-case scenario, we need to cut `nums` until the range has no element, it takes logarithmic time to reach this break condition.\n    \n\n* Space complexity: $$O(1)$$\n\n    - During the loop, we only need to record three indexes, `left`, `right`, and `mid`, they take constant space.---\n\n### Approach 4: Use built-in tools.\n\n#### Intuition   \n\nWe have implemented various templates of binary search, now let's quickly go through the last approach that uses built-in functions. C++ provides the `` library that defines functions for binary searching, Python provides `bisect` module which also supports binary search functions. If we are solving some standard problems that do not require a lot of customization, it's feasible to rely on these built-in tools to save time.\n\nNote that `upper_bound` and `bisect.bisect_right` look for the rightmost insertion position and bring the same result as approach 2, while `lower_bound` and `bisect.bisect_left` look for the leftmost insertion position and end up with the same result as approach 3. Once we find the insertion position, check if the value at the corresponding position equals `target`.\n\nHere we implement the method that uses **upper_bound** or **bisect.bisect_right** and leave another half as a practice!#### Algorithm\n\n1) Use built-in tools to locate the rightmost insertion position `idx`.\n2) If `idx > 0` and `nums[idx - 1] = target`, return `idx -1`. Otherwise, return `-1`.\n\n#### Implementation#### Complexity Analysis\n\nLet $$n$$ be the size of the input array `nums`.\n\n* Time complexity: $$O(\\log n)$$\n\n    - The time complexity of the built-in binary search is $$O(\\log n)$$.\n    \n\n* Space complexity: $$O(1)$$\n\n    - The built-in binary search only takes $$O(1)$$ space."
}