{
  "title": "Minimum Cost to Divide Array Into Subarrays",
  "problem_id": "3765",
  "frontend_id": "3500",
  "difficulty": "Hard",
  "problem_slug": "minimum-cost-to-divide-array-into-subarrays",
  "topics": [
    "Array",
    "Dynamic Programming",
    "Prefix Sum"
  ],
  "description": "You are given two integer arrays, nums and cost, of the same size, and an integer k.\nYou can divide nums into subarrays. The cost of the ith subarray consisting of elements nums[l..r] is:\nNote that i represents the order of the subarray: 1 for the first subarray, 2 for the second, and so on.\nReturn the minimum total cost possible from any valid division.\nExample 1:\nExample 2:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: nums = [3,1,4], cost = [4,6,6], k = 1\nOutput: 110\nExplanation:",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input: nums = [4,8,5,1,14,2,2,12,1], cost = [7,2,8,4,2,2,1,1,2], k = 7\nOutput: 985\nExplanation:",
      "images": []
    }
  ],
  "constraints": [
    "1 <= nums.length <= 1000",
    "cost.length == nums.length",
    "1 <= nums[i], cost[i] <= 1000",
    "1 <= k <= 1000"
  ],
  "follow_ups": [],
  "hints": [
    "<code>dp[i]</code> is the minimum cost to split the array suffix starting at <code>i</code>.",
    "Observe that no matter how many subarrays we have, if we have the first subarray on the left, the total cost of the previous subarrays increases by <code>k * total_cost_of_the_subarray</code>. This is because when we increase <code>i</code> to <code>(i + 1)</code>, the cost increase is just the suffix sum of the cost array."
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    long long minimumCost(vector<int>& nums, vector<int>& cost, int k) {\n        \n    }\n};",
    "java": "class Solution {\n    public long minimumCost(int[] nums, int[] cost, int k) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def minimumCost(self, nums, cost, k):\n        \"\"\"\n        :type nums: List[int]\n        :type cost: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def minimumCost(self, nums: List[int], cost: List[int], k: int) -> int:\n        ",
    "c": "long long minimumCost(int* nums, int numsSize, int* cost, int costSize, int k) {\n    \n}",
    "csharp": "public class Solution {\n    public long MinimumCost(int[] nums, int[] cost, int k) {\n        \n    }\n}",
    "javascript": "/**\n * @param {number[]} nums\n * @param {number[]} cost\n * @param {number} k\n * @return {number}\n */\nvar minimumCost = function(nums, cost, k) {\n    \n};",
    "typescript": "function minimumCost(nums: number[], cost: number[], k: number): number {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @param Integer[] $cost\n     * @param Integer $k\n     * @return Integer\n     */\n    function minimumCost($nums, $cost, $k) {\n        \n    }\n}",
    "swift": "class Solution {\n    func minimumCost(_ nums: [Int], _ cost: [Int], _ k: Int) -> Int {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun minimumCost(nums: IntArray, cost: IntArray, k: Int): Long {\n        \n    }\n}",
    "dart": "class Solution {\n  int minimumCost(List<int> nums, List<int> cost, int k) {\n    \n  }\n}",
    "golang": "func minimumCost(nums []int, cost []int, k int) int64 {\n    \n}",
    "ruby": "# @param {Integer[]} nums\n# @param {Integer[]} cost\n# @param {Integer} k\n# @return {Integer}\ndef minimum_cost(nums, cost, k)\n    \nend",
    "scala": "object Solution {\n    def minimumCost(nums: Array[Int], cost: Array[Int], k: Int): Long = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn minimum_cost(nums: Vec<i32>, cost: Vec<i32>, k: i32) -> i64 {\n        \n    }\n}",
    "racket": "(define/contract (minimum-cost nums cost k)\n  (-> (listof exact-integer?) (listof exact-integer?) exact-integer? exact-integer?)\n  )",
    "erlang": "-spec minimum_cost(Nums :: [integer()], Cost :: [integer()], K :: integer()) -> integer().\nminimum_cost(Nums, Cost, K) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec minimum_cost(nums :: [integer], cost :: [integer], k :: integer) :: integer\n  def minimum_cost(nums, cost, k) do\n    \n  end\nend"
  }
}