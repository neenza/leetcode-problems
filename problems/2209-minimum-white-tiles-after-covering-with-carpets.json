{
  "title": "Minimum White Tiles After Covering With Carpets",
  "problem_id": "2311",
  "frontend_id": "2209",
  "difficulty": "Hard",
  "problem_slug": "minimum-white-tiles-after-covering-with-carpets",
  "topics": [
    "String",
    "Dynamic Programming",
    "Prefix Sum"
  ],
  "description": "You are given a 0-indexed binary string floor, which represents the colors of tiles on a floor:\nYou are also given numCarpets and carpetLen. You have numCarpets black carpets, each of length carpetLen tiles. Cover the tiles with the given carpets such that the number of white tiles still visible is minimum. Carpets may overlap one another.\nReturn the minimum number of white tiles still visible.\nExample 1:\nExample 2:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: floor = \"10110101\", numCarpets = 2, carpetLen = 2\nOutput: 2\nExplanation: \nThe figure above shows one way of covering the tiles with the carpets such that only 2 white tiles are visible.\nNo other way of covering the tiles with the carpets can leave less than 2 white tiles visible.",
      "images": [
        "https://assets.leetcode.com/uploads/2022/02/10/ex1-1.png"
      ]
    },
    {
      "example_num": 2,
      "example_text": "Input: floor = \"11111\", numCarpets = 2, carpetLen = 3\nOutput: 0\nExplanation: \nThe figure above shows one way of covering the tiles with the carpets such that no white tiles are visible.\nNote that the carpets are able to overlap one another.",
      "images": [
        "https://assets.leetcode.com/uploads/2022/02/10/ex2.png"
      ]
    }
  ],
  "constraints": [
    "1 <= carpetLen <= floor.length <= 1000",
    "floor[i] is either '0' or '1'.",
    "1 <= numCarpets <= 1000"
  ],
  "follow_ups": [],
  "hints": [
    "Can you think of a DP solution?",
    "Let DP[i][j] denote the minimum number of white tiles still visible from indices i to floor.length-1 after covering with at most j carpets.",
    "The transition will be whether to put down the carpet at position i (if possible), or not."
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\n        \n    }\n};",
    "java": "class Solution {\n    public int minimumWhiteTiles(String floor, int numCarpets, int carpetLen) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def minimumWhiteTiles(self, floor, numCarpets, carpetLen):\n        \"\"\"\n        :type floor: str\n        :type numCarpets: int\n        :type carpetLen: int\n        :rtype: int\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\n        ",
    "c": "int minimumWhiteTiles(char* floor, int numCarpets, int carpetLen) {\n    \n}",
    "csharp": "public class Solution {\n    public int MinimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\n        \n    }\n}",
    "javascript": "/**\n * @param {string} floor\n * @param {number} numCarpets\n * @param {number} carpetLen\n * @return {number}\n */\nvar minimumWhiteTiles = function(floor, numCarpets, carpetLen) {\n    \n};",
    "typescript": "function minimumWhiteTiles(floor: string, numCarpets: number, carpetLen: number): number {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param String $floor\n     * @param Integer $numCarpets\n     * @param Integer $carpetLen\n     * @return Integer\n     */\n    function minimumWhiteTiles($floor, $numCarpets, $carpetLen) {\n        \n    }\n}",
    "swift": "class Solution {\n    func minimumWhiteTiles(_ floor: String, _ numCarpets: Int, _ carpetLen: Int) -> Int {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun minimumWhiteTiles(floor: String, numCarpets: Int, carpetLen: Int): Int {\n        \n    }\n}",
    "dart": "class Solution {\n  int minimumWhiteTiles(String floor, int numCarpets, int carpetLen) {\n    \n  }\n}",
    "golang": "func minimumWhiteTiles(floor string, numCarpets int, carpetLen int) int {\n    \n}",
    "ruby": "# @param {String} floor\n# @param {Integer} num_carpets\n# @param {Integer} carpet_len\n# @return {Integer}\ndef minimum_white_tiles(floor, num_carpets, carpet_len)\n    \nend",
    "scala": "object Solution {\n    def minimumWhiteTiles(floor: String, numCarpets: Int, carpetLen: Int): Int = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn minimum_white_tiles(floor: String, num_carpets: i32, carpet_len: i32) -> i32 {\n        \n    }\n}",
    "racket": "(define/contract (minimum-white-tiles floor numCarpets carpetLen)\n  (-> string? exact-integer? exact-integer? exact-integer?)\n  )",
    "erlang": "-spec minimum_white_tiles(Floor :: unicode:unicode_binary(), NumCarpets :: integer(), CarpetLen :: integer()) -> integer().\nminimum_white_tiles(Floor, NumCarpets, CarpetLen) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec minimum_white_tiles(floor :: String.t, num_carpets :: integer, carpet_len :: integer) :: integer\n  def minimum_white_tiles(floor, num_carpets, carpet_len) do\n    \n  end\nend"
  }
}