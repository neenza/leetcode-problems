{
  "title": "Find the Winner of an Array Game",
  "problem_id": "1657",
  "frontend_id": "1535",
  "difficulty": "Medium",
  "problem_slug": "find-the-winner-of-an-array-game",
  "topics": [
    "Array",
    "Simulation"
  ],
  "description": "Given an integer array arr of distinct integers and an integer k.\nA game will be played between the first two elements of the array (i.e. arr[0] and arr[1]). In each round of the game, we compare arr[0] with arr[1], the larger integer wins and remains at position 0, and the smaller integer moves to the end of the array. The game ends when an integer wins k consecutive rounds.\nReturn the integer which will win the game.\nIt is guaranteed that there will be a winner of the game.\nExample 1:\nExample 2:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: arr = [2,1,3,5,4,6,7], k = 2\nOutput: 5\nExplanation: Let's see the rounds of the game:\nRound |       arr       | winner | win_count\n  1   | [2,1,3,5,4,6,7] | 2      | 1\n  2   | [2,3,5,4,6,7,1] | 3      | 1\n  3   | [3,5,4,6,7,1,2] | 5      | 1\n  4   | [5,4,6,7,1,2,3] | 5      | 2\nSo we can see that 4 rounds will be played and 5 is the winner because it wins 2 consecutive games.",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input: arr = [3,2,1], k = 10\nOutput: 3\nExplanation: 3 will win the first 10 rounds consecutively.",
      "images": []
    }
  ],
  "constraints": [
    "2 <= arr.length <= 105",
    "1 <= arr[i] <= 106",
    "arr contains distinct integers.",
    "1 <= k <= 109"
  ],
  "follow_ups": [],
  "hints": [
    "If k â‰¥ arr.length return the max element of the array.",
    "If k < arr.length simulate the game until a number wins k consecutive games."
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    int getWinner(vector<int>& arr, int k) {\n        \n    }\n};",
    "java": "class Solution {\n    public int getWinner(int[] arr, int k) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def getWinner(self, arr, k):\n        \"\"\"\n        :type arr: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def getWinner(self, arr: List[int], k: int) -> int:\n        ",
    "c": "int getWinner(int* arr, int arrSize, int k) {\n    \n}",
    "csharp": "public class Solution {\n    public int GetWinner(int[] arr, int k) {\n        \n    }\n}",
    "javascript": "/**\n * @param {number[]} arr\n * @param {number} k\n * @return {number}\n */\nvar getWinner = function(arr, k) {\n    \n};",
    "typescript": "function getWinner(arr: number[], k: number): number {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param Integer[] $arr\n     * @param Integer $k\n     * @return Integer\n     */\n    function getWinner($arr, $k) {\n        \n    }\n}",
    "swift": "class Solution {\n    func getWinner(_ arr: [Int], _ k: Int) -> Int {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun getWinner(arr: IntArray, k: Int): Int {\n        \n    }\n}",
    "dart": "class Solution {\n  int getWinner(List<int> arr, int k) {\n    \n  }\n}",
    "golang": "func getWinner(arr []int, k int) int {\n    \n}",
    "ruby": "# @param {Integer[]} arr\n# @param {Integer} k\n# @return {Integer}\ndef get_winner(arr, k)\n    \nend",
    "scala": "object Solution {\n    def getWinner(arr: Array[Int], k: Int): Int = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn get_winner(arr: Vec<i32>, k: i32) -> i32 {\n        \n    }\n}",
    "racket": "(define/contract (get-winner arr k)\n  (-> (listof exact-integer?) exact-integer? exact-integer?)\n  )",
    "erlang": "-spec get_winner(Arr :: [integer()], K :: integer()) -> integer().\nget_winner(Arr, K) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec get_winner(arr :: [integer], k :: integer) :: integer\n  def get_winner(arr, k) do\n    \n  end\nend"
  },
  "solution": "[TOC]\n\n## Solution\n\n---\n\n### Approach 1: Simulate Process With Queue\n\n**Intuition**\n\nWe have an interesting game here. Let's try to fully understand it so that we can simulate it.\n\n- In each round, two players face each other. The player with a larger value wins.\n- The problem states that `arr` has distinct integers, so we don't need to worry about tiebreaks.\n- The game ends when someone wins `k` rounds in a row.\n- The game starts between the first two elements of `arr`. The other elements of `arr` represent a line.\n- After each round, the next round is played between the winner and the next player in line.\n- The loser goes to the end of the line.\n\nThe functionality of a line can be implemented using a queue. We remove from the front of the queue to determine the next player, and we add to the back of the queue when a player loses. Using a queue and some integers, we can simulate the game.\n\n- Let `curr` represent the winner of the most recent round. Initially, `curr = arr[0]`.\n- Let `winstreak` represent the winstreak of the current player. Initially, `winstreak = 0`.\n- Let `queue` represent the line. Initially, `queue` holds all the elements of `arr` in order, except for the first element.\n\nNow, let's simulate the game. At each round:\n\n- Remove from the front of `queue` and let this value be `opponent`.\n- If `curr > opponent`, the current player wins. Add `opponent` to the back of `queue` and increment `winstreak`.\n- Otherwise, `opponent` wins. Add `curr` to the back of `queue`, update `curr = opponent`, and set `winstreak = 1`.\n- If `winstreak = k`, the current player has won `k` rounds in a row. We can return `curr`.\n\n!?!../Documents/1535.json:960,540!?!This simulation process works, but there is an issue. If we examine the constraints, we find that $$k$$ can be up to 1 billion! If we tried to simulate a billion rounds, we would exceed the time limit. How do we solve this?\n\nWe can make another observation: let the player with the largest value in `arr` be `maxElement`. Since the elements in the array are all unique, this player will **never** lose a round, so if the current player ever becomes `maxElement`, it will surely end up winning so many games as long as the simulation continues, no matter how large the required `k` is. Thus, if `curr = maxElement`, we can immediately return `curr` without actually simulating all the games, because we know that all future games will result in `curr` winning!\n\n**Algorithm**\n\n1. Initialize:\n    - `maxElement` as the maximum element in `arr`.\n    - `queue` as a queue with every element in `arr` except the first one.\n    - `curr = arr[0]`.\n    - `winstreak = 0`.\n2. While `queue` is not empty (could also do `while True`):\n    - Pop `opponent` from the front of `queue`.\n    - If `curr > opponent`:\n        - Push `opponent` to the back of `queue`.\n        - Increment `winstreak`.\n    - Else:\n        - Push `curr` to the back of `queue`.\n        - Set `curr = opponent`.\n        - Set `winstreak = 1`.\n    - If `winstreak = k` or `curr = maxElement`, return `curr`.\n3. The code should never reach this point since there is guaranteed to be a winner. Return anything.\n\n**Implementation****Complexity Analysis**\n\nGiven $$n$$ as the length of `arr`,\n\n* Time complexity: $$O(n)$$\n\n    We spend $$O(n)$$ to find `maxElement` and to initialize `queue`.\n\n    Then, we perform a while loop. Each iteration of the while loop costs $$O(1)$$. The number of iterations is limited to $$O(n)$$, since we visit the elements of `arr` in order and terminate if we find `maxElement`. Thus, the while loop costs up to $$O(n)$$.\n\n    Note that the value of $$k$$ is not relevant. If $$k < n$$, then it wouldn't change the time complexity. If $$k > n$$, we would terminate before $$k$$ operations anyway, as we must find `maxElement` within $$n$$ rounds.\n\n* Space complexity: $$O(n)$$\n\n    `queue` has a size of $$O(n)$$.---\n\n### Approach 2: No Queue\n\n**Intuition**\n\nEach player that is not `maxElement` has two possibilities:\n\n1. They come after `maxElement` in `arr`. \n2. They come before `maxElement` in `arr`.\n\nIf a player comes after `maxElement`, they will not play any rounds in our simulation, since we immediately terminate upon finding `maxElement`.\n\nIf a player comes before `maxElement` and loses, they will move to the back of the line **behind `maxElement`**. This means they will never appear in the simulation again, because `maxElement` will play before them, and we immediately terminate the simulation once `maxElement` plays.\n\nThus, in our simulation, when a player loses, they never play again. That means we don't actually need the queue to maintain their positions at all! We can simply use a for loop to iterate over the opponents while implementing the same simulation.\n\n**Algorithm**\n\n1. Initialize:\n    - `maxElement` as the maximum element in `arr`.\n    - `curr = arr[0]`.\n    - `winstreak = 0`.\n2. Iterate `i` over the indices of `arr`, starting from `1`:\n    - Set `opponent = arr[i]`.\n    - If `curr > opponent`:\n        - Increment `winstreak`.\n    - Else:\n        - Set `curr = opponent`.\n        - Set `winstreak = 1`.\n    - If `winstreak = k` or `curr = maxElement`, return `curr`.\n3. The code should never reach this point since we would surely find `maxElement`. Return anything.\n\n**Implementation****Complexity Analysis**\n\nGiven $$n$$ as the length of `arr`,\n\n* Time complexity: $$O(n)$$\n\n    We spend $$O(n)$$ to find `maxElement`.\n\n    Then, we perform a for loop over the indices of `arr`. Each iteration costs $$O(1)$$, so this loop costs $$O(n)$$ in total.\n\n* Space complexity: $$O(1)$$\n\n    We are only using a few integer variables.---"
}