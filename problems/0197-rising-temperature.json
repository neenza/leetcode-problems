{
  "title": "Rising Temperature",
  "problem_id": "197",
  "frontend_id": "197",
  "difficulty": "Easy",
  "problem_slug": "rising-temperature",
  "topics": [
    "Database"
  ],
  "description": "Table: Weather\nWrite a solution to find all dates' id with higher temperatures compared to its previous dates (yesterday).\nReturn the result table in any order.\nThe result format is in the following example.\nExample 1:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "+---------------+---------+\n| Column Name   | Type    |\n+---------------+---------+\n| id            | int     |\n| recordDate    | date    |\n| temperature   | int     |\n+---------------+---------+\nid is the column with unique values for this table.\nThere are no different rows with the same recordDate.\nThis table contains information about the temperature on a certain day.",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input: \nWeather table:\n+----+------------+-------------+\n| id | recordDate | temperature |\n+----+------------+-------------+\n| 1  | 2015-01-01 | 10          |\n| 2  | 2015-01-02 | 25          |\n| 3  | 2015-01-03 | 20          |\n| 4  | 2015-01-04 | 30          |\n+----+------------+-------------+\nOutput: \n+----+\n| id |\n+----+\n| 2  |\n| 4  |\n+----+\nExplanation: \nIn 2015-01-02, the temperature was higher than the previous day (10 -> 25).\nIn 2015-01-04, the temperature was higher than the previous day (20 -> 30).",
      "images": []
    }
  ],
  "constraints": [],
  "follow_ups": [],
  "hints": [],
  "code_snippets": {
    "mysql": "# Write your MySQL query statement below\n",
    "mssql": "/* Write your T-SQL query statement below */\n",
    "oraclesql": "/* Write your PL/SQL query statement below */\n",
    "pythondata": "import pandas as pd\n\ndef rising_temperature(weather: pd.DataFrame) -> pd.DataFrame:\n    ",
    "postgresql": "-- Write your PostgreSQL query statement below\n"
  },
  "solution": "[TOC]\n\n# Solution\n---\n\n### Overview\n\n**Problem Statement Reference**\n> Write a solution to find all dates' Id with higher temperatures compared to its previous dates (yesterday). Return the result table in any order.\n\nLet's further elaborate on the given example to deepen our understanding of the problem at hand.\n\nIf we conduct a time series analysis of the temperature data, we would notice distinct points where there is a rise in temperature compared to the previous day. This phenomenon is precisely what we are interested in identifying.\n\nBy analyzing the given data:idrecordDatetemperature12015-01-011022015-01-022532015-01-032042015-01-0430We can graphically represent the temperature readings across the consecutive dates. When we plot these points on a graph, with the `recordDate` on the X-axis and the `temperature` on the Y-axis, we observe a graphical representation of the temperature variations over the specified period.\n\n![fig](../Figures/197/197-1.png)\n\nFrom this graphical analysis, we notice two instances where there is a rise in the temperature compared to the day before:\n\n1. **January 2, 2015 (id: 2)**: On this day, the temperature is recorded to be 25, which is higher than the 10 recorded on January 1st.\n   \n2. **January 4, 2015 (id: 4)**: Here, the temperature escalated to 30, surpassing the temperature of 20 noted on January 3rd.\n\nThus, based on our criteria of identifying days with a temperature rise compared to the immediate preceding day, we should return the ids for January 2nd and January 4th, which are 2 and 4 respectively.\n\n---\n\n## pandas\n\n### Approach 1: Shifted Dataframe Merge on Record Date\n\n#### Intuition\n\nWe are creating a new DataFrame that represents the data shifted by one day and merging it with the original DataFrame based on the `recordDate`. This way, for each record, we will have information on both the current day and the previous day in the same row, enabling easy comparison of temperatures across consecutive days.\n\nLet's break this down step by step:\n\n**Step 1: Converting `recordDate` to Datetime Type**\n\n```python\n# Ensure the 'recordDate' column is a datetime type\nweather['recordDate'] = pd.to_datetime(weather['recordDate'])\n```\n\n- Before working with date data, it is good practice to ensure that the date column is of the datetime data type to facilitate date-based operations correctly.\n  \n**Step 2: Creating a Shifted DataFrame**\n\n```python\n# Create a copy of the weather DataFrame with a 1 day shift \nweather_shifted = weather.copy()\nweather_shifted['recordDate'] = weather_shifted['recordDate'] + pd.to_timedelta(1, unit='D')\n```\n\n- A copy of the original DataFrame is created, where the `recordDate` for each entry is shifted forward by one day. This allows us to later merge this DataFrame with the original one to compare the temperatures of each day with the previous day.\n\n**Step 3: Merging the Original and Shifted DataFrames**\n\n```python\n# Merging the DataFrames on the 'recordDate' column to find consecutive dates\nmerged_df = pd.merge(weather, weather_shifted, on='recordDate', suffixes=('_today', '_yesterday'))\n```\n\n- The original and shifted DataFrames are merged based on the `recordDate` column, which now contains consecutive dates. This merge operation forms pairs of consecutive days so that we can directly compare the temperatures of each day with the previous day.\n\n**Step 4: Identifying Days with Higher Temperatures than the Previous Day**\n\n```python\n# Finding rows where the temperature is greater on the current day compared to the previous day\nresult = merged_df[merged_df['temperature_today'] > merged_df['temperature_yesterday']][['id_today']].rename(columns={'id_today': 'Id'})\n```\n\n- Within the merged DataFrame, we apply a condition to retain only those rows where the temperature of the current day (`temperature_today`) is greater than that of the previous day (`temperature_yesterday`). This effectively identifies all the days where the temperature was higher than the previous day.\n- We select only the ID column corresponding to the days that satisfy this condition, renaming it to `Id` to meet the output specification.\n\n**Step 5: Returning the Result**\n\n```python\nreturn result\n```\n\n- The final step is to return the DataFrame containing the IDs of the days where the temperature was higher than on the previous day.\n\n\n#### Implementation### Approach 2: Shift Function with Precise Date Match\n\n#### Intuition\n\nIn this approach, we sort the DataFrame by `recordDate` and then use the shift function to create new columns that hold the data for the previous day. After that, we filter the DataFrame to only include the rows where the temperature is greater than that of the previous day and the dates are precisely one day apart.\n\nLet's break this down step by step:\n\n**Step 1: Converting `recordDate` to Datetime Type**\n\n```python\nweather['recordDate'] = pd.to_datetime(weather['recordDate'])\n```\n- Before performing operations based on dates, we first ensure that the `recordDate` column is of datetime type. This allows us to easily perform date-specific operations later in the function.\n\n**Step 2: Sorting the DataFrame**\n\n```python\nweather.sort_values('recordDate', inplace=True)\n```\n- We sort the data based on the `recordDate` to maintain a chronological order. This step is crucial because the next steps involve operations that are dependent on the order of the dates.\n\n**Step 3: Creating Columns for Previous Day's Data**\n\n```python\nweather['PreviousTemperature'] = weather['temperature'].shift(1)\nweather['PreviousRecordDate'] = weather['recordDate'].shift(1)\n```\n- We create two new columns in the `weather` DataFrame:\n  - `PreviousTemperature`: This column is constructed by shifting the `temperature` column down by one row using `shift(1)`. This means that the value in each row of `PreviousTemperature` is the temperature value from the immediately preceding row in the DataFrame, not necessarily from the immediately preceding day in terms of time.\n  - `PreviousRecordDate`: Similarly, this column is formed by shifting the `recordDate` column down by one row. Hence, each value in `PreviousRecordDate` corresponds to the date from the immediately preceding row, not necessarily the day immediately before the current `recordDate`.\n\nBy having these new columns, we align each row with the temperature and record date of its preceding row in the DataFrame, allowing for comparisons between a day's temperature and that of the previous row. It’s crucial to note that these “previous” values come from the DataFrame's order and do not always represent the chronological day before, as there might be gaps in the dates within the data.\n\n**Step 4: Filtering for Days with Higher Temperature than the Previous Day**\n\n```python\nresult = weather[\n    (weather['temperature'] > weather['PreviousTemperature']) & \n    (weather['recordDate'] == weather['PreviousRecordDate'] + pd.Timedelta(days=1))\n][['id']].rename(columns={'id': 'Id'})\n```\n\n- We are filtering the DataFrame for rows where the temperature is higher than the previous day's temperature: `(weather['temperature'] > weather['PreviousTemperature'])`.\n- We also ensure that the record date is exactly one day more than the previous record date: `(weather['recordDate'] == weather['PreviousRecordDate'] + pd.Timedelta(days=1))`. This is done using `pd.Timedelta(days=1)` to add a day to the previous record date and checking if it equals the current record date.\n\n**Step 5: Returning the Result**\n\n```python\nreturn result\n```\n- Finally, we return the filtered DataFrame which contains only the `Id` column that satisfies both conditions specified in step 4. This DataFrame represents all the dates where the temperature was higher than the temperature of the previous day.\n\n#### Implementation---\n\n## Database\n\n### Approach 1: Using `JOIN` and `DATEDIFF()` \n\n#### Intuition\n\nBy doing a self-join on the `Weather` table, we create a Cartesian product of the table with itself, creating pairs of days. We then use the `DATEDIFF` function to restrict these pairs to only include consecutive days. Lastly, we filter these pairs of consecutive days further to only include pairs where the temperature is higher on the second day. The resulting ids represent the days where the temperature was higher than the previous day.\n\nLet's break this down step by step:\n\n**Step 1: Defining the Main Query Structure**\n\n```sql\nSELECT \n    w1.id\nFROM \n    Weather w1\nJOIN \n    Weather w2\n```\n\nHere, we are setting up a query to retrieve the `id` from the `Weather` table aliased as `w1`. To find the records where the temperature is greater than the previous day, we are performing a self-join on the `Weather` table, creating a second alias `w2`. This allows us to compare each record in `w1` with each record in `w2`.\n\n**Step 2: Join Condition**\n\n```sql\nON \n    DATEDIFF(w1.recordDate, w2.recordDate) = 1\n```\n\nIn the join condition, we are using the `DATEDIFF` function to find pairs of records where the `recordDate` differs by exactly one day. This condition ensures that we are comparing each day's temperature with the temperature of the previous day.\n\n**Step 3: Filter Records with Higher Temperature**\n\n```sql\nWHERE \n    w1.temperature > w2.temperature;\n```\n\nAfter finding pairs of days that are consecutive, we apply a filter in the `WHERE` clause to only get the records where the temperature on a day (represented by a record in `w1`) is greater than the temperature on the previous day (represented by a record in `w2`). This is the main condition to fulfill the requirement of finding the ids where the temperature is higher than the previous day.\n\n\n#### Implementation\n\n\n\n```mysql []\nSELECT \n    w1.id\nFROM \n    Weather w1\nJOIN \n    Weather w2\nON \n    DATEDIFF(w1.recordDate, w2.recordDate) = 1\nWHERE \n    w1.temperature > w2.temperature;\n\n```\n\n### Approach 2: Using `LAG()` Function\n\n#### Intuition\n\nLet's break this down step by step:\n\n**Step 1: Creating a Common Table Expression (CTE) with Lag Function**\n\n```sql\nWITH PreviousWeatherData AS\n(\n    SELECT \n        id,\n        recordDate,\n        temperature, \n        LAG(temperature, 1) OVER (ORDER BY recordDate) AS PreviousTemperature,\n        LAG(recordDate, 1) OVER (ORDER BY recordDate) AS PreviousRecordDate\n    FROM \n        Weather\n)\n```\n\nIn this step, we create a Common Table Expression (CTE) named `PreviousWeatherData` using a `WITH` clause. Inside this CTE, we are selecting all the rows from the \"Weather\" table along with two additional columns:\n\n1. `PreviousTemperature`: The temperature from the previous day, which is obtained using the `LAG()` function with an offset of 1, ordered by `recordDate`.\n2. `PreviousRecordDate`: The record date of the previous day, similarly obtained using the `LAG()` function with an offset of 1, ordered by `recordDate`.\n\nThis setup helps us associate each record with the respective details from the previous day in the same row.\n\n**Step 2: Selecting IDs with Conditions on Temperature and Date**\n\n```sql\nSELECT \n    id \nFROM \n    PreviousWeatherData\nWHERE \n    temperature > PreviousTemperature\nAND \n    recordDate = DATE_ADD(PreviousRecordDate, INTERVAL 1 DAY);\n```\n\nIn this step, we execute a query on the `PreviousWeatherData` CTE with two conditions in the WHERE clause to filter the required IDs:\n\n1. `temperature > PreviousTemperature`: This condition filters for the days where the temperature was higher than the previous day's temperature.\n2. `recordDate = DATE_ADD(PreviousRecordDate, INTERVAL 1 DAY)`: This condition ensures that we are comparing consecutive days. It uses the `DATE_ADD()` function to add an interval of 1 day to the `PreviousRecordDate` and checks if it equals the current `recordDate`.\n\nBy combining these two conditions with an `AND` clause, we ensure that we only select the IDs where both conditions are met, which are the days when the temperature is higher than the day before.\n\n\n#### Implementation\n\n\n```mysql []\nWITH PreviousWeatherData AS\n(\n    SELECT \n        id,\n        recordDate,\n        temperature, \n        LAG(temperature, 1) OVER (ORDER BY recordDate) AS PreviousTemperature,\n        LAG(recordDate, 1) OVER (ORDER BY recordDate) AS PreviousRecordDate\n    FROM \n        Weather\n)\nSELECT \n    id \nFROM \n    PreviousWeatherData\nWHERE \n    temperature > PreviousTemperature\nAND \n    recordDate = DATE_ADD(PreviousRecordDate, INTERVAL 1 DAY);\n\n```\n\n### Approach 3: Using Subquery\n\n#### Intuition\n\nLet's break this down step by step:\n\n**Step 1: Inner Subquery to Get the Previous Day’s Temperature**\n\n```sql\n        SELECT \n            w2.temperature\n        FROM \n            Weather w2\n        WHERE \n            w2.recordDate = DATE_SUB(w1.recordDate, INTERVAL 1 DAY)\n```\n\nThe inner query is responsible for retrieving the temperature of the day before the date currently under consideration in the outer query. \n\nIt utilizes the `DATE_SUB` function to find the date one day before the `recordDate` in the outer query (`w1.recordDate`) and then fetches the temperature recorded on that previous date from the same Weather table (alias `w2`).\n\n**Step 2: Outer Query to Find Days with Higher Temperature**\n\n```sql\nSELECT \n    w1.id\nFROM \n    Weather w1\nWHERE \n    w1.temperature > (\n        -- ... (inner subquery)\n    );\n```\n\nThe outer query iterates over each row (each day) in the Weather table (alias `w1`) and checks if the temperature on that day is greater than the temperature on the previous day, the latter being obtained from the inner subquery.\n\n**Step 3: Comparing Temperatures**\n\n```sql\n    w1.temperature > (\n        -- ... (inner subquery)\n    )\n```\n\nHere, we have the crucial comparison that serves our goal. For each day in the outer query, it checks whether the temperature is greater than the temperature fetched from the inner subquery (which is the temperature of the previous day).\n\n**Step 4: Selecting the ID**\n\n```sql\nSELECT \n    w1.id\n```\n\nIf the condition in the `WHERE` clause is satisfied (today’s temperature is greater than yesterday’s), we select the ID of the current day (from the outer query’s perspective). This ID indicates a day where the temperature was higher than the temperature on the previous day.\n\n#### Implementation\n\n\n\n```mysql []\nSELECT \n    w1.id\nFROM \n    Weather w1\nWHERE \n    w1.temperature > (\n        SELECT \n            w2.temperature\n        FROM \n            Weather w2\n        WHERE \n            w2.recordDate = DATE_SUB(w1.recordDate, INTERVAL 1 DAY)\n    );\n\n```\n\n### Approach 4: Using Cartesian Product and `WHERE` Clause\n\n#### Intuition\n\nLet's break this down step by step:\n\n**Step 1: Cartesian Product**\n```sql\nFROM \n    Weather w1, Weather w2\n```\n\nIn this step, we are performing a Cartesian product (or cross join) of the `Weather` table with itself. This means we create a new table where each row from `w1` (first instance of the Weather table) is paired with every row from `w2` (second instance of the Weather table), resulting in a table with n² rows (where n is the number of rows in the Weather table).\n\n**Step 2: Filtering Based on Date Difference**\n```sql\nWHERE \n    DATEDIFF(w2.recordDate, w1.recordDate) = 1 \n```\n\nNext, we use the `DATEDIFF` function to find pairs of rows where the difference between the 'recordDate' in w2 and w1 is exactly 1 day. This effectively filters down to pairs of rows representing consecutive days.\n\n**Step 3: Filtering Based on Temperature Difference**\n```sql\nAND \n    w2.temperature > w1.temperature;\n```\n\nIn this step, we are filtering the pairs further to retain only those where the temperature on the second day (`w2.temperature`) is greater than the temperature on the first day (`w1.temperature`). This finds the days where the temperature is rising compared to the previous day.\n\n**Step 4: Selecting the Result**\n```sql\nSELECT \n    w2.id\n```\n\nFinally, from all the pairs that satisfy the conditions set in the WHERE clause, we select the ID of the day from the w2 table (i.e., the ID of the day with the higher temperature).\n\n\n#### Implementation\n\n\n\n```mysql []\nSELECT \n    w2.id\nFROM \n    Weather w1, Weather w2\nWHERE \n    DATEDIFF(w2.recordDate, w1.recordDate) = 1 \nAND \n    w2.temperature > w1.temperature;\n\n```"
}