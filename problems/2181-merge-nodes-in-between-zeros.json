{
  "title": "Merge Nodes in Between Zeros",
  "problem_id": "2299",
  "frontend_id": "2181",
  "difficulty": "Medium",
  "problem_slug": "merge-nodes-in-between-zeros",
  "topics": [
    "Linked List",
    "Simulation"
  ],
  "description": "You are given the head of a linked list, which contains a series of integers separated by 0's. The beginning and end of the linked list will have Node.val == 0.\nFor every two consecutive 0's, merge all the nodes lying in between them into a single node whose value is the sum of all the merged nodes. The modified list should not contain any 0's.\nReturn the head of the modified linked list.\nExample 1:\nExample 2:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: head = [0,3,1,0,4,5,2,0]\nOutput: [4,11]\nExplanation: \nThe above figure represents the given linked list. The modified list contains\n- The sum of the nodes marked in green: 3 + 1 = 4.\n- The sum of the nodes marked in red: 4 + 5 + 2 = 11.",
      "images": [
        "https://assets.leetcode.com/uploads/2022/02/02/ex1-1.png"
      ]
    },
    {
      "example_num": 2,
      "example_text": "Input: head = [0,1,0,3,0,2,2,0]\nOutput: [1,3,4]\nExplanation: \nThe above figure represents the given linked list. The modified list contains\n- The sum of the nodes marked in green: 1 = 1.\n- The sum of the nodes marked in red: 3 = 3.\n- The sum of the nodes marked in yellow: 2 + 2 = 4.",
      "images": [
        "https://assets.leetcode.com/uploads/2022/02/02/ex2-1.png"
      ]
    }
  ],
  "constraints": [
    "The number of nodes in the list is in the range [3, 2 * 105].",
    "0 <= Node.val <= 1000",
    "There are no two consecutive nodes with Node.val == 0.",
    "The beginning and end of the linked list have Node.val == 0."
  ],
  "follow_ups": [],
  "hints": [
    "How can you use two pointers to modify the original list into the new list?",
    "Have a pointer traverse the entire linked list, while another pointer looks at a node that is currently being modified.",
    "Keep on summing the values of the nodes between the traversal pointer and the modifying pointer until the former comes across a ‘0’. In that case, the modifying pointer is incremented to modify the next node.",
    "Do not forget to have the next pointer of the final node of the modified list point to null."
  ],
  "code_snippets": {
    "cpp": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* mergeNodes(ListNode* head) {\n        \n    }\n};",
    "java": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode mergeNodes(ListNode head) {\n        \n    }\n}",
    "python": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def mergeNodes(self, head):\n        \"\"\"\n        :type head: Optional[ListNode]\n        :rtype: Optional[ListNode]\n        \"\"\"\n        ",
    "python3": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def mergeNodes(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        ",
    "c": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     struct ListNode *next;\n * };\n */\nstruct ListNode* mergeNodes(struct ListNode* head) {\n    \n}",
    "csharp": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     public int val;\n *     public ListNode next;\n *     public ListNode(int val=0, ListNode next=null) {\n *         this.val = val;\n *         this.next = next;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode MergeNodes(ListNode head) {\n        \n    }\n}",
    "javascript": "/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar mergeNodes = function(head) {\n    \n};",
    "typescript": "/**\n * Definition for singly-linked list.\n * class ListNode {\n *     val: number\n *     next: ListNode | null\n *     constructor(val?: number, next?: ListNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.next = (next===undefined ? null : next)\n *     }\n * }\n */\n\nfunction mergeNodes(head: ListNode | null): ListNode | null {\n    \n};",
    "php": "/**\n * Definition for a singly-linked list.\n * class ListNode {\n *     public $val = 0;\n *     public $next = null;\n *     function __construct($val = 0, $next = null) {\n *         $this->val = $val;\n *         $this->next = $next;\n *     }\n * }\n */\nclass Solution {\n\n    /**\n     * @param ListNode $head\n     * @return ListNode\n     */\n    function mergeNodes($head) {\n        \n    }\n}",
    "swift": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     public var val: Int\n *     public var next: ListNode?\n *     public init() { self.val = 0; self.next = nil; }\n *     public init(_ val: Int) { self.val = val; self.next = nil; }\n *     public init(_ val: Int, _ next: ListNode?) { self.val = val; self.next = next; }\n * }\n */\nclass Solution {\n    func mergeNodes(_ head: ListNode?) -> ListNode? {\n        \n    }\n}",
    "kotlin": "/**\n * Example:\n * var li = ListNode(5)\n * var v = li.`val`\n * Definition for singly-linked list.\n * class ListNode(var `val`: Int) {\n *     var next: ListNode? = null\n * }\n */\nclass Solution {\n    fun mergeNodes(head: ListNode?): ListNode? {\n        \n    }\n}",
    "dart": "/**\n * Definition for singly-linked list.\n * class ListNode {\n *   int val;\n *   ListNode? next;\n *   ListNode([this.val = 0, this.next]);\n * }\n */\nclass Solution {\n  ListNode? mergeNodes(ListNode? head) {\n    \n  }\n}",
    "golang": "/**\n * Definition for singly-linked list.\n * type ListNode struct {\n *     Val int\n *     Next *ListNode\n * }\n */\nfunc mergeNodes(head *ListNode) *ListNode {\n    \n}",
    "ruby": "# Definition for singly-linked list.\n# class ListNode\n#     attr_accessor :val, :next\n#     def initialize(val = 0, _next = nil)\n#         @val = val\n#         @next = _next\n#     end\n# end\n# @param {ListNode} head\n# @return {ListNode}\ndef merge_nodes(head)\n    \nend",
    "scala": "/**\n * Definition for singly-linked list.\n * class ListNode(_x: Int = 0, _next: ListNode = null) {\n *   var next: ListNode = _next\n *   var x: Int = _x\n * }\n */\nobject Solution {\n    def mergeNodes(head: ListNode): ListNode = {\n        \n    }\n}",
    "rust": "// Definition for singly-linked list.\n// #[derive(PartialEq, Eq, Clone, Debug)]\n// pub struct ListNode {\n//   pub val: i32,\n//   pub next: Option<Box<ListNode>>\n// }\n// \n// impl ListNode {\n//   #[inline]\n//   fn new(val: i32) -> Self {\n//     ListNode {\n//       next: None,\n//       val\n//     }\n//   }\n// }\nimpl Solution {\n    pub fn merge_nodes(head: Option<Box<ListNode>>) -> Option<Box<ListNode>> {\n        \n    }\n}",
    "racket": "; Definition for singly-linked list:\n#|\n\n; val : integer?\n; next : (or/c list-node? #f)\n(struct list-node\n  (val next) #:mutable #:transparent)\n\n; constructor\n(define (make-list-node [val 0])\n  (list-node val #f))\n\n|#\n\n(define/contract (merge-nodes head)\n  (-> (or/c list-node? #f) (or/c list-node? #f))\n  )",
    "erlang": "%% Definition for singly-linked list.\n%%\n%% -record(list_node, {val = 0 :: integer(),\n%%                     next = null :: 'null' | #list_node{}}).\n\n-spec merge_nodes(Head :: #list_node{} | null) -> #list_node{} | null.\nmerge_nodes(Head) ->\n  .",
    "elixir": "# Definition for singly-linked list.\n#\n# defmodule ListNode do\n#   @type t :: %__MODULE__{\n#           val: integer,\n#           next: ListNode.t() | nil\n#         }\n#   defstruct val: 0, next: nil\n# end\n\ndefmodule Solution do\n  @spec merge_nodes(head :: ListNode.t | nil) :: ListNode.t | nil\n  def merge_nodes(head) do\n    \n  end\nend"
  },
  "solution": "[TOC]\n\n## Solution\n\n---\n\n### Approach 1: Two-Pointer (One-Pass)\n\n#### Intuition\n\nWe can break this problem into two tasks: finding the sum of all the nodes between two consecutive `0`s, and merging these values into a single list. One brute force idea is to iterate through the linked list, summing the node values, and adding this sum to a new linked list when we encounter a `0`. However, we can modify the linked list in the given problem.\n\nWe can use a two-pointer approach to modify the list. The first pointer, `modify`, changes the linked list and the second pointer, `nextSum`, calculates the sum for each block between two `0`s. Initially, both pointers start at the beginning of the list.\n\nHow can we manage both pointers while traversing the list? After `nextSum` calculates the sum for the current block, we store this value at the `modify` node. Since `nextSum` is at a `0` at the end of the block, it moves to the next node to start summing the next block.\n\nThe number of nodes in the modified linked list matches the number of blocks between consecutive `0`s. After processing each block, we update `modify`'s next pointer to `nextSum`, helping maintain the size of the modified list, with both pointers reaching the end simultaneously.\n\n#### Algorithm\n\n1. Initialize `modify` and `nextSum` with `head->next` that stores the first node with a non-zero value.\n2. Iterate through the list until `modify` is not null:\n   - Initialize `sum` with `0` to store the sum of the current block.\n   - Iterate through the block until `nextSum` encounters a `0`:\n     - Add the value of the current node to `sum`.\n     - Move `nextSum` to the next node.\n   - Modify the node value at `modify` to `sum`.\n   - Move `nextSum` to the next node that stores the next block's first non-zero value. Also, set `modify->next` to this node. \n   - Move `modify` to it's next node.\n3. Return `head->next`.\n\n!?!../Documents/2181/slideshow1.json:960,454!?!\n \n#### Implementation#### Complexity Analysis\n\nLet $n$ be the size of the linked list.\n\n- Time complexity: $O(n)$\n\n    All the nodes of the linked list are visited exactly once. Therefore, the total time complexity is given by $O(n)$.\n\n- Space complexity: $O(1)$\n\n    Apart from the original list, we don't use any additional space. Therefore, the total space complexity is given by $O(1)$.\n\n---\n\n### Approach 2: Recursion\n\n#### Intuition\n\nRecursion is useful for solving problems that can be broken down into smaller, repetitive sub-problems. Finding the sum of every 0-separated block is an example of such a sub-problem, making recursion an appropriate approach.\n\nWe can start at the beginning of a block with the current node's value as `0` and calculate the sum for this block by iterating through the list and adding values until encountering another `0`. At this point, the pointer will be at the start of the next block. The new list starting at this pointer resembles the original list but with one less block to compute. Therefore, we can pass this pointer to the recursive function as a new sub-problem, as explained below:\n\n![img](../Figures/2181/Slide8.png)\n\n#### Algorithm\n\n1. Store the first non-zero value, given by `head->next`, in `head`.\n2. If `head` is null, return `head`.\n3. Initialize a dummy node `temp` with `head`.\n4. Initialize `sum` with `0`.\n5. Iterate through the list until the value of `temp` is not `0`:\n   - Increment `sum` with the value of `temp`.\n   - Set `temp` as `temp->next`.\n6. Store the updated `sum` in the value of `head`.\n7. Store `head->next` as the solution of the sub-problem starting at `temp`, given by `mergeNodes(temp)`.\n8. Return `head`.\n \n#### Implementation#### Complexity Analysis\n\nLet $n$ be the size of the linked list.\n\n- Time complexity: $O(n)$\n\n    All the nodes of the linked list are visited exactly once. Therefore, the total time complexity is given by $O(n)$.\n\n- Space complexity: $O(n)$\n\n    The extra space comes from implicit stack space due to recursion. The recursion could go up to $n$ levels deep. Therefore, the total space complexity is given by $O(n)$.\n\n---"
}