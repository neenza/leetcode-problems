{
  "title": "Max Value of Equation",
  "problem_id": "1622",
  "frontend_id": "1499",
  "difficulty": "Hard",
  "problem_slug": "max-value-of-equation",
  "topics": [
    "Array",
    "Queue",
    "Sliding Window",
    "Heap (Priority Queue)",
    "Monotonic Queue"
  ],
  "description": "You are given an array points containing the coordinates of points on a 2D plane, sorted by the x-values, where points[i] = [xi, yi] such that xi < xj for all 1 <= i < j <= points.length. You are also given an integer k.\nReturn the maximum value of the equation yi + yj + |xi - xj| where |xi - xj| <= k and 1 <= i < j <= points.length.\nIt is guaranteed that there exists at least one pair of points that satisfy the constraint |xi - xj| <= k.\nExample 1:\nExample 2:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: points = [[1,3],[2,0],[5,10],[6,-10]], k = 1\nOutput: 4\nExplanation: The first two points satisfy the condition |xi - xj| <= 1 and if we calculate the equation we get 3 + 0 + |1 - 2| = 4. Third and fourth points also satisfy the condition and give a value of 10 + -10 + |5 - 6| = 1.\nNo other pairs satisfy the condition, so we return the max of 4 and 1.",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input: points = [[0,0],[3,0],[9,2]], k = 3\nOutput: 3\nExplanation: Only the first two points have an absolute difference of 3 or less in the x-values, and give the value of 0 + 0 + |0 - 3| = 3.",
      "images": []
    }
  ],
  "constraints": [
    "2 <= points.length <= 105",
    "points[i].length == 2",
    "-108 <= xi, yi <= 108",
    "0 <= k <= 2 * 108",
    "xi < xj for all 1 <= i < j <= points.length",
    "xi form a strictly increasing sequence."
  ],
  "follow_ups": [],
  "hints": [
    "Use a priority queue to store for each point i, the tuple [yi-xi, xi]",
    "Loop through the array and pop elements from the heap if the condition xj - xi > k, where j is the current index and i is the point on top the queue.",
    "After popping elements from the queue. If the queue is not empty, calculate the equation with the current point and the point on top of the queue and maximize the answer."
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    int findMaxValueOfEquation(vector<vector<int>>& points, int k) {\n        \n    }\n};",
    "java": "class Solution {\n    public int findMaxValueOfEquation(int[][] points, int k) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def findMaxValueOfEquation(self, points, k):\n        \"\"\"\n        :type points: List[List[int]]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def findMaxValueOfEquation(self, points: List[List[int]], k: int) -> int:\n        ",
    "c": "int findMaxValueOfEquation(int** points, int pointsSize, int* pointsColSize, int k) {\n    \n}",
    "csharp": "public class Solution {\n    public int FindMaxValueOfEquation(int[][] points, int k) {\n        \n    }\n}",
    "javascript": "/**\n * @param {number[][]} points\n * @param {number} k\n * @return {number}\n */\nvar findMaxValueOfEquation = function(points, k) {\n    \n};",
    "typescript": "function findMaxValueOfEquation(points: number[][], k: number): number {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param Integer[][] $points\n     * @param Integer $k\n     * @return Integer\n     */\n    function findMaxValueOfEquation($points, $k) {\n        \n    }\n}",
    "swift": "class Solution {\n    func findMaxValueOfEquation(_ points: [[Int]], _ k: Int) -> Int {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun findMaxValueOfEquation(points: Array<IntArray>, k: Int): Int {\n        \n    }\n}",
    "dart": "class Solution {\n  int findMaxValueOfEquation(List<List<int>> points, int k) {\n    \n  }\n}",
    "golang": "func findMaxValueOfEquation(points [][]int, k int) int {\n    \n}",
    "ruby": "# @param {Integer[][]} points\n# @param {Integer} k\n# @return {Integer}\ndef find_max_value_of_equation(points, k)\n    \nend",
    "scala": "object Solution {\n    def findMaxValueOfEquation(points: Array[Array[Int]], k: Int): Int = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn find_max_value_of_equation(points: Vec<Vec<i32>>, k: i32) -> i32 {\n        \n    }\n}",
    "racket": "(define/contract (find-max-value-of-equation points k)\n  (-> (listof (listof exact-integer?)) exact-integer? exact-integer?)\n  )",
    "erlang": "-spec find_max_value_of_equation(Points :: [[integer()]], K :: integer()) -> integer().\nfind_max_value_of_equation(Points, K) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec find_max_value_of_equation(points :: [[integer]], k :: integer) :: integer\n  def find_max_value_of_equation(points, k) do\n    \n  end\nend"
  }
}