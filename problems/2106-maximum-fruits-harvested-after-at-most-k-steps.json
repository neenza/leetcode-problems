{
  "title": "Maximum Fruits Harvested After at Most K Steps",
  "problem_id": "2229",
  "frontend_id": "2106",
  "difficulty": "Hard",
  "problem_slug": "maximum-fruits-harvested-after-at-most-k-steps",
  "topics": [
    "Array",
    "Binary Search",
    "Sliding Window",
    "Prefix Sum"
  ],
  "description": "Fruits are available at some positions on an infinite x-axis. You are given a 2D integer array fruits where fruits[i] = [positioni, amounti] depicts amounti fruits at the position positioni. fruits is already sorted by positioni in ascending order, and each positioni is unique.\nYou are also given an integer startPos and an integer k. Initially, you are at the position startPos. From any position, you can either walk to the left or right. It takes one step to move one unit on the x-axis, and you can walk at most k steps in total. For every position you reach, you harvest all the fruits at that position, and the fruits will disappear from that position.\nReturn the maximum total number of fruits you can harvest.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: fruits = [[2,8],[6,3],[8,6]], startPos = 5, k = 4\nOutput: 9\nExplanation: \nThe optimal way is to:\n- Move right to position 6 and harvest 3 fruits\n- Move right to position 8 and harvest 6 fruits\nYou moved 3 steps and harvested 3 + 6 = 9 fruits in total.",
      "images": [
        "https://assets.leetcode.com/uploads/2021/11/21/1.png"
      ]
    },
    {
      "example_num": 2,
      "example_text": "Input: fruits = [[0,9],[4,1],[5,7],[6,2],[7,4],[10,9]], startPos = 5, k = 4\nOutput: 14\nExplanation: \nYou can move at most k = 4 steps, so you cannot reach position 0 nor 10.\nThe optimal way is to:\n- Harvest the 7 fruits at the starting position 5\n- Move left to position 4 and harvest 1 fruit\n- Move right to position 6 and harvest 2 fruits\n- Move right to position 7 and harvest 4 fruits\nYou moved 1 + 3 = 4 steps and harvested 7 + 1 + 2 + 4 = 14 fruits in total.",
      "images": [
        "https://assets.leetcode.com/uploads/2021/11/21/2.png"
      ]
    },
    {
      "example_num": 3,
      "example_text": "Input: fruits = [[0,3],[6,4],[8,5]], startPos = 3, k = 2\nOutput: 0\nExplanation:\nYou can move at most k = 2 steps and cannot reach any position with fruits.",
      "images": [
        "https://assets.leetcode.com/uploads/2021/11/21/3.png"
      ]
    }
  ],
  "constraints": [
    "1 <= fruits.length <= 105",
    "fruits[i].length == 2",
    "0 <= startPos, positioni <= 2 * 105",
    "positioni-1 < positioni for any i > 0Â (0-indexed)",
    "1 <= amounti <= 104",
    "0 <= k <= 2 * 105"
  ],
  "follow_ups": [],
  "hints": [
    "Does an optimal path have very few patterns? For example, could a path that goes left, turns and goes right, then turns again and goes left be any better than a path that simply goes left, turns, and goes right?",
    "The optimal path turns at most once. That is, the optimal path is one of these: to go left only; to go right only; to go left, turn and go right; or to go right, turn and go left.",
    "Moving x steps left then k-x steps right gives you a range of positions that you can reach.",
    "Use prefix sums to get the sum of all fruits for each possible range.",
    "Use a similar strategy for all the paths that go right, then turn and go left."
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    int maxTotalFruits(vector<vector<int>>& fruits, int startPos, int k) {\n        \n    }\n};",
    "java": "class Solution {\n    public int maxTotalFruits(int[][] fruits, int startPos, int k) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def maxTotalFruits(self, fruits, startPos, k):\n        \"\"\"\n        :type fruits: List[List[int]]\n        :type startPos: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def maxTotalFruits(self, fruits: List[List[int]], startPos: int, k: int) -> int:\n        ",
    "c": "int maxTotalFruits(int** fruits, int fruitsSize, int* fruitsColSize, int startPos, int k) {\n    \n}",
    "csharp": "public class Solution {\n    public int MaxTotalFruits(int[][] fruits, int startPos, int k) {\n        \n    }\n}",
    "javascript": "/**\n * @param {number[][]} fruits\n * @param {number} startPos\n * @param {number} k\n * @return {number}\n */\nvar maxTotalFruits = function(fruits, startPos, k) {\n    \n};",
    "typescript": "function maxTotalFruits(fruits: number[][], startPos: number, k: number): number {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param Integer[][] $fruits\n     * @param Integer $startPos\n     * @param Integer $k\n     * @return Integer\n     */\n    function maxTotalFruits($fruits, $startPos, $k) {\n        \n    }\n}",
    "swift": "class Solution {\n    func maxTotalFruits(_ fruits: [[Int]], _ startPos: Int, _ k: Int) -> Int {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun maxTotalFruits(fruits: Array<IntArray>, startPos: Int, k: Int): Int {\n        \n    }\n}",
    "dart": "class Solution {\n  int maxTotalFruits(List<List<int>> fruits, int startPos, int k) {\n    \n  }\n}",
    "golang": "func maxTotalFruits(fruits [][]int, startPos int, k int) int {\n    \n}",
    "ruby": "# @param {Integer[][]} fruits\n# @param {Integer} start_pos\n# @param {Integer} k\n# @return {Integer}\ndef max_total_fruits(fruits, start_pos, k)\n    \nend",
    "scala": "object Solution {\n    def maxTotalFruits(fruits: Array[Array[Int]], startPos: Int, k: Int): Int = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn max_total_fruits(fruits: Vec<Vec<i32>>, start_pos: i32, k: i32) -> i32 {\n        \n    }\n}",
    "racket": "(define/contract (max-total-fruits fruits startPos k)\n  (-> (listof (listof exact-integer?)) exact-integer? exact-integer? exact-integer?)\n  )",
    "erlang": "-spec max_total_fruits(Fruits :: [[integer()]], StartPos :: integer(), K :: integer()) -> integer().\nmax_total_fruits(Fruits, StartPos, K) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec max_total_fruits(fruits :: [[integer]], start_pos :: integer, k :: integer) :: integer\n  def max_total_fruits(fruits, start_pos, k) do\n    \n  end\nend"
  },
  "solution": "### Approach 1: Binary Search\n\n#### Intuition\n\nSince the fruit positions are already sorted in ascending order, we can efficiently determine how many fruits fall within any interval on the x-axis using binary search. The main challenge is to find the interval of positions that can be reached from `startPos` using at most $k$ steps, such that the total number of fruits collected is maximized.\n\nWe follow a greedy strategy, moving in one direction first and then turning around. This works because fruits can only be picked once, and covering a wider range increases the chance of collecting more fruits.\n\nThere are two main movement patterns:\n\n- Move $x$ steps in one direction, then $k - x$ steps in the opposite direction.\n- When $x = 0$, we simply move in one direction for $k$ steps.\n\nFor each $x$ in the range $[0, \\left\\lfloor \\frac{k}{2} \\right\\rfloor]$, we consider:\n\n1. Left-first movement: move left $x$ steps, then right $(k - x)$ steps. This covers the interval $[\\textit{startPos} - x, \\textit{startPos} + k - 2x]$.\n2. Right-first movement: move right $x$ steps, then left $(k - x)$ steps. This covers the interval $[\\textit{startPos} - (k - 2x), \\textit{startPos} + x]$.\n\nFor each of these intervals, we compute the number of fruits using prefix sums and binary search in $O(\\log n)$ time. The maximum value across all such intervals gives the answer.\n\n#### Implementation#### Complexity Analysis\n\nLet $n$ be the length of the array $\\textit{fruits}$, and let $k$ be the given integer.\n\n- Time complexity: $O(n + k \\log n)$.\n  \n  The time complexity for calculating the prefix sum of the array is $O(n)$, and the time required for each query to find the number of fruits in a range is $O(\\log n)$. Since there are a total of $k$ queries, the overall time complexity is $O(n + k \\log n)$.\n\n- Space complexity: $O(n)$.\n  \n  We calculate and store the prefix sum of the array, which requires $O(n)$ space.\n\n---\n\n### Approach 2: Sliding Window\n\n#### Intuition\n\nWe can approach the problem from a new perspective. Suppose we fix an interval $[ \\textit{left}, \\textit{right} ]$ (where `left` and `right` are **indices** in the `fruits` array). From the given starting position `startPos`, how many steps are required to visit all fruit positions within this interval?\n\nThere are three cases to consider:\n\n* **Case 1:** `startPos > fruits[right][0]`\n  The interval lies entirely to the left of `startPos`. We need to move left to reach `fruits[left][0]`.\n  Steps needed:\n\n  $$\n  \\textit{startPos} - \\textit{fruits[left][0]}\n  $$\n\n* **Case 2:** `startPos < fruits[left][0]`\n  The interval lies entirely to the right of `startPos`. We need to move right to reach `fruits[right][0]`.\n  Steps needed:\n\n  $$\n  \\textit{fruits[right][0]} - \\textit{startPos}\n  $$\n\n* **Case 3:** `startPos` is within the interval\n  There are two ways to visit both ends:\n\n  * Go left first to `fruits[left][0]`, then right to `fruits[right][0]`\n    Steps:\n\n    $$\n    \\textit{startPos} - \\textit{fruits[left][0]} + \\textit{fruits[right][0]} - \\textit{fruits[left][0]}\n    $$\n  * Go right first to `fruits[right][0]`, then left to `fruits[left][0]`\n    Steps:\n\n    $$\n    \\textit{fruits[right][0]} - \\textit{startPos} + \\textit{fruits[right][0]} - \\textit{fruits[left][0]}\n    $$\n\nSo, in general, the minimum number of steps required to traverse the interval $[ \\textit{fruits[left][0]}, \\textit{fruits[right][0]} ]$ is:\n\n$$\n\\text{step}(left, right) = \\textit{fruits[right][0]} - \\textit{fruits[left][0]} + \\min\\left( |\\textit{startPos} - \\textit{fruits[left][0]}|,\\ |\\textit{startPos} - \\textit{fruits[right][0]}| \\right)\n$$\n\nThis expression ensures that we count both the total distance and the shorter leg from `startPos` to either end.\n\nNow, if we fix `right` and slide `left`, we observe:\n\n* If `fruits[left][0] < startPos`, decreasing `left` can decrease the `step` value.\n* If `fruits[left][0] â¥ startPos`, decreasing `left` no longer helps and `step` stays the same or increases.\n\nThus, for fixed `right`, the `step(left, right)` function is non-increasing as long as `fruits[left][0] < startPos`, and non-decreasing afterward.\n\nThus, we use a sliding window where both `left` and `right` are pointers to intervals in the `fruits` array. As we move `right` forward to include more fruits, we check whether the number of steps needed to reach the interval exceeds `k`. If it does, we increment `left` to shrink the window until the constraint is satisfied. At each step, we track the sum of fruits in the valid window and update the maximum found so far.\n\n#### Implementation#### Complexity Analysis\n\nLet $n$ be the length of the array $\\textit{fruits}$.\n\n- Time complexity: $O(n)$.\n  \n  Each time, we move the right endpoint of the fixed window and then try to move the left endpoint. The right endpoint can move at most $n$ times, and the left endpoint can also move at most $n$ times. Therefore, the time complexity is $O(2n) = O(n)$.\n\n- Space complexity: $O(1)$.\n\n---"
}