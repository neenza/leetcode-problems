{
  "title": "Word Subsets",
  "problem_id": "952",
  "frontend_id": "916",
  "difficulty": "Medium",
  "problem_slug": "word-subsets",
  "topics": [
    "Array",
    "Hash Table",
    "String"
  ],
  "description": "You are given two string arrays words1 and words2.\nA string b is a subset of string a if every letter in b occurs in a including multiplicity.\nA string a from words1 is universal if for every string b in words2, b is a subset of a.\nReturn an array of all the universal strings in words1. You may return the answer in any order.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: words1 = [\"amazon\",\"apple\",\"facebook\",\"google\",\"leetcode\"], words2 = [\"e\",\"o\"]\nOutput: [\"facebook\",\"google\",\"leetcode\"]",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input: words1 = [\"amazon\",\"apple\",\"facebook\",\"google\",\"leetcode\"], words2 = [\"lc\",\"eo\"]\nOutput: [\"leetcode\"]",
      "images": []
    },
    {
      "example_num": 3,
      "example_text": "Input: words1 = [\"acaac\",\"cccbb\",\"aacbb\",\"caacc\",\"bcbbb\"], words2 = [\"c\",\"cc\",\"b\"]\nOutput: [\"cccbb\"]",
      "images": []
    }
  ],
  "constraints": [
    "1 <= words1.length, words2.length <= 104",
    "1 <= words1[i].length, words2[i].length <= 10",
    "words1[i] and words2[i] consist only of lowercase English letters.",
    "All the strings of words1 are unique."
  ],
  "follow_ups": [],
  "hints": [],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    vector<string> wordSubsets(vector<string>& words1, vector<string>& words2) {\n        \n    }\n};",
    "java": "class Solution {\n    public List<String> wordSubsets(String[] words1, String[] words2) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def wordSubsets(self, words1, words2):\n        \"\"\"\n        :type words1: List[str]\n        :type words2: List[str]\n        :rtype: List[str]\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def wordSubsets(self, words1: List[str], words2: List[str]) -> List[str]:\n        ",
    "c": "/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nchar** wordSubsets(char** words1, int words1Size, char** words2, int words2Size, int* returnSize) {\n    \n}",
    "csharp": "public class Solution {\n    public IList<string> WordSubsets(string[] words1, string[] words2) {\n        \n    }\n}",
    "javascript": "/**\n * @param {string[]} words1\n * @param {string[]} words2\n * @return {string[]}\n */\nvar wordSubsets = function(words1, words2) {\n    \n};",
    "typescript": "function wordSubsets(words1: string[], words2: string[]): string[] {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param String[] $words1\n     * @param String[] $words2\n     * @return String[]\n     */\n    function wordSubsets($words1, $words2) {\n        \n    }\n}",
    "swift": "class Solution {\n    func wordSubsets(_ words1: [String], _ words2: [String]) -> [String] {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun wordSubsets(words1: Array<String>, words2: Array<String>): List<String> {\n        \n    }\n}",
    "dart": "class Solution {\n  List<String> wordSubsets(List<String> words1, List<String> words2) {\n    \n  }\n}",
    "golang": "func wordSubsets(words1 []string, words2 []string) []string {\n    \n}",
    "ruby": "# @param {String[]} words1\n# @param {String[]} words2\n# @return {String[]}\ndef word_subsets(words1, words2)\n    \nend",
    "scala": "object Solution {\n    def wordSubsets(words1: Array[String], words2: Array[String]): List[String] = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn word_subsets(words1: Vec<String>, words2: Vec<String>) -> Vec<String> {\n        \n    }\n}",
    "racket": "(define/contract (word-subsets words1 words2)\n  (-> (listof string?) (listof string?) (listof string?))\n  )",
    "erlang": "-spec word_subsets(Words1 :: [unicode:unicode_binary()], Words2 :: [unicode:unicode_binary()]) -> [unicode:unicode_binary()].\nword_subsets(Words1, Words2) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec word_subsets(words1 :: [String.t], words2 :: [String.t]) :: [String.t]\n  def word_subsets(words1, words2) do\n    \n  end\nend"
  },
  "solution": "[TOC]\n\n## Solution\n\n---\n\n### Approach: Reduce to Single Word in B\n\n#### Intuition  \n\nIf `b` is a subset of `a`, then say `a` is a superset of `b`.  Also, say $$N_{\\text{\"a\"}}(\\text{word})$$ is the count of the number of $$\\text{\"a\"}$$'s in the word.\n\nWhen we check whether a word `wordA` in `words1` is a superset of `wordB`, we are individually checking the counts of letters: that for each $$\\text{letter}$$, we have $$N_{\\text{letter}}(\\text{wordA}) \\geq N_{\\text{letter}}(\\text{wordB})$$.\n\nNow, if we check whether a word `wordA` is a superset of all words $$\\text{wordB}_i$$, we will check for each letter and each $$i$$, that $$N_{\\text{letter}}(\\text{wordA}) \\geq N_{\\text{letter}}(\\text{wordB}_i)$$.  This is the same as checking $$N_{\\text{letter}}(\\text{wordA}) \\geq \\max\\limits_i(N_{\\text{letter}}(\\text{wordB}_i))$$.\n\nFor example, when checking whether `\"warrior\"` is a superset of words `B = [\"wrr\", \"wa\", \"or\"]`,  we can combine these words in `B` to form a \"maximum\" word `\"arrow\"`, that has the maximum count of every letter in each word in `B`.\n\n#### Algorithm\n\n- Define a helper function `count(S)`:\n  - Create an integer array `ans` of size 26 to store the frequency of each character in string `S`.\n  - Iterate through each character `c` in `S`:\n    - Increment the corresponding index in `ans` based on `c - 'a'`.\n  - Return the `ans` array.\n\n- Initialize an integer array `bmax` of size 26 to store the maximum frequency of each character across all strings in `words2`.\n- Iterate through each string `b` in array `words2`:\n  - Compute the character frequencies of `b` using the `count` function, storing the result in `bCount`.\n  - For each character (index `i` from 0 to 25), update `bmax[i]` as the maximum of its current value and `bCount[i]`.\n\n- Initialize an empty list `ans` to store the result.\n\n- Iterate through each string `a` in array `words1`:\n  - Compute the character frequencies of `a` using the `count` function, storing the result in `aCount`.\n  - For each character (index `i` from 0 to 25):\n    - If `aCount[i]` is less than `bmax[i]`, skip to the next string in `A`.\n  - If all frequency conditions are satisfied, add `a` to the `ans` list.\n\n- Return the list `ans`, which contains all universal strings from `words1`.\n\n#### Implementation#### Complexity Analysis\n\nLet $\\mathcal{A}$ and $\\mathcal{B}$ represent the total information in `words1` and `words2`, respectively.\n\n- Time Complexity: $O(\\mathcal{A} + \\mathcal{B})$\n\n    This accounts for processing all elements or data points in both inputs.\n\n- Space Complexity: $O(1)$ or $O(A\\text{.length})$\n\n    Without considering the output space, the space complexity is $O(1)$, as no additional data structures are used. Including the output space, the complexity is $O(A\\text{.length})$, since the output depends solely on `words1`.  \n\n---"
}