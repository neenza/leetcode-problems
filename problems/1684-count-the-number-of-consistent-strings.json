{
  "title": "Count the Number of Consistent Strings",
  "problem_id": "1786",
  "frontend_id": "1684",
  "difficulty": "Easy",
  "problem_slug": "count-the-number-of-consistent-strings",
  "topics": [
    "Array",
    "Hash Table",
    "String",
    "Bit Manipulation",
    "Counting"
  ],
  "description": "You are given a string allowed consisting of distinct characters and an array of strings words. A string is consistent if all characters in the string appear in the string allowed.\nReturn the number of consistent strings in the array words.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: allowed = \"ab\", words = [\"ad\",\"bd\",\"aaab\",\"baa\",\"badab\"]\nOutput: 2\nExplanation: Strings \"aaab\" and \"baa\" are consistent since they only contain characters 'a' and 'b'.",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input: allowed = \"abc\", words = [\"a\",\"b\",\"c\",\"ab\",\"ac\",\"bc\",\"abc\"]\nOutput: 7\nExplanation: All strings are consistent.",
      "images": []
    },
    {
      "example_num": 3,
      "example_text": "Input: allowed = \"cad\", words = [\"cc\",\"acd\",\"b\",\"ba\",\"bac\",\"bad\",\"ac\",\"d\"]\nOutput: 4\nExplanation: Strings \"cc\", \"acd\", \"ac\", and \"d\" are consistent.",
      "images": []
    }
  ],
  "constraints": [
    "1 <= words.length <= 104",
    "1 <= allowed.length <= 26",
    "1 <= words[i].length <= 10",
    "The characters in allowed are distinct.",
    "words[i] and allowed contain only lowercase English letters."
  ],
  "follow_ups": [],
  "hints": [
    "A string is incorrect if it contains a character that is not allowed",
    "Constraints are small enough for brute force"
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    int countConsistentStrings(string allowed, vector<string>& words) {\n        \n    }\n};",
    "java": "class Solution {\n    public int countConsistentStrings(String allowed, String[] words) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def countConsistentStrings(self, allowed, words):\n        \"\"\"\n        :type allowed: str\n        :type words: List[str]\n        :rtype: int\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def countConsistentStrings(self, allowed: str, words: List[str]) -> int:\n        ",
    "c": "\n\nint countConsistentStrings(char * allowed, char ** words, int wordsSize){\n\n}",
    "csharp": "public class Solution {\n    public int CountConsistentStrings(string allowed, string[] words) {\n        \n    }\n}",
    "javascript": "/**\n * @param {string} allowed\n * @param {string[]} words\n * @return {number}\n */\nvar countConsistentStrings = function(allowed, words) {\n    \n};",
    "typescript": "function countConsistentStrings(allowed: string, words: string[]): number {\n\n};",
    "php": "class Solution {\n\n    /**\n     * @param String $allowed\n     * @param String[] $words\n     * @return Integer\n     */\n    function countConsistentStrings($allowed, $words) {\n        \n    }\n}",
    "swift": "class Solution {\n    func countConsistentStrings(_ allowed: String, _ words: [String]) -> Int {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun countConsistentStrings(allowed: String, words: Array<String>): Int {\n        \n    }\n}",
    "golang": "func countConsistentStrings(allowed string, words []string) int {\n    \n}",
    "ruby": "# @param {String} allowed\n# @param {String[]} words\n# @return {Integer}\ndef count_consistent_strings(allowed, words)\n    \nend",
    "scala": "object Solution {\n    def countConsistentStrings(allowed: String, words: Array[String]): Int = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn count_consistent_strings(allowed: String, words: Vec<String>) -> i32 {\n        \n    }\n}"
  },
  "solution": "[TOC]\n\n## Solution\n\n---\n\n### Approach 1: Brute Force\n\n#### Intuition\n\nWe need to find how many words in the given array contain only characters from the allowed string. To do this, we will go through each word in the array and check if it meets the condition.\n\nWe'll use a counter variable, `consistentCount`, to keep track of how many words meet the condition. For each word, we'll check every character it contains. If all the characters in a word are present in the `allowed` string, we'll count that word as consistent and increase our counter.\n\nAfter checking all the words, we'll return the value of `consistentCount` as the result.\n\n#### Algorithm\n\n- Initialize a variable `consistentCount` to store the number of consistent strings found.\n- Iterate through each `word` in the `words` array:\n  - Initialize a boolean variable `isWordConsistent` to `true`.\n  - Start an inner loop to iterate through each character in the current `word`:\n    - Set a boolean variable `isCharAllowed` to `false`, assuming the character is not allowed until found in the `allowed` string.\n    - Start another inner loop to iterate through each character in `allowed`:\n      - Compare the current character from the word with each character in `allowed`.\n      - If a match is found, set `isCharAllowed` to `true` and break out of the inner loop.\n    - If `isCharAllowed` is still `false`, set `isWordConsistent` to `false` and break out of the character checking loop.\n  - If `isWordConsistent` is `true`, increment `consistentCount` by 1.\n- Return the final value of `consistentCount` as the result.\n\n#### Implementation#### Complexity Analysis\n\nLet $m$ and $n$ be the lengths of `allowed` and `words`, respectively. \n\n- Time complexity: $O(m \\cdot n \\cdot k)$\n\n    The outermost loop iterates through each word in the `words` array, which has $n$ elements. This contributes $O(n)$ to our time complexity.\n\n    For each word, the algorithm iterates through its characters. If we denote the length of the longest word as $k$, this inner loop has a complexity of $O(k)$.\n\n    For each character in a word, in the worst case, we may need to search through the entire allowed string, taking $O(m)$ time.\n\n    Thus, the overall time complexity of the algorithm is $O(m \\cdot n \\cdot k)$.\n\n- Space complexity: $O(1)$\n\n    The algorithm does not use any data structures that scale with input space. Thus, the space complexity is constant.\n\n---\n\n### Approach 2: Boolean Array\n\n#### Intuition\n\nTo solve this problem efficiently, we need a better way to check if a string is consistent. The brute-force approach was slow because we kept checking each character against the `allowed` string. We need a faster method.\n\nThe key idea is to use a boolean array to mark which characters are allowed. Since we're only dealing with lowercase English letters, we need an array of size 26. Each index in the array will correspond to a character based on its ASCII value.\n\nEach character has an integer representation called its ASCII value. For example, `a` has an ASCII value of 97, `b` is 98, and so on until `z`, which is 122. We can map each character to an index from 0 to 25 by subtracting the ASCII value of `a` from the character's ASCII value. For example, `c` maps to index 2 because the difference between the ASCII values of `c` (99) and `a` (97) is 2.\n\nWith this setup, we can loop through each character in every word and check in constant time whether that character is allowed. If any character's index in our boolean array is `false`, the word isn't consistent. If all characters are marked `true`, we increase our counter of consistent words.\n\n#### Algorithm\n\n- Initialize a boolean array `isAllowed` of size `26` to store which characters are allowed.\n- Iterate through each character in the `allowed` string:\n  - Mark the corresponding index in `isAllowed` as `true`.\n- Initialize a variable `consistentCount` to store the number of consistent strings.\n- Iterate through each `word` in the `words` array:\n  - Set a boolean variable `isConsistent` to `true`.\n  - Iterate through each character in `word`:\n    - Check if the current character is allowed by accessing the corresponding index in `isAllowed`:\n      - If not allowed, set `isConsistent` to `false` and break the inner loop.\n  - If `isConsistent` is `true`, increment `consistentCount`.\n- Return the final value of `consistentCount` as the result.\n  \n#### Implementation#### Complexity Analysis\n\nLet $m$ and $n$ be the lengths of `allowed` and `words`, respectively. \n\n- Time complexity: $O(m + n \\cdot k)$\n\n    The algorithm iterates over each character in `allowed` to mark it as `true`, which takes $O(m)$ time.\n\n    The algorithm then iterates through each character of each word in the `words` array. If $k$ is the length of the longest word, the overall time complexity of this portion is $O(n \\cdot k)$.\n\n    Thus, the time complexity of the algorithm is $O(m) + O(n \\cdot k) = O(m + n \\cdot k)$.\n\n- Space complexity: $O(1)$\n\n    The only additional space used by the algorithm is the `isAllowed` array, which has a constant length of $26$. \n\n---\n\n### Approach 3: Hash Set\n\n#### Intuition\n\nAn alternative data structure that allows us to quickly check whether a given element exists or not is a hash set.  If you're new to hash sets, this LeetCode [Explore Card](https://leetcode.com/explore/learn/card/hash-table/183/combination-with-other-algorithms/1130/) provides a detailed explanation.\n\nWe'll start by creating a hash set called `allowedChars` and fill it with characters from the `allowed` string. This set will act as our lookup table for permitted characters. A key benefit of using a set over a boolean array is its flexibility: a boolean array always has 26 slots, even if `allowed` has fewer characters. A set, on the other hand, adjusts to only use the space it needs.\n\nNext, we loop through each word in `words`. For each word, we'll check each character to see if it's in the set. If every character of the word is present, we increment our counter.\n\n#### Algorithm\n \n- Initialize a set `allowedChars` to store the allowed characters.\n- Iterate through each character in the `allowed` string and add it to `allowedChars`.\n- Initialize a variable `consistentCount` to store the number of consistent strings.\n- Iterate through each `word` in the `words` array:\n  - Set a boolean variable `isConsistent` to `true`.\n  - Iterate through each character in `word`:\n    - Check if the current character is contained in `allowedChars`:\n      - If not, set `isConsistent` to `false` and break the inner loop.\n  - If `isConsistent` is `true`, increment `consistentCount`.\n- Return `consistentCount` as our answer.\n\n#### Implementation#### Complexity Analysis\n\nLet $m$ and $n$ be the lengths of `allowed` and `words`, respectively. \n\n* Time complexity: $O(m + n \\cdot k)$\n\n    The algorithm loops over `allowed` to populate the `allowedChars` set, taking $O(m)$ time.\n\n    The algorithm then iterates over each character of each word in the `words` array. If the $k$ is the length of the longest word, this takes $O(n \\cdot k)$ time.\n\n    Thus, the overall time complexity of the algorithm is $O(m) + O(n \\cdot k) = O(m + n \\cdot k)$.\n\n* Space complexity: $O(m)$\n\n    The `allowedChars` set can have a size of $m$ in the worst case (all characters in `allowed` are unique). All other variables take constant space.\n\n    Thus, the space complexity of the algorithm is $O(m)$.\n\n---\n\n### Approach 4: Bit Manipulation\n\n#### Intuition\n\nIn a binary number, each bit can be `0` or `1`. A boolean variable can be either `true` or `false`. The pattern is clear: each bit in a binary number can represent a boolean value. We can use this to show whether a character is in `allowed`. This representation is called a bitmask, which will work like the boolean array in the second approach, where each index stands for a character from `a` to `z`.\n\nSince there are only 26 possible characters, a 32-bit integer will be enough for our bitmask. We need to perform two main operations with this bitmask:\n\n1. Setting a bit: Each bit will show whether a character from `a` to `z` is present (`1`) or not (`0`). As in the second approach, the 0th bit will represent `a`, the 1st bit will represent `b`, and so on. To mark the presence of a character, we'll set the corresponding bit to `1`. To set a bit, we use Bitwise OR with `1` shifted left by that bit's position. For example, to set the 2nd bit in the binary number `1000010`, we use Bitwise OR with `1` shifted left by `2`. Here’s the pseudo-code for setting a bit for a character:\n\n```\nIf c is the character to be marked:\nmask = mask | (1 << (c - 'a'))\n```\n\n![](../Figures/1684/set.png)\n\n2. Checking a bit: To see if a character is in `allowed`, we check the corresponding bit in the bitmask. We can isolate the bit by right-shifting the bitmask by the bit's position and then using Bitwise AND with `1`. If the result is `1`, the character is in `allowed`. For example, to check if the 2nd bit in `1000110` is set, we right-shift by `2` and use Bitwise AND with `1`. This gives us `1`, so the bit is set. Here’s the pseudo-code for this check:\n\n```\nIf c is the character to be checked:\nbit = (mask >> (c - 'a')) & 1\n```\n\n![](../Figures/1684/check.png)\n\nUsing these methods, we can check each character in a word to see if the word is consistent.\n\n#### Algorithm\n\n- Initialize a variable `allowedBits` to store the bitmask of allowed characters.\n- Iterate through each character in the `allowed` string:\n  - Set the corresponding bit in `allowedBits` for each character.\n- Initialize a variable `consistentCount` to store the number of consistent strings.\n- Iterate through each `word` in the `words` array:\n  - Initialize a boolean variable `isConsistent` as `true`.\n  - Iterate through each character in `word`:\n    - Find the `bit` corresponding to the character in `allowedBits`.\n    - If the bit is `0`: \n      - Set `isConsistent` to `false` and break the inner loop.\n  - If `isConsistent` is `true`, increment `consistentCount`.\n- Return the final value of `consistentCount` as the result. \n\n#### Implementation#### Complexity Analysis\n\nLet $m$ and $n$ be the lengths of `allowed` and `words`, respectively. \n\n- Time complexity: $O(m + n \\cdot k)$\n\n    Setting each bit for the characters in `allowed` takes $O(m)$ time.\n\n    If $k$ is the length of the longest word, iterating through each character in each word of the `words` array takes $O(n \\cdot k)$ time.\n\n    Thus, the overall time complexity of the algorithm is $O(m) + O(n \\cdot k) = O(m + n \\cdot k)$.\n\n- Space complexity: $O(1)$\n\n    All variables used by the algorithm take constant space.  \n\n---"
}