{
  "title": "Number of Students Unable to Eat Lunch",
  "problem_id": "1802",
  "frontend_id": "1700",
  "difficulty": "Easy",
  "problem_slug": "number-of-students-unable-to-eat-lunch",
  "topics": [
    "Array",
    "Stack",
    "Queue",
    "Simulation"
  ],
  "description": "The school cafeteria offers circular and square sandwiches at lunch break, referred to by numbers 0 and 1 respectively. All students stand in a queue. Each student either prefers square or circular sandwiches.\nThe number of sandwiches in the cafeteria is equal to the number of students. The sandwiches are placed in a stack. At each step:\nThis continues until none of the queue students want to take the top sandwich and are thus unable to eat.\nYou are given two integer arrays students and sandwiches where sandwiches[i] is the type of the i​​​​​​th sandwich in the stack (i = 0 is the top of the stack) and students[j] is the preference of the j​​​​​​th student in the initial queue (j = 0 is the front of the queue). Return the number of students that are unable to eat.\nExample 1:\nExample 2:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: students = [1,1,0,0], sandwiches = [0,1,0,1]\nOutput: 0 \nExplanation:\n- Front student leaves the top sandwich and returns to the end of the line making students = [1,0,0,1].\n- Front student leaves the top sandwich and returns to the end of the line making students = [0,0,1,1].\n- Front student takes the top sandwich and leaves the line making students = [0,1,1] and sandwiches = [1,0,1].\n- Front student leaves the top sandwich and returns to the end of the line making students = [1,1,0].\n- Front student takes the top sandwich and leaves the line making students = [1,0] and sandwiches = [0,1].\n- Front student leaves the top sandwich and returns to the end of the line making students = [0,1].\n- Front student takes the top sandwich and leaves the line making students = [1] and sandwiches = [1].\n- Front student takes the top sandwich and leaves the line making students = [] and sandwiches = [].\nHence all students are able to eat.",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input: students = [1,1,1,0,0,1], sandwiches = [1,0,0,0,1,1]\nOutput: 3",
      "images": []
    }
  ],
  "constraints": [
    "1 <= students.length, sandwiches.length <= 100",
    "students.length == sandwiches.length",
    "sandwiches[i] is 0 or 1.",
    "students[i] is 0 or 1."
  ],
  "follow_ups": [],
  "hints": [
    "Simulate the given in the statement",
    "Calculate those who will eat instead of those who will not."
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    int countStudents(vector<int>& students, vector<int>& sandwiches) {\n        \n    }\n};",
    "java": "class Solution {\n    public int countStudents(int[] students, int[] sandwiches) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def countStudents(self, students, sandwiches):\n        \"\"\"\n        :type students: List[int]\n        :type sandwiches: List[int]\n        :rtype: int\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def countStudents(self, students: List[int], sandwiches: List[int]) -> int:\n        ",
    "c": "int countStudents(int* students, int studentsSize, int* sandwiches, int sandwichesSize) {\n    \n}",
    "csharp": "public class Solution {\n    public int CountStudents(int[] students, int[] sandwiches) {\n        \n    }\n}",
    "javascript": "/**\n * @param {number[]} students\n * @param {number[]} sandwiches\n * @return {number}\n */\nvar countStudents = function(students, sandwiches) {\n    \n};",
    "typescript": "function countStudents(students: number[], sandwiches: number[]): number {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param Integer[] $students\n     * @param Integer[] $sandwiches\n     * @return Integer\n     */\n    function countStudents($students, $sandwiches) {\n        \n    }\n}",
    "swift": "class Solution {\n    func countStudents(_ students: [Int], _ sandwiches: [Int]) -> Int {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun countStudents(students: IntArray, sandwiches: IntArray): Int {\n        \n    }\n}",
    "dart": "class Solution {\n  int countStudents(List<int> students, List<int> sandwiches) {\n    \n  }\n}",
    "golang": "func countStudents(students []int, sandwiches []int) int {\n    \n}",
    "ruby": "# @param {Integer[]} students\n# @param {Integer[]} sandwiches\n# @return {Integer}\ndef count_students(students, sandwiches)\n    \nend",
    "scala": "object Solution {\n    def countStudents(students: Array[Int], sandwiches: Array[Int]): Int = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn count_students(students: Vec<i32>, sandwiches: Vec<i32>) -> i32 {\n        \n    }\n}",
    "racket": "(define/contract (count-students students sandwiches)\n  (-> (listof exact-integer?) (listof exact-integer?) exact-integer?)\n  )",
    "erlang": "-spec count_students(Students :: [integer()], Sandwiches :: [integer()]) -> integer().\ncount_students(Students, Sandwiches) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec count_students(students :: [integer], sandwiches :: [integer]) :: integer\n  def count_students(students, sandwiches) do\n    \n  end\nend"
  },
  "solution": "[TOC]\n\n## Solution\n\n---\n\n### Overview\n\nWe need to find the number of students who are unable to eat lunch at the school cafeteria.\n\nWe are given an array `sandwiches` that represents a stack of sandwiches, where `sandwiches[0]` is the sandwich at the top of the stack.\n\n- Circular sandwiches are represented with a `0`.\n- Square sandwiches are represented with a `1`.\n\nWe are also given an array `students` which represents a queue of students in line at the cafeteria, where `students[0]` is the first student in the queue.\n\n- Students who prefer circular sandwiches are represented with a `0`.\n- Students who prefer square sandwiches are represented with a `1`.\n\nLunch proceeds with the following process:\n\nThe first student takes the top sandwich if it matches their preference and leaves the queue, otherwise, they go to the back of the queue. This repeats until none of the students in the queue want to take the top sandwich.\n\nAfter this, we return the number of students who are unable to eat, which will be the number of students remaining in the queue.\n\n**Key Observations:**\n- The number of students and the number of sandwiches are the same.\n- We cannot change the order of the sandwiches.\n- The only ways we can modify the order of the students is by giving them sandwiches, which removes them from the queue, or sending them to the back of the queue.\n\n---\n\n### Approach 1: Simulation Using Queue and Stack\n\n#### Intuition\n\nWe can simulate the lunch process by using a queue of students and a stack of sandwiches.\n\nWhile there are unserved students in the queue, we check if the sandwich at the top of the sandwich stack meets the front student in the queue's preference. If so, we remove the sandwich from the stack and remove the student from the queue. Otherwise, we move the student to the back of the queue.\n\n**How do we know when none of the students in the queue want to take the top sandwich?**\n\nWe can keep track of when we last served a student using the variable `lastServed`. If we are unable to serve a student, we increment `lastServed`. When we do serve a student, we reset `lastServed` to zero. When `lastServed` reaches the same size as the queue, we know we have offered the top sandwich to every student in the queue, so we stop the lunch process.\n\nAfter serving all the sandwiches we can, the remaining students in the queue are the unserved students.\n\n#### Algorithm\n\n1. Initialize a variable `len` to the length of `students`. `sandwiches` will be the same length.\n\n2. Initialize a queue `studentQueue` for storing the students and a stack `sandwichStack` for storing the sandwiches.\n\n3. Add the students and sandwiches to the queue and stack:\n\n    - Use a `for` loop to iterate from `i = 0` to `len`:\n        - Add the next student, `student[i]`, to the back of `studentQueue`.\n        - Add the next sandwich, `sandwich[len - i - 1]`, to the top of `sandwichStack`, which will build the stack so it is in the same order as the given `sandwiches`.\n\n4. Initialize a variable `lastServed` to `0` to store how many students ago the most recent sandwich was served.\n\n5. Simulate the lunch process by serving sandwiches and sending students to the back of the queue.\n\n    - While the size of `studentQueue` is greater than `0` and greater than `lastServed`:\n        - If the first student in the queue's preference matches the top sandwich in the stack, remove the student from the queue and the sandwich from the stack, and reset `lastServed` to `0`.\n        - Otherwise, move the first student to the back of the queue and increment `lastServed` by `1`.\n\n6. Return the number of remaining students in the queue.\n\nThe algorithm is visualized below:\n\n!?!../Documents/1700/1700slideshow1.json:960,540!?!\n\n#### Implementation#### Complexity Analysis\n\nLet $n$ be the length of `students` and $m$ be the length of `sandwiches`. Note that $n$ and $m$ are equal.\n\n* Time complexity: $O(n \\cdot m)$\n\n    Populating `studentQueue` and `sandwichStack` takes $O(n)$. \n\n    In the worst case, each student may go through the queue up to $m$ times, being offered the wrong sandwich type each time. Therefore, the time complexity is $O(n \\cdot m)$.\n\n    Therefore, the overall time complexity is $O(n \\cdot m)$.\n\n* Space complexity: $O(n + m)$\n\n    The main space we use is for `studentQueue` which is size $n$ and `sandwichStack` which is size $m$ so the space complexity is $O(n + m)$.\n\n---\n\n### Approach 2: Counting\n\n#### Intuition\n\nThere are two main cases:\n\n1. Every student in the queue receives a sandwich, so the number of students unable to eat is `0`.\n\n> Input: students = [1,1,0,0], sandwiches = [0,1,0,1]\n> Output: 0\n\n2. None of the remaining students in the queue want the top sandwich, so they are unable to eat lunch.\n\n> Input: students = [1,1,1,0,0,1], sandwiches = [1,0,0,0,1,1]\n> Output: 3\n> After the lunch process, students = [1,1,1] and sandwiches = [0,1,1]\n\n***Key Observation:** If none of the students in the queue's preference matches the top sandwich, none of the remaining students can eat.*\n\nWe can utilize this observation to develop a constant space solution.\n\nFirst, we count the number of students who prefer circle sandwiches and the number of students who prefer square sandwiches.\n\nThen, we iterate through the available sandwiches in the stack. If the top sandwich is a circle sandwich, we serve it to a student who prefers circle sandwiches by decrementing the number of students who prefer circle sandwiches. If the top sandwich is square, we serve it to a student who prefers square sandwiches by decrementing the number of students who prefer square sandwiches. \n\nIf the number of students who prefer a certain type of sandwich becomes zero, and the sandwich at the top of the stack is that same type of sandwich, none of the remaining students want that sandwich. We return the number of unserved students, which is the count of the students who prefer the other type of sandwich.\n\n#### Algorithm\n\n1. Initialize `circleStudentCount` and `squareStudentCount` to `0`.\n\n2. Iterate through the `students` array:\n   - If the current student prefers a circle sandwich (value is `0`), increment `circleStudentCount`.\n   - Otherwise, the current student prefers a square sandwich (value is `1`), increment `squareStudentCount`.\n\n3. Iterate through the `sandwiches` array:\n   - If the current sandwich is a circle sandwich (value is `0`) and there are no students who want circle sandwiches (`circleStudentCount` is `0`), return `squareStudentCount`.\n   - If the current sandwich is square (value is `1`) and there are no students who want square sandwiches (`squareStudentCount` is `0`), return `circleStudentCount`.\n   - If the current sandwich matches a student's preference:\n        - If the current sandwich is a circle sandwich (value is `0`), decrement `circleStudentCount`.\n        - Otherwise, the current sandwich is square (value is `1`), decrement `squareStudentCount`.\n\n4. If the loop completes without returning, it means that all students received a sandwich, return `0`.\n\nThe algorithm is visualized below:\n\n!?!../Documents/1700/1700slideshow2.json:960,540!?!\n\n#### Implementation#### Complexity Analysis\n\nLet $n$ be the length of `students` and $m$ be the length of `sandwiches`.\n\n* Time complexity: $O(n + m)$\n\n    Counting the number of students who prefer each kind of sandwich takes $O(n)$.\n\n    We loop through each sandwich in `sandwiches` to serve the sandwiches, which takes up to $O(m)$.\n\n    Therefore, the overall time complexity is $O(n + m)$.\n\n> **Note:** Since $n$ and $m$ are equal, we could alternatively represent the time complexity as $O(n)$.\n\n* Space complexity: $O(1)$\n\n    We use a couple of variables to count the students who want each type of sandwich, but we don't use any data structures that grow with input size, so the space complexity is constant, i.e. $O(1)$\n\n---"
}