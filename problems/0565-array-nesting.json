{
  "title": "Array Nesting",
  "problem_id": "565",
  "frontend_id": "565",
  "difficulty": "Medium",
  "problem_slug": "array-nesting",
  "topics": [
    "Array",
    "Depth-First Search"
  ],
  "description": "You are given an integer array nums of length n where nums is a permutation of the numbers in the range [0, n - 1].\nYou should build a set s[k] = {nums[k], nums[nums[k]], nums[nums[nums[k]]], ... } subjected to the following rule:\nReturn the longest length of a set s[k].\nExample 1:\nExample 2:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: nums = [5,4,0,3,1,6,2]\nOutput: 4\nExplanation: \nnums[0] = 5, nums[1] = 4, nums[2] = 0, nums[3] = 3, nums[4] = 1, nums[5] = 6, nums[6] = 2.\nOne of the longest sets s[k]:\ns[0] = {nums[0], nums[5], nums[6], nums[2]} = {5, 6, 2, 0}",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input: nums = [0,1,2]\nOutput: 1",
      "images": []
    }
  ],
  "constraints": [
    "1 <= nums.length <= 105",
    "0 <= nums[i] < nums.length",
    "All the values of nums are unique."
  ],
  "follow_ups": [],
  "hints": [],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    int arrayNesting(vector<int>& nums) {\n        \n    }\n};",
    "java": "class Solution {\n    public int arrayNesting(int[] nums) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def arrayNesting(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def arrayNesting(self, nums: List[int]) -> int:\n        ",
    "c": "int arrayNesting(int* nums, int numsSize) {\n    \n}",
    "csharp": "public class Solution {\n    public int ArrayNesting(int[] nums) {\n        \n    }\n}",
    "javascript": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar arrayNesting = function(nums) {\n    \n};",
    "typescript": "function arrayNesting(nums: number[]): number {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @return Integer\n     */\n    function arrayNesting($nums) {\n        \n    }\n}",
    "swift": "class Solution {\n    func arrayNesting(_ nums: [Int]) -> Int {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun arrayNesting(nums: IntArray): Int {\n        \n    }\n}",
    "dart": "class Solution {\n  int arrayNesting(List<int> nums) {\n    \n  }\n}",
    "golang": "func arrayNesting(nums []int) int {\n    \n}",
    "ruby": "# @param {Integer[]} nums\n# @return {Integer}\ndef array_nesting(nums)\n    \nend",
    "scala": "object Solution {\n    def arrayNesting(nums: Array[Int]): Int = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn array_nesting(nums: Vec<i32>) -> i32 {\n        \n    }\n}",
    "racket": "(define/contract (array-nesting nums)\n  (-> (listof exact-integer?) exact-integer?)\n  )",
    "erlang": "-spec array_nesting(Nums :: [integer()]) -> integer().\narray_nesting(Nums) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec array_nesting(nums :: [integer]) :: integer\n  def array_nesting(nums) do\n    \n  end\nend"
  },
  "solution": "[TOC]\n\n## Solution\n\n---\n### Approach #1 Brute Force [Time Limit Exceeded]\n\nThe simplest method is to iterate over all the indices of the given $$nums$$ array. For every index $$i$$ chosen, we find the element $$nums[i]$$ and increment the $$count$$ for a new element added for the current index $$i$$. Since $$nums[i]$$ has to act as the new index for finding the next element belonging to the set corresponding to the index $$i$$, the new index is $$j=nums[i]$$.\n\nWe continue this process of index updation and keep on incrementing the $$count$$ for new elements added to the set corresponding to the index $$i$$. Now, since all the elements in $$nums$$ lie in the range $$(0,..., N-1)$$, the new indices generated will never lie outside the array size limits. But, we'll always reach a point where the current element becomes equal to the element  $$nums[i]$$ with which we started the nestings in the first place. Thus, after this, the new indices generated will be just the repetitions of the previously generated ones, and thus would not lead to an increase in the size of the current set. Thus, this condition of the current number being equal to the starting number acts as the terminating condition for $$count$$ incrementation for a particular index.\n\nWe do the same process for every index chosen as the starting index. At the end, the maximum value of $$count$$ obtained gives the size of the largest set.**Complexity Analysis**\n\n* Time complexity : $$O(n^2)$$. In worst case, for example- `[1,2,3,4,5,0]`, loop body will be executed $$n^2$$ times.\n\n* Space complexity : $$O(1)$$. Constant space is used.\n\n---\n### Approach #2 Using Visited Array [Accepted]\n\n**Algorithm**\n\nIn the last approach, we observed that in the worst case, all the elements of the $$nums$$ array are added to the sets corresponding to all the starting indices. But, all these sets correspond to the same set of elements only, leading to redundant calculations.\n\nWe consider a simple example and see how this problem can be resolved. From the figure below, we can see that the elements in the current nesting shown by arrows form a cycle. Thus, the same elements will be added to the current set irrespective of the first element chosen to be added to the set out of these marked elements.\n\n![Array_Nesting](../Figures/565/Array_Nesting.PNG)\n\nThus, when we add an element $$nums[j]$$ to a set corresponding to any of the indices, we mark its position as visited in a $$visited$$ array. This is done so that whenever this index is chosen as the starting index in the future, we do not go for redundant $$count$$ calculations, since we've already considered the elements linked with this index, which will be added to a new(duplicate) set.\n\nBy doing so, we ensure that the duplicate sets aren't considered again and again.\n\nFurther, we can also observe that no two elements at indices $$i$$ and $$j$$ will lead to a jump to the same index $$k$$, since it would require $$nums[i] = nums[j] = k$$, which isn't possible since all the elements are distinct. Also, because of the same reasoning, no element outside any cycle could lead to an element inside the cycle. Because of this, the use of $$visited$$ array goes correctly.**Complexity Analysis**\n\n* Time complexity : $$O(n)$$. Every element of the $$nums$$ array will be considered at most once.\n\n* Space complexity : $$O(n)$$. $$visited$$ array of size $$n$$ is used.\n\n---\n### Approach #3 Without Using Extra Space [Accepted]\n\n**Algorithm**\n\nIn the last approach, the $$visited$$ array is used just to keep a track of the elements of the array which have already been visited. Instead of making use of a separate array to keep track of the same, we can mark the visited elements in the original array $$nums$$ itself. Since, the range of the elements can only be between 1 to 20,000, we can put a very large integer value `Integer.MAX_VALUE` at the position which has been visited. The rest process of traversals remains the same as in the last approach.**Complexity Analysis**\n\n* Time complexity : $$O(n)$$. Every element of the $$nums$$ array will be considered at most once.\n\n* Space complexity : $$O(1)$$. Constant Space is used."
}