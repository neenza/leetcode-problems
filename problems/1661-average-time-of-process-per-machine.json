{
  "title": "Average Time of Process per Machine",
  "problem_id": "1801",
  "frontend_id": "1661",
  "difficulty": "Easy",
  "problem_slug": "average-time-of-process-per-machine",
  "topics": [
    "Database"
  ],
  "description": "Table: Activity\nThere is a factory website that has several machines each running the same number of processes. Write a solution to find the average time each machine takes to complete a process.\nThe time to complete a process is the 'end' timestamp minus the 'start' timestamp. The average time is calculated by the total time to complete every process on the machine divided by the number of processes that were run.\nThe resulting table should have the machine_id along with the average time as processing_time, which should be rounded to 3 decimal places.\nReturn the result table in any order.\nThe result format is in the following example.\nExample 1:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "+----------------+---------+\n| Column Name    | Type    |\n+----------------+---------+\n| machine_id     | int     |\n| process_id     | int     |\n| activity_type  | enum    |\n| timestamp      | float   |\n+----------------+---------+\nThe table shows the user activities for a factory website.\n(machine_id, process_id, activity_type) is the primary key (combination of columns with unique values) of this table.\nmachine_id is the ID of a machine.\nprocess_id is the ID of a process running on the machine with ID machine_id.\nactivity_type is an ENUM (category) of type ('start', 'end').\ntimestamp is a float representing the current time in seconds.\n'start' means the machine starts the process at the given timestamp and 'end' means the machine ends the process at the given timestamp.\nThe 'start' timestamp will always be before the 'end' timestamp for every (machine_id, process_id) pair.\nIt is guaranteed that each (machine_id, process_id) pair has a 'start' and 'end' timestamp.",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input: \nActivity table:\n+------------+------------+---------------+-----------+\n| machine_id | process_id | activity_type | timestamp |\n+------------+------------+---------------+-----------+\n| 0          | 0          | start         | 0.712     |\n| 0          | 0          | end           | 1.520     |\n| 0          | 1          | start         | 3.140     |\n| 0          | 1          | end           | 4.120     |\n| 1          | 0          | start         | 0.550     |\n| 1          | 0          | end           | 1.550     |\n| 1          | 1          | start         | 0.430     |\n| 1          | 1          | end           | 1.420     |\n| 2          | 0          | start         | 4.100     |\n| 2          | 0          | end           | 4.512     |\n| 2          | 1          | start         | 2.500     |\n| 2          | 1          | end           | 5.000     |\n+------------+------------+---------------+-----------+\nOutput: \n+------------+-----------------+\n| machine_id | processing_time |\n+------------+-----------------+\n| 0          | 0.894           |\n| 1          | 0.995           |\n| 2          | 1.456           |\n+------------+-----------------+\nExplanation: \nThere are 3 machines running 2 processes each.\nMachine 0's average time is ((1.520 - 0.712) + (4.120 - 3.140)) / 2 = 0.894\nMachine 1's average time is ((1.550 - 0.550) + (1.420 - 0.430)) / 2 = 0.995\nMachine 2's average time is ((4.512 - 4.100) + (5.000 - 2.500)) / 2 = 1.456",
      "images": []
    }
  ],
  "constraints": [],
  "follow_ups": [],
  "hints": [],
  "code_snippets": {
    "mysql": "# Write your MySQL query statement below\n",
    "mssql": "/* Write your T-SQL query statement below */\n",
    "oraclesql": "/* Write your PL/SQL query statement below */\n",
    "pythondata": "import pandas as pd\n\ndef get_average_time(activity: pd.DataFrame) -> pd.DataFrame:\n    ",
    "postgresql": "-- Write your PostgreSQL query statement below\n"
  },
  "solution": "​\n[TOC]\n​\n# Solution\n​\n---\n\n​\n\n## pandas\nWe provide two different ways to perform calculations on two sets of data in the same column. One way is to use custom changes to distinguish between the two sets of data. The other way is to split the column into two different columns based on filters. Then we can calculate the aggregate total based on those isolated sets.\n\n\n### Approach 1: Update Values with lambda and then Calculate\n\n#### AlgorithmTo calculate the time to complete a process, we need to know the difference between the 'start' `timestamp` and the 'end' `timestamp` for each machine and process. If we set all the 'start' `timestamp` to its negative value, we can get the time difference by using `SUM()`, since `(-start) + end` is equal to `end - start`, which is the time difference. \n\nWe use [`apply()`](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.apply.html) and `lambda` to transform the `timestamp` for all rows that have an `activity_type` equals to 'start'. To convert the `timestamp` to negative, we have the `timestamp` multiplied by -1. We pass the parameter 'axis=1' so the calculation will be applied across rows.  \n\n```python\nactivity['timestamp'] = activity.apply(lambda x: x.timestamp * -1 if x.activity_type == 'start' else x.timestamp, axis=1)\n```\n\nNow we have an updated DataFrame with all start `timestamp`  set to negative. \n\n| machine_id | process_id | activity_type | timestamp |\n| ---------- | ---------- | ------------- | --------- |\n| 0          | 0          | start         | -0.712    |\n| 0          | 0          | end           | 1.52      |\n| 0          | 1          | start         | -3.14     |\n| 0          | 1          | end           | 4.12      |\n\n\nWith this updated DataFrame, we can now calculate the time to complete a process for each machine and process by adding the start `timestamp` and the end `timestamp`: \n\n```python\nsum_machine_process = activity.groupby(['machine_id', 'process_id'], as_index=False)['timestamp'].sum()\n```\n\n| machine_id | process_id | timestamp |\n| ---------- | ---------- | --------- |\n| 0          | 0          | 0.808     |\n| 0          | 1          | 0.98      |\n| 1          | 0          | 1         |\n| 1          | 1          | 0.99      |\n| 2          | 0          | 0.412     |\n| 2          | 1          | 2.5       |\n\nSince we want the average processing time by each machine, that has more than one process, we then calculate the aggregate average for each machine with the same method: \n\n```python\nmean_machine = sum_machine_process.groupby(['machine_id'], as_index=False)['timestamp'].mean()\n```\n\nLastly, we want to round this final calculation to 3 decimal places and rename the column name as requested. We can add the functions `round` and `rename` directly to the code from the previous step: \n\n```python\nmean_machine = sum_machine_process.groupby(['machine_id'], as_index=False)['timestamp'].mean().round(3).rename(columns = {'timestamp': 'processing_time'})\n```\n\n\n#### Final Code---\n\n\n### Approach 2: Split One Column Into Two and then Calculate \n\n\n#### Algorithm\n\n\nIn this approach, we split the original column into two separate ones and then calculate the aggregate values using these two columns. \n\nFor this problem, we create two separate `timestamp` columns by splitting the original DataFrame by the values in the column `activity_type`: \n\n```python\n#this DataFrame contains all the records with the start timestamp\nstart_df = activity[activity['activity_type'] == 'start']\n#this DataFrame contains all the records with end timestamp\nend_df = activity[activity['activity_type'] == 'end']\n```\n\nWe then merge the two newly created DataFrames on the two shared columns `machine_id` and `process_id` for the later calculation. \n\n```python\nmerge_df = end_df.merge(start_df, on = ['machine_id', 'process_id'])\n```\n\nNow we have a DataFrame that contains the start `timestamp` and end `timestamp` for each machine and process in two different columns. Notice we have the `end_df` join the `start_df`, so the `activity_type_x` and `timestamp_x` are the values from `end_df`. \n\n| machine_id | process_id | activity_type_x | timestamp_x | activity_type_y | timestamp_y |\n| ---------- | ---------- | --------------- | ----------- | --------------- | ----------- |\n| 0          | 0          | end             | 1.52        | start           | 0.712       |\n| 0          | 1          | end             | 4.12        | start           | 3.14        |\n| 1          | 0          | end             | 1.55        | start           | 0.55        |\n​\n\nNow we can calculate the time to complete a process. We use the function [`assign()`](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.assign.html) to minus start `timestamp` (`timestamp_y`) from the end `timestamp` (`timestamp_x`) and store the calculated value in a new column `processing_time`. \n\n```python\ndf = merge_df.assign(processing_time = merge_df['timestamp_x'] - merge_df['timestamp_y'])\n```\nBelow is the output. A new column, `processing_time` has been added to the original DataFrame (`merge_df`). \n\n| machine_id | process_id | activity_type_x | timestamp_x | activity_type_y | timestamp_y | processing_time |\n| ---------- | ---------- | --------------- | ----------- | --------------- | ----------- | --------------- |\n| 0          | 0          | end             | 1.52        | start           | 0.712       | 0.808           |\n| 0          | 1          | end             | 4.12        | start           | 3.14        | 0.98            |\n| 1          | 0          | end             | 1.55        | start           | 0.55        | 1               |\n| 1          | 1          | end             | 1.42        | start           | 0.43        | 0.99            |\n| 2          | 0          | end             | 4.512       | start           | 4.1         | 0.412           |\n| 2          | 1          | end             | 5           | start           | 2.5         | 2.5             |\n\nWith the newly created `processing_time`, we can calculate the average processing time for each `machine_id` using `groupby()`. The calculation can be added to the previous step:\n\n```python\n df = merge_df.assign(processing_time = merge_df['timestamp_x'] - merge_df['timestamp_y']).groupby(['machine_id'])['processing_time'].mean()\n```\n\nLast but not least, we want to make sure the calculated value is rounded to 3 decimal places by using `round()`. Again, we can add this function to the previous step: \n\n```python\ndf = merge_df.assign(processing_time = merge_df['timestamp_x'] - merge_df['timestamp_y']).groupby(['machine_id'], as_index=False)['processing_time'].mean().round(3)\n```\n\n\n#### Implementation---\n\n\n## Database\n\n\n### Approach 1: Transform Values with CASE WHEN and then Calculate\n\n\n#### Algorithm\n\n\nTo calculate the time to complete a process, we need to know the difference between the 'start' `timestamp` and the 'end' `timestamp` for each machine and process. If we set all the 'start' `timestamp` to its negative value, we can get the time difference by using `SUM()`, since `(-start) + end` is equal to `end - start`, which is the time difference. \n\nTo do this, we use `CASE WHEN` to multiply all the start `timestamp` by -1, so the aggregated total of `timestamp` becomes the time to complete a process for each machine. \n\n```sql\nSUM(CASE WHEN activity_type = 'start' THEN timestamp*-1 ELSE timestamp END)\n```\n\nSince we need the average by each `machine_id` and there might be multiple processes for each machine, we manually calculate the average by having the processing time divided by the number of processes. Luckily, for this question, all machines have the same number of processes.\n\n```sql\nSUM(CASE WHEN activity_type='start' THEN timestamp*-1 ELSE timestamp END)*1.0/(SELECT COUNT(DISTINCT process_id))\n```\n\nLastly, we round the `processing_time` to 3 decimal places by using the function `ROUND()` and rename the column name. \n\n```sql\nROUND(SUM(CASE WHEN activity_type='start' THEN timestamp*-1 ELSE timestamp END)*1.0/(SELECT COUNT(DISTINCT process_id)),3) AS processing_time\n```\n\n\n#### Implementation\n\n```sql\nSELECT \n    machine_id,\n    ROUND(SUM(CASE WHEN activity_type='start' THEN timestamp*-1 ELSE timestamp END)*1.0\n    / (SELECT COUNT(DISTINCT process_id)),3) AS processing_time\nFROM \n    Activity\nGROUP BY machine_id\n```\n​\n\n### Approach 2: Calling the original Table twice and Calculate as two columns\n\n\n#### Algorithm\n\n\nFor this approach, we are calling the original table twice, once as the table that stores the start `timestamps` and once as the table that stores the end `timestamps`. To create the table alias, we give the original table `Activity` two different names, and filter each table by the `activity_type`. We also make sure the two tables are joined on the `machine_id` and `process_id`, so the output will have the start `timestamp` and end `timestamp` stored in two different columns for each machine and process. \n\n```sql\nSELECT *\nFROM Activity a, \n     Activity b\nWHERE \n    a.machine_id = b.machine_id\nAND \n    a.process_id = b.process_id\nAND \n    a.activity_type = 'start'\nAND \n    b.activity_type = 'end'\n```\n\nThe output looks like this: \n\n| machine_id | process_id | activity_type | timestamp | machine_id | process_id | activity_type | timestamp |\n| ---------- | ---------- | ------------- | --------- | ---------- | ---------- | ------------- | --------- |\n| 0          | 0          | start         | 0.712     | 0          | 0          | end           | 1.52      |\n| 0          | 1          | start         | 3.14      | 0          | 1          | end           | 4.12      |\n| 1          | 0          | start         | 0.55      | 1          | 0          | end           | 1.55      |\n| 1          | 1          | start         | 0.43      | 1          | 1          | end           | 1.42      |\n| 2          | 0          | start         | 4.1       | 2          | 0          | end           | 4.512     |\n| 2          | 1          | start         | 2.5       | 2          | 1          | end           | 5         |\n\nWith this table, we can update the calculation for `processing_time` by having all the timestamps from table b (end `timestamp`) to subtract all the `timestamp` in table a (start `timestamp`):\n\n```sql\nSELECT (b.timestamp - a.timestamp) AS processing_time\n```\n\nSince we want the average `processing_time` at the `machine_id` level, we add AVG() to the `processing_time` calculation and round it to 3 decimal places using the function `ROUND()`. \n\n```sql\nSELECT a.machine_id, \n       ROUND(AVG(b.timestamp - a.timestamp), 3) AS processing_time\n```\n\n\n#### Implementation\n\n```sql\nSELECT a.machine_id, \n       ROUND(AVG(b.timestamp - a.timestamp), 3) AS processing_time\nFROM Activity a, \n     Activity b\nWHERE \n    a.machine_id = b.machine_id\nAND \n    a.process_id = b.process_id\nAND \n    a.activity_type = 'start'\nAND \n    b.activity_type = 'end'\nGROUP BY machine_id\n```\n​\n---"
}