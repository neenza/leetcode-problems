{
  "title": "Find K Pairs with Smallest Sums",
  "problem_id": "373",
  "frontend_id": "373",
  "difficulty": "Medium",
  "problem_slug": "find-k-pairs-with-smallest-sums",
  "topics": [
    "Array",
    "Heap (Priority Queue)"
  ],
  "description": "You are given two integer arrays nums1 and nums2 sorted in non-decreasing order and an integer k.\nDefine a pair (u, v) which consists of one element from the first array and one element from the second array.\nReturn the k pairs (u1, v1), (u2, v2), ..., (uk, vk) with the smallest sums.\nExample 1:\nExample 2:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: nums1 = [1,7,11], nums2 = [2,4,6], k = 3\nOutput: [[1,2],[1,4],[1,6]]\nExplanation: The first 3 pairs are returned from the sequence: [1,2],[1,4],[1,6],[7,2],[7,4],[11,2],[7,6],[11,4],[11,6]",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input: nums1 = [1,1,2], nums2 = [1,2,3], k = 2\nOutput: [[1,1],[1,1]]\nExplanation: The first 2 pairs are returned from the sequence: [1,1],[1,1],[1,2],[2,1],[1,2],[2,2],[1,3],[1,3],[2,3]",
      "images": []
    }
  ],
  "constraints": [
    "1 <= nums1.length, nums2.length <= 105",
    "-109 <= nums1[i], nums2[i] <= 109",
    "nums1 and nums2 both are sorted in non-decreasing order.",
    "1 <= k <= 104",
    "k <= nums1.length * nums2.length"
  ],
  "follow_ups": [],
  "hints": [],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    vector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) {\n        \n    }\n};",
    "java": "class Solution {\n    public List<List<Integer>> kSmallestPairs(int[] nums1, int[] nums2, int k) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def kSmallestPairs(self, nums1, nums2, k):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :type k: int\n        :rtype: List[List[int]]\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def kSmallestPairs(self, nums1: List[int], nums2: List[int], k: int) -> List[List[int]]:\n        ",
    "c": "/**\n * Return an array of arrays of size *returnSize.\n * The sizes of the arrays are returned as *returnColumnSizes array.\n * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().\n */\nint** kSmallestPairs(int* nums1, int nums1Size, int* nums2, int nums2Size, int k, int* returnSize, int** returnColumnSizes) {\n    \n}",
    "csharp": "public class Solution {\n    public IList<IList<int>> KSmallestPairs(int[] nums1, int[] nums2, int k) {\n        \n    }\n}",
    "javascript": "/**\n * @param {number[]} nums1\n * @param {number[]} nums2\n * @param {number} k\n * @return {number[][]}\n */\nvar kSmallestPairs = function(nums1, nums2, k) {\n    \n};",
    "typescript": "function kSmallestPairs(nums1: number[], nums2: number[], k: number): number[][] {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param Integer[] $nums1\n     * @param Integer[] $nums2\n     * @param Integer $k\n     * @return Integer[][]\n     */\n    function kSmallestPairs($nums1, $nums2, $k) {\n        \n    }\n}",
    "swift": "class Solution {\n    func kSmallestPairs(_ nums1: [Int], _ nums2: [Int], _ k: Int) -> [[Int]] {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun kSmallestPairs(nums1: IntArray, nums2: IntArray, k: Int): List<List<Int>> {\n        \n    }\n}",
    "dart": "class Solution {\n  List<List<int>> kSmallestPairs(List<int> nums1, List<int> nums2, int k) {\n    \n  }\n}",
    "golang": "func kSmallestPairs(nums1 []int, nums2 []int, k int) [][]int {\n    \n}",
    "ruby": "# @param {Integer[]} nums1\n# @param {Integer[]} nums2\n# @param {Integer} k\n# @return {Integer[][]}\ndef k_smallest_pairs(nums1, nums2, k)\n    \nend",
    "scala": "object Solution {\n    def kSmallestPairs(nums1: Array[Int], nums2: Array[Int], k: Int): List[List[Int]] = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn k_smallest_pairs(nums1: Vec<i32>, nums2: Vec<i32>, k: i32) -> Vec<Vec<i32>> {\n        \n    }\n}",
    "racket": "(define/contract (k-smallest-pairs nums1 nums2 k)\n  (-> (listof exact-integer?) (listof exact-integer?) exact-integer? (listof (listof exact-integer?)))\n  )",
    "erlang": "-spec k_smallest_pairs(Nums1 :: [integer()], Nums2 :: [integer()], K :: integer()) -> [[integer()]].\nk_smallest_pairs(Nums1, Nums2, K) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec k_smallest_pairs(nums1 :: [integer], nums2 :: [integer], k :: integer) :: [[integer]]\n  def k_smallest_pairs(nums1, nums2, k) do\n    \n  end\nend"
  },
  "solution": "[TOC]\n\n## Solution\n\n---\n\n### Overview\n\nWe are given two integer arrays `nums1` and `nums2` sorted in ascending order and an integer `k`.\n\nOur task is to return the `k` pairs ($u_1$, $v_1$), ($u_2$, $v_2$), ..., ($u_k$, $v_k$) with the smallest sums where the first element in the pair is from `nums1` and second elements is from `nums2`.\n\n---\n\n### Approach: Using Heap\n\n#### Intuition\n\nThe brute force approach to solving this problem is to compute the sum of all the pairs, sort the list of sums, and select the first 'k' elements from it. If the size of `nums1` is `m` and size of `nums2` is `n`, there will be `m * n` pairs in total that will be formed. As a result, it will take $O(m \\cdot n)$ time to calculate the sum of all the pairs and $O(m \\cdot n \\cdot \\log(m \\cdot n))$ time to sort the list of sums. This will result in the time limit being exceeded (TLE).\n\nWe can see from the problem description that both arrays are sorted. Let us try to make use of it.\n\nBecause the arrays are sorted, the pair with the smallest sum is undoubtedly the one formed by selecting the first element from both arrays, i.e., pair with indices `(0, 0)` where the first element is index of `nums1` and second is index of `nums2`. As a result, we add `(nums1[0], nums2[0])` to our answer list.\n\nWhat about the next pair whose sum is just greater than (or equal to) the sum of the previous pair?\n\nThe next pair with a sum that is just greater than (or equal to) the sum of the previous pair would be formed by selecting either the first element of `nums1` and the second element of `nums2`, `(0, 1)`, or the second element of `nums1` and the first element of `nums2`, `(1, 0)`, whichever has smaller sum. We only need to look at these two pairs because the sum of all the other pairs will be greater than this pair.\n\nAssume we chose `(0, 1)` as our second pair. The next smallest pair whose sum is greater than (or equal to) the sum of the second pair is either the previous iteration's leftover pair `(1, 0)`, or one of the pairs formed by taking the current pair `(0, 1)` and taking a new element from either array, so either `(1, 1)` or `(0, 2)` (notice that this is the same option we had after taking the first pair `(0, 0)`).\n\n> At each step, we chose the minimum sum pair from the remaining leftover pairs and the next two new pairs. The answer will not be present outside of these pairs being considered only because the arrays are sorted. We repeat this process until we get `k` pairs.\n\nA **heap** is a useful data structure when it is necessary to repeatedly remove the object with the lowest (or highest) priority, or when insertions need to be interspersed with removals of the objects.\n\nWe will use a min heap to solve the problem because we need to iterate from the lowest sum of a pair to pairs with higher sums. The sums of pairs will be stored in the heap, and the data structure will keep the sums in sorted order. We must store the information of the indices of `nums1` and `nums2` that lead to the formation of a particular sum in the heap in order to return the pair of integers.\n\nIn the heap, we would store a triplet of integers: the pair's sum, the first element's index in `nums1`, and the second element's index in `nums2`. We start with an empty list `ans` and push all of the `k` pairs that make up the answer one-by-one.\n\nWe begin by inserting `nums1[0] + nums2[0], 0, 0` into the heap because the sum of the first element of both arrays is guaranteed to be the smallest.\n\nTo obtain the minimum sum of a pair among all the pairs under consideration, the top of the heap is popped out. We save the triplet in `val`, `i` and `j`. We put the pair `(nums1[i], nums2[j])` in `ans`.\n\nWe then push the two new pairs as discussed in the heap. We push `nums1[i + 1] + nums2[j], i + 1, j` and `nums1[i] + nums2[j + 1], i, j + 1`.\n\nWe do this until we get `k` pairs or heap becomes empty which would happen if we have covered all the `m * n` pairs and `k > m * n`, where `m` is size of `nums1` and `n` is size of `nums2`.\n\nThe only thing to keep in mind here is that when we push the new pairs, there may be repeating states. For `(0, 0)` for example, we will push `(1, 0)` and `(0, 1)`. Then on both `(1, 0)` and `(0, 1)`, we would push `(1, 1)`. As you can see, we pushed the pair `i = 1, j = 1` twice.\n\nTo avoid this, we can create a hash set called `visited` and store the pairs that have already been pushed into the heap in order to avoid pushing them again.\n\nHere is a visual representation of how this approach works for the first example given in the problem description:\n\n!?!../Documents/373/373-slides.json:601,301!?!\n\nThis method is very similar to the Dijkstra algorithm in that we find the shortest distance between any two nodes. To find the edge with the smallest weight, we heap all of the edge weights. Then we move on to the next node (using minimum weight edge selected). We add all of the edge weights for the edges connected with the node back to the heap from the current node and choose the edge with the lowest weight from the available edges. We use the edge to move to another unvisited node and continue popping nodes and adding edge weights to the heap until all of the nodes are covered.\n\n#### Algorithm\n\n1. Create two integer variables `m` and `n`. Initialize them to size of `nums1` and `nums2` respectively.\n2. Create a list `ans` to store the pairs with smallest sums that are to be returned as the answer.\n3. Create a hash set `visited` to keep track of pairs that are seen. Please note that we used `ordered_set` in `C++` in place of `unordered_set` because the `unordered_set` uses `hash` template to compute hashes for its entries and there is no `hash` specialization for pairs. Either we define the `hash` function of pairs or use `ordered_set` which is a little expensive as it adds `log` factor. We are using `ordered_set` here.\n4. Initialize a min heap `minHeap` that takes a triplet of integers: the sum of the pair, the index in `nums1` of the first element of the pair, and the index in `nums2` of the second element of the pair.\n5. Push the first element from the both the arrays in `minHeap`, i.e., we push `nums1[0] + nums2[0], 0, 0`. We also insert pair `(0, 0)` in `visited`.\n6. Iterate till we get `k` pairs and `minHeap` is not empty:\n    - Pop the top of `minHeap` and set `i  = top[1]` and `j = top[2]`.\n    - Push pair `(nums1[i], nums2[j])` in `ans`.\n    - If `i + 1 < m` and pair `(i + 1, j)` is not in `visited`, we push a new pair `nums1[i + 1] + nums2[j], i + 1, j` into the heap.\n    - If `j + 1 < n` and pair `(i, j + 1)` is not in `visited`, we push a new pair `nums1[i] + nums2[j + 1], i, j + 1` into the heap.\n7. Return `ans`.\n\n#### Implementation#### Complexity Analysis\n\nHere, $m$ is the size of `nums1` and $n$ is the size of `nums2`.\n\n* Time complexity: $O(\\min(k \\cdot \\log k, m \\cdot n \\cdot \\log (m \\cdot n)))$\n\n    - We iterate $O(\\min(k, m \\cdot n))$ times to get the required number of pairs.\n    - The `visited` set and `heap` both can grow up to a size of $O(\\min(k, m \\cdot n))$ because at each iteration we are inserting at most two pairs and popping one pair. Insertions into a min-heap take an additional $\\log$ factor. So, to insert $O(\\min(k, m \\cdot n))$ elements into `minHeap`, we need $O(\\min(k \\cdot \\log k, m \\cdot n \\cdot \\log (m \\cdot n))$ time.\n    - The `visited` set takes on an average constant time and hence will take $O(\\min(k, m \\cdot n))$ time in major languages like Java and Python except in C++ where it would also take $O(\\min(k \\cdot \\log k, m \\cdot n \\cdot \\log (m \\cdot n)))$ because we used `ordered_set` that keeps the values in sorted order.\n\n* Space complexity: $O(\\min(k, m \\cdot n))$\n\n    - The `visited` set and `heap` can both grow up to a size of $O(\\min(k, m \\cdot n))$ because at each iteration we are inserting at most two pairs and popping one pair."
}