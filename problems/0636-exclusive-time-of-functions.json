{
  "title": "Exclusive Time of Functions",
  "problem_id": "636",
  "frontend_id": "636",
  "difficulty": "Medium",
  "problem_slug": "exclusive-time-of-functions",
  "topics": [
    "Array",
    "Stack"
  ],
  "description": "On a single-threaded CPU, we execute a program containing n functions. Each function has a unique ID between 0 and n-1.\nFunction calls are stored in a call stack: when a function call starts, its ID is pushed onto the stack, and when a function call ends, its ID is popped off the stack. The function whose ID is at the top of the stack is the current function being executed. Each time a function starts or ends, we write a log with the ID, whether it started or ended, and the timestamp.\nYou are given a list logs, where logs[i] represents the ith log message formatted as a string \"{function_id}:{\"start\" | \"end\"}:{timestamp}\". For example, \"0:start:3\" means a function call with function ID 0 started at the beginning of timestamp 3, and \"1:end:2\" means a function call with function ID 1 ended at the end of timestamp 2. Note that a function can be called multiple times, possibly recursively.\nA function's exclusive time is the sum of execution times for all function calls in the program. For example, if a function is called twice, one call executing for 2 time units and another call executing for 1 time unit, the exclusive time is 2 + 1 = 3.\nReturn the exclusive time of each function in an array, where the value at the ith index represents the exclusive time for the function with ID i.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: n = 2, logs = [\"0:start:0\",\"1:start:2\",\"1:end:5\",\"0:end:6\"]\nOutput: [3,4]\nExplanation:\nFunction 0 starts at the beginning of time 0, then it executes 2 for units of time and reaches the end of time 1.\nFunction 1 starts at the beginning of time 2, executes for 4 units of time, and ends at the end of time 5.\nFunction 0 resumes execution at the beginning of time 6 and executes for 1 unit of time.\nSo function 0 spends 2 + 1 = 3 units of total time executing, and function 1 spends 4 units of total time executing.",
      "images": [
        "https://assets.leetcode.com/uploads/2019/04/05/diag1b.png"
      ]
    },
    {
      "example_num": 2,
      "example_text": "Input: n = 1, logs = [\"0:start:0\",\"0:start:2\",\"0:end:5\",\"0:start:6\",\"0:end:6\",\"0:end:7\"]\nOutput: [8]\nExplanation:\nFunction 0 starts at the beginning of time 0, executes for 2 units of time, and recursively calls itself.\nFunction 0 (recursive call) starts at the beginning of time 2 and executes for 4 units of time.\nFunction 0 (initial call) resumes execution then immediately calls itself again.\nFunction 0 (2nd recursive call) starts at the beginning of time 6 and executes for 1 unit of time.\nFunction 0 (initial call) resumes execution at the beginning of time 7 and executes for 1 unit of time.\nSo function 0 spends 2 + 4 + 1 + 1 = 8 units of total time executing.",
      "images": [
        "https://assets.leetcode.com/uploads/2019/04/05/diag1b.png"
      ]
    },
    {
      "example_num": 3,
      "example_text": "Input: n = 2, logs = [\"0:start:0\",\"0:start:2\",\"0:end:5\",\"1:start:6\",\"1:end:6\",\"0:end:7\"]\nOutput: [7,1]\nExplanation:\nFunction 0 starts at the beginning of time 0, executes for 2 units of time, and recursively calls itself.\nFunction 0 (recursive call) starts at the beginning of time 2 and executes for 4 units of time.\nFunction 0 (initial call) resumes execution then immediately calls function 1.\nFunction 1 starts at the beginning of time 6, executes 1 unit of time, and ends at the end of time 6.\nFunction 0 resumes execution at the beginning of time 6 and executes for 2 units of time.\nSo function 0 spends 2 + 4 + 1 = 7 units of total time executing, and function 1 spends 1 unit of total time executing.",
      "images": [
        "https://assets.leetcode.com/uploads/2019/04/05/diag1b.png"
      ]
    }
  ],
  "constraints": [
    "1 <= n <= 100",
    "2 <= logs.length <= 500",
    "0 <= function_id < n",
    "0 <= timestamp <= 109",
    "No two start events will happen at the same timestamp.",
    "No two end events will happen at the same timestamp.",
    "Each function has an \"end\" log for each \"start\" log."
  ],
  "follow_ups": [],
  "hints": [],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    vector<int> exclusiveTime(int n, vector<string>& logs) {\n        \n    }\n};",
    "java": "class Solution {\n    public int[] exclusiveTime(int n, List<String> logs) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def exclusiveTime(self, n, logs):\n        \"\"\"\n        :type n: int\n        :type logs: List[str]\n        :rtype: List[int]\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def exclusiveTime(self, n: int, logs: List[str]) -> List[int]:\n        ",
    "c": "/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nint* exclusiveTime(int n, char** logs, int logsSize, int* returnSize) {\n    \n}",
    "csharp": "public class Solution {\n    public int[] ExclusiveTime(int n, IList<string> logs) {\n        \n    }\n}",
    "javascript": "/**\n * @param {number} n\n * @param {string[]} logs\n * @return {number[]}\n */\nvar exclusiveTime = function(n, logs) {\n    \n};",
    "typescript": "function exclusiveTime(n: number, logs: string[]): number[] {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param Integer $n\n     * @param String[] $logs\n     * @return Integer[]\n     */\n    function exclusiveTime($n, $logs) {\n        \n    }\n}",
    "swift": "class Solution {\n    func exclusiveTime(_ n: Int, _ logs: [String]) -> [Int] {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun exclusiveTime(n: Int, logs: List<String>): IntArray {\n        \n    }\n}",
    "dart": "class Solution {\n  List<int> exclusiveTime(int n, List<String> logs) {\n    \n  }\n}",
    "golang": "func exclusiveTime(n int, logs []string) []int {\n    \n}",
    "ruby": "# @param {Integer} n\n# @param {String[]} logs\n# @return {Integer[]}\ndef exclusive_time(n, logs)\n    \nend",
    "scala": "object Solution {\n    def exclusiveTime(n: Int, logs: List[String]): Array[Int] = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn exclusive_time(n: i32, logs: Vec<String>) -> Vec<i32> {\n        \n    }\n}",
    "racket": "(define/contract (exclusive-time n logs)\n  (-> exact-integer? (listof string?) (listof exact-integer?))\n  )",
    "erlang": "-spec exclusive_time(N :: integer(), Logs :: [unicode:unicode_binary()]) -> [integer()].\nexclusive_time(N, Logs) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec exclusive_time(n :: integer, logs :: [String.t]) :: [integer]\n  def exclusive_time(n, logs) do\n    \n  end\nend"
  }
}