{
  "title": "First Completely Painted Row or Column",
  "problem_id": "2685",
  "frontend_id": "2661",
  "difficulty": "Medium",
  "problem_slug": "first-completely-painted-row-or-column",
  "topics": [
    "Array",
    "Hash Table",
    "Matrix"
  ],
  "description": "You are given a 0-indexed integer array arr, and an m x n integer matrix mat. arr and mat both contain all the integers in the range [1, m * n].\nGo through each index i in arr starting from index 0 and paint the cell in mat containing the integer arr[i].\nReturn the smallest index i at which either a row or a column will be completely painted in mat.\nExample 1:\nExample 2:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: arr = [1,3,4,2], mat = [[1,4],[2,3]]\nOutput: 2\nExplanation: The moves are shown in order, and both the first row and second column of the matrix become fully painted at arr[2].",
      "images": [
        "https://assets.leetcode.com/uploads/2023/01/18/grid1.jpg"
      ]
    },
    {
      "example_num": 2,
      "example_text": "Input: arr = [2,8,7,4,1,3,5,6,9], mat = [[3,2,5],[1,4,6],[8,7,9]]\nOutput: 3\nExplanation: The second column becomes fully painted at arr[3].",
      "images": [
        "https://assets.leetcode.com/uploads/2023/01/18/grid2.jpg"
      ]
    }
  ],
  "constraints": [
    "m == mat.length",
    "n = mat[i].length",
    "arr.length == m * n",
    "1 <= m, n <= 105",
    "1 <= m * n <= 105",
    "1 <= arr[i], mat[r][c] <= m * n",
    "All the integers of arr are unique.",
    "All the integers of mat are unique."
  ],
  "follow_ups": [],
  "hints": [
    "Can we use a frequency array?",
    "Pre-process the positions of the values in the matrix.",
    "Traverse the array and increment the corresponding row and column frequency using the pre-processed positions.",
    "If the row frequency becomes equal to the number of columns, or vice-versa return the current index."
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\n        \n    }\n};",
    "java": "class Solution {\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def firstCompleteIndex(self, arr, mat):\n        \"\"\"\n        :type arr: List[int]\n        :type mat: List[List[int]]\n        :rtype: int\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def firstCompleteIndex(self, arr: List[int], mat: List[List[int]]) -> int:\n        ",
    "c": "int firstCompleteIndex(int* arr, int arrSize, int** mat, int matSize, int* matColSize) {\n    \n}",
    "csharp": "public class Solution {\n    public int FirstCompleteIndex(int[] arr, int[][] mat) {\n        \n    }\n}",
    "javascript": "/**\n * @param {number[]} arr\n * @param {number[][]} mat\n * @return {number}\n */\nvar firstCompleteIndex = function(arr, mat) {\n    \n};",
    "typescript": "function firstCompleteIndex(arr: number[], mat: number[][]): number {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param Integer[] $arr\n     * @param Integer[][] $mat\n     * @return Integer\n     */\n    function firstCompleteIndex($arr, $mat) {\n        \n    }\n}",
    "swift": "class Solution {\n    func firstCompleteIndex(_ arr: [Int], _ mat: [[Int]]) -> Int {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun firstCompleteIndex(arr: IntArray, mat: Array<IntArray>): Int {\n        \n    }\n}",
    "dart": "class Solution {\n  int firstCompleteIndex(List<int> arr, List<List<int>> mat) {\n    \n  }\n}",
    "golang": "func firstCompleteIndex(arr []int, mat [][]int) int {\n    \n}",
    "ruby": "# @param {Integer[]} arr\n# @param {Integer[][]} mat\n# @return {Integer}\ndef first_complete_index(arr, mat)\n    \nend",
    "scala": "object Solution {\n    def firstCompleteIndex(arr: Array[Int], mat: Array[Array[Int]]): Int = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn first_complete_index(arr: Vec<i32>, mat: Vec<Vec<i32>>) -> i32 {\n        \n    }\n}",
    "racket": "(define/contract (first-complete-index arr mat)\n  (-> (listof exact-integer?) (listof (listof exact-integer?)) exact-integer?)\n  )",
    "erlang": "-spec first_complete_index(Arr :: [integer()], Mat :: [[integer()]]) -> integer().\nfirst_complete_index(Arr, Mat) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec first_complete_index(arr :: [integer], mat :: [[integer]]) :: integer\n  def first_complete_index(arr, mat) do\n    \n  end\nend"
  },
  "solution": "[TOC]\n\n## Solution\n\n--- \n\n### Overview\n\nWe are given two inputs: an array `arr` and a matrix `mat`. The array `arr` is a list of numbers, and the matrix `mat` is a grid where each cell contains one of these numbers. Both `arr` and `mat` contain all integers from 1 to $m \\cdot n$, where $m$ is the number of rows in the matrix and $n$ is the number of its columns.  \n\nOur goal is to simulate a process where we \"paint\" the cells of the matrix in the order defined by `arr`. Starting from the first number in `arr`, we find the corresponding cell in `mat` and mark it as painted. As we progress through `arr`, more cells in `mat` will become painted.  \n\nWe need to find the smallest index `i` in `arr` such that, after painting the cell corresponding to $arr[i]$, either:  \n1. An entire row in the matrix becomes completely painted (all cells in the row are marked).  \n2. An entire column in the matrix becomes completely painted (all cells in the column are marked).  \n\n> Note: Each number in `arr` corresponds to a unique cell in `mat`. This means no number is repeated, and every cell in the matrix will eventually be painted.\n\n---\n\n### Approach 1: Brute-Force\n\n#### Intuition   \n\nA brute force way to solve this problem will be to start processing each element of `arr` one by one, paint the corresponding cell in `mat` and then iterate over its row and column to check whether at least one of them is completely painted.\n\nTo achieve this, we need a way to efficiently retrieve the position of each number in the matrix. For this purpose, we create a map called `numToPos`, where each key represents a number from `mat`, and its corresponding value is the position (row and column) of that number in `mat`. This map allows us to quickly look up the position of any number during processing.\n\nAfter constructing the map, we start iterating through each number in `arr`. For each number, we check where it appears in `mat` by looking it up in the map. Once we find the number’s position, we mark it as \"seen\" by setting its value in `mat` to a negative number. This marking indicates that the cell is painted.\n\nAfter marking the cell, the next step is to check whether the current row or column is completely filled. To do this:\n- We scan the entire row where the marked cell is located. If every element in that row is now negative, we know the entire row is painted.\n- Similarly, we check the entire column for the same condition. If all elements in that column are negative, we know the column is fully painted.\n\nIf either the row or the column of the marked cell is completely painted, we immediately return the current index in `arr` since this is the first index, the processing of which resulted in fully painted row or column.\n \nSince `mat` and `arr` always contain the same numbers, every cell in `mat` will eventually be painted. Therefore, we don’t need to account for a scenario where we reach the end of the array without completing a row or column. If such a scenario were possible, we might theoretically return an invalid value (e.g.,` -1`), but this is not allowed under the given constraints.\n\n#### Algorithm\n\n- Initialize `numRows` and `numCols` to the number of rows and columns in the matrix `mat`, respectively.\n- Create a `numToPos` map to store the position (row, column) of each number in the matrix.\n\n- Populate `numToPos` by iterating over the matrix `mat`:\n  - For each element `value` in the matrix, store its position `(row, col)` in `numToPos`.\n\n- Iterate over each element `num` in the array `arr`:\n  - Retrieve the position `(row, col)` of `num` from `numToPos`.\n  - Mark the element in `mat[row][col]` as seen by negating its value (`mat[row][col] = -mat[row][col]`).\n\n  - Check if the entire row or column has been marked (i.e., if all values in the row/column are negative):\n    - Call `checkRow(row, mat)` to check if the row is fully marked.\n    - Call `checkColumn(col, mat)` to check if the column is fully marked.\n    - If either check is `true`, return the current index `i` in `arr`.\n\n- Return `-1` (This line is a safeguard and will never be reached because of the problem constraints).\n\n- The helper functions `checkRow(row, mat)` and `checkColumn(col, mat)`:\n  - Both functions iterate through the row or column, respectively, to check if all values are negative.\n  - Return `true` if the entire row or column is fully marked, otherwise `false`.\n\n#### Implementation\n\n> Note: This solution gets a TLE because of high time complexity#### Complexity Analysis\n\nLet $k = m \\cdot n$ be the size of `arr` (since $arr.length == m \\cdot n$), $m$ the number of rows in `mat`, and $n$ the number of columns in `mat`.\n\n- Time complexity: $O(k \\cdot (m + n) + m \\cdot n)$\n\n    We first build a map to store the positions of each element in the matrix, which takes $O(m \\cdot n)$ time. Then, we iterate through the array `arr` and for each element, we check if the corresponding row or column is completely painted. This checking step takes $O(m + n)$ for each element in `arr`, leading to a total time complexity of $O(k \\cdot (m + n) + m \\cdot n)$.\n\n- Space complexity: $O(m \\cdot n)$\n\n    We use a map to store the positions of each element in the matrix, which requires $O(m \\cdot n)$ space. Other variables use constant space, so the total space complexity is $O(m \\cdot n)$.\n\n---\n\n### Approach 2: Brute Force Optimized with Counting\n\n#### Intuition   \n\nThe brute force approach works by iterating over a row and a column after each number is marked, to check whether they have become fully painted.  However, we noticed that this is inefficient and leads to Time Limit Exceeded (TLE) error. \n\nIn this approach, instead of checking the entire row or column after each step, we maintain counters for the number of painted cells in of them. This way, we avoid iterating through the entire row and column every time, making the \"fully-colored check\" a constant-time operation.\n\nJust like in the brute force approach, we first map every number in `mat` to its position (row and column) using a hashmap `numToPos`. This allows us to efficiently find where each number from `arr` appears in `mat`.\n\nAdditionally, we maintain two arrays `rowCount` and `colCount` to track how many numbers have been marked in each row and column, respectively. Initially, all values in these arrays are set to `0`.\n\nEach time a number is marked, we increment the count for its corresponding row and column. This allows us to efficiently track the progress of the marking without re-scanning the whole row or column.\n\nAfter marking a number, we only need to check if the entire row or column has been filled:\n- If the count of marked numbers in the row (`rowCount[row]`) is equal to the number of columns, it means the row is fully marked.\n- Similarly, if the count of marked numbers in the column (`colCount[col]`) is equal to the number of rows, the column is fully marked.\n\nAgain, since the problem guarantees that a row or column will eventually be fully marked, we don't need to worry about handling edge cases where no completion happens. The return value of `-1` is just a safeguard, but it will never be reached given the problem constraints.\n\n#### Algorithm\n\n- Initialize `numRows` and `numCols` to the number of rows and columns in the matrix `mat`.\n- Create two arrays, `rowCount` and `colCount`, to keep track of the number of times each row and column have been \"painted\". Initialize all their elements to `0`.\n- Create a map `numToPos` to store the position of each number in the matrix.\n\n- Iterate through the matrix `mat` to populate `numToPos` with the position (row, col) of each value in `mat`.\n\n- Iterate through the array `arr`:\n  - For each number `num` in `arr`, retrieve its position `(row, col)` from `numToPos`.\n  - Increment the count of the corresponding row and column in `rowCount` and `colCount`.\n  - If the count for the row reaches `numCols` or the count for the column reaches `numRows`, return the current index `i` (indicating the number that completes a row or column).\n\n- Return `-1` (This line is a safeguard and will never be reached because of the problem constraints).\n\n#### Implementation#### Complexity Analysis\n\nLet $k = m \\cdot n$ be the size of `arr` (since $arr.length == m \\cdot n$), $m$ the number of rows in `mat`, and $n$ the number of columns in `mat`.\n\n- Time complexity: $O(k) \\equiv O(m \\cdot n)$\n\n    We first build a map to store the positions of each element in the matrix, which takes $O(k)$ time. Then, we iterate through the array `arr` (of size $m \\cdot n$) and for each element, we update the counts for the corresponding row and column. This step also takes $O(k)$ time. Therefore, the total time complexity is $O(k) \\equiv O(m \\cdot n)$.\n\n- Space complexity: $O(m \\cdot n)$\n\n    We use a map to store the positions of each element in the matrix, which requires $O(k)$ space. Additionally, we use two arrays (`rowCount` and `colCount`) of sizes $m$ and $n$ respectively, contributing $O(m + n)$ space. Thus, the total space complexity is $O(k + m + n) \\equiv O((m \\cdot n) + m + n) \\approx O(m \\cdot n)$.\n\n---\n\n### Approach 3: Reverse Mapping\n\n#### Intuition\n\nIn Approach 2, we were checking the count of \"painted\" elements for each row and column after every marking operation. Now, instead of that, we track the greatest index at which an element of each row and column occurs in `arr`. This will reduce space usage and eliminate the need for redundant checks, as we won’t need the `rowCount` and `colCount` arrays anymore. \n\nSimilarly to the previous approaches, we begin by mapping each number to its position (index)  in `arr`, using a hashmap, `numToIndex`.\n\nInstead of counting marked numbers, we consider a different question: When will a row or column be fully painted? Intuitively, this happens when all the numbers in that row or column have been processed. Building on this idea, we observe that it suffices to track the latest index in `arr` where each number in a row or column appears. If we know the greatest index for any element in a row or column, that row or column will be fully painted once that index is reached.\n\nFor example, consider a row of `mat`, which contains the numbers 3, 5, and 8. If their indices in `arr` are 1, 3, and 2 respectively, the row will be fully painted when index 3 (the largest index for any number in that row) in arr is reached.\n\nAfter determining the greatest index for each row and column, we identify the row or column with the smallest maximum index, as this represents the first to be fully painted. \n\nThe algorithm is visualized below:\n\n!?!../Documents/2661/reverse_mapping.json:880,790!?!\n\n#### Algorithm\n\n- Initialize a `numToIndex` unordered map to store the index of each element from `arr`.\n- Populate `numToIndex` by iterating over the `arr` and recording the index of each element.\n\n- Initialize `lastElementIndex` to `INT_MAX` and `result` to `INT_MIN` to track the earliest complete row or column.\n- Initialize `numRows` and `numCols` to the number of rows and columns in the matrix `mat`, respectively.\n\n- Check for the earliest row to be completely painted:\n  - Iterate through each row in the matrix `mat`:\n    - Initialize `result` to `INT_MIN` for each row.\n    - Iterate through each column in the current row:\n      - For each element in the row, find its index in `numToIndex` and update `result` with the maximum of its current value and index of the current element in `arr`.\n    - Update `lastElementIndex` with the minimum of `lastElementIndex` and the row's `result`.\n\n- Check for the earliest column to be completely painted:\n  - Iterate through each column in the matrix `mat`:\n    - Initialize `result` to `INT_MIN` for each column.\n    - Iterate through each row in the current column:\n      - For each element in the column, find its index in `numToIndex` and update `result` with the maximum index value.\n    - Update `lastElementIndex` with the minimum of `lastElementIndex` and the column's `result`.\n\n- Return `lastElementIndex`, which represents the earliest index where a row or column has been completely painted.\n\n#### Implementation#### Complexity Analysis\n\nLet $k = m \\cdot n$ be the size of `arr` (since $arr.length == m \\cdot n$), $m$ the number of rows in `mat`, and $n$ the number of columns in `mat`.\n\n- Time complexity: $O(m \\cdot n)$\n\n    We first build a map to store the index of each element in `arr`, which takes $O(k)$ time. Then, we check for the earliest row and column to be completely painted, which takes $O(m \\cdot n)$ time. Since $k = m \\cdot n$, the total time complexity is $O(m \\cdot n)$.\n\n- Space complexity: $O(k) \\equiv O(m\\cdot n)$\n\n    We use a map to store the index of each element in `arr`, which requires $O(k)$ space. Other variables use constant space, so the total space complexity is $O(k) \\equiv O(m\\cdot n)$.\n\n---"
}