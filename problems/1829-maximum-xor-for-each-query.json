{
  "title": "Maximum XOR for Each Query",
  "problem_id": "1940",
  "frontend_id": "1829",
  "difficulty": "Medium",
  "problem_slug": "maximum-xor-for-each-query",
  "topics": [
    "Array",
    "Bit Manipulation",
    "Prefix Sum"
  ],
  "description": "You are given a sorted array nums of n non-negative integers and an integer maximumBit. You want to perform the following query n times:\nReturn an array answer, where answer[i] is the answer to the ith query.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: nums = [0,1,1,3], maximumBit = 2\nOutput: [0,3,2,3]\nExplanation: The queries are answered as follows:\n1st query: nums = [0,1,1,3], k = 0 since 0 XOR 1 XOR 1 XOR 3 XOR 0 = 3.\n2nd query: nums = [0,1,1], k = 3 since 0 XOR 1 XOR 1 XOR 3 = 3.\n3rd query: nums = [0,1], k = 2 since 0 XOR 1 XOR 2 = 3.\n4th query: nums = [0], k = 3 since 0 XOR 3 = 3.",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input: nums = [2,3,4,7], maximumBit = 3\nOutput: [5,2,6,5]\nExplanation: The queries are answered as follows:\n1st query: nums = [2,3,4,7], k = 5 since 2 XOR 3 XOR 4 XOR 7 XOR 5 = 7.\n2nd query: nums = [2,3,4], k = 2 since 2 XOR 3 XOR 4 XOR 2 = 7.\n3rd query: nums = [2,3], k = 6 since 2 XOR 3 XOR 6 = 7.\n4th query: nums = [2], k = 5 since 2 XOR 5 = 7.",
      "images": []
    },
    {
      "example_num": 3,
      "example_text": "Input: nums = [0,1,2,2,5,7], maximumBit = 3\nOutput: [4,3,6,4,6,7]",
      "images": []
    }
  ],
  "constraints": [
    "nums.length == n",
    "1 <= n <= 105",
    "1 <= maximumBit <= 20",
    "0 <= nums[i] < 2maximumBit",
    "nums​​​ is sorted in ascending order."
  ],
  "follow_ups": [],
  "hints": [
    "Note that the maximum possible XOR result is always 2^(maximumBit) - 1",
    "So the answer for a prefix is the XOR of that prefix XORed with 2^(maximumBit)-1"
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    vector<int> getMaximumXor(vector<int>& nums, int maximumBit) {\n        \n    }\n};",
    "java": "class Solution {\n    public int[] getMaximumXor(int[] nums, int maximumBit) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def getMaximumXor(self, nums, maximumBit):\n        \"\"\"\n        :type nums: List[int]\n        :type maximumBit: int\n        :rtype: List[int]\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def getMaximumXor(self, nums: List[int], maximumBit: int) -> List[int]:\n        ",
    "c": "/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nint* getMaximumXor(int* nums, int numsSize, int maximumBit, int* returnSize) {\n    \n}",
    "csharp": "public class Solution {\n    public int[] GetMaximumXor(int[] nums, int maximumBit) {\n        \n    }\n}",
    "javascript": "/**\n * @param {number[]} nums\n * @param {number} maximumBit\n * @return {number[]}\n */\nvar getMaximumXor = function(nums, maximumBit) {\n    \n};",
    "typescript": "function getMaximumXor(nums: number[], maximumBit: number): number[] {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @param Integer $maximumBit\n     * @return Integer[]\n     */\n    function getMaximumXor($nums, $maximumBit) {\n        \n    }\n}",
    "swift": "class Solution {\n    func getMaximumXor(_ nums: [Int], _ maximumBit: Int) -> [Int] {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun getMaximumXor(nums: IntArray, maximumBit: Int): IntArray {\n        \n    }\n}",
    "dart": "class Solution {\n  List<int> getMaximumXor(List<int> nums, int maximumBit) {\n    \n  }\n}",
    "golang": "func getMaximumXor(nums []int, maximumBit int) []int {\n    \n}",
    "ruby": "# @param {Integer[]} nums\n# @param {Integer} maximum_bit\n# @return {Integer[]}\ndef get_maximum_xor(nums, maximum_bit)\n    \nend",
    "scala": "object Solution {\n    def getMaximumXor(nums: Array[Int], maximumBit: Int): Array[Int] = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn get_maximum_xor(nums: Vec<i32>, maximum_bit: i32) -> Vec<i32> {\n        \n    }\n}",
    "racket": "(define/contract (get-maximum-xor nums maximumBit)\n  (-> (listof exact-integer?) exact-integer? (listof exact-integer?))\n  )",
    "erlang": "-spec get_maximum_xor(Nums :: [integer()], MaximumBit :: integer()) -> [integer()].\nget_maximum_xor(Nums, MaximumBit) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec get_maximum_xor(nums :: [integer], maximum_bit :: integer) :: [integer]\n  def get_maximum_xor(nums, maximum_bit) do\n    \n  end\nend"
  },
  "solution": "[TOC]\n\n## Solution\n\n---\n\n### Overview\n\nIn this problem, we have to answer `n` queries. To answer the `i`-th query, we have to find the `k` where `k` has to be less than $2^{\\text{maximumBit}}$ and maximizes the $XOR$ product between `k` and `nums[0], nums[1],..., nums[i]`. We will explore two approaches that will dive into how to calculate this `k` efficiently for all queries.\n\n### Approach 1: Prefix Array + Bit Masking\n\n#### Intuition\n\nFor the `i-th` query, we need to first calculate the $XOR$ product for the numbers `nums[0], nums[1],..., nums[i]`. Once we have this XOR value, which we'll call `product`, we want to find a `k` that maximizes the result of `k XOR product`. We first discuss how to find the `product` for each query efficiently.\n\nTo efficiently calculate the initial `product` for each query, we can save time by precomputing these values. We do this by performing a linear scan through the `nums` array to build a prefix array called `prefixXOR`. In this array, `prefixXOR[i]` will hold the XOR product of all numbers from `nums[0]` to `nums[i]`. For any query at index `i`, we can easily retrieve the `product` as `prefixXOR[i]`. \n\nNow that we have the `product` for each query, our next task is to find a `k` that will maximize `k XOR product`. A brute force approach would involve trying all possible bit combinations for `k`, where there is a total of $2^{\\text{maximumBit}}$ bit combinations, and selecting the one that has the highest `k XOR product` value. \n \nHowever, due to the constraint on `k` where `k` can only have at most `maximumBit` bits, we know that we can only ever change at most the first `maximumBit` bits of `product` when maximizing our value of `k XOR product`. Specifically, we can achieve the greatest value by choosing a `k` that will make the first `maximumBits` bits set to all `1`s. Because the $XOR$ operator evaluates to 1 when the operands differ (0 and 1, or 1 and 0), we can do this by setting our `k` as the inverse of the first `maximumBits` of `product`. Because each respective bit is different, the XOR between a number and its inverse will lead to all bits being set to 1.\n\nTo quickly find this inverse, we create a bitmask called `mask`. This mask can be generated using the formula `mask = (1 << maximumBit) - 1`, which gives us a number where the first `maximumBit` bits are set to `1`. Then, to get our desired `k` for a given `product`, we can simply compute `product XOR mask`. Here, if a bit in `product` is set to 0, its XOR with the respective bit from `mask` set to 1 will make the resulting bit 1. Similarly, if the bit in `product` is set to 1, its XOR with the respective bit from `mask` will make the resulting bit 0. Thus, applying this mask will provide us with the inverse of the first `maximumBits` of `product`, which is the value of `k` that maximizes our result.\n\n\n#### Algorithm\n\n1. Calculate prefix array `prefixXOR` to store the prefix `XOR` products for all the queries:\n    * Initialize `prefixXOR[0]` to `nums[0]`\n    * From `i = 1` to `i = nums.length - 1`:\n        * `prefixXOR[i] = prefixXOR[i - 1] XOR nums[i]`\n2. Define our bitmask `mask = (1 << maximumBit) - 1`\n3. Initialize our answer array `ans`\n4. Answer each query and populate `ans`:\n    * From `i = 0` to `i = nums.length - 1`:\n        * The current XOR product we're dealing with is `product = prefixXOR[-i]`\n        * Set `ans[i]` to be `product XOR mask`, giving us a `k` that inverts the first `maximumBit` bits of `product` to maximize our value `product XOR k`\n5. Return `ans`\n\n#### Implementation#### Complexity Analysis\n\n* Time Complexity: $O(n)$\n\n    Calculating our prefix array takes $O(n)$ time. Going through all `n` queries will take $O(n)$ time where the $XOR$ calculation for each query takes constant time. Thus, the total time complexity is $O(n)$.\n\n* Space Complexity: $O(n)$\n\n    Our prefix array has a size of $n$, resulting in a space complexity of $O(n)$.\n\n---\n\n### Approach 2: Optimized Calculation + Bit Masking\n\n#### Intuition\n\nIn Approach 1, we used a prefix array to quickly fetch the relevant XOR product for each query. In this approach, we explore a more space-efficient way to do so. \n\nFor the first query, we notice that we start with the $XOR$ product that involves all numbers in `nums`. As we move on to each subsequent query, we calculate a new $XOR$ product that drops the last number in the previous calculation. \n\nTo do this, we can start by calculating the initial XOR product, which we'll call`firstProduct`. This represents the XOR of all numbers in `nums`. This will give us the starting product used in the first query. Then, for each query `i`, we can then update `firstProduct` by removing the `i-th` last element from our previous calculations. We do this with the expression `firstProduct = firstProduct XOR nums[-i]`. \n\nThe insight here is that when we XOR the same number again, it cancels itself out. This means that by applying the XOR operation to `firstProduct` with `nums[-i]`, we effectively remove that element from our calculations. This approach allows us to update the XOR product for each query efficiently without needing to recalculate everything from scratch.  \n\n#### Algorithm\n\n1. Calculate our initial $XOR$ product:\n    * `xorProduct = 0`\n    * For each `num` in `nums`: `xorProduct = xorProduct XOR num`\n2. Define our bitmask `mask = (1 << maximumBit) - 1`\n3. Initialize our answer array `ans`\n4. Answer each query and populate `ans`:\n    * From `i = 0` to `i = nums.length - 1`:\n        * Set `ans[i]` to be `xorProduct XOR mask`, giving us a `k` that inverts the first `maximumBit` bits of `product` to maximize our value `product XOR k`\n        * Update `xorProduct` for the next query by removing the last element: `xorProduct = xorProduct XOR nums[-i]`\n5. Return `ans`\n\n#### Implementation#### Complexity Analysis\n\n* Time Complexity: $O(n)$\n\n    Going through all `n` queries will take $O(n)$ time where the $XOR$ calculations for each query take constant time. Thus, the total time complexity is $O(n)$.\n\n* Space Complexity: $O(1)$\n\n    We do not have any auxiliary data structures besides the required `ans` array, so the space complexity is $O(1)$.\n    \n    \n---"
}