{
  "title": "Count Number of Teams",
  "problem_id": "1511",
  "frontend_id": "1395",
  "difficulty": "Medium",
  "problem_slug": "count-number-of-teams",
  "topics": [
    "Array",
    "Dynamic Programming",
    "Binary Indexed Tree",
    "Segment Tree"
  ],
  "description": "There are n soldiers standing in a line. Each soldier is assigned a unique rating value.\nYou have to form a team of 3 soldiers amongst them under the following rules:\nReturn the number of teams you can form given the conditions. (soldiers can be part of multiple teams).\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: rating = [2,5,3,4,1]\nOutput: 3\nExplanation: We can form three teams given the conditions. (2,3,4), (5,4,1), (5,3,1).",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input: rating = [2,1,3]\nOutput: 0\nExplanation: We can't form any team given the conditions.",
      "images": []
    },
    {
      "example_num": 3,
      "example_text": "Input: rating = [1,2,3,4]\nOutput: 4",
      "images": []
    }
  ],
  "constraints": [
    "n == rating.length",
    "3 <= n <= 1000",
    "1 <= rating[i] <= 105",
    "All the integers in rating are unique."
  ],
  "follow_ups": [],
  "hints": [
    "BruteForce, check all possibilities."
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    int numTeams(vector<int>& rating) {\n        \n    }\n};",
    "java": "class Solution {\n    public int numTeams(int[] rating) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def numTeams(self, rating):\n        \"\"\"\n        :type rating: List[int]\n        :rtype: int\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def numTeams(self, rating: List[int]) -> int:\n        ",
    "c": "int numTeams(int* rating, int ratingSize) {\n    \n}",
    "csharp": "public class Solution {\n    public int NumTeams(int[] rating) {\n        \n    }\n}",
    "javascript": "/**\n * @param {number[]} rating\n * @return {number}\n */\nvar numTeams = function(rating) {\n    \n};",
    "typescript": "function numTeams(rating: number[]): number {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param Integer[] $rating\n     * @return Integer\n     */\n    function numTeams($rating) {\n        \n    }\n}",
    "swift": "class Solution {\n    func numTeams(_ rating: [Int]) -> Int {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun numTeams(rating: IntArray): Int {\n        \n    }\n}",
    "dart": "class Solution {\n  int numTeams(List<int> rating) {\n    \n  }\n}",
    "golang": "func numTeams(rating []int) int {\n    \n}",
    "ruby": "# @param {Integer[]} rating\n# @return {Integer}\ndef num_teams(rating)\n    \nend",
    "scala": "object Solution {\n    def numTeams(rating: Array[Int]): Int = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn num_teams(rating: Vec<i32>) -> i32 {\n        \n    }\n}",
    "racket": "(define/contract (num-teams rating)\n  (-> (listof exact-integer?) exact-integer?)\n  )",
    "erlang": "-spec num_teams(Rating :: [integer()]) -> integer().\nnum_teams(Rating) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec num_teams(rating :: [integer]) :: integer\n  def num_teams(rating) do\n    \n  end\nend"
  },
  "solution": "[TOC]\n\n## Solution\n\n---\n\n### Approach 1: Dynamic Programming (Memoization) \n\n#### Intuition\n\nThe brute force approach to solving this problem involves checking all possible combinations of `rating` and counting those that meet our conditions. However, such an approach would have a time complexity of $O(n^3)$, which would not satisfy the given constraints. \n\nInstead of using nested loops to examine all possible combinations of soldiers, we can simplify the problem by breaking it down into smaller sub-problems. The core idea is to determine how many teams each soldier can join and then sum these totals to get the final answer.\n\nWe can achieve this by employing recursion. Specifically, we define a function called `countIncreasingTeams` that takes two parameters: an index from the `rating` array and the number of members currently in the team. This function will return the total number of valid teams that can be formed starting from the given index with the current team size.\n\nFor each soldier, the function will explore all potential next soldiers who can be added to the team, provided they satisfy the rating condition. It will then recursively count the number of valid teams that can be formed from this new state. The recursion will terminate when the team has reached the maximum size of three members. At each step, the function accumulates the number of valid teams and returns this count.\n\nDuring the recursion, we might encounter the same sub-problem multiple times at different stages, which are known as overlapping sub-problems. To optimize our solution and avoid redundant computations, we use memoization. This technique involves storing the result of each sub-problem the first time it is computed so that when we encounter the same sub-problem again, we can retrieve the result from a cache rather than recomputing it.\n\nSince we need to count both increasing and decreasing teams, we set up two separate recursive functions, each with its cache. Each sub-problem is uniquely identified by two states: the current index and the size of the team already formed.\n\nTo get the final result, we initiate our recursive functions starting from each index in the `rating` array. By summing the number of teams returned by each recursion, we obtain the total number of valid teams.\n\n#### Algorithm\n\nMain method `numTeams`:\n\n- Initialize:\n  - `n` as the length of `rating`.\n  - `teams` to store the total number of possible teams.\n  - two arrays `increasingCache` and `decreasingCache` of size $n \\times 4$ to serve as cache for the memoization.\n- Loop over the array `rating`. For each index `startIndex`:\n  - Call `countIncreasingTeams` and `countDecreasingTeams` with `startIndex`. Add their results to `teams`.\n- Return `teams`.\n  \nHelper method `countIncreasingTeams`:\n\n- Define a method `countIncreasingTeams` with parameters: `rating`, `currentIndex`, `teamSize` and the cache `increasingCache`.\n- Initialize `n` as the length of `rating`.\n- If `currentIndex` is equal to `n`, return `0`.\n- If `teamSize` is equal to `3`, return `1`.\n- If `increasingCache` already contains an entry with the current state, return it.\n- Initialize a variable `validTeams` to `0`.\n- Loop over all indices from `currentIndex + 1` to the end of the array. For each index `nextIndex`:\n  - If `rating[nextIndex]` is greater than `rating[currentIndex]`, call `countIncreasingTeams` with `nextIndex` and `teamSize` incremented by `1`.\n- Cache `validTeams` with the current state in `increasingCache` and return it.\n\nHelper method `countDecreasingTeams`:\n- Define a method `countDecreasingTeams` with parameters: `rating`, `currentIndex`, `teamSize` and the cache `decreasingCache`.\n- This method is exactly the same as `countIncreasingTeams` except for majorly one thing:\n  - We check whether `rating[nextIndex]` is less than `rating[currentIndex]` to call `countDecreasingTeams`.\n\n#### Implementation#### Complexity Analysis\n\nLet $n$ be the length of the `rating` array.\n\n- Time complexity: $O(n^2)$\n\n    The algorithm iterates through `rating`, each time calling `countIncreasingTeams` and `countDecreasingTeams`. In the worst case, the recursive functions might explore all subsequent soldiers for each call. However, due to memoization, each unique subproblem is only computed once. There are $n$ possible indices and $3$ possible team sizes $(1, 2, 3)$. This gives us $n \\times 3 = O(n)$ unique sub-problems. Each sub-problem may iterate through up to $n$ soldiers in the worst case. Therefore, the overall time complexity is $O(n^2)$.\n\n- Space complexity: $O(n)$\n\n    Each cache (`increasingCache` and `decreasingCache`) is a 2D array of size $n \\times 4$, thus taking $O(8 \\cdot n) = O(n)$ space. \n    \n    The maximum depth of recursion is $3$, so this doesn't add to the asymptotic space complexity. \n\n    Thus, the overall space complexity is $O(n)$.\n\n---\n\n### Approach 2: Dynamic Programming (Tabulation) \n\n#### Intuition\n\nThe main drawback of using the memoization approach is the significant space consumed by the recursion stack. To address this issue, we can refine the algorithm to reduce space usage by eliminating recursion.\n\nIn the memoization approach, the recursive function solves each sub-problem and stores the results in a cache. Since the solution to the main problem is derived from all its sub-problems, the final answer ends up being stored in the cache. Therefore, if we can construct the cache without recursion, we can avoid the overhead associated with the recursion stack.\n\nTo achieve this, weâ€™ll use two 2D arrays: `increasingTeams` and `decreasingTeams`. Each array will have the position `(i, j)` representing the number of teams of size `j` that end with the `i`th member of the `rating` array. Initially, we populate these arrays with the base case: for all positions `(i, j)` where `j=1`, the number of ways to form a team is `1`, as the `i`th soldier alone constitutes a single-member team.\n\nWe then use three nested loops to consider all combinations of team lengths 2 and 3. For each position `(i, j)`, if we can append `rating[j]` to the sequence ending with `rating[i]`, we update the count of teams at `j` by adding the count of teams of the previous length at `i`.\n\nFinally, to find the total number of teams of length 3, we iterate over both arrays and sum up the counts for all positions where `j` equals `3`. This accumulated total represents the number of teams formed, providing the answer to the problem without incurring recursion space overhead.\n\n#### Algorithm\n\n- Initialize:       \n  - `n` to the length of `rating`.\n  - `teams` to store the required number of teams.\n- Create two 2D arrays `increasingTeams` and `decreasingTeams` of size $n \\times 4$ to store the count of increasing and decreasing sequences respectively.\n- Fill base case. For all `i` from `0` to `n`:\n  - Set `increasingTeams[i][1]` and `decreasingTeams[i][1]` to `1` (as each soldier forms a sequence of length 1).\n- Use 3 nested loops to fill the tables. The outer loop iterates over sequence lengths 2 and 3. The middle loop sets the middle soldier. The inner loop iterates over all soldiers as potential end points. For each pair of soldiers `i` and `j`:\n  - If `rating[j] > rating[i]`, add `increasingTeams[i][count-1]` to `increasingTeams[j][count]`.\n  - If `rating[j] < rating[i]`, add `decreasingTeams[i][count-1]` to `decreasingTeams[j][count]`.\n- Set `teams` as the sum of all sequences of length 3.\n- Return `teams` as our answer.\n\n#### Implementation#### Complexity Analysis\n\nLet $n$ be the length of the `rating` array.\n\n- Time complexity: $O(n^2)$\n\n    Initializing the `increasingTeams` and `decreasingTeams` arrays take $O(n)$ time. \n\n    In the nested loops: the outer loop runs $2$ times, the middle loop $n$ times and the inner loop at most $n$ times. Thus, the total complexity of the section is $O(2 \\cdot n \\cdot n)$, which simplifies to $O(n^2)$.\n\n    The final summation loop runs in linear time.\n\n    Thus, the total time complexity of the algorithm is dominated by the nested loops, resulting in $O(n^2)$.\n\n- Space complexity: $O(n)$\n\n    The two 2D arrays `increasingTeams` and `decreasingTeams` each take $n \\times 4$ space, which give them a total space complexity of $O(2 \\cdot 4 \\cdot n) = O(n)$.\n\n    All other elements take constant space, so the space complexity of the algorithm is $O(n)$.\n\n---\n\n### Approach 3: Dynamic Programming (Optimized)\n\n#### Intuition\n\nHaving explored team formations by fixing either the starting or ending points, let's now consider an alternative approach: focusing on the middle member of each team.\n\nThe key insight here is to examine each soldier as a potential middle member. For each such soldier, we need to count:\n- How many soldiers to their left have lower ratings\n- How many soldiers to their right have higher ratings\n\nWe apply the same logic for descending teams:\n- How many soldiers to their left have higher ratings\n- How many soldiers to their right have lower ratings\n\nFor ascending teams, the number of valid teams for each index is the product of the number of smaller-rated soldiers to the left and larger-rated soldiers to the right. This is because each soldier with a lower rating to the left can be paired with each soldier with a higher rating to the right to form a valid team with the middle soldier.\n\nThe same principle applies to descending teams, where we multiply the count of higher-rated soldiers to the left by the count of lower-rated soldiers to the right.\n\nTo obtain the final result, we sum the number of teams formed for each potential middle soldier.\n\n#### Algorithm\n\n- Initialize variables:\n  - `n`: length of the `rating` array.\n  - `teams`: to store the total count of valid teams.\n- Iterate through `rating`. For each soldier `mid`:\n  - Set `leftSmaller` and `rightLarger` counters to `0`.\n  - Count smaller rating to the left of `mid` and store it in `leftSmaller`.\n  - Count larger rating to the right of `mid` and store it in `rightLarger`.\n  - Calculate the number of ascending rating teams:\n    - Multiply `leftSmaller` by `rightLarger` and add it to `teams`.\n  - Calculate the number of descending rating teams:\n    - Set `leftLarger` as the total soldiers on left - `leftSmaller`.\n    - Set `rightSmaller` as the total soldiers on right - `rightLarger`.\n    - Multiply `leftLarger` by `rightSmaller` and add to `teams`.\n- Return `teams` as our answer.\n\n#### Implementation#### Complexity Analysis\n\nLet $n$ be the length of the `rating` array.\n\n* Time complexity: $O(n^2)$\n\n    The main loop iterates through the `rating` array, which takes linear time. In each iteration, the two inner loops compare $n-1$ elements in total. Thus, the overall time complexity is $O(n \\cdot (n-1))$, which simplifies to $O(n^2)$.\n\n* Space complexity: $O(1)$\n\n    The space complexity is constant since no additional data structures dependent on the length of the input space are used.\n\n---\n\n### Approach 4: Binary Indexed Tree (Fenwick Tree) \n\n#### Intuition\n\nIn our previous approach, we performed a linear scan of elements to the left and right of each middle soldier, which contributed an $O(n)$ factor to our overall complexity. To enhance efficiency, we need to explore a more advanced approach.\n\nOne such optimization involves querying the total count of smaller soldiers on either side of each soldier. This type of query can be optimized to $O(\\log n)$ time using a data structure known as a Binary Indexed Tree (BIT) or Fenwick Tree. While a comprehensive explanation of how a BIT operates is beyond the scope of this article, interested readers can refer to [this discussion](https://cs.stackexchange.com/questions/10538/bit-what-is-the-intuition-behind-a-binary-indexed-tree-and-how-was-it-thought-a) for a deeper understanding. For hands-on practice, consider tackling these problems:\n1. [Range Sum Query - Mutable](https://leetcode.com/problems/range-sum-query-mutable/description/)\n2. [Count of Smaller Numbers After Self](https://leetcode.com/problems/count-of-smaller-numbers-after-self/description/)\n\nOur improved solution utilizes two BITs: one to manage the left side and another for the right side of the current soldier. Each `BIT` stores frequency counts of ratings within a specific range. For instance, `BIT[5]` keeps track of the number of soldiers with a rating of `5`, while `BIT[6]` aggregates counts for ratings of `5` and `6`.\n\nHere is an example to get a better understanding of how the BIT stores the frequency counts of ratings:\n\n!?!../Documents/1395/slideshow.json:1402,922!?!\n\nTo implement our algorithm, we start by populating the right `BIT` with all the soldier ratings. As we process each soldier, we remove their rating from the right `BIT` and consider them the middle soldier. To count increasing sequences, we query the number of soldiers with lower ratings in the left `BIT` and the number of soldiers with higher ratings in the right `BIT`. The product of these two counts gives the total number of increasing teams with the current soldier positioned in the middle. Similarly, we perform this process to calculate the number of decreasing sequence teams. After processing, the current soldier's rating is added to the left `BIT`, and we continue with the next iteration.\n\n#### Algorithm\n \nMain method `numTeams`:\n\n- Set `maxRating` to the maximum rating in the `rating` array.\n- Initialize two binary indexed trees `leftBIT` and `rightBIT`, each of size `maxRating + 1`.\n- Populate `rightBIT` with all ratings initially using the `updateBIT` method.\n- Initialize `teams` to `0` to store the count of valid teams.\n- Iterate through each `rating` in the input array:\n  - Remove the current `rating` from `rightBIT`.\n  - Count `smallerRatingsLeft` using `getPrefixSum` on `leftBIT`.\n  - Count `smallerRatingsRight` using `getPrefixSum` on `rightBIT`.\n  - Set `largerRatingsLeft` as (all ratings) - (the ratings at and below the current `rating`) on `leftBIT`.\n  - Set `largerRatingsRight` as (all ratings) - (the ratings at or below the current `rating`) on `rightBIT`.\n  - Add to `teams`:\n    - Product of `smallerRatingsLeft` and `largerRatingsRight` (increasing sequences).\n    - Product of `largerRatingsLeft` and `smallerRatingsRight` (decreasing sequences).\n  - Add the current `rating` to the `leftBIT`.\n- Returns `teams` as the total number of teams possible.\n\nHelper method `updateBIT`:\n\n- Define a method `updateBIT` with parameters: `BIT`, `index` and `value`.\n- While `index` is within the bounds of `BIT`:\n  - Add the given `value` to the current `index`.\n  - Move to the next node in the `BIT` by adding `index & (-index)` to `index`.\n\nHelper method `getPrefixSum`:\n\n- Define a method `getPrefixSum` with parameters: `BIT` and `index`.\n- Initialize a variable `sum` to `0`.\n- While `index` is greater than `0`:\n  - Add the value at the current `index` in the `BIT` to `sum`.\n  - Move to the parent node in the `BIT` by subtracting `index & (-index)` from `index`.\n- Return `sum`.\n\n#### Implementation#### Complexity Analysis\n\nLet $n$ be the length of the `rating` array and $\\text{maxRating}$ be the maximum rating in `rating`.\n\n* Time complexity: $O(n \\cdot \\log(\\text{maxRating}))$\n\n    Finding `maxRating` takes linear time. \n\n    Initially populating the `rightBIT` takes $O(n \\cdot \\log(\\text{maxRating}))$ time. \n\n    The main loop iterates $n$ times. For each iteration, updating the BIT's have a complexity of $O(\\log(\\text{maxRating}))$ and getting the prefix sums also take  $O(\\log(\\text{maxRating}))$ time. Thus, the total for the main loop is $O(n \\cdot \\log(\\text{maxRating}))$.\n\n    Thus, the overall time complexity of the algorithm comes out to be $O(n) + O(2 \\cdot n \\cdot \\log(\\text{maxRating}))$, which simplifies to $O(n \\cdot \\log(\\text{maxRating}))$.\n\n* Space complexity: $O(\\text{maxRating})$\n\n    The only additional space used are the two arrays for the BIT, each taking $O(\\text{maxRating})$ space.\n    \n    This makes the space complexity of the algorithm $O(2 \\cdot \\text{maxRating}) = O(\\text{maxRating})$.\n\n---"
}