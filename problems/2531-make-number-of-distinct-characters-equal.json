{
  "title": "Make Number of Distinct Characters Equal",
  "problem_id": "2615",
  "frontend_id": "2531",
  "difficulty": "Medium",
  "problem_slug": "make-number-of-distinct-characters-equal",
  "topics": [
    "Hash Table",
    "String",
    "Counting"
  ],
  "description": "You are given two 0-indexed strings word1 and word2.\nA move consists of choosing two indices i and j such that 0 <= i < word1.length and 0 <= j < word2.length and swapping word1[i] with word2[j].\nReturn true if it is possible to get the number of distinct characters in word1 and word2 to be equal with exactly one move. Return false otherwise.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: word1 = \"ac\", word2 = \"b\"\nOutput: false\nExplanation: Any pair of swaps would yield two distinct characters in the first string, and one in the second string.",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input: word1 = \"abcc\", word2 = \"aab\"\nOutput: true\nExplanation: We swap index 2 of the first string with index 0 of the second string. The resulting strings are word1 = \"abac\" and word2 = \"cab\", which both have 3 distinct characters.",
      "images": []
    },
    {
      "example_num": 3,
      "example_text": "Input: word1 = \"abcde\", word2 = \"fghij\"\nOutput: true\nExplanation: Both resulting strings will have 5 distinct characters, regardless of which indices we swap.",
      "images": []
    }
  ],
  "constraints": [
    "1 <= word1.length, word2.length <= 105",
    "word1 and word2 consist of only lowercase English letters."
  ],
  "follow_ups": [],
  "hints": [
    "Create a frequency array of the letters of each string.",
    "There are 26*26 possible pairs of letters to swap. Can we try them all?",
    "Iterate over all possible pairs of letters and check if swapping them will yield two strings that have the same number of distinct characters. Use the frequency array for the check."
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    bool isItPossible(string word1, string word2) {\n        \n    }\n};",
    "java": "class Solution {\n    public boolean isItPossible(String word1, String word2) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def isItPossible(self, word1, word2):\n        \"\"\"\n        :type word1: str\n        :type word2: str\n        :rtype: bool\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def isItPossible(self, word1: str, word2: str) -> bool:\n        ",
    "c": "bool isItPossible(char* word1, char* word2) {\n    \n}",
    "csharp": "public class Solution {\n    public bool IsItPossible(string word1, string word2) {\n        \n    }\n}",
    "javascript": "/**\n * @param {string} word1\n * @param {string} word2\n * @return {boolean}\n */\nvar isItPossible = function(word1, word2) {\n    \n};",
    "typescript": "function isItPossible(word1: string, word2: string): boolean {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param String $word1\n     * @param String $word2\n     * @return Boolean\n     */\n    function isItPossible($word1, $word2) {\n        \n    }\n}",
    "swift": "class Solution {\n    func isItPossible(_ word1: String, _ word2: String) -> Bool {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun isItPossible(word1: String, word2: String): Boolean {\n        \n    }\n}",
    "dart": "class Solution {\n  bool isItPossible(String word1, String word2) {\n    \n  }\n}",
    "golang": "func isItPossible(word1 string, word2 string) bool {\n    \n}",
    "ruby": "# @param {String} word1\n# @param {String} word2\n# @return {Boolean}\ndef is_it_possible(word1, word2)\n    \nend",
    "scala": "object Solution {\n    def isItPossible(word1: String, word2: String): Boolean = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn is_it_possible(word1: String, word2: String) -> bool {\n        \n    }\n}",
    "racket": "(define/contract (is-it-possible word1 word2)\n  (-> string? string? boolean?)\n  )",
    "erlang": "-spec is_it_possible(Word1 :: unicode:unicode_binary(), Word2 :: unicode:unicode_binary()) -> boolean().\nis_it_possible(Word1, Word2) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec is_it_possible(word1 :: String.t, word2 :: String.t) :: boolean\n  def is_it_possible(word1, word2) do\n    \n  end\nend"
  }
}