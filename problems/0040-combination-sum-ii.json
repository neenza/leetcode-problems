{
  "title": "Combination Sum II",
  "problem_id": "40",
  "frontend_id": "40",
  "difficulty": "Medium",
  "problem_slug": "combination-sum-ii",
  "topics": [
    "Array",
    "Backtracking"
  ],
  "description": "Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sum to target.\nEach number in candidates may only be used once in the combination.\nNote: The solution set must not contain duplicate combinations.\nExample 1:\nExample 2:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: candidates = [10,1,2,7,6,1,5], target = 8\nOutput: \n[\n[1,1,6],\n[1,2,5],\n[1,7],\n[2,6]\n]",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input: candidates = [2,5,2,1,2], target = 5\nOutput: \n[\n[1,2,2],\n[5]\n]",
      "images": []
    }
  ],
  "constraints": [
    "1 <= candidates.length <= 100",
    "1 <= candidates[i] <= 50",
    "1 <= target <= 30"
  ],
  "follow_ups": [],
  "hints": [],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\n        \n    }\n};",
    "java": "class Solution {\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def combinationSum2(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\n        ",
    "c": "/**\n * Return an array of arrays of size *returnSize.\n * The sizes of the arrays are returned as *returnColumnSizes array.\n * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().\n */\nint** combinationSum2(int* candidates, int candidatesSize, int target, int* returnSize, int** returnColumnSizes) {\n    \n}",
    "csharp": "public class Solution {\n    public IList<IList<int>> CombinationSum2(int[] candidates, int target) {\n        \n    }\n}",
    "javascript": "/**\n * @param {number[]} candidates\n * @param {number} target\n * @return {number[][]}\n */\nvar combinationSum2 = function(candidates, target) {\n    \n};",
    "typescript": "function combinationSum2(candidates: number[], target: number): number[][] {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param Integer[] $candidates\n     * @param Integer $target\n     * @return Integer[][]\n     */\n    function combinationSum2($candidates, $target) {\n        \n    }\n}",
    "swift": "class Solution {\n    func combinationSum2(_ candidates: [Int], _ target: Int) -> [[Int]] {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun combinationSum2(candidates: IntArray, target: Int): List<List<Int>> {\n        \n    }\n}",
    "dart": "class Solution {\n  List<List<int>> combinationSum2(List<int> candidates, int target) {\n    \n  }\n}",
    "golang": "func combinationSum2(candidates []int, target int) [][]int {\n    \n}",
    "ruby": "# @param {Integer[]} candidates\n# @param {Integer} target\n# @return {Integer[][]}\ndef combination_sum2(candidates, target)\n    \nend",
    "scala": "object Solution {\n    def combinationSum2(candidates: Array[Int], target: Int): List[List[Int]] = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn combination_sum2(candidates: Vec<i32>, target: i32) -> Vec<Vec<i32>> {\n        \n    }\n}",
    "racket": "(define/contract (combination-sum2 candidates target)\n  (-> (listof exact-integer?) exact-integer? (listof (listof exact-integer?)))\n  )",
    "erlang": "-spec combination_sum2(Candidates :: [integer()], Target :: integer()) -> [[integer()]].\ncombination_sum2(Candidates, Target) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec combination_sum2(candidates :: [integer], target :: integer) :: [[integer]]\n  def combination_sum2(candidates, target) do\n    \n  end\nend"
  },
  "solution": "[TOC]  \n\n## Solution\n\n---\n\n### Overview\n\nThis is one of the problems in the series of combination sums. All these problems can be solved with the same backtracking algorithm.\n\nWe recommend trying these similar problems before tackling this one: [Combination Sum](https://leetcode.com/problems/combination-sum/description/) and [Combination Sum III](https://leetcode.com/problems/combination-sum-iii/description/), which are arguably easier and one can tweak the solution a bit to solve this problem.\n\nWe also listed some follow-up problems at the end of the article if you are interested in exploring the bactracking algorithm further.\n\n---\n\n### Approach: Backtracking\n\n#### Intuition\n\nIn this problem, we need to generate unique combinations with the given sum value. In the worst case, we might need to generate the sum of all combinations in the array. Backtracking can be effectively used to generate all the possible combinations recursively. Backtracking incrementally builds candidates to the solutions and abandons a candidate (backtracks) as soon as it determines that this candidate can't lead to a final solution. For example, in the given problem, we can discard the candidate solution when it exceeds the sum value, provided the array contains non-negative values. Refer to this [backtracking explore card](https://leetcode.com/explore/learn/card/recursion-ii/472/backtracking/2654/) to read more about backtracking.\n\nUsing backtracking, we could incrementally build the combinations. When we find the current combination is not valid, we backtrack and try another option. For the first option, we add the current array element to the current combination array and move this combination to the next index recursively. Similarly, for the second option, we remove the element from the current combination array and move this combination to the next index. Therefore, for every index, we explored two possibilities of including and excluding that value and calculated the combination sum of the maintained combination array. If the desired sum is reached, we can append the list to the answer list. To demonstrate the idea, we showcase how it works with a concrete example in the following tree:\n\n![fig](../Figures/40/40.png)\n\nAre there any optimizations to reduce the backtracking calls? Since we need to return unique combinations, we can group equal values of the array together. The simplest way to group all elements together is by sorting them. Now, suppose the frequency of an element is `freq`, and you need to make backtracking calls for all its possible frequencies between `0` and `freq`, then we can simply pick them from the beginning of its group in the sorted array.\n\n#### Algorithm\n\n- Create a list `list` to store all the unique combinations that sum up to the target.\n- Sort the `candidates` array to handle duplicates and facilitate the backtracking process.\n- Call the `backtrack` function with the following parameters:\n  - `answer`: List to store the final combinations.\n  - `tempList`: Temporary list to store the current combination.\n  - `candidates`: Input array of numbers.\n  - `totalLeft`: Remaining sum to reach the target.\n  - `index`: Starting index for the current recursion.\n\n- Within the `backtrack` function:\n  - If `totalLeft` is less than 0, return immediately (invalid path).\n  - If `totalLeft` equals 0:\n    - Add a copy of `tempList` to `answer` (valid combination found).\n  - Otherwise:\n    - Iterate over `candidates` starting from `index`:\n      - Skip duplicate numbers by checking if `candidates[i] == candidates[i - 1]` for `i > index`.\n      - Add `candidates[i]` to `tempList`.\n      - Recursively call `backtrack` with:\n        - Updated `totalLeft` reduced by `candidates[i]`.\n        - Updated `index` as `i + 1` to avoid reusing the same element.\n      - Remove the last element from `tempList` to backtrack and explore other possibilities.\n\n- Return `list` containing all unique combinations after the recursive calls complete.\n\n#### Implementation#### Complexity Analysis\n\nLet $N$ be the number of $candidates$ in the array.\n\n- Time complexity: $O(2^N)$\n\n    In the worst case, our algorithm will exhaust all possible combinations from the input array. Again, in the worst case, let us assume that each number is unique. The number of combinations for an array of size $N$ would be $2^N$, i.e. each number is included or excluded in a combination. \n    \n    Additionally, it takes $O(N)$ time to build a counter table out of the input array.\n    \n    Therefore, the overall time complexity of the algorithm is dominated by the backtracking process, which is $O(2^N)$.\n\n    You must think about how the solution passes the test cases when the value of $N$ goes up to 100. [Pruning](https://en.wikipedia.org/wiki/Decision_tree_pruning) is the process of writing some additional conditions within our recursion code that help us to reduce the size of our recursion trees by removing redundant sections. For example, in this problem, the maximum value of any `candidates` element is given by 50, whereas the maximum `target` value is 30. So, we can stop the recursion when the value of candidates exceeds the `target` value. Sorting the array is another way to prune the recursion tree. Checkout the image for an explanation:\n\n    ![fig](../Figures/40/image.png)\n   \n- Space complexity: $O(N)$\n   \n    We first create a `tempList`, which in the worst case will consume $O(N)$ space to keep track of the combinations. In addition, we apply recursion in the algorithm, which will incur additional memory consumption in the function call stack. In the worst case, the stack will pile up to $O(N)$ space.\n\n    To sum up, the overall space complexity of the algorithm is $O(N)$.\n\n    Note: we did not take into account the space needed to hold the final results of the combination in the above analysis.\n\n---\n\nHere are a series of problems you can solve, with some tweaks of the backtracking algorithm presented in this article.\n\n[Subsets](https://leetcode.com/problems/subsets/description/)\n[Subsets II](https://leetcode.com/problems/subsets-ii/description/)\n[Permutations](https://leetcode.com/problems/permutations/description/)\n[Permutations II](https://leetcode.com/problems/permutations-ii/description/)\n[Combinations](https://leetcode.com/problems/combinations/description/)\n[Combination Sum](https://leetcode.com/problems/combination-sum/description/)\n[Combination Sum III](https://leetcode.com/problems/combination-sum-iii/description/)\n[Palindrome Partition](https://leetcode.com/problems/palindrome-partitioning/description/)\n\n---"
}