{
  "title": "Special Array With X Elements Greater Than or Equal X",
  "problem_id": "1730",
  "frontend_id": "1608",
  "difficulty": "Easy",
  "problem_slug": "special-array-with-x-elements-greater-than-or-equal-x",
  "topics": [
    "Array",
    "Binary Search",
    "Sorting"
  ],
  "description": "You are given an array nums of non-negative integers. nums is considered special if there exists a number x such that there are exactly x numbers in nums that are greater than or equal to x.\nNotice that x does not have to be an element in nums.\nReturn x if the array is special, otherwise, return -1. It can be proven that if nums is special, the value for x is unique.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: nums = [3,5]\nOutput: 2\nExplanation: There are 2 values (3 and 5) that are greater than or equal to 2.",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input: nums = [0,0]\nOutput: -1\nExplanation: No numbers fit the criteria for x.\nIf x = 0, there should be 0 numbers >= x, but there are 2.\nIf x = 1, there should be 1 number >= x, but there are 0.\nIf x = 2, there should be 2 numbers >= x, but there are 0.\nx cannot be greater since there are only 2 numbers in nums.",
      "images": []
    },
    {
      "example_num": 3,
      "example_text": "Input: nums = [0,4,3,0,4]\nOutput: 3\nExplanation: There are 3 values that are greater than or equal to 3.",
      "images": []
    }
  ],
  "constraints": [
    "1 <= nums.length <= 100",
    "0 <= nums[i] <= 1000"
  ],
  "follow_ups": [],
  "hints": [
    "Count the number of elements greater than or equal to x for each x in the range [0, nums.length].",
    "If for any x, the condition satisfies, return that x. Otherwise, there is no answer."
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    int specialArray(vector<int>& nums) {\n        \n    }\n};",
    "java": "class Solution {\n    public int specialArray(int[] nums) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def specialArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def specialArray(self, nums: List[int]) -> int:\n        ",
    "c": "int specialArray(int* nums, int numsSize) {\n    \n}",
    "csharp": "public class Solution {\n    public int SpecialArray(int[] nums) {\n        \n    }\n}",
    "javascript": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar specialArray = function(nums) {\n    \n};",
    "typescript": "function specialArray(nums: number[]): number {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @return Integer\n     */\n    function specialArray($nums) {\n        \n    }\n}",
    "swift": "class Solution {\n    func specialArray(_ nums: [Int]) -> Int {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun specialArray(nums: IntArray): Int {\n        \n    }\n}",
    "dart": "class Solution {\n  int specialArray(List<int> nums) {\n    \n  }\n}",
    "golang": "func specialArray(nums []int) int {\n    \n}",
    "ruby": "# @param {Integer[]} nums\n# @return {Integer}\ndef special_array(nums)\n    \nend",
    "scala": "object Solution {\n    def specialArray(nums: Array[Int]): Int = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn special_array(nums: Vec<i32>) -> i32 {\n        \n    }\n}",
    "racket": "(define/contract (special-array nums)\n  (-> (listof exact-integer?) exact-integer?)\n  )",
    "erlang": "-spec special_array(Nums :: [integer()]) -> integer().\nspecial_array(Nums) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec special_array(nums :: [integer]) :: integer\n  def special_array(nums) do\n    \n  end\nend"
  },
  "solution": "## Solution\n\n---\n\n### Approach 1: Sorting\n\n#### Intuition\n\nWe are given a non-negative integer array `nums`. We need to return an integer `x` such that there are exactly `x` integers in the array `nums` that are greater than or equal to `x`. The value of `x` will be unique for a given array `nums` if `nums` is unique. If no such value `x` exists, return `-1`. Note that the integer `x` doesn't have to be in the array `nums`.\n\nThe first observation is that the value of `x` cannot be more than the length of the array `nums`. This is because for an integer to be the answer, there must be at least that number of integers in `nums`. If we assume `x` to be `nums.length + 1`, there must be precisely `nums.length + 1` integers in the array that are greater than or equal to `x`, but there are only `nums.length` integers in `nums`. Also, the minimum possible value for `x` is `1`. This is because if `x` equals `0`, the array `nums` must be empty, but the constraints guarantee that `nums` has at least `1` element.\n\nThe naive way to solve the problem is to iterate over the integers from `1` to `nums.length` and check if each is special. To check this, we can again iterate over the array `nums` to find the count of integers that are greater or equal to the value. If this count is equal to the value, then return this value; otherwise, move on to the next value. This approach, however, is not efficient as it uses nested loops, so the time complexity will be quadratic.\n\nWe can efficiently find the number of integers that are greater than or equal to an element if the array is sorted. We can then use binary search to find the first index where the value is greater than or equal to the element. All elements after that index would also be greater or equal to the element. In each step of the binary search, we will check the mid index in the current range of `nums`. If this mid element is greater than `val`, it implies this can be our answer. Thus, we will store the index and move on to the left half of the current range of `nums` to check if there's a better answer. If the mid element is smaller than `val` we will move on to the right half.\n\n> Binary search is an algorithm for finding the position of a target value within a sorted array. It searches efficiently by dividing the search space in half with every iteration. If you are unfamiliar with binary search, check out the [binary search explore card](https://leetcode.com/explore/learn/card/binary-search/).\n\n\n#### Algorithm\n\n1. Sort the array `nums`.\n2. Iterate over integers from `1` to `nums.length` (N) for each value `i`:\n\n    - Find the index of the first integer in the array `nums` that is greater than or equal to `i` as `k` using the binary search method `getFirstGreaterOrEqual`.\n\n        - The search space for the binary search is `0` to `N - 1`; hence, initialize `start` to `0` and `end` to `N - 1`.\n        - Initialize `index` to `N`, this is because if all elements are less than `i` (`val`), we will return `N` as the answer.\n        - Repeat the following until the range `[start, end]` is empty:\n\n            - Find the `mid` as `(start + end) / 2`.\n            - If `nums[mid]` is greater than or equal to `val`, then update `index` to `mid` and move to the left half of the current search space.\n            - Else, move to the right half of the current search space.\n        - Return `index`.\n\n    - If the number of integers after index `k` in the array `nums`, i.e. `N - k`, is equal to `i` then return `i`.\n\n3. If we have iterated over all possible values and still didn't return any value, it implies no special value exists. Return `-1`.\n\n#### Implementation#### Complexity Analysis\n\nHere, $N$ is the number of integers in the array `nums`.\n\n* Time complexity: $O(N \\log N)$\n\n  Sorting the array `nums` takes $O(N \\log N)$ time. Then we iterate over all values from `1` to `N` and, for each value, perform the binary search on `nums`, which takes $O(\\log N)$ time. Thus, this step takes $O(N \\log N)$ time. Therefore, the total time complexity equals $O(N \\log N)$.\n\n* Space complexity: $O(\\log N)$ or $O(N)$\n\n  No extra space is needed apart from a few variables. However, some space is required for sorting. The space complexity of the sorting algorithm depends on the implementation of each programming language. For instance, in Java, the `Arrays.sort()` for primitives is implemented as a variant of the quicksort algorithm whose space complexity is $O(\\log⁡⁡ N)$. In C++ `sort()` function provided by STL is a hybrid of Quick Sort, Heap Sort, and Insertion Sort and has a worst-case space complexity of $O(\\log⁡⁡ N)$. In Python, the `sort` method sorts a list using the Tim Sort algorithm which is a combination of Merge Sort and Insertion Sort and uses $O(N)$ additional space. Thus, the inbuilt `sort()` function might add up to $O(\\log⁡⁡ N)$ or $O(N)$ to the space complexity.\n\n---\n\n### Approach 2: Counting Sort + Prefix Sum\n\n#### Intuition\n\nAn efficient strategy to find the number of integers in the array `nums` that are greater than or equal to all possible values from `1` to `N` could reduce the overall time complexity.\n\nIf we store the frequency of each `nums` integer in the array `freq`, then we can efficiently find the number of integers that are greater than or equal to each integer. We can take the prefix sum from the end of the range of possible values for `x`, i.e., `N` to `1`. We will keep adding the frequencies of integers from the right end of `freq` to calculate the number of array values larger than the current element.\n\nThe prefix sum (or rather suffix, to be precise, as we calculate it from the right end) doesn't have to be a separate array. Instead, we can calculate the running sum and check if the current sum is equal to the current value. If the current sum from the right end is equal to the current value then we can return the current value. Otherwise, we keep iterating. After the loop completes, we return `-1` if we don't find a valid `x`.\n\nThe below implementation stores the count of all values in `nums` that are greater than the length of array `nums` at `freq[N]` where `N` is the length of `nums`. This is because, as we discussed, `x` cannot be greater than `N`. This will reduce the space used for the frequency array as instead of having an array with the size of the maximum element in the array `nums` we can use an array of size `N + 1`.\n\n![fig](../Figures/1608/1608A.png)\n\n#### Algorithm\n\n1. Initialize an array `freq` with size `N + 1` with all values as `0`.\n2. Iterate over the array `nums` and store the frequency of each integer in the array `freq`. If the value `nums[i]` is greater than `N` store the frequency at index `N`.\n3. Initialize the variable `numGreaterThanOrEqual` to `0`. This is the number of elements that are greater than or equal to the current element.\n4. Iterate over the values from `N` to `1` and for each value `i`:\n\n    - Add the value `freq[i]` to `numGreaterThanOrEqual`;\n    - If the value `i` is equal to the `numGreaterThanOrEqual` then return `i`\n\n5. Return `-1`.\n\n#### Implementation#### Complexity Analysis\n\nHere, $N$ is the number of integers in the array `nums`.\n\n* Time complexity: $O(N)$\n\n  We first iterate over the integers in the array `nums` to store the frequencies in the array `freq`, which takes $O(N)$. We then iterate over the values from `N` to `1` to find the possible answers; this is again a $O(N)$ process. Thus, the total time complexity is equal to $O(N)$.\n\n* Space complexity: $O(N)$\n\n  The main space required is the array `freq` of size `N + 1`. Therefore, the total space complexity is equal to $O(N)$.\n---"
}