{
  "title": "The Number of Beautiful Subsets",
  "problem_id": "2696",
  "frontend_id": "2597",
  "difficulty": "Medium",
  "problem_slug": "the-number-of-beautiful-subsets",
  "topics": [
    "Array",
    "Hash Table",
    "Math",
    "Dynamic Programming",
    "Backtracking",
    "Sorting",
    "Combinatorics"
  ],
  "description": "You are given an array nums of positive integers and a positive integer k.\nA subset of nums is beautiful if it does not contain two integers with an absolute difference equal to k.\nReturn the number of non-empty beautiful subsets of the array nums.\nA subset of nums is an array that can be obtained by deleting some (possibly none) elements from nums. Two subsets are different if and only if the chosen indices to delete are different.\nExample 1:\nExample 2:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: nums = [2,4,6], k = 2\nOutput: 4\nExplanation: The beautiful subsets of the array nums are: [2], [4], [6], [2, 6].\nIt can be proved that there are only 4 beautiful subsets in the array [2,4,6].",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input: nums = [1], k = 1\nOutput: 1\nExplanation: The beautiful subset of the array nums is [1].\nIt can be proved that there is only 1 beautiful subset in the array [1].",
      "images": []
    }
  ],
  "constraints": [
    "1 <= nums.length <= 18",
    "1 <= nums[i], k <= 1000"
  ],
  "follow_ups": [],
  "hints": [
    "Sort the array nums and create another array cnt of size nums[i].",
    "Use backtracking to generate all the beautiful subsets. If cnt[nums[i] - k] is positive, then it is impossible to add nums[i] in the subset, and we just move to the next index. Otherwise, it is also possible to add nums[i] in the subset, in this case, increase cnt[nums[i]], and move to the next index.",
    "Bonus: Can you solve the problem in O(n log n)?"
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    int beautifulSubsets(vector<int>& nums, int k) {\n        \n    }\n};",
    "java": "class Solution {\n    public int beautifulSubsets(int[] nums, int k) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def beautifulSubsets(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def beautifulSubsets(self, nums: List[int], k: int) -> int:\n        ",
    "c": "int beautifulSubsets(int* nums, int numsSize, int k) {\n    \n}",
    "csharp": "public class Solution {\n    public int BeautifulSubsets(int[] nums, int k) {\n        \n    }\n}",
    "javascript": "/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number}\n */\nvar beautifulSubsets = function(nums, k) {\n    \n};",
    "typescript": "function beautifulSubsets(nums: number[], k: number): number {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @param Integer $k\n     * @return Integer\n     */\n    function beautifulSubsets($nums, $k) {\n        \n    }\n}",
    "swift": "class Solution {\n    func beautifulSubsets(_ nums: [Int], _ k: Int) -> Int {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun beautifulSubsets(nums: IntArray, k: Int): Int {\n        \n    }\n}",
    "dart": "class Solution {\n  int beautifulSubsets(List<int> nums, int k) {\n    \n  }\n}",
    "golang": "func beautifulSubsets(nums []int, k int) int {\n    \n}",
    "ruby": "# @param {Integer[]} nums\n# @param {Integer} k\n# @return {Integer}\ndef beautiful_subsets(nums, k)\n    \nend",
    "scala": "object Solution {\n    def beautifulSubsets(nums: Array[Int], k: Int): Int = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn beautiful_subsets(nums: Vec<i32>, k: i32) -> i32 {\n        \n    }\n}",
    "racket": "(define/contract (beautiful-subsets nums k)\n  (-> (listof exact-integer?) exact-integer? exact-integer?)\n  )",
    "erlang": "-spec beautiful_subsets(Nums :: [integer()], K :: integer()) -> integer().\nbeautiful_subsets(Nums, K) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec beautiful_subsets(nums :: [integer], k :: integer) :: integer\n  def beautiful_subsets(nums, k) do\n    \n  end\nend"
  },
  "solution": "[TOC]\n\n## Solution\n\n---\n\n### Overview\n\nWe are given an array of positive integers `nums` and a positive integer `k`; the task is to find the number of non-empty beautiful subsets of `nums`.\n\n**Key Observations:**\n1. A subset is defined as a set of elements taken from the original array `nums`.\n2. If a subset contains two integers `a` and `b` such that `|a - b| = k`, then it's not beautiful.\n3. We need to count the number of possible beautiful subsets of `nums`.\n\nThe solutions in this editorial utilize the following concepts:\n\n- Recursion: [Recursion Explore Card](https://leetcode.com/explore/learn/card/recursion-ii/)\n- Dynamic Programming: [Dynamic Programming](https://leetcode.com/explore/learn/card/dynamic-programming/)\n- **XOR** and **OR** bitwise operations: [Bitwise Operator Explore Card](https://leetcode.com/explore/learn/card/bit-manipulation/669/bit-manipulation-concepts/4496/)\n\nIf you are not familiar with a topic, we recommend you read the corresponding linked explore card.\n\n---\n\n### Approach 1: Using Bitset\n\n#### Intuition\n\nThe size of the `nums` array is very small (`<= 20`). This means that the number of possible subsets is also relatively small, as there are at most $2^{20}$ subsets. We can take advantage of this fact and use a bitset to represent the subsets.\n\nA bitset is a compact way of representing a set of elements, where each bit corresponds to a single element. If the bit is set (1), it means the element is included in the set; otherwise, it is not included (0).\n\nExample: nums = [1,2,3,4,5,6], subset: [1,3,4]\n\nThis subset includes the elements at indices 0, 2, and 3, so the corresponding mask is `001101`. The least significant bit corresponds to the element at index zero.\n\nWe traverse the elements of the array `nums`. For each element `nums[i]`, we check if including it in the current subset would make the subset ugly (i.e., if there exists a pair of elements with a difference of `k`). We can do this by checking all previously included elements in the bitset.\n\nIf the current element `nums[i]` does not make the subset ugly, we include it in the bitset by setting the corresponding bit. Otherwise, we skip it and move to the next element.\n\nThe process is visualized below:\n\n![bitset](../Figures/2597/bitset.png)\n\n#### Algorithm\n\n`beautifulSubsets` Method:\n- Call `countBeautifulSubsets` with initial parameters `nums`, `k`, `0`, and `0` to calculate the number of beautiful subsets of an array `nums` with a given difference `k`.\n- Return the result.\n\n`countBeautifulSubsets` Method:\n- It takes four parameters: `nums` (the array of integers), `difference` (`k`), `index` (the index of the current element being considered), and `mask` (an integer representing the current subset).\n- Base case: When we process the last index of `nums` (i.e., the index equals the size of `nums`), if `mask` is greater than `0` (i.e., indicating a non-empty subset), then return `1`; otherwise, return `0`.\n- Initialize a boolean variable `isBeautiful` to true.\n- Iterate through the elements before the current index to check if the current number forms a beautiful pair with any previous number in the subset.\n- Recursively calculate beautiful subsets including and excluding the current number.\n  - `skip`: Call `countBeautifulSubsets` with the next index and the same `mask`.\n  - `take`: If the current subset is beautiful, call `countBeautifulSubsets` with the next index and the updated `mask` (adding the current index to the `mask`); otherwise, set `take` to `0`.\n- Return the sum of `skip` and `take`.\n\n#### Implementation#### Complexity Analysis\n\nLet $n$ be the size of the `nums` array.\n\n* Time complexity: $O(n \\cdot 2^n)$\n\n    Each number in the input array `nums` can be either included or excluded in a subset, resulting in $2^n$ possible subsets.\n\n    Work done within each recursive call: The function iterates over the previous elements in the current subset to check if any pair satisfies the difference constraint. In the worst case, when all elements are included in the subset, the iteration takes $O(n)$ time.\n\n    Combining the number of recursive calls and the work done within each call, the overall time complexity will be $O(n \\cdot 2^n)$.\n\n* Space complexity: $O(n)$\n\n    The space complexity is dominated by the recursive call stack, which can grow up to the depth of the input array `nums`. Hence, the space complexity is $O(n)$.\n\n---\n\n### Approach 2: Recursion with Backtracking \n\n#### Intuition\n\nTo build subsets, we decide for each number in `nums` whether to include it in the subset or not. This creates two paths: one where we add the number to the subset and one where we don't.\n\nFor an array of size `n`, there can be up to $2^n$ subsets, as each element can either be included or excluded. At index `i`, we make two subsets: one with it and one without it. One of the subsets we create will be the empty subset, so we subtract 1 at the end to exclude it.\n\nTo ensure a \"beautiful\" subset, we need to check if neither `nums[i] + k` nor `nums[i] - k` has been used before. We can use a frequency map that will keep track of seen numbers. Before adding `nums[i]`, we check if neither `nums[i] + k` nor `nums[i] - k` is in the map. If both are absent, we add `nums[i]` to the subset.\n\nBut what if we know that before the current index `i`, there were no larger elements in the array? Then we only need to check for the existence of `nums[i] - k`. We don't even need to check for `nums[i] + k` because any element larger than `nums[i]` would not have been processed yet due to the sorted order. Therefore, we sort the array before starting the recursion.\n\nThis way, we only need to check for `nums[i] - k`, leading to fewer operations. \n\n#### Algorithm\n\n`beautifulSubsets` Method:\n- Initialize a `map` called `freqMap` to keep track of the frequency of elements.\n- Sort the `nums` array.\n- Call the `countBeautifulSubsets` method with parameters `nums`, `k`, `freqMap`, and `0`.\n- Subtract `1` from the result and return it.\n\n`countBeautifulSubsets` Method:\n- It takes four parameters: `nums` (given array), `difference` (given as `k`), `freqMap` (a map to keep track of element frequencies), and `i` (the index of the current element being considered).\n- Base case: If `i` is equal to the length of the array `nums`, return 1 (representing a subset of size 1).\n- Recursively call `countBeautifulSubsets` with `i + 1` to count subsets without including the current element.\n- Check if it's possible to include the current element `nums[i]` without violating the condition.\n  - If `nums[i] - k` is not present in `freqMap`, it means the difference condition is satisfied.\n  - Mark `nums[i]` as taken in `freqMap`.\n  - Recursively call `countBeautifulSubsets` with `i + 1` to count subsets including the current element.\n  - Backtrack: Mark `nums[i]` as not taken in `freqMap`.\n  - Remove `nums[i]` from `freqMap` if its count becomes 0.\n- Return the total count of beautiful subsets.\n\n#### Implementation#### Complexity Analysis\n\nLet $n$ be the size of `nums` array.\n\n- Time complexity: $O(2^n)$\n\n     The time complexity of the solution is primarily determined by the number of subsets generated. Since the algorithm explores all possible subsets of the input array, the maximum number of subsets that can be generated from an array of size $n$ is $2^n$\n\n    Additionally, sorting `nums` takes $O(n \\log n)$ time.\n\n    Therefore, the overall time complexity is $O(2^n)$, because it is dominated by the subset generation.\n\n- Space complexity: $O(n)$\n\n    Note that some extra space is used when we sort an array in place. The space complexity of the sorting algorithm depends on the programming language.\n    - In Python, the `sort` method sorts a list using the Tim Sort algorithm which is a combination of Merge Sort and Insertion Sort and has $O(n)$ additional space. Additionally, Tim Sort is designed to be a stable algorithm.\n    - In Java, `Arrays.sort()` is implemented using a variant of the Quick Sort algorithm which has a space complexity of $O( \\log n)$ for sorting an array.\n    - In C++, the `sort()` function is implemented as a hybrid of Quick Sort, Heap Sort, and Insertion Sort, with a worse-case space complexity of $O( \\log n)$. \n\n    The recursion stack space and the frequency map each use $O(n)$ space. Thus, the total space complexity is $O(n)$.\n\n---\n\n### Approach 3: Optimised Recursion (Deriving Recurrence Relation)\n\n#### Intuition\n\nIn the previous approach, we generated all possible subsets and checked each one to find the beautiful subsets. This lead to an exponential time complexity. However, we can optimize this approach by identifying certain cases where we can directly calculate the number of beautiful subsets without generating all subsets. What if there are no elements with a difference of `k` in the array?\n\nLet's understand this with a few examples:\n\n##### Direct Calculation of Beautiful Subsets:\n\n**Example 1: No Elements with Difference k**\n- Suppose `nums = [1, 3, 5, 7]` and `k = 1`. We observe that there are no pairs of elements in the array with a difference of `k` (i.e., 1). This means that every subset of this array is a beautiful subset. Therefore, we can directly return `2^n - 1` (subtracting 1 for the empty subset) as the number of beautiful subsets, without checking every subset.\n\n**Example 2: Handling Elements with Difference k**\n- Now, consider `nums = [1, 2, 3, 4]` and `k = 2`. Here, we notice that the difference of 2 can be achieved by pairs like (4, 2) and (3, 1). This means that if we include both elements of such a pair in the same subset, it will not be a beautiful subset. To handle this, we can separate the array into groups, where each group contains elements that cannot form a pair with a difference of `k` with any element from another group.\n\n##### Subsets Separation and Calculation:\n\nIn this example, we can separate the array into two groups: `s1 = [1, 3]` and `s2 = [2, 4]`. We can calculate the number of beautiful subsets for $s_1$ and $s_2$ separately, denoted as $f(s_1)$ and $f(s_2)$, because the choices in $s_1$ are independent of $s_2$ and vice versa.\n\nFor final answer, we can multiply $f(s_1)$ and $f(s_2)$ because there is no pair $(x_1, x_2)$ such that $x_1 ∈ s_1$ , $x_2 ∈ s_2$ and $∣x_1 − x_2∣ = k$\n\n##### Takeaway\n\nThe final answer would be $f(nums) = f(s_1) \\times f(s_2) - 1$ (subtracting 1 for the empty subset).\n\nIn general, we can separate the given array into groups such that there is no pair `(x1, x2)` with `x1` and `x2` belonging to different groups and `|x1 - x2| = k`. We can create these groups based on the remainder when each element is divided by `k`. For instance, if `nums = [1, 2, 3, 4, 5, 6]` and `k = 2`, we can create the groups: `s1: [2, 4, 6]` (where `nums[i] % k = 0`) and `s2: [1, 3, 5]` (where `nums[i] % k = 1`).\n\nNow consider `nums = [5, 5, 5, 7, 7, 11, 11]` and `k = 2`. We can't include `[5, 7]` in the same subset due to the restriction. We represent $s_1$ as `[5: 3, 7: 2, 11: 2]` (indicating the frequency of each value).\n\n##### Developing the Recurrence Relation:\n\nNow, let's derive the mathematical proof and recurrence relation for calculating the number of beautiful subsets.\n\nLet `f(i)` be the number of beautiful subsets in $s_1$ starting from index `i`. We want to calculate `f(0)`.\n\nWhen i = 0, the element is 5. There are two options: skip it or take it. There are $2^3$ ways we can include the three occurrences of `5` in subsets. $2^3 - 1 = 7$ of these take at least one 5, and one that skips 5.\n\n$take_{5} = 7$, $skip_{5} = 1$\n\nNow, the next element at i + 1 is 7 = 5 + 2 = 5 + k, so we can't take it if we took 5. Therefore, the number of ways of taking 5 will be $take_{5} \\times f(i + 2)$. \n\nThe number of ways of skipping 5 will be $skip_{5} \\times f(i + 1)$. \n\n$take_{s[i]} = 2 ^ {frequency(s[i])} - 1$\n\n$skip_{s[i]} = 1$\n\n$f(i) = take_{s[i]} \\times f(i + 2) + skip_{s[i]} \\times f(i + 1)$\n\n$f(0) = 7 \\times f(2) + 1 \\times f(1)$\n\nWhen i = 1, the value is 7. There are two options: $take_{7} = 2^2 - 1 = 3$ and $skip_{7} = 1$. The next element is 11 = 7 + 4 = 7 + 2k, so we can take it even if we took 7.\n\n$f(i) = take_{s[i]} \\times f(i + 1) + skip_{s[i]} \\times f(i + 1)$\n\n$f(1) = 3 \\times f(2) + 1 \\times f(2)$\n\nWhen i = 2, the value is 11. There are two options: $take_{11} = 2^2 - 1 = 3$ and $skip_{11} = 1$. There is not a next element. So, we will denote this as a base case $f(n) = 1$.\n\n$f(i) = take_{s[i]} \\times f(i + 1) + skip_{s[i]} \\times f(i + 1)$\n\n$f(2) = 3 \\times f(3) + 1 \\times f(3) = 3 \\times 1 + 1 \\times 1 = 4$\n\n$f(1) = 3 \\times f(2) + 1 \\times f(2) = 3 \\times 4 + 1 \\times 4 = 16$\n\n$f(0) = 7 \\times f(2) + 1 \\times f(1) = 7 \\times 4 + 1 \\times 16 = 44$\n\n$answer = f(0) - 1 = 43$\n\nThe general recurrence relation for `f(i)` will be:\n\n$f(i) = \\text{skip}_{s[i]} \\times f(i + 1) + \\text{take}_{s[i]} \\times \\begin{cases} f(i + 2) & \\text{if } s[i + 1] - s[i] = k \\\\ f(i + 1) & \\text{otherwise} \\end{cases}$\n\nIf we follow these steps, the final answer will be as listed below:\n1. Split the array into different groups, denoted $s_i$, based on their remainder when divided by $k$.\n2. Sort the groups and represent in {value:frequency} form.\n\n$\\text{answer} = \\left(\\prod_i f_{s_i}(0)\\right) - 1$\n\nThis approach optimizes the naive approach by avoiding the generation of all subsets and directly calculating the number of beautiful subsets based on the properties of the array and the value of `k`.\n\n\n#### Algorithm\n\n`beautifulSubsets` Method:\n- Initialize `totalCount` to 1.\n- Initialize a `map` called `freqMap` to track the frequency of elements based on their remainder when divided by `k`.\n- Calculate frequencies for each element in `nums` and update `freqMap`.\n- Iterate over each remainder group in `freqMap`.\n  - Convert the frequency map of each remainder group into an array of pairs (`subsets`) containing the element and its frequency.\n  - Call the `countBeautifulSubsets` method with parameters `subsets`, `subsets.size()`, `k`, and `0`.\n  - Multiply `totalCount` with the result of `countBeautifulSubsets` for each remainder group.\n- Return `totalCount - 1`.\n\n`countBeautifulSubsets` Method:\n- It takes four parameters: `subsets` (the array of pairs containing element frequencies), `numSubsets` (the number of subsets), `difference` (the given difference), and `i` (the index of the current subset being considered).\n- Base case: If `i` is equal to `numSubsets`, return 1 (representing a subset of size 1).\n- Calculate subsets where the current subset is not taken by recursively calling `countBeautifulSubsets` with `i + 1`.\n- Calculate subsets where the current subset is taken by multiplying `(1 << subsets[i].second) - 1` (which represents all possible combinations of taking elements from the current subset).\n- If the next number has a `difference`, calculate subsets recursively; otherwise, move to the next subset.\n- Return the sum of subsets where the current subset is taken and not taken.\n\n#### Implementation#### Complexity Analysis\n\nLet $n$ be the size of the nums array.  \n\n- Time complexity: $O(n \\log n + 2^n) = O(2^n)$\n\n    Since the map is sorted and implemented using a Self-Balancing Binary Search Tree (BST), the insert operation is $O(\\log n)$. Thus, constructing the map takes $O(n \\log n)$. With a maximum of $k$ different remainders, there can be up to $k$ subset splits. In the worst-case scenario, where all numbers have the same remainder, and none are repeated (frequency = 1), this approach still results in a time complexity of $O(2^n)$.\n\n   > In Python3 we use a `defaultdict`. Inserting a key-value pair into a dictionary takes $O(1)$ on average, resulting in a construction time of $O(n)$. Still, the overall time complexity remains $O(2^n)$.\n    \n- Space complexity: $O(n)$\n\n    The frequency map stores the count of elements based on their remainders when divided by `k`. In the worst case, this requires $O(n)$ space, as it needs to store counts for each element.\n\n    The depth of the recursive call stack can grow up to the number of unique elements in the subset list, which is at most $n$. Thus, the space used by the call stack is $O(n)$.\n\n    For the `counts` array, which is used for memoization, its size is equal to the number of unique elements in each subset list, which again can be up to $n$. This results in $O(n)$ space complexity for the `counts` array.\n\n    The `subsets` list, derived from the frequency map, stores pairs of element values and their counts. In the worst case, there could be $n$ such pairs, resulting in a space complexity of $O(n)$.\n    \n    So, overall, the space complexity is $O(n)$.\n\n---\n\n### Approach 4: Dynamic Programming - Memoization\n\n#### Intuition\n\nIn the previous approach we developed the recurrence relation for calculating the number of beautiful subsets.\n\nThe function `f(i)` calculates the number of beautiful subsets in the array `s` starting from index `i`. Now, instead of recomputing `f(i)` for the same index multiple times during recursion, we can memoize the function `f(i)` in a data structure, such as an array.\n\n> Memoization is a technique used to optimize recursive solutions by storing the results of expensive function calls and reusing them instead of recomputing them every time. \n\nSo whenever we need to compute `f(i)`, we first check if the result is already stored in the memoized array. If it is, we return the stored result; otherwise, we compute `f(i)`, store the result in the memoized array, and return the computed value.\n\nBy memoizing `f(i)`, we avoid redundant calculations and improve the overall time complexity of the solution.\n\n#### Algorithm\n \n`beautifulSubsets` Method:\n- Initialize `totalCount` to 1.\n- Initialize a `map` called `freqMap` to track the frequency of elements based on their remainder when divided by `k`.\n- Calculate frequencies for each element in `nums` and update `freqMap`.\n- Iterate over each remainder group in `freqMap`.\n  - Convert the frequency map of each remainder group into an array of pairs (`subsets`) containing the element and its frequency.\n  - Initialize an array called `counts` with size equal to the number of distinct elements in the current remainder group, filled with `-1` for memoization purposes.\n  - Call the `countBeautifulSubsets` method with parameters `subsets`, `subsets.size()`, `k`, `0`, and `counts`.\n  - Multipy `totalCount` with the result of `countBeautifulSubsets` for each remainder group.\n- Return `totalCount - 1`.\n\n`countBeautifulSubsets` Method:\n- It takes five parameters: `subsets` (the array of pairs containing element frequencies), `numSubsets` (the number of subsets), `difference` (the given difference), `i` (the index of the current subset being considered), and `counts` (an array to store counts of subsets for memoization).\n- Base case: If `i` is equal to `numSubsets`, return 1 (representing a subset of size 1).\n- If the count for the current subset has already been calculated (stored in `counts[i]`), return it.\n- Calculate subsets where the current subset is not taken by recursively calling `countBeautifulSubsets` with `i + 1`.\n- Calculate subsets where the current subset is taken by multiplying `(1 << subsets[i].second) - 1` (which represents all possible combinations of taking elements from the current subset).\n- If the next number has a difference of 'difference', calculate subsets accordingly by recursively calling `countBeautifulSubsets`; otherwise, move to the next subset.\n- Store the calculated count in `counts[i]` for memoization.\n- Return the sum of subsets where the current subset is taken and not taken.\n\n#### Implementation#### Complexity Analysis\n\nLet $n$ be the size of the nums array.\n\n- Time complexity: $O(n \\log n + n) = O(n \\log n)$ \n\n    We first group the numbers by their remainder modulo $k$, which takes $O(n)$ time. For each group, we sort its unique numbers, which takes $O(g \\log g)$ per group, where $g$ is the number of unique elements in that group. Across all $k$ remainder groups, this totals to $O(n \\log n)$ since the sum of all group sizes is at most $n$.\n\n    Then, for each group, we use memoized recursion to count all valid subsets. Each group of size $g$ contributes at most $O(g)$ recursive calls thanks to memoization (each index visited once). Across all groups, this step is bounded by $O(n)$.\n\n    Thus, the total time complexity is: $O(n + n \\log n + n) = O(n \\log n)$\n\n    > In Python3, `defaultdict` provides average-case $O(1)$ insertion time, so grouping the numbers by their remainder is $O(n)$, not $O(n \\log n)$ as would be the case in a language using a self-balancing BST (e.g., `TreeMap` in Java or `map` in C++).\n\n- Space complexity: $O(n)$\n\n    The frequency map stores the count of elements based on their remainders when divided by `k`. In the worst case, this requires $O(n)$ space, as it needs to store counts for each element.\n\n    The depth of the recursive call stack can grow up to the number of unique elements in the subset list, which is at most $n$. Thus, the space used by the call stack is $O(n)$.\n\n    For the `counts` array, which is used for memoization, its size is equal to the number of unique elements in each subset list, which again can be up to $n$. This results in $O(n)$ space complexity for the `counts` array.\n\n    The `subsets` list, derived from the frequency map, stores pairs of element values and their counts. In the worst case, there could be $n$ such pairs, resulting in a space complexity of $O(n)$.\n    \n    So, overall, the space complexity is $O(n)$.\n\n---\n\n### Approach 5: Dynamic Programming - Iterative \n\n#### Intuition\n\nWe can reduce the overhead needed to solve the problem by changing the recursive approach to an iterative one using Dynamic Programming (DP). Instead of making recursive calls, which require space on the call stack, we can use an array to store the values of `f(i)` for different indices `i`.\n\nTo calculate `f(i)`, we need to know the values of `f(i + 1)` and `f(i + 2)`. This is because when we include the element at index `i` in the subset, we need to check if the next element `nums[i + 1]` satisfies the condition `|nums[i + 1] - nums[i]| != k`. If it does, we can include it in the subset, and the number of beautiful subsets starting from `i + 1` is `f(i + 1)`. Otherwise, we need to skip `nums[i + 1]` and consider the number of beautiful subsets starting from `i + 2`, which is `f(i + 2)`.\n\nSince we need to know the values of `f(i + 1)` and `f(i + 2)` to compute `f(i)`, we need to fill the DP array from right to left, starting from the end of the array.\n\n#### Algorithm\n\n- Initialize `totalCount` to 1.\n- Initialize a `map` called `freqMap` to track the frequency of elements based on their remainder when divided by `k`.\n- Calculate frequencies for each element in `nums` and update `freqMap`.\n- Iterate over each remainder group in `freqMap`.\n  - Calculate the number of elements `n` in the current group.\n  - Convert the frequency map of each remainder group into an array of pairs (`subsets`) containing the element and its frequency.\n  - Initialize an array called `counts` with size `n + 1` to store counts of subsets.\n  - Initialize `counts[n]` to 1, representing the count of the last subset.\n  - Iterate from the second-to-last subset to the first one.\n    - Calculate subsets where the current subset is not taken (`skip`) by using the count of the next subset (`counts[i + 1]`).\n    - Calculate subsets where the current subset is taken (`take`) by multiplying `(1 << subsets[i].second) - 1` (representing all possible combinations of taking elements from the current subset) and the count of the next subset (`counts[i + 1]` or `count[i + 2]` depending on the difference condition).\n    - Store the total count for the current subset in `counts[i]`.\n  - Multiply `totalCount` with the count of the first subset (stored in `counts[0]`).\n- Return `totalCount - 1`.\n\nThe algorithm is visualized below:\n\n!?!../Documents/2597/approach5.json:960,333!?!\n\n#### Implementation#### Complexity Analysis\n\nLet $n$ be the size of the nums arrays. \n\n- Time complexity: $O(n \\log n)$\n\n    Since the map is sorted and implemented using a Self-Balancing Binary Search Tree (BST), the insert operation is $O(\\log n)$. Thus, constructing the map takes $O(n \\log n)$.\n    \n    Then, iterating through each remainder group and its associated numbers involves nested loops. In the worst-case scenario, each remainder group contains $n/k$ elements. The time complexity of iterating through each remainder group is $O(k \\cdot (n/k) \\log (n/k)) $. The number of groups is limited to $n$, and so is the group size. Therefore, we can we can simplify this to $O(n \\log n)$.\n\n- Space complexity: $O(n)$\n\n    The frequency map stores a remainder group for each unique remainder. Each remainder group stores an entry for each unique element in the group. In the worst case, when each element in `nums` is unique, $n$ elements will be stored across all of the remainder groups. \n    \n    For the `counts` array, which is used for memoization, its size is equal to the number of unique elements in each subset list, which again can be up to $n$. This results in $O(n)$ space complexity for the `counts` array.\n\n    The `subsets` list, derived from the frequency map, stores pairs of element values and their counts. In the worst case, there could be $n$ such pairs, resulting in a space complexity of $O(n)$.\n    \n    Therefore, the total space complexity is $O(n)$.\n\n---\n\n### Approach 6: Dynamic Programming - Optimized Iterative\n\n#### Intuition\n\nIn the previous iterative DP approach, we calculated the DP array in the reverse direction (right to left) of the array `s`. This was necessary because we needed to know the values of `f(i + 1)` and `f(i + 2)` to compute `f(i)`. However, the above approach required us to convert the sorted map (which represents the frequency of each element in the array) into an array (named `subsets`) first.\n\nThis conversion step can be avoided if we traverse the array(`s`) from left to right instead of right to left.\n\nBy traversing from left to right, we can directly use the sorted map and update the values of `f(i)` accordingly. This approach eliminates the need for the conversion step, thereby optimizing the time complexity.\n\nWe can also optimize space usage by observing that to calculate `f(i)`, we only need `f(i + 1)` and `f(i + 2)`. Storing `f(i + 3)` onwards is unnecessary, as those values are not required for further calculations.\n\nInstead of using an array to store all the values of `f(i)`, we will use three variables `curr`, `prev1`, and `prev2` to store the values of `f(i)`, `f(i + 1)`, and `f(i + 2)`, respectively. We can update these variables in each iteration, effectively reusing the same space instead of allocating new space for each index.\n\nThe core idea is that, when we traverse from left to right, we can keep track of the elements we have processed so far. For each new element, we can check if it satisfies the condition `|nums[i] - nums[j]| != k` for all previously processed elements `j`. If the condition is satisfied, we can include the current element in the subset and update the value of `f(i)` accordingly.\n\n#### Algorithm\n\n- Initialize `totalCount` to 1.\n- Initialize a `map` called `freqMap` to track the frequency of elements based on their remainder when divided by `k`.\n- Calculate frequencies for each element in `nums` and update `freqMap`.\n- Iterate over each remainder group in `freqMap`.\n  - Initialize variables `prevNum`, `prev1`, and `prev2`.\n  - Iterate through each number in the current remainder group.\n    - Calculate subsets where the current number is not taken (`skip`) by using the count of the previous number (`prev1`).\n    - Calculate subsets where the current number is taken (`take`) by multiplying `(1 << freq) - 1` (representing all possible combinations of taking elements with the current frequency) and the count of the previous number (`prev1` or `prev2` depending on whether the current number and the previous number form a beautiful pair).\n    - Store the total count for the current number in `curr`.\n    - Update `prev2` with the value of `prev1`, `prev1` with the value of `curr`, and `prevNum` with the current number.\n  - Multiply `totalCount` with the count of the last calculated number (stored in `curr`).\n- Return `totalCount - 1`.\n\n#### Implementation#### Complexity Analysis\n\nLet $n$ be the size of the nums array. \n\n- Time complexity: $O(n \\log n)$\n\n    The time complexity of this approach primarily arises from the operations on the map data structure. Since up to $n$ values are added to the frequency map, the sorting operation on the frequency map takes $O(n \\log n)$ time.\n    \n    Then, iterating through each remainder group and its associated numbers involves nested loops. In the worst-case scenario, each remainder group contains $n/k$ elements, where $n/k$ is a positive integer. The time complexity of iterating through each remainder group is $O(k \\cdot (n/k) \\log (n/k)) $, which we can simplify to $O(n \\log n)$.\n\n    > The $(\\log n)$ term arises from the usage of the map data structure in the code. map/TreeMap is implemented as a self-balancing binary search tree (such as Red-Black Tree) in C++/Java, which provides logarithmic time complexity for operations such as insertion, deletion, and retrieval.\n\n- Space complexity: $O(n)$\n\n    The frequency map stores a remainder group for each unique remainder. Each remainder group stores an entry for each unique element in the group. In the worst case, when each element in `nums` is unique, $n$ elements will be stored across all of the remainder groups. Therefore, the total space complexity is $O(n)$.\n\n---"
}