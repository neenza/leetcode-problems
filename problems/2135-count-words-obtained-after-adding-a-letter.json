{
  "title": "Count Words Obtained After Adding a Letter",
  "problem_id": "2256",
  "frontend_id": "2135",
  "difficulty": "Medium",
  "problem_slug": "count-words-obtained-after-adding-a-letter",
  "topics": [
    "Array",
    "Hash Table",
    "String",
    "Bit Manipulation",
    "Sorting"
  ],
  "description": "You are given two 0-indexed arrays of strings startWords and targetWords. Each string consists of lowercase English letters only.\nFor each string in targetWords, check if it is possible to choose a string from startWords and perform a conversion operation on it to be equal to that from targetWords.\nThe conversion operation is described in the following two steps:\nReturn the number of strings in targetWords that can be obtained by performing the operations on any string of startWords.\nNote that you will only be verifying if the string in targetWords can be obtained from a string in startWords by performing the operations. The strings in startWords do not actually change during this process.\nExample 1:\nExample 2:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: startWords = [\"ant\",\"act\",\"tack\"], targetWords = [\"tack\",\"act\",\"acti\"]\nOutput: 2\nExplanation:\n- In order to form targetWords[0] = \"tack\", we use startWords[1] = \"act\", append 'k' to it, and rearrange \"actk\" to \"tack\".\n- There is no string in startWords that can be used to obtain targetWords[1] = \"act\".\n  Note that \"act\" does exist in startWords, but we must append one letter to the string before rearranging it.\n- In order to form targetWords[2] = \"acti\", we use startWords[1] = \"act\", append 'i' to it, and rearrange \"acti\" to \"acti\" itself.",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input: startWords = [\"ab\",\"a\"], targetWords = [\"abc\",\"abcd\"]\nOutput: 1\nExplanation:\n- In order to form targetWords[0] = \"abc\", we use startWords[0] = \"ab\", add 'c' to it, and rearrange it to \"abc\".\n- There is no string in startWords that can be used to obtain targetWords[1] = \"abcd\".",
      "images": []
    }
  ],
  "constraints": [
    "1 <= startWords.length, targetWords.length <= 5 * 104",
    "1 <= startWords[i].length, targetWords[j].length <= 26",
    "Each string of startWords and targetWords consists of lowercase English letters only.",
    "No letter occurs more than once in any string of startWords or targetWords."
  ],
  "follow_ups": [],
  "hints": [
    "Which data structure can be used to efficiently check if a string exists in startWords?",
    "After appending a letter, all letters of a string can be rearranged in any possible way. How can we use this to reduce our search space while checking if a string in targetWords can be obtained from a string in startWords?"
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    int wordCount(vector<string>& startWords, vector<string>& targetWords) {\n        \n    }\n};",
    "java": "class Solution {\n    public int wordCount(String[] startWords, String[] targetWords) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def wordCount(self, startWords, targetWords):\n        \"\"\"\n        :type startWords: List[str]\n        :type targetWords: List[str]\n        :rtype: int\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def wordCount(self, startWords: List[str], targetWords: List[str]) -> int:\n        ",
    "c": "int wordCount(char** startWords, int startWordsSize, char** targetWords, int targetWordsSize) {\n    \n}",
    "csharp": "public class Solution {\n    public int WordCount(string[] startWords, string[] targetWords) {\n        \n    }\n}",
    "javascript": "/**\n * @param {string[]} startWords\n * @param {string[]} targetWords\n * @return {number}\n */\nvar wordCount = function(startWords, targetWords) {\n    \n};",
    "typescript": "function wordCount(startWords: string[], targetWords: string[]): number {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param String[] $startWords\n     * @param String[] $targetWords\n     * @return Integer\n     */\n    function wordCount($startWords, $targetWords) {\n        \n    }\n}",
    "swift": "class Solution {\n    func wordCount(_ startWords: [String], _ targetWords: [String]) -> Int {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun wordCount(startWords: Array<String>, targetWords: Array<String>): Int {\n        \n    }\n}",
    "dart": "class Solution {\n  int wordCount(List<String> startWords, List<String> targetWords) {\n    \n  }\n}",
    "golang": "func wordCount(startWords []string, targetWords []string) int {\n    \n}",
    "ruby": "# @param {String[]} start_words\n# @param {String[]} target_words\n# @return {Integer}\ndef word_count(start_words, target_words)\n    \nend",
    "scala": "object Solution {\n    def wordCount(startWords: Array[String], targetWords: Array[String]): Int = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn word_count(start_words: Vec<String>, target_words: Vec<String>) -> i32 {\n        \n    }\n}",
    "racket": "(define/contract (word-count startWords targetWords)\n  (-> (listof string?) (listof string?) exact-integer?)\n  )",
    "erlang": "-spec word_count(StartWords :: [unicode:unicode_binary()], TargetWords :: [unicode:unicode_binary()]) -> integer().\nword_count(StartWords, TargetWords) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec word_count(start_words :: [String.t], target_words :: [String.t]) :: integer\n  def word_count(start_words, target_words) do\n    \n  end\nend"
  }
}