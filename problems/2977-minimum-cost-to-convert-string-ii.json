{
  "title": "Minimum Cost to Convert String II",
  "problem_id": "3238",
  "frontend_id": "2977",
  "difficulty": "Hard",
  "problem_slug": "minimum-cost-to-convert-string-ii",
  "topics": [
    "Array",
    "String",
    "Dynamic Programming",
    "Graph",
    "Trie",
    "Shortest Path"
  ],
  "description": "You are given two 0-indexed strings source and target, both of length n and consisting of lowercase English characters. You are also given two 0-indexed string arrays original and changed, and an integer array cost, where cost[i] represents the cost of converting the string original[i] to the string changed[i].\nYou start with the string source. In one operation, you can pick a substring x from the string, and change it to y at a cost of z if there exists any index j such that cost[j] == z, original[j] == x, and changed[j] == y. You are allowed to do any number of operations, but any pair of operations must satisfy either of these two conditions:\nReturn the minimum cost to convert the string source to the string target using any number of operations. If it is impossible to convert source to target, return -1.\nNote that there may exist indices i, j such that original[j] == original[i] and changed[j] == changed[i].\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: source = \"abcd\", target = \"acbe\", original = [\"a\",\"b\",\"c\",\"c\",\"e\",\"d\"], changed = [\"b\",\"c\",\"b\",\"e\",\"b\",\"e\"], cost = [2,5,5,1,2,20]\nOutput: 28\nExplanation: To convert \"abcd\" to \"acbe\", do the following operations:\n- Change substring source[1..1] from \"b\" to \"c\" at a cost of 5.\n- Change substring source[2..2] from \"c\" to \"e\" at a cost of 1.\n- Change substring source[2..2] from \"e\" to \"b\" at a cost of 2.\n- Change substring source[3..3] from \"d\" to \"e\" at a cost of 20.\nThe total cost incurred is 5 + 1 + 2 + 20 = 28. \nIt can be shown that this is the minimum possible cost.",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input: source = \"abcdefgh\", target = \"acdeeghh\", original = [\"bcd\",\"fgh\",\"thh\"], changed = [\"cde\",\"thh\",\"ghh\"], cost = [1,3,5]\nOutput: 9\nExplanation: To convert \"abcdefgh\" to \"acdeeghh\", do the following operations:\n- Change substring source[1..3] from \"bcd\" to \"cde\" at a cost of 1.\n- Change substring source[5..7] from \"fgh\" to \"thh\" at a cost of 3. We can do this operation because indices [5,7] are disjoint with indices picked in the first operation.\n- Change substring source[5..7] from \"thh\" to \"ghh\" at a cost of 5. We can do this operation because indices [5,7] are disjoint with indices picked in the first operation, and identical with indices picked in the second operation.\nThe total cost incurred is 1 + 3 + 5 = 9.\nIt can be shown that this is the minimum possible cost.",
      "images": []
    },
    {
      "example_num": 3,
      "example_text": "Input: source = \"abcdefgh\", target = \"addddddd\", original = [\"bcd\",\"defgh\"], changed = [\"ddd\",\"ddddd\"], cost = [100,1578]\nOutput: -1\nExplanation: It is impossible to convert \"abcdefgh\" to \"addddddd\".\nIf you select substring source[1..3] as the first operation to change \"abcdefgh\" to \"adddefgh\", you cannot select substring source[3..7] as the second operation because it has a common index, 3, with the first operation.\nIf you select substring source[3..7] as the first operation to change \"abcdefgh\" to \"abcddddd\", you cannot select substring source[1..3] as the second operation because it has a common index, 3, with the first operation.",
      "images": []
    }
  ],
  "constraints": [
    "1 <= source.length == target.length <= 1000",
    "source, target consist only of lowercase English characters.",
    "1 <= cost.length == original.length == changed.length <= 100",
    "1 <= original[i].length == changed[i].length <= source.length",
    "original[i], changed[i] consist only of lowercase English characters.",
    "original[i] != changed[i]",
    "1 <= cost[i] <= 106"
  ],
  "follow_ups": [],
  "hints": [
    "Give each unique string in <code>original</code> and <code>changed</code> arrays a unique id. There are at most <code>2 * m</code> unique strings in total where <code>m</code> is the length of the arrays. We can put them into a hash map to assign ids.",
    "We can pre-compute the smallest costs between all pairs of unique strings using Floyd Warshall algorithm in <code>O(m ^ 3)</code> time complexity.",
    "Let <code>dp[i]</code> be the smallest cost to change the first <code>i</code> characters (prefix) of <code>source</code> into <code>target</code>, leaving the suffix untouched.\r\nWe have <code>dp[0] = 0</code>.\r\n<code>dp[i] = min(\r\ndp[i - 1] if (source[i - 1] == target[i - 1]),\r\ndp[j-1] + cost[x][y] where x is the id of source[j..(i - 1)] and y is the id of target e[j..(i - 1)])\r\n)</code>.\r\nIf neither of the two conditions is satisfied, <code>dp[i] = infinity</code>.",
    "We can use Trie to check for the second condition in <code>O(1)</code>.",
    "The answer is <code>dp[n]</code> where <code>n</code> is <code>source.length</code>."
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    long long minimumCost(string source, string target, vector<string>& original, vector<string>& changed, vector<int>& cost) {\n        \n    }\n};",
    "java": "class Solution {\n    public long minimumCost(String source, String target, String[] original, String[] changed, int[] cost) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def minimumCost(self, source, target, original, changed, cost):\n        \"\"\"\n        :type source: str\n        :type target: str\n        :type original: List[str]\n        :type changed: List[str]\n        :type cost: List[int]\n        :rtype: int\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def minimumCost(self, source: str, target: str, original: List[str], changed: List[str], cost: List[int]) -> int:\n        ",
    "c": "long long minimumCost(char* source, char* target, char** original, int originalSize, char** changed, int changedSize, int* cost, int costSize) {\n    \n}",
    "csharp": "public class Solution {\n    public long MinimumCost(string source, string target, string[] original, string[] changed, int[] cost) {\n        \n    }\n}",
    "javascript": "/**\n * @param {string} source\n * @param {string} target\n * @param {string[]} original\n * @param {string[]} changed\n * @param {number[]} cost\n * @return {number}\n */\nvar minimumCost = function(source, target, original, changed, cost) {\n    \n};",
    "typescript": "function minimumCost(source: string, target: string, original: string[], changed: string[], cost: number[]): number {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param String $source\n     * @param String $target\n     * @param String[] $original\n     * @param String[] $changed\n     * @param Integer[] $cost\n     * @return Integer\n     */\n    function minimumCost($source, $target, $original, $changed, $cost) {\n        \n    }\n}",
    "swift": "class Solution {\n    func minimumCost(_ source: String, _ target: String, _ original: [String], _ changed: [String], _ cost: [Int]) -> Int {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun minimumCost(source: String, target: String, original: Array<String>, changed: Array<String>, cost: IntArray): Long {\n        \n    }\n}",
    "dart": "class Solution {\n  int minimumCost(String source, String target, List<String> original, List<String> changed, List<int> cost) {\n    \n  }\n}",
    "golang": "func minimumCost(source string, target string, original []string, changed []string, cost []int) int64 {\n    \n}",
    "ruby": "# @param {String} source\n# @param {String} target\n# @param {String[]} original\n# @param {String[]} changed\n# @param {Integer[]} cost\n# @return {Integer}\ndef minimum_cost(source, target, original, changed, cost)\n    \nend",
    "scala": "object Solution {\n    def minimumCost(source: String, target: String, original: Array[String], changed: Array[String], cost: Array[Int]): Long = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn minimum_cost(source: String, target: String, original: Vec<String>, changed: Vec<String>, cost: Vec<i32>) -> i64 {\n        \n    }\n}",
    "racket": "(define/contract (minimum-cost source target original changed cost)\n  (-> string? string? (listof string?) (listof string?) (listof exact-integer?) exact-integer?)\n  )",
    "erlang": "-spec minimum_cost(Source :: unicode:unicode_binary(), Target :: unicode:unicode_binary(), Original :: [unicode:unicode_binary()], Changed :: [unicode:unicode_binary()], Cost :: [integer()]) -> integer().\nminimum_cost(Source, Target, Original, Changed, Cost) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec minimum_cost(source :: String.t, target :: String.t, original :: [String.t], changed :: [String.t], cost :: [integer]) :: integer\n  def minimum_cost(source, target, original, changed, cost) do\n    \n  end\nend"
  }
}