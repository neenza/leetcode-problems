{
  "title": "Relative Ranks",
  "problem_id": "506",
  "frontend_id": "506",
  "difficulty": "Easy",
  "problem_slug": "relative-ranks",
  "topics": [
    "Array",
    "Sorting",
    "Heap (Priority Queue)"
  ],
  "description": "You are given an integer array score of size n, where score[i] is the score of the ith athlete in a competition. All the scores are guaranteed to be unique.\nThe athletes are placed based on their scores, where the 1st place athlete has the highest score, the 2nd place athlete has the 2nd highest score, and so on. The placement of each athlete determines their rank:\nReturn an array answer of size n where answer[i] is the rank of the ith athlete.\nExample 1:\nExample 2:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: score = [5,4,3,2,1]\nOutput: [\"Gold Medal\",\"Silver Medal\",\"Bronze Medal\",\"4\",\"5\"]\nExplanation: The placements are [1st, 2nd, 3rd, 4th, 5th].",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input: score = [10,3,8,9,4]\nOutput: [\"Gold Medal\",\"5\",\"Bronze Medal\",\"Silver Medal\",\"4\"]\nExplanation: The placements are [1st, 5th, 3rd, 2nd, 4th].",
      "images": []
    }
  ],
  "constraints": [
    "n == score.length",
    "1 <= n <= 104",
    "0 <= score[i] <= 106",
    "All the values in score are unique."
  ],
  "follow_ups": [],
  "hints": [],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    vector<string> findRelativeRanks(vector<int>& score) {\n        \n    }\n};",
    "java": "class Solution {\n    public String[] findRelativeRanks(int[] score) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def findRelativeRanks(self, score):\n        \"\"\"\n        :type score: List[int]\n        :rtype: List[str]\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def findRelativeRanks(self, score: List[int]) -> List[str]:\n        ",
    "c": "/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nchar** findRelativeRanks(int* score, int scoreSize, int* returnSize) {\n    \n}",
    "csharp": "public class Solution {\n    public string[] FindRelativeRanks(int[] score) {\n        \n    }\n}",
    "javascript": "/**\n * @param {number[]} score\n * @return {string[]}\n */\nvar findRelativeRanks = function(score) {\n    \n};",
    "typescript": "function findRelativeRanks(score: number[]): string[] {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param Integer[] $score\n     * @return String[]\n     */\n    function findRelativeRanks($score) {\n        \n    }\n}",
    "swift": "class Solution {\n    func findRelativeRanks(_ score: [Int]) -> [String] {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun findRelativeRanks(score: IntArray): Array<String> {\n        \n    }\n}",
    "dart": "class Solution {\n  List<String> findRelativeRanks(List<int> score) {\n    \n  }\n}",
    "golang": "func findRelativeRanks(score []int) []string {\n    \n}",
    "ruby": "# @param {Integer[]} score\n# @return {String[]}\ndef find_relative_ranks(score)\n    \nend",
    "scala": "object Solution {\n    def findRelativeRanks(score: Array[Int]): Array[String] = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn find_relative_ranks(score: Vec<i32>) -> Vec<String> {\n        \n    }\n}",
    "racket": "(define/contract (find-relative-ranks score)\n  (-> (listof exact-integer?) (listof string?))\n  )",
    "erlang": "-spec find_relative_ranks(Score :: [integer()]) -> [unicode:unicode_binary()].\nfind_relative_ranks(Score) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec find_relative_ranks(score :: [integer]) :: [String.t]\n  def find_relative_ranks(score) do\n    \n  end\nend"
  },
  "solution": "[TOC]\n\n## Solution\n\n---\n\n### Overview\n\nGiven an array `score` with athletes' scores, we need to return their rank. The athlete with the highest score has the lowest place, and the athlete with the second-highest score will have the second-lowest place, and so on. The athletes in first, second, and third place receive gold, silver, and bronze medals, respectively. All other athletes receive their place as their rank.\n\n**Key Observation:**\n- All the scores are guaranteed to be unique.\n\n---\n\n### Approach 1: Sort & Reverse\n\n#### Intuition\n\nConsider Example 1 from the problem description: \n\n> **Input:** `score` = [5, 4, 3, 2, 1]\nPlacements: [1st, 2nd, 3rd, 4th, 5th]\n\nThe placements are assigned in order for this example. This works because the scores are given in decreasing order.\n\nWhen the scores are sorted in decreasing order, each athlete gets assigned the next place.\n\nWe can start developing a solution by sorting the `score` array in decreasing order.\n\nConsider Example 2 from the problem description: \n\n> **Input:** `score` = [10, 3, 8, 9, 4]\n`score` sorted in decreasing order: [10, 9, 8, 4, 3]\nPlacements: [1st, 2nd, 3rd, 4th, 5th]\n\nFor this example, we now have the scores and placements, but because we sorted `score`, we don't know the order the placements should be in the result.\n\nWe can solve this by saving each athlete's original index in a hashmap before sorting the `score` array. The key is the athlete's score, and the value is the athlete's original index.\n\n`scoreToIndex` hashmap: [10 ⟶ 0, 3 ⟶ 1, 8 ⟶ 2, 9 ⟶ 3, 4 ⟶ 4]\n\nThen, we can use the hashmap and the sorted `score` array to add the athletes' ranks to the correct index in the result.\n\n`score` sorted in decreasing order: [10, 9, 8, 4, 3]\n`scoreToIndex` hashmap: [10 ⟶ 0, 3 ⟶ 1, 8 ⟶ 2, 9 ⟶ 3, 4 ⟶ 4]\n\n- Place the 1st ranked athlete, who scored 10, at index 0.\n- Place the 2nd ranked athlete, who scored 9, at index 3.\n- Place the 3rd ranked athlete, who scored 8, at index 2.\n- Place the 4th ranked athlete, who scored 4, at index 4.\n- Place the 5th ranked athlete, who scored 3, at index 1.\n\nFor places 1st, 2nd, and 3rd, we assign medals.\n\n`rank`:\n| index | 0            | 1   | 2              | 3              |   4 |\n| ------| ------------ | --- | -------------- | -------------- | --- |\n| rank  | \"Gold Medal\" | \"5\" | \"Bronze Medal\" | \"Silver Medal\" | \"4\" |\n\n> Output: [\"Gold Medal\", \"5\", \"Bronze Medal\", \"Silver Medal\", \"4\"]\n\n#### Algorithm\n\n1. Initialize a variable `N` to the length of the `score` array.\n2. Initialize a hashmap `scoreToIndex` and save the original index of each athlete based on their `score`. The key is the `score` and the value is the original index.\n3. Sort the `score` array in descending order. Then, the scores will be in order from highest to lowest. Since the highest score corresponds to the lowest place, this means the places will be in order.\n4. Initialize a string array `rank` of size `N` for storing the result.\n5. Assign ranks to athletes. We use the `scoreToIndex` hashmap to retrieve the index in the result of the athlete with `score[i]`. For each rank `i`:\n    - If `i` is `0`, assign the athlete the \"Gold Medal\".\n    - If `i` is `1`, assign the athlete the \"Silver Medal\".\n    - If `i` is `2`, assign the athlete the \"Bronze Medal\".\n    - Otherwise, set `rank[score_to_index[score[i]]] = str(i + 1)`.\n6. Return `rank`.\n\n#### Implementation\n\n> **Notes:** \n> - The best practice is to not modify the input, so we create a copy of the `score` array in the below implementation. We sort the copy, leaving the original array unmodified.\n>\n> - Java does not have a built-in ability to sort an array in reverse order. Therefore, we sort the score array in ascending order and then traverse the array in reverse order using `n - i - 1` when we assign ranks to the athletes.#### Complexity Analysis\n\n​Let $n$ be the length of `score`.\n​\n* Time complexity: $O(n \\log n)$\n\n    We traverse the score array once and populate `scoreToIndex`. Since inserting in a hashmap takes $O(1)$ time on average, the entire operation takes $O(n)$. Collisions are unlikely since the scores are guaranteed to be unique according to the constraints.\n  \n    Sorting the the score array array takes $O(n \\log n)$.\n  \n    Finally, traversing the score array and assigning ranks to athletes takes $O(n)$.\n  \n    The dominating term is $O(n \\log n)$.\n​\n* Space complexity: $O(n)$\n\n    The hashmap `scoreToIndex` stores $n$ `(key, value)` mappings, so it requires $O(n)$ auxiliary space.\n  \n    The `rank` array is only used to store the result, so it does not contribute towards the space complexity. \n  \n    Note that some extra space is used when we sort the score array. The space complexity of the sorting algorithm depends on the programming language.\n    - In Python, the `sort` method sorts a list using the Timsort algorithm which is a combination of Merge Sort and Insertion Sort and has $O(n)$ additional space. \n    - In Java, Arrays.sort() is implemented using a variant of the Quick Sort algorithm which has a space complexity of $O( \\log n)$ for sorting two arrays.\n    - In C++, the sort() function is implemented as a hybrid of Quick Sort, Heap Sort, and Insertion Sort, with a worse-case space complexity of $O( \\log n )$.\n\n    $O(n)$ is the dominating term.\n\n---\n\n### Approach 2: Heap (Priority Queue)\n\n#### Intuition\n\nWhen we assign placements, we assign the next place to the next highest score.\n\nTo assign ranks, we can make use of a max heap. By adding all scores to a heap and subsequently removing them, they'll be in descending order.\n\nHeaps are a data structure that allows us to efficiently find the maximum or minimum value in a dataset. If you are not familiar with heaps, we recommend checking out the [Heap Explore Card](https://leetcode.com/explore/learn/card/heap/).\n\nAs discussed in the previous solution, we need to save each athlete's original index in the `score` array. For each athlete, we will create a `score, index` pair and push it to the heap.\n\nThen, we assign ranks by removing each athlete from the heap and storing their corresponding index as `originalIndex`. We assign the current athlete the next rank and place the rank in the `rank` array at index `originalIndex`. The first three ranks receive medals.\n\n#### Algorithm\n\n1. Initialize a variable `N` to the length of the `score` array.\n2. Initialize a max-heap (priority queue) that will store `(score, index)` pairs.\n3. For each index in `score`, add a pair to the heap with the score and index.\n4. Initialize a string array `rank` of size `N` for storing the answer.\n5. Initialize a varaible `place` to `1`.\n6. Assign ranks to athletes. While the heap is not empty:\n    - Pop the pair with the highest score from the heap. Save the index in `originalIndex`. \n    - Add the corresponding place to the `rank` array at index `originalIndex`:\n        - If `place` is `1`, assign the athlete the \"Gold Medal\".\n        - If `place` is `2`, assign the athlete the \"Silver Medal\".\n        - If `place` is `3`, assign the athlete the \"Bronze Medal\".\n        - Otherwise, set `rank[originalIndex] = str(place)`.\n    - Increment `place`.\n7. Return `rank`.\n\n\n#### Implementation\n\n> **Note:** The Python3 heap implementation is a min-heap by default. We achieve max-heap behavior in the above solution by negating the score when we add it to the heap. Scores with the highest absolute values have the lowest negative values.#### Complexity Analysis\n\n​Let $n$ be the length of `score`.\n​\n* Time complexity: $O(n \\log n)$\n\n  We traverse the `score` array once and populate the `heap` with each score. Adding an element to the heap takes $\\log n$ time, resulting in a time complexity of $O(n \\log n)$ for this step.\n  \n  When assigning ranks to athletes, we pop each pair from the heap. Removing an element from the heap also takes $\\log n$ time, so removing $n$ elements will take $O(n \\log n)$ time.\n  \n  The overall time complexity is $O(2n \\log n)$, which we can simplify to $O(n \\log n)$.\n​\n* Space complexity: $O(n)$\n\n  The `heap` stores $n$ `(score, index)` pairs, so it requires $O(n)$ auxiliary space.\n  \n  The `rank` array is only used to store the result, so it does not contribute towards the space complexity. \n\n---\n\n### Approach 3: Array as Map\n\n#### Intuition\n\nThe above approaches both have log-linear time complexities. Let's develop a more efficient approach.\n\nIn the first approach, we used a hashmap to save the original indices of the athletes. An alternative to using a map is an array.\n\nWe can use an array `scoreToIndex` to store the athletes' original indices. The \"key\" is the score, and the \"value\" is the original index of the athlete. An athlete's original index can be found at `scoreToIndex[score[i]]`. For example, the original index of an athlete with the score `5` is stored at `scoreToIndex[5]`.\n\nConsider the example `score = [10, 3, 8, 9, 4]`.\n\nThe range of scores may not be equal to the number of athletes. Therefore, we must ensure that the `scoreToIndex` array is large enough to store the entire range of scores. As a result, we will begin by identifying the maximum score, and then declare our array `scoreToIndex` to be of size one greater than that maximum score.\n\nThere may be some indices in the `scoreToIndex` array that do not store indices of athletes, as the array may be larger than the number of athletes. Indices that do not correspond to athletes will contain `0` by default. One athlete will have the original index `0`, which cannot be differentiated from the default `0` indices if we store the athlete's original indices directly, we address this issue by adding one when adding the athletes to the `scoreToIndex` array. Later, when we iterate through the original indices, we subtract one to obtain the correct original index.\n\nThe indices of the `scoreToindex` array represent the scores. The highest score corresponds to the lowest rank, and the second-highest score corresponds to the second-lowest rank, and so on. \n\nIn the first approach, we reversed the scores so we could easily determine the ranks. We can mimic this strategy by traversing the `scoreToIndex` in reverse, from the highest index to the lowest index. We can use a variable `place` to track the placement, and we can find the position in the `rank` array by saving `scoreToIndex[i] - 1` as the `orignalIndex`.\n\n**Example:**\n\n> **Input:** `score` = [10, 3, 8, 9, 4]\n\nThe max score is 10.\n\n`scoreToIndex`:\n| index            | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 |\n| ---------------- | - | - | - | - | - | - | - | - | - | - | -  |\n|original index + 1| 0 | 0 | 0 | 2 | 5 | 0 | 0 | 0 | 3 | 4 | 1  |\n \n- Place the 1st ranked athlete, who scored 10, at index 1 - 1 = 0.\n- Place the 2nd ranked athlete, who scored 9, at index 4 - 1 = 3.\n- Place the 3rd ranked athlete, who scored 8, at index 3 - 1 = 2.\n- Place the 4th ranked athlete, who scored 4, at index 5 - 1 = 4.\n- Place the 5th ranked athlete, who scored 3, at index 2 - 1 = 1.\n\nFor places 1st, 2nd, and 3rd, we assign medals.\n\n`rank`:\n| index | 0            | 1   | 2              | 3              |   4 |\n| ----- | ------------ | --- | -------------- | -------------- | --- |\n| rank  | \"Gold Medal\" | \"5\" | \"Bronze Medal\" | \"Silver Medal\" | \"4\" |\n\n> **Output:** Output: [\"Gold Medal\", \"5\", \"Bronze Medal\", \"Silver Medal\", \"4\"]\n\nIn this approach, we use a constant string array to store the medals. We use `MEDALS[place - 1]` to assign medals to the first three places instead of using an `if` statement for each medal.\n\n#### Algorithm\n\n1. Initialize a variable `N` to the length of the `score` array.\n2. Define a function `findMax` that returns the maximum score in the array.\n    - Initialize a variable `maxScore` to `0`.\n    - For each score in the `score` array, if the score is greater than `maxScore`, update `maxScore` to the new score.\n    - Return `maxScore`.\n3. Initialize a variable `M` to the result of `findMax(score)`.\n4. Initialize an array `scoretoIndex` of size `M + 1`. For each score `i` in the score array, set `scoreToIndex[score[i]]` to `i + 1`.\n5. Create a constant string array to store the `MEDALS`: `[\"Gold Medal\", \"Silver Medal\", \"Bronze Medal\"]`.\n6. Initialize a string array `rank` of size `N` for storing the answer.\n7. Initialize a variable `place` to `1`.\n8. Assign ranks to athletes using a `for` loop. For each nonzero entry of `scoreToIndex`, `i`, starting with the last and moving to the first:\n    - Set a variable `originalIndex` to `scoreToIndex[i] - 1`.\n    - Add the place to the `rank` array at index `originalIndex`:\n        - If `place` is less than `4`, assign the athlete `medals[place - 1]`.\n        - Otherwise, set `rank[originalIndex] = str(place)`.\n    - Increment `place`.\n9. Return `rank`.\n\n#### Implementation#### Complexity Analysis\n\n​Let $n$ be the length of `score` and $m$ be the maximum value in the array.\n​\n* Time complexity: $O(n + m)$\n\n  The `findMax` function takes $O(n)$ because it traverses `score` once. We call this function once.\n\n  Populating `scoreToIndex` takes $O(n)$ because we add one entry for each athlete.\n\n  When we assign ranks to athletes, we iterate through every index of the `scoreToIndex` array, which is size $m + 1$. The operations within the loop take constant time, so this step takes $O(m)$.\n  \n  The overall time complexity is $O(2n + m)$, which we can simplify to $O(n + m)$.\n​\n* Space complexity: $O(m)$\n\n  The `scoreToIndex` array is size $m + 1$.\n\n  The `rank` array is only used to store the result, so it does not contribute towards the space complexity. \n\n  Therefore, the overall space complexity is $O(m)$.\n\n---"
}