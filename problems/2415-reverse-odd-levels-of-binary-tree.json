{
  "title": "Reverse Odd Levels of Binary Tree",
  "problem_id": "2493",
  "frontend_id": "2415",
  "difficulty": "Medium",
  "problem_slug": "reverse-odd-levels-of-binary-tree",
  "topics": [
    "Tree",
    "Depth-First Search",
    "Breadth-First Search",
    "Binary Tree"
  ],
  "description": "Given the root of a perfect binary tree, reverse the node values at each odd level of the tree.\nReturn the root of the reversed tree.\nA binary tree is perfect if all parent nodes have two children and all leaves are on the same level.\nThe level of a node is the number of edges along the path between it and the root node.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: root = [2,3,5,8,13,21,34]\nOutput: [2,5,3,8,13,21,34]\nExplanation: \nThe tree has only one odd level.\nThe nodes at level 1 are 3, 5 respectively, which are reversed and become 5, 3.",
      "images": [
        "https://assets.leetcode.com/uploads/2022/07/28/first_case1.png"
      ]
    },
    {
      "example_num": 2,
      "example_text": "Input: root = [7,13,11]\nOutput: [7,11,13]\nExplanation: \nThe nodes at level 1 are 13, 11, which are reversed and become 11, 13.",
      "images": [
        "https://assets.leetcode.com/uploads/2022/07/28/second_case3.png"
      ]
    },
    {
      "example_num": 3,
      "example_text": "Input: root = [0,1,2,0,0,0,0,1,1,1,1,2,2,2,2]\nOutput: [0,2,1,0,0,0,0,2,2,2,2,1,1,1,1]\nExplanation: \nThe odd levels have non-zero values.\nThe nodes at level 1 were 1, 2, and are 2, 1 after the reversal.\nThe nodes at level 3 were 1, 1, 1, 1, 2, 2, 2, 2, and are 2, 2, 2, 2, 1, 1, 1, 1 after the reversal.",
      "images": [
        "https://assets.leetcode.com/uploads/2022/07/28/second_case3.png"
      ]
    }
  ],
  "constraints": [
    "The number of nodes in the tree is in the range [1, 214].",
    "0 <= Node.val <= 105",
    "root is a perfect binary tree."
  ],
  "follow_ups": [],
  "hints": [
    "Try to solve recursively for each level independently.",
    "While performing a depth-first search, pass the left and right nodes (which should be paired) to the next level. If the current level is odd, then reverse their values, or else recursively move to the next level."
  ],
  "code_snippets": {
    "cpp": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* reverseOddLevels(TreeNode* root) {\n        \n    }\n};",
    "java": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public TreeNode reverseOddLevels(TreeNode root) {\n        \n    }\n}",
    "python": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def reverseOddLevels(self, root):\n        \"\"\"\n        :type root: Optional[TreeNode]\n        :rtype: Optional[TreeNode]\n        \"\"\"\n        ",
    "python3": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def reverseOddLevels(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\n        ",
    "c": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     struct TreeNode *left;\n *     struct TreeNode *right;\n * };\n */\nstruct TreeNode* reverseOddLevels(struct TreeNode* root) {\n    \n}",
    "csharp": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public int val;\n *     public TreeNode left;\n *     public TreeNode right;\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\npublic class Solution {\n    public TreeNode ReverseOddLevels(TreeNode root) {\n        \n    }\n}",
    "javascript": "/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {TreeNode}\n */\nvar reverseOddLevels = function(root) {\n    \n};",
    "typescript": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nfunction reverseOddLevels(root: TreeNode | null): TreeNode | null {\n    \n};",
    "php": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     public $val = null;\n *     public $left = null;\n *     public $right = null;\n *     function __construct($val = 0, $left = null, $right = null) {\n *         $this->val = $val;\n *         $this->left = $left;\n *         $this->right = $right;\n *     }\n * }\n */\nclass Solution {\n\n    /**\n     * @param TreeNode $root\n     * @return TreeNode\n     */\n    function reverseOddLevels($root) {\n        \n    }\n}",
    "swift": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public var val: Int\n *     public var left: TreeNode?\n *     public var right: TreeNode?\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\n *         self.val = val\n *         self.left = left\n *         self.right = right\n *     }\n * }\n */\nclass Solution {\n    func reverseOddLevels(_ root: TreeNode?) -> TreeNode? {\n        \n    }\n}",
    "kotlin": "/**\n * Example:\n * var ti = TreeNode(5)\n * var v = ti.`val`\n * Definition for a binary tree node.\n * class TreeNode(var `val`: Int) {\n *     var left: TreeNode? = null\n *     var right: TreeNode? = null\n * }\n */\nclass Solution {\n    fun reverseOddLevels(root: TreeNode?): TreeNode? {\n        \n    }\n}",
    "dart": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *   int val;\n *   TreeNode? left;\n *   TreeNode? right;\n *   TreeNode([this.val = 0, this.left, this.right]);\n * }\n */\nclass Solution {\n  TreeNode? reverseOddLevels(TreeNode? root) {\n    \n  }\n}",
    "golang": "/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\nfunc reverseOddLevels(root *TreeNode) *TreeNode {\n    \n}",
    "ruby": "# Definition for a binary tree node.\n# class TreeNode\n#     attr_accessor :val, :left, :right\n#     def initialize(val = 0, left = nil, right = nil)\n#         @val = val\n#         @left = left\n#         @right = right\n#     end\n# end\n# @param {TreeNode} root\n# @return {TreeNode}\ndef reverse_odd_levels(root)\n    \nend",
    "scala": "/**\n * Definition for a binary tree node.\n * class TreeNode(_value: Int = 0, _left: TreeNode = null, _right: TreeNode = null) {\n *   var value: Int = _value\n *   var left: TreeNode = _left\n *   var right: TreeNode = _right\n * }\n */\nobject Solution {\n    def reverseOddLevels(root: TreeNode): TreeNode = {\n        \n    }\n}",
    "rust": "// Definition for a binary tree node.\n// #[derive(Debug, PartialEq, Eq)]\n// pub struct TreeNode {\n//   pub val: i32,\n//   pub left: Option<Rc<RefCell<TreeNode>>>,\n//   pub right: Option<Rc<RefCell<TreeNode>>>,\n// }\n// \n// impl TreeNode {\n//   #[inline]\n//   pub fn new(val: i32) -> Self {\n//     TreeNode {\n//       val,\n//       left: None,\n//       right: None\n//     }\n//   }\n// }\nuse std::rc::Rc;\nuse std::cell::RefCell;\nimpl Solution {\n    pub fn reverse_odd_levels(root: Option<Rc<RefCell<TreeNode>>>) -> Option<Rc<RefCell<TreeNode>>> {\n        \n    }\n}",
    "racket": "; Definition for a binary tree node.\n#|\n\n; val : integer?\n; left : (or/c tree-node? #f)\n; right : (or/c tree-node? #f)\n(struct tree-node\n  (val left right) #:mutable #:transparent)\n\n; constructor\n(define (make-tree-node [val 0])\n  (tree-node val #f #f))\n\n|#\n\n(define/contract (reverse-odd-levels root)\n  (-> (or/c tree-node? #f) (or/c tree-node? #f))\n  )",
    "erlang": "%% Definition for a binary tree node.\n%%\n%% -record(tree_node, {val = 0 :: integer(),\n%%                     left = null  :: 'null' | #tree_node{},\n%%                     right = null :: 'null' | #tree_node{}}).\n\n-spec reverse_odd_levels(Root :: #tree_node{} | null) -> #tree_node{} | null.\nreverse_odd_levels(Root) ->\n  .",
    "elixir": "# Definition for a binary tree node.\n#\n# defmodule TreeNode do\n#   @type t :: %__MODULE__{\n#           val: integer,\n#           left: TreeNode.t() | nil,\n#           right: TreeNode.t() | nil\n#         }\n#   defstruct val: 0, left: nil, right: nil\n# end\n\ndefmodule Solution do\n  @spec reverse_odd_levels(root :: TreeNode.t | nil) :: TreeNode.t | nil\n  def reverse_odd_levels(root) do\n    \n  end\nend"
  },
  "solution": "[TOC]\n\n## Solution\n\n--- \n\n### Overview\n\nWe are given the `root` of a perfect binary tree, and our task is to return the `root` after reversing the values at the odd levels of the tree.\n\n> A binary tree is considered perfect if all parent nodes have exactly two children and all leaves are on the same level.\n> The level of a node is defined as the number of edges along the path between it and the root node.\n\n---\n\n### Approach 1: Depth-First Search\n\n#### Intuition   \n\nThe structure of binary trees is inherently recursive; that is, each node's left and right children can themselves be considered the roots of smaller binary trees. This allows us to traverse the tree using recursion, breaking the problem into smaller, independent subproblems.\n\nAs we traverse the tree recursively, we process the left and right children of the current `root`. For nodes at even levels, we swap the values at their left and right child nodes to reverse the arrangement of nodes below their level, while leaving the children of odd levels unchanged.\n\nLet's discuss the implementation of the recursive function `traverseDFS(node, leftChild, rightChild, int level)`:\n\n- Base case: If `leftChild` or `rightChild` is null, then we can stop the recursive traversal for further child nodes.\n\n- Even level: If the current level is even, swap the values rooted at `leftChild` and `rightChild`.\n\n- Perfect binary tree: Since the binary tree is perfect, it is symmetrical in nature. Therefore, to reverse the levels, we would want to swap the left value of the left child with the right value of the right child, and the right value of the left child with the left value of the right child. This can be illustrated using the slideshow shown below:\n\n!?!../Documents/2415/slideshow.json:960,540!?!\n\n> For a more comprehensive understanding of depth-first search, check out the [DFS Explore Card 🔗](https://leetcode.com/explore/learn/card/graph/619/depth-first-search-in-graph/). This resource provides an in-depth look at DFS, explaining its key concepts and applications with a variety of problems to solidify understanding of the pattern.\n\n#### Algorithm\n\nMain function - `reverseOddLevels(Node root)`\n\n- Call `traverseDFS` with the left and right children of the root, starting at level 0.\n\n`traverseDFS` function:\n  - If either `leftChild` or `rightChild` is null, return immediately (base case).\n\n  - If the current `level` is even (odd-level swapping occurs at 0-based indexing):\n    - Swap the values of `leftChild` and `rightChild` using a temporary variable.\n\n  - Recursively call `traverseDFS` for the next level:\n    - Call `traverseDFS` with `leftChild.left` and `rightChild.right` (mirroring structure).\n    - Call `traverseDFS` with `leftChild.right` and `rightChild.left` (mirroring structure).\n\n- Continue recursion until all levels of the tree are processed.\n\n- Return the updated `root` after all odd levels are reversed.\n\n#### Implementation#### Complexity Analysis\n\nLet $n$ be the number of nodes in the given tree.\n\n- Time complexity: $O(n)$\n    \n    In the worst case, the algorithm visits each node exactly once, resulting in a time complexity of $O(n)$. The swapping at each recursive step takes constant time. Therefore, the overall time complexity is $O(n)$.\n\n- Space complexity: $O(\\log n))$\n\n    The space complexity is determined by the recursion depth of the DFS. Since we are given a perfect binary tree, the height of the tree is bounded by $\\log n$. Therefore, the space complexity is given by $O(\\log n))$.\n\n---\n\n### Approach 2: Breadth-First Search\n\n#### Intuition\n\nInstead of DFS, we can use a breadth-first search (BFS) to traverse the tree level by level and reverse values at odd levels. We start by adding the root node to a queue, which helps manage nodes at each level.\n\nFor each level, we will pop all the nodes currently in the queue, which represent the nodes at the current level. Then, we will push their children to the queue to represent the next level. This ensures that the queue always contains the nodes for just one level at a time. When processing odd levels, we will collect the values of the nodes in an array, reverse that array, and then update the nodes' values with the reversed values. This step only happens for odd levels, while even levels remain unchanged.\n\nThis process continues until all levels are traversed. Finally, we return the root with the values at odd levels reversed.\n\n> For a more comprehensive understanding of breadth-first search, check out the [BFS Explore Card 🔗](https://leetcode.com/explore/featured/card/graph/620/breadth-first-search-in-graph/). This resource provides an in-depth look at BFS, explaining its key concepts and applications with a variety of problems to solidify understanding of the pattern.\n#### Algorithm\n\n1. Create a queue `queue` to store the level-order traversal of the tree. Initialize it with the `root` node.\n2. Initialize a variable `level` to `0` to keep track of the current tree level.\n3. Perform BFS traversal:\n    - While the `queue` is not empty, process the nodes level by level:\n        - Retrieve the size of the current level using the queue size.\n        - Create a list, `currentLevelNodes`, to store all nodes at the current level.\n        - Iterate over all nodes in the current level:\n            - Dequeue each node and add it to `currentLevelNodes`.\n            - Enqueue its left and right children (if they exist) to the queue for the next level.\n        - Check if the current level is odd:\n            - If `level % 2 == 1`, reverse the values of nodes in `currentLevelNodes`.\n            - Use two pointers (`left` and `right`) to swap values from the leftmost and rightmost ends of the list.\n4. Increment the `level` counter after processing each level.\n5. Return the `root` node after completing the traversal and reversing odd levels.\n\n#### Implementation#### Complexity Analysis\n\nLet $n$ be the number of nodes in the tree.\n\n- Time complexity: $O(n)$\n\n    The algorithm iterates through the tree, processing each level of nodes. The main loop performs BFS traversal, visiting each node exactly once, which results in a time complexity of $O(n)$. \n    \n    Additionally, at each level, the algorithm checks if it is odd and reverses the node values if necessary. This operation occurs for each node in the queue and takes constant time per node. The overall time complexity is dominated by the BFS traversal, resulting in $O(n)$.\n\n- Space complexity: $O(n)$\n\n    The space used by the algorithm is determined by the queue that holds the nodes at each level during BFS traversal. At most, the queue will hold all the nodes at one level, which is bounded by the number of nodes in the tree, resulting in a space complexity of $O(n)$. \n    \n    Other space requirements are constant and do not contribute significantly to the space complexity. Therefore, the overall space complexity is $O(n)$.\n\n---"
}