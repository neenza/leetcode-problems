{
  "title": "Minimum Add to Make Parentheses Valid",
  "problem_id": "957",
  "frontend_id": "921",
  "difficulty": "Medium",
  "problem_slug": "minimum-add-to-make-parentheses-valid",
  "topics": [
    "String",
    "Stack",
    "Greedy"
  ],
  "description": "A parentheses string is valid if and only if:\nYou are given a parentheses string s. In one move, you can insert a parenthesis at any position of the string.\nReturn the minimum number of moves required to make s valid.\nExample 1:\nExample 2:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: s = \"())\"\nOutput: 1",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input: s = \"(((\"\nOutput: 3",
      "images": []
    }
  ],
  "constraints": [
    "1 <= s.length <= 1000",
    "s[i] is either '(' or ')'."
  ],
  "follow_ups": [],
  "hints": [],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    int minAddToMakeValid(string s) {\n        \n    }\n};",
    "java": "class Solution {\n    public int minAddToMakeValid(String s) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def minAddToMakeValid(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def minAddToMakeValid(self, s: str) -> int:\n        ",
    "c": "int minAddToMakeValid(char* s) {\n    \n}",
    "csharp": "public class Solution {\n    public int MinAddToMakeValid(string s) {\n        \n    }\n}",
    "javascript": "/**\n * @param {string} s\n * @return {number}\n */\nvar minAddToMakeValid = function(s) {\n    \n};",
    "typescript": "function minAddToMakeValid(s: string): number {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param String $s\n     * @return Integer\n     */\n    function minAddToMakeValid($s) {\n        \n    }\n}",
    "swift": "class Solution {\n    func minAddToMakeValid(_ s: String) -> Int {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun minAddToMakeValid(s: String): Int {\n        \n    }\n}",
    "dart": "class Solution {\n  int minAddToMakeValid(String s) {\n    \n  }\n}",
    "golang": "func minAddToMakeValid(s string) int {\n    \n}",
    "ruby": "# @param {String} s\n# @return {Integer}\ndef min_add_to_make_valid(s)\n    \nend",
    "scala": "object Solution {\n    def minAddToMakeValid(s: String): Int = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn min_add_to_make_valid(s: String) -> i32 {\n        \n    }\n}",
    "racket": "(define/contract (min-add-to-make-valid s)\n  (-> string? exact-integer?)\n  )",
    "erlang": "-spec min_add_to_make_valid(S :: unicode:unicode_binary()) -> integer().\nmin_add_to_make_valid(S) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec min_add_to_make_valid(s :: String.t) :: integer\n  def min_add_to_make_valid(s) do\n    \n  end\nend"
  },
  "solution": "## Solution\n\n---\n\n### Approach: Open Bracket Counter\n\n#### Intuition\n\nWe are given a string `s` that consists only of open (`(`) and close (`)`) parentheses. This string may not be valid, meaning that an open parenthesis might not have a corresponding close parenthesis, or vice versa. Our goal is to determine the minimum number of operations required to make the string valid. In each operation, we can add either an open or close parenthesis at any position in the string.\n\nThe key observation is to match as many parentheses as possible to minimize the number of additional parentheses needed. We will iterate over the string from left to right and track the parentheses as we encounter them. Open parentheses should appear before their corresponding close parentheses. We will keep a count of open parentheses, and when we encounter a close parenthesis, we check if there is an unmatched open parenthesis available. If there is, we match them by reducing the open parenthesis count.\n\nIf we encounter a close parenthesis but no open parenthesis is available to match it, this means that we need to add an open parenthesis to balance the string, so we increment the `minAddsRequired` counter. After iterating through the entire string, there may still be unmatched open parentheses left. In this case, we need to add a close parenthesis for each remaining unmatched open parenthesis. Therefore, the total number of operations required to make the string valid is the sum of `minAddsRequired` and the remaining unmatched open parentheses.\n\nIn problems involving parentheses matching, a stack is often useful for storing open parentheses, and when encountering a close parenthesis, we can check if a matching open parenthesis exists at the top of the stack. Although we could use a stack in this problem to find the remaining open parentheses by checking its size, a simpler approach is possible here. Since there is only one type of parenthesis, we can efficiently handle the matching process with a counter.\n\nWhile the stack-based approach is more generic and preferred for cases involving multiple types of parentheses, it is not necessary here. We can use a counter variable, `openBrackets`, to track the number of unmatched open parentheses. We increment it for every open parenthesis and decrement it when encountering a close parenthesis. By the end, this counter will reflect the number of unmatched open parentheses.\n\n![fig](../Figures/921/921-Steps-Demonstration.png)\n\n#### Algorithm\n\n1. Create two variables: `openBrackets` (to track unmatched open brackets) and `minAddsRequired` both initialized to `0`.\n2. Loop through each character in the string `s`:\n    - If the current character is an open bracket `(`, increment the `openBrackets` counter, as it is unmatched for now.\n    - If the current character is a close bracket `)`:\n        - Check if there are any unmatched open brackets (`openBrackets` > 0).\n        - If an unmatched open bracket exists, decrement `openBrackets` to indicate that a matching pair has been formed.\n        - If no unmatched open brackets are available, increment `minAddsRequired` as we need to add an open bracket to make this close bracket valid.\n3. The total number of additions required will be the sum of `minAddsRequired` and any remaining unmatched open brackets (`openBrackets`). Return this value as the result.\n\n#### Implementation#### Complexity Analysis\nHere, $N$ is the number of characters in the string `s`.\n\n- Time complexity: $O(N)$\n\n  We iterate over each character in the string `s` once. For each character, we either increment, decrement, or compare a counter. These operations take constant time. Therefore, the overall time complexity is linear, $O(N)$.\n\n- Space complexity: $O(1)$\n\n  We use only two variables, `openBrackets` and `minAddsRequired`, to count unmatched brackets. These variables require constant space, and we do not use any extra data structures that depend on the input size. Thus, the space complexity is constant.\n\n\n---"
}