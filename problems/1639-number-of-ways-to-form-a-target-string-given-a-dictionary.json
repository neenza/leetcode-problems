{
  "title": "Number of Ways to Form a Target String Given a Dictionary",
  "problem_id": "1744",
  "frontend_id": "1639",
  "difficulty": "Hard",
  "problem_slug": "number-of-ways-to-form-a-target-string-given-a-dictionary",
  "topics": [
    "Array",
    "String",
    "Dynamic Programming"
  ],
  "description": "You are given a list of strings of the same length words and a string target.\nYour task is to form target using the given words under the following rules:\nNotice that you can use multiple characters from the same string in words provided the conditions above are met.\nReturn the number of ways to form target from words. Since the answer may be too large, return it modulo 109 + 7.\nExample 1:\nExample 2:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: words = [\"acca\",\"bbbb\",\"caca\"], target = \"aba\"\nOutput: 6\nExplanation: There are 6 ways to form target.\n\"aba\" -> index 0 (\"acca\"), index 1 (\"bbbb\"), index 3 (\"caca\")\n\"aba\" -> index 0 (\"acca\"), index 2 (\"bbbb\"), index 3 (\"caca\")\n\"aba\" -> index 0 (\"acca\"), index 1 (\"bbbb\"), index 3 (\"acca\")\n\"aba\" -> index 0 (\"acca\"), index 2 (\"bbbb\"), index 3 (\"acca\")\n\"aba\" -> index 1 (\"caca\"), index 2 (\"bbbb\"), index 3 (\"acca\")\n\"aba\" -> index 1 (\"caca\"), index 2 (\"bbbb\"), index 3 (\"caca\")",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input: words = [\"abba\",\"baab\"], target = \"bab\"\nOutput: 4\nExplanation: There are 4 ways to form target.\n\"bab\" -> index 0 (\"baab\"), index 1 (\"baab\"), index 2 (\"abba\")\n\"bab\" -> index 0 (\"baab\"), index 1 (\"baab\"), index 3 (\"baab\")\n\"bab\" -> index 0 (\"baab\"), index 2 (\"baab\"), index 3 (\"baab\")\n\"bab\" -> index 1 (\"abba\"), index 2 (\"baab\"), index 3 (\"baab\")",
      "images": []
    }
  ],
  "constraints": [
    "1 <= words.length <= 1000",
    "1 <= words[i].length <= 1000",
    "All strings in words have the same length.",
    "1 <= target.length <= 1000",
    "words[i] and target contain only lowercase English letters."
  ],
  "follow_ups": [],
  "hints": [
    "For each index i, store the frequency of each character in the ith row.",
    "Use dynamic programing to calculate the number of ways to get the target string using the frequency array."
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    int numWays(vector<string>& words, string target) {\n        \n    }\n};",
    "java": "class Solution {\n    public int numWays(String[] words, String target) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def numWays(self, words, target):\n        \"\"\"\n        :type words: List[str]\n        :type target: str\n        :rtype: int\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def numWays(self, words: List[str], target: str) -> int:\n        ",
    "c": "int numWays(char** words, int wordsSize, char* target) {\n    \n}",
    "csharp": "public class Solution {\n    public int NumWays(string[] words, string target) {\n        \n    }\n}",
    "javascript": "/**\n * @param {string[]} words\n * @param {string} target\n * @return {number}\n */\nvar numWays = function(words, target) {\n    \n};",
    "typescript": "function numWays(words: string[], target: string): number {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param String[] $words\n     * @param String $target\n     * @return Integer\n     */\n    function numWays($words, $target) {\n        \n    }\n}",
    "swift": "class Solution {\n    func numWays(_ words: [String], _ target: String) -> Int {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun numWays(words: Array<String>, target: String): Int {\n        \n    }\n}",
    "dart": "class Solution {\n  int numWays(List<String> words, String target) {\n    \n  }\n}",
    "golang": "func numWays(words []string, target string) int {\n    \n}",
    "ruby": "# @param {String[]} words\n# @param {String} target\n# @return {Integer}\ndef num_ways(words, target)\n    \nend",
    "scala": "object Solution {\n    def numWays(words: Array[String], target: String): Int = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn num_ways(words: Vec<String>, target: String) -> i32 {\n        \n    }\n}",
    "racket": "(define/contract (num-ways words target)\n  (-> (listof string?) string? exact-integer?)\n  )",
    "erlang": "-spec num_ways(Words :: [unicode:unicode_binary()], Target :: unicode:unicode_binary()) -> integer().\nnum_ways(Words, Target) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec num_ways(words :: [String.t], target :: String.t) :: integer\n  def num_ways(words, target) do\n    \n  end\nend"
  },
  "solution": "[TOC]\n\n## Solution\n\n---\n\n### Overview\n\nWe are given a list of equal-length strings, `words`, and a `target` string. The task is to count the number of ways we can form the `target` by selecting characters from `words`.\n\nTo construct the `target`:\n\n- Start with the first character of `target` and find a matching character in any of the strings in `words`.\n- For each subsequent character in `target`, pick characters from higher indices in the strings of `words` without revisiting previous ones.\n\n>Note: For this problem, we assume that you already know the fundamentals of dynamic programming and are figuring out how to apply it to a wide range of problems, such as this one. If you are not yet at this stage, we recommend checking out our relevant [Explore Card content on dynamic programming](https://leetcode.com/explore/featured/card/dynamic-programming/) before coming back to this article.\n\n---\n\n### Approach 1: Top-down Dynamic Programming\n\n#### Intuition\n\nLet's say we match the first character of `target` with the first character of a `word` in words. We then move to the next character in `target` and search for it in the remaining words. This creates a subproblem where the `target` becomes shorter by one character, and the search space in `words` is reduced. We also have the option to skip the current match and search for another match in subsequent words. This branching of choices makes the problem recursive.\n\nThe recursion tracks two indices: `wordsIndex` for the position in `words` and `targetIndex` for the position in `target`. \n\nThe base cases are:\n- If all characters in `target` are matched, return `1` (successful match).\n- If `words` is exhausted or the remaining `target` characters exceed available `words`, return `0` (no match).\n\nAt each step, two options are explored:\n1. Match the current character: If `target[targetIndex]` matches any character in `words[wordsIndex]`, recursively proceed with the next character of `target` and the next word. Contributions from multiple matches are summed. \n2. Skip the current word: Continue searching with the same `target` position but move to the next word. \n\nThis generates a recursive tree with exponential complexity in the worst case ($(\\text{number of words})^{\\text{target.length}}$), making it inefficient for large inputs.\n\nHowever, since we have `wordsIndex` and `targetIndex` as independent states in the recursion, we can optimize the solution using memoization. The total number of states would remain limited to `words.length * target.length`. By storing the results of each state in a `dp` matrix, we can avoid redundant calculations and significantly reduce the time complexity.\n\n#### Algorithm\n\nMain function - `numWays(words, target)`\n\n1. Initialize the data structures:\n    - Create a 2D `dp` array with dimensions `[words[0].size()][target.size()]` and initialize all values to `-1` (used for memoization).\n    - Create a 2D `charFrequency` array with dimensions `[words[0].size()][26]` to store the frequency of characters at each index across all words.\n\n2. Populate the `charFrequency` matrix:\n    - Iterate over all the words in the `words` list.\n    - For each character at index `j` in each word, increment the corresponding frequency count in `charFrequency[j][character]`.\n\n3. Call the recursive function `getWords(words, target, 0, 0, dp, charFrequency)` to calculate the number of ways to match the target string with the words matrix.\n\nRecursive Function - `getWords(words, target, wordsIndex, targetIndex, dp, charFrequency)`\n\n1. Base case:\n    - If `targetIndex == target.size()`, return `1`, indicating all characters of the target have been successfully matched.\n    - If `wordsIndex == words[0].size()` or there are fewer remaining characters in words than needed by target, return `0`, indicating it's not possible to match the target.\n\n2. Memoization check:\n    - If `dp[wordsIndex][targetIndex] != -1`, return the stored result from the `dp` array.\n\n3. Recursive calculation:\n    - Initialize `countWays = 0`.\n    - Calculate `curPos = target[targetIndex] - 'a'` to get the target character position.\n    - Two choices:\n        - Option 1: Do not match the current character of target with the current word at `wordsIndex`. Recursively call `getWords` with `wordsIndex + 1` and the same `targetIndex`.\n        - Option 2: Match the current character of `target` with a character at `wordsIndex`. Multiply the number of valid choices at `charFrequency[wordsIndex][curPos]` with the result of recursively calling `getWords` with `wordsIndex + 1` and `targetIndex + 1`.\n\n4. Store the calculated countWays in `dp[wordsIndex][targetIndex]`, modulo $1000000007$ to avoid overflow.\n\n5. Return the value stored in `dp[wordsIndex][targetIndex]`.\n\n#### Implementation#### Complexity Analysis\n\nLet $\\text{totalWords}$ be the total number of words in the `words` matrix, and $\\text{wordLength}$ and $\\text{targetLength}$ represent the length of any word in `words` and the `target` string, respectively.\n\n- Time Complexity: $O(wordLength \\cdot targetLength + wordLength \\cdot totalWords)$\n\n    We first calculate the frequency of characters in the `words` matrix, which takes $O(wordLength \\cdot totalWords)$ time. \n    \n    The `getWords` function is called recursively for each combination of `word` index and `target` index, leading to $O(wordLength \\cdot targetLength)$ recursive calls. Each call involves constant-time operations, and memoization ensures that each combination is computed once, making the recursion time complexity $O(wordLength \\cdot targetLength)$. \n    \n    Thus, the total time complexity is $O(wordLength \\cdot targetLength + wordLength \\cdot totalWords)$.\n\n- Space Complexity: $O(wordLength \\cdot targetLength)$\n\n    The space complexity is dominated by two factors:\n\n    - Memoization (`dp` table): The dp table stores the intermediate results for every combination of `wordIndex` and `targetIndex`. This table has dimensions of `wordLength x targetLength`, so its space complexity is $O(wordLength \\cdot targetLength)$.\n\n    - Character Frequency Matrix (`charFrequency`): The `charFrequency` matrix stores the frequency of each character at each column of the `words` matrix. This matrix has dimensions of `wordLength x 26`, where 26 corresponds to the number of possible characters (assuming lowercase English letters), resulting in a space complexity of $O(wordLength \\cdot 26)$, which simplifies to $O(wordLength)$.\n    \n    Combining both, the overall space complexity is given by $O(wordLength \\cdot targetLength + wordLength) \\approx O(wordLength \\cdot targetLength)$.\n\n---\n\n### Approach 2: Bottom-up Dynamic Programming\n\n#### Intuition\n\nTabulation is a dynamic programming technique that iteratively computes solutions for all combinations of parameters. Unlike memoization, it avoids recursive stack overhead by using a iterative way, making it more efficient. We have two variables that change as we progress through the matrix: the current word index (`currWord`) and the current `target` string index (`currTarget`). To thoroughly explore the combinations, we use two nested loops to iterate through these variables.\n\nFirst, we establish the base case: if `currTarget` is `0`, then `dp[currWord][0] = 1`, meaning there is exactly one way to form an empty `target` string, regardless of the number of columns in `words`.\n\nNow to achieve the goal we will fill the DP table with two main steps:\n\n1. Skip the current column of `words`:\n   Carry over the value from the previous row: $dp[currWord][currTarget] = dp[currWord - 1][currTarget]$\n2. Include the current character if it matches:\n   If `target[currTarget - 1]` matches a character in the current column of `words`, add its contribution: $dp[currWord][currTarget] += \\text{charFrequency}[currWord - 1][\\text{target}[currTarget - 1] - 'a'] \\cdot dp[currWord - 1][currTarget - 1]$\n\nFinally, we take the result modulo $10^9 + 7$ at every step to prevent overflow.\n\nAt the end, the total number of ways to form the `target` string is stored in `dp[wordLength][targetLength]`.\n\n#### Algorithm\n\n1. Create a 2D array `charFrequency` of size `wordLength x 26` to store the frequency of each character at every index in `words`.\n2. Fill `charFrequency` by iterating over each string in `words`:\n   - For each string, increment the count of the respective character for the corresponding column.\n3. Initialize a DP table `dp` of size `(wordLength + 1) x (targetLength + 1)` and set all values to `0`.\n4. Set the base case:\n   - For all `currWord` from `0` to `wordLength`, set `dp[currWord][0] = 1`.\n5. Iterate `currWord` from `1` to `wordLength`:\n   - Iterate `currTarget` from `1` to `targetLength`:\n     - Set `dp[currWord][currTarget] = dp[currWord - 1][currTarget]`.\n     - If the character at `target[currTarget - 1]` matches a character in `words` at `currWord - 1`, add the contribution:  \n       $dp[currWord][currTarget] += charFrequency[currWord - 1][target[currTarget - 1] - 'a'] * dp[currWord - 1][currTarget - 1]$\n     - Apply modulo `10^9 + 7` to prevent overflow.\n6. Return the value in `dp[wordLength][targetLength]`.\n\n#### Implementation#### Complexity Analysis\n\nLet $\\text{totalWords}$ be the total number of words in the `words` matrix, and $\\text{wordLength}$ and $\\text{targetLength}$ represent the length of any word in `words` and the `target` string, respectively.\n\n- Time Complexity: $O(wordLength \\cdot targetLength + wordLength \\cdot totalWords)$\n\n    To find the frequency of all the characters in the `words` matrix, we iterate through all the characters in the matrix. This takes $O(wordLength \\cdot totalWords)$ time.\n\n    The dynamic programming table `dp` is filled by iterating over each combination of `word` index and `target` index, leading to a total of $O(wordLength \\cdot targetLength)$ iterations. Each iteration performs constant-time operations such as looking up values in the `charFrequency` matrix and updating the `dp` table.\n\n    Therefore, the total time complexity is given by $O(wordLength \\cdot targetLength + wordLength \\cdot totalWords)$.\n\n- Space Complexity: $O(wordLength \\cdot targetLength)$\n\n    The space complexity is dominated by two factors:\n\n    - `dp` table: The `dp` table stores the intermediate results for every combination of `wordIndex` and `targetIndex`. This table has dimensions of `wordLength x targetLength`, so its space complexity is $O(wordLength \\cdot targetLength)$.\n\n    - Character Frequency Matrix (`charFrequency`): The `charFrequency` matrix stores the frequency of each character at each column of the `words` matrix. This matrix has dimensions of `wordLength x 26`, where 26 corresponds to the number of possible characters (assuming lowercase English letters). The space complexity of this matrix is $O(wordLength \\cdot 26)$, which simplifies to $O(wordLength)$.\n\n    Combining both, the overall space complexity is $O(wordLength \\cdot targetLength)$.\n\n---\n\n### Approach 3: Optimized Bottom-up Dynamic Programming\n\n#### Intuition\n\nFrom the previous approach, we see that calculating the number of ways to form the target string at position `(currWord, currTarget)` depends only on two values: `(currWord-1, currTarget)` and `(currWord-1, currTarget-1)`. This relationship is expressed as:\n\n$currCount[currTarget] = currCount[currTarget] + (charFrequency[currWord-1][target[currTarget-1] - 'a'] \\cdot prevCount[currTarget-1]) \\mod MOD$\n\nHere:\n- `currCount[currTarget]` accumulates the count of ways to form the target string up to `currTarget`.\n- `charFrequency[currWord-1][target[currTarget-1] - 'a']` gives the frequency of the current target character in the previous word.\n- `prevCount[currTarget-1]` provides the count of ways to form the target string up to the previous position before the current update.\n\nThis relationship ensures that each character from the `target` is considered while accounting for its frequency in the available words.\n\nUsing this insight, we can optimize the 2D DP table to a 1D array `currCount`, where each element represents the ways to form the target string up to a specific index. To manage the dependency on values from the previous row, we maintain an additional variable, `prevCount`, which temporarily stores the value of `currCount` before it is updated in the current iteration. Once all iterations are complete, the result is stored in `currCount[target.length()]`.\n\n#### Algorithm\n\n1. Create a 2D array `charFrequency` of size `wordLength x 26` to store the frequency of each character at every index in `words`. Iterate over each string in `words`, and for each string, increment the count of the respective character for the corresponding column in `charFrequency`.\n2. Initialize two DP arrays: `prevCount` and `currCount`. Both arrays are of size `targetLength + 1`, and are initially set to `0`. Set `prevCount[0] = 1` because there is one way to form an empty target string.\n3. Iterate `currWord` from `1` to `wordLength`:\n    - Copy the values from `prevCount` to `currCount` to carry over the previous row.\n    - Iterate `currTarget` from `1` to `targetLength`:\n        - First, carry over the previous value without using the current column of words by setting `currCount[currTarget] = prevCount[currTarget]`.\n        - Then, if the character at `target[currTarget - 1]` matches a character in words at `currWord - 1`, add the contribution from `charFrequency[currWord - 1][target[currTarget - 1] - 'a'] * prevCount[currTarget - 1]` to `currCount[currTarget]`.\n        - Apply modulo `10^9 + 7` to the `result` to prevent overflow.\n        - After processing each `currWord`, copy the values of `currCount` to `prevCount` for the next iteration.\n4. Finally, return the value in `currCount[targetLength]`, which stores the number of ways to form the target string using the entire words matrix.\n\n#### Implementation#### Complexity Analysis\n\nLet $\\text{totalWords}$ be the total number of words in the `words` matrix, and $\\text{wordLength}$ and $\\text{targetLength}$ represent the length of any word in `words` and the `target` string, respectively.\n\n- Time Complexity: $O(wordLength \\cdot targetLength + wordLength \\cdot totalWords)$\n\n    To find the frequency of all the characters in the `words` matrix, we iterate through all the characters in the matrix. This takes $O(wordLength \\cdot totalWords)$ time.\n\n    The dynamic programming arrays `prevCount` and `currCount` are filled by iterating over each combination of `word` index and `target` index, leading to a total of $O(wordLength \\cdot targetLength)$ iterations. Each iteration performs constant-time operations such as looking up values in the `charFrequency` matrix and updating the dp table.\n\n    Therefore, the total time complexity is given by $O(wordLength \\cdot targetLength + wordLength \\cdot totalWords)$.\n\n- Space Complexity: $O(wordLength)$\n\n    The space complexity is dominated by two factors:\n\n    1. The dp arrays `prevCount` and `currCount`: These arrays store the results for every combination of `wordIndex` and `targetIndex`. Each array has a size of $(targetLength + 1)$, but since `targetLength` can't be larger than `wordLength`, the space complexity is effectively $O(wordLength)$.\n    \n    2. Character Frequency Matrix (`charFrequency`): The `charFrequency` matrix stores the frequency of each character at each column of the `words` matrix. This matrix has dimensions of `wordLength x 26`, where 26 corresponds to the number of possible characters (assuming lowercase English letters). The space complexity of this matrix is $O(wordLength \\cdot 26)$, which simplifies to $O(wordLength)$.\n\n    Combining both, the overall space complexity is $O(wordLength)$.\n\n---"
}