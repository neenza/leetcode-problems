{
  "title": "Minimum Length of String After Deleting Similar Ends",
  "problem_id": "1850",
  "frontend_id": "1750",
  "difficulty": "Medium",
  "problem_slug": "minimum-length-of-string-after-deleting-similar-ends",
  "topics": [
    "Two Pointers",
    "String"
  ],
  "description": "Given a string s consisting only of characters 'a', 'b', and 'c'. You are asked to apply the following algorithm on the string any number of times:\nReturn the minimum length of s after performing the above operation any number of times (possibly zero times).\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: s = \"ca\"\nOutput: 2\nExplanation: You can't remove any characters, so the string stays as is.",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input: s = \"cabaabac\"\nOutput: 0\nExplanation: An optimal sequence of operations is:\n- Take prefix = \"c\" and suffix = \"c\" and remove them, s = \"abaaba\".\n- Take prefix = \"a\" and suffix = \"a\" and remove them, s = \"baab\".\n- Take prefix = \"b\" and suffix = \"b\" and remove them, s = \"aa\".\n- Take prefix = \"a\" and suffix = \"a\" and remove them, s = \"\".",
      "images": []
    },
    {
      "example_num": 3,
      "example_text": "Input: s = \"aabccabba\"\nOutput: 3\nExplanation: An optimal sequence of operations is:\n- Take prefix = \"aa\" and suffix = \"a\" and remove them, s = \"bccabb\".\n- Take prefix = \"b\" and suffix = \"bb\" and remove them, s = \"cca\".",
      "images": []
    }
  ],
  "constraints": [
    "1 <= s.length <= 105",
    "s only consists of characters 'a', 'b', and 'c'."
  ],
  "follow_ups": [],
  "hints": [
    "If both ends have distinct characters, no more operations can be made. Otherwise, the only operation is to remove all of the same characters from both ends. We will do this as many times as we can.",
    "Note that if the length is equal 1 the answer is 1"
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    int minimumLength(string s) {\n        \n    }\n};",
    "java": "class Solution {\n    public int minimumLength(String s) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def minimumLength(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def minimumLength(self, s: str) -> int:\n        ",
    "c": "int minimumLength(char* s) {\n    \n}",
    "csharp": "public class Solution {\n    public int MinimumLength(string s) {\n        \n    }\n}",
    "javascript": "/**\n * @param {string} s\n * @return {number}\n */\nvar minimumLength = function(s) {\n    \n};",
    "typescript": "function minimumLength(s: string): number {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param String $s\n     * @return Integer\n     */\n    function minimumLength($s) {\n        \n    }\n}",
    "swift": "class Solution {\n    func minimumLength(_ s: String) -> Int {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun minimumLength(s: String): Int {\n        \n    }\n}",
    "dart": "class Solution {\n  int minimumLength(String s) {\n    \n  }\n}",
    "golang": "func minimumLength(s string) int {\n    \n}",
    "ruby": "# @param {String} s\n# @return {Integer}\ndef minimum_length(s)\n    \nend",
    "scala": "object Solution {\n    def minimumLength(s: String): Int = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn minimum_length(s: String) -> i32 {\n        \n    }\n}",
    "racket": "(define/contract (minimum-length s)\n  (-> string? exact-integer?)\n  )",
    "erlang": "-spec minimum_length(S :: unicode:unicode_binary()) -> integer().\nminimum_length(S) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec minimum_length(s :: String.t) :: integer\n  def minimum_length(s) do\n    \n  end\nend"
  },
  "solution": "[TOC]\n\n## Solution\n\n---\n\n### Overview\n\nGiven a string `s`, we aim to return the length of `s` after deleting similar ends.\n\nWhen the characters at the beginning and end of `s` are the same, we can delete the prefix and suffix. A prefix or suffix can contain multiple of the same character. The prefix and suffix can be of different lengths, but must not intersect.\n\nNote that the objective is to find the length of `s` after deleting characters, not to return the modified string. The best practice is not to modify the input; we can count the remaining characters after identifying characters we would delete.\n\n---\n\n### Approach 1: Two Pointers\n\n#### Intuition\n\nAfter deleting similar ends, our goal is to find the number of characters remaining in `s`. \n\n**When can we delete the prefix and suffix?**\n\nWe can delete the prefix and suffix when the character at the beginning of `s` is the same as the character at the end of `s`. Let's call this character `c`.\n\nAs shown in example 3 from the problem description, for a given character `c`, we can delete multiple occurrences of it as the prefix and suffix. For the input `s = \"aabccabba\"`, two occurrences of `\"a\"` are deleted as the prefix, and one occurrence of `\"a\"` is deleted as the suffix.\n\nWhen the characters at the beginning and end of `s` both equal `c`, we can delete characters at the beginning of `s` until the first character of `s` no longer equals `c`. Then, we can delete the characters at the end of `s` until the last character of `s` no longer equals `c`.\n\nWe can compare the characters at the beginning and end of `s` by using two pointers: `begin`, which points to the beginning of `s`, and `end`, which points to the end. \n\nTo \"delete\" a character, we move the `begin` or `end` pointer one step to the center. \n\nWe can process `s` with these pointers until they meet in the middle or the characters at the beginning and end of the substring of `s` differ. When we cannot delete more characters, we find the remaining characters. The characters between `begin` and `end` are the remaining characters. To calculate the number of remaining characters, we can subtract `begin` from `end`, then add `1`. We add `1` because when `end` and `begin` are the same and have a difference of `0`, there is `1` remianing character in the string.\n\n> **How do we know this approach will delete all similar ends?**\n>\n> With each iteration, `begin` is incremented to delete the prefix, and `end` is decremented to delete the suffix, unless all remaining characters are the same, in which case the `begin` pointer is used to delete both the prefix and suffix. The pointers move towards each other, so we will process a prefix and suffix with each iteration.\n>\n> Our algorithm stops in three cases:\n>\n> 1. The character at `s[begin]` is different from the character at `s[end]`: every time we delete a character, we delete all occurrences of that character on each end. This means that when there are no longer similar ends, we have deleted them all.\n> 2. `begin` is equal to `end`: we have processed the whole string and deleted all but `1` character; we can no longer delete a separate prefix and suffix, so all similar ends have been deleted.\n> 3. `begin` is greater than `end`: we have processed and deleted the whole string.\n\nBelow is a visualization of the two-pointer method for deleting similar ends:\n\n\n!?!../Documents/1750/1750_slideshow.json:960,540!?!\n\n\n#### Algorithm\n\n1. Initialize two variables, `begin` to `0` and `end` to `s.length() - 1`. `begin` points to the first index of `s` and `end` points to the last index.\n2. While `begin` is less than `end` and the character at `s[begin]` equals the character at `s[end]`:\n    - Initialize a character `c` to `s[begin]`.\n    - While `begin` is less than or equal to `end` and `s[begin]` equals `c`, increment `begin` by `1` to delete a prefix character.\n    - While `end` is greater than `begin` and `s[end]` equals `c`, decrement `end` by `1` to delete a suffix character.\n3. After processing `s`, return `end - begin + 1`, the number of remaining characters.\n\n\n#### Implementation\n\n**Implementation 1: Iterative****Implementation 2: Tail Recursion**\n\nWe can implement the above approach recursively as well as iteratively. We can delete similar ends, and then recursively delete similar ends on the remaining string. \n\nWe use a helper function, `deleteSimilarEnds`, so we can pass `begin` and `end` as parameters. The base case is when a prefix and suffix cannot be deleted because the ends differ or meet in the middle. In this case, we return the number of remaining characters. \nWhen there are similar ends, the function deletes them using a similar process as the above implementation and recursively calls itself.  \n\nIn a recursive function, each recursive call creates a new stack frame, which can lead to a stack overflow if the function is called too many times. Tail recursion reduces this problem by reusing the current stack frame instead of creating a new one. \nIt's an optimization technique used in functional programming to avoid the use of explicit loops and improve performance.\n\nTo use tail recursion, the last statement of a function must be a recursive call, and the function must have a base case that can be reached by the recursive call. The base case is used to stop the recursion and return a value.\nSince our approach has both conditions, we can use tail recursion in the below implementation.\n\n> Note: The implementation shown here is provided for the purpose of building perspective on different ways to solve a problem. While the recursion-based solution is valid, the two-pointer implementation remains the most intuitive and optimized solution.The time complexity of the recursive implementation is the same as the iterative implementation. The main space required for this recursive implementation is the call stack, which can grow as large as the number of recursive calls. There will be a recursive call for each pair of similar ends, and there can be as many as $\\frac{n}{2}$ similar ends, so our implementation will have $\\frac{n}{2}$ recursive calls. $\\frac{n}{2}$ is a linear complexity, so we describe the space complexity as $O(n)$.\n\n#### Complexity Analysis\n\nLet $n$ be the length of `s`.\n\n* Time complexity: $O(n)$\n\n    We process `s` using the pointers `begin` and `end` until they meet in the middle. Although we use nested while loops, with each iteration,  `begin` is incremented, and/or `end` is decremented, or the loop terminates because a prefix and suffix can no longer be deleted. We handle each character of `s` at most once, so the time complexity is $O(n)$.\n\n* Space complexity: $O(1)$\n\n    The iterative implementation uses a few variables and no additional data structures that grow with input size, so the space complexity is constant, $O(1)$.\n\n---"
}