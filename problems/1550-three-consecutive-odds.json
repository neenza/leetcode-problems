{
  "title": "Three Consecutive Odds",
  "problem_id": "1293",
  "frontend_id": "1550",
  "difficulty": "Easy",
  "problem_slug": "three-consecutive-odds",
  "topics": [
    "Array"
  ],
  "description": "Example 1:\nExample 2:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: arr = [2,6,4,1]\nOutput: false\nExplanation: There are no three consecutive odds.",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input: arr = [1,2,34,3,4,5,7,23,12]\nOutput: true\nExplanation: [5,7,23] are three consecutive odds.",
      "images": []
    }
  ],
  "constraints": [
    "1 <= arr.length <= 1000",
    "1 <= arr[i] <= 1000"
  ],
  "follow_ups": [],
  "hints": [
    "Check every three consecutive numbers in the array for parity."
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    bool threeConsecutiveOdds(vector<int>& arr) {\n        \n    }\n};",
    "java": "class Solution {\n    public boolean threeConsecutiveOdds(int[] arr) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def threeConsecutiveOdds(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: bool\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def threeConsecutiveOdds(self, arr: List[int]) -> bool:\n        ",
    "c": "bool threeConsecutiveOdds(int* arr, int arrSize) {\n    \n}",
    "csharp": "public class Solution {\n    public bool ThreeConsecutiveOdds(int[] arr) {\n        \n    }\n}",
    "javascript": "/**\n * @param {number[]} arr\n * @return {boolean}\n */\nvar threeConsecutiveOdds = function(arr) {\n    \n};",
    "typescript": "function threeConsecutiveOdds(arr: number[]): boolean {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param Integer[] $arr\n     * @return Boolean\n     */\n    function threeConsecutiveOdds($arr) {\n        \n    }\n}",
    "swift": "class Solution {\n    func threeConsecutiveOdds(_ arr: [Int]) -> Bool {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun threeConsecutiveOdds(arr: IntArray): Boolean {\n        \n    }\n}",
    "dart": "class Solution {\n  bool threeConsecutiveOdds(List<int> arr) {\n    \n  }\n}",
    "golang": "func threeConsecutiveOdds(arr []int) bool {\n    \n}",
    "ruby": "# @param {Integer[]} arr\n# @return {Boolean}\ndef three_consecutive_odds(arr)\n    \nend",
    "scala": "object Solution {\n    def threeConsecutiveOdds(arr: Array[Int]): Boolean = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn three_consecutive_odds(arr: Vec<i32>) -> bool {\n        \n    }\n}",
    "racket": "(define/contract (three-consecutive-odds arr)\n  (-> (listof exact-integer?) boolean?)\n  )",
    "erlang": "-spec three_consecutive_odds(Arr :: [integer()]) -> boolean().\nthree_consecutive_odds(Arr) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec three_consecutive_odds(arr :: [integer]) :: boolean\n  def three_consecutive_odds(arr) do\n    \n  end\nend"
  },
  "solution": "[TOC]\n\n## Solution\n\n---\n\n### Approach 1: Brute Force\n\n#### Intuition\n\nLet's examine the brute force approach, which essentially replicates what the problem asks us to do.\n\nWe iterate through the array, examining each group of three consecutive elements. If all three numbers in a group are odd, we return true. If no such group is found, we return false.\n\n> Note: We don't need to traverse the entire array. We stop two elements before the end. Why? Because each group we're checking consists of the current element plus the next two. Therefore, we must ensure those next two elements are within the array's bounds.\n\n#### Algorithm\n\n- Iterate over the array till the third last element. For each element:\n  - Check if the current and next two elements are all odd\n    - If all three elements are odd, return `true`.\n- Return `false` otherwise.\n\n#### Implementation#### Complexity Analysis\n\nLet $n$ be the the length of the given array `arr`.\n\n- Time complexity: $O(n)$\n\n    The algorithm loops from $0$ to $n-2$, which has a time complexity of $O(n-2)$. This can be simplified to a time complexity of $O(n)$.\n\n- Space complexity: $O(1)$\n\n    The algorithm has a constant space complexity, as it does not use any additional space.\n\n---\n\n### Approach 2: Counting\n\n#### Intuition\n\nEssentially, we need to examine elements sequentially while using a counter to track the number of consecutive odd numbers. When we find an odd number, we increment our counter; otherwise, we reset it to zero. If the counter hits 3 at any point, it indicates we've found three consecutive odd numbers, allowing us to return `true`. However, if we traverse the entire array without the counter reaching 3, we return `false`.\n\nCheck out this slideshow to better understand this process:\n\n!?!../Documents/1550/slideshow.json:1162,442!?!\n\n#### Algorithm\n \n- Initialize a variable `consecutiveOdds` to store the number of consecutive odd numbers during the loop.\n- Loop through the given array:\n  - If the current element is odd, increment `consecutiveOdds`.\n  - Otherwise, reset `consecutiveOdds` to 0.\n  - If `consecutiveOdds` is equal to 3, return `true`.\n- Return `false`, indicating no three consecutive odds were found.\n\n#### Implementation#### Complexity Analysis\n\nLet $n$ be the length of the given array `arr`.\n\n* Time complexity: $O(n)$\n\n    The algorithm loops over `arr` only once. Thus, the time complexity remains $O(n)$.\n\n* Space complexity: $O(1)$\n\n    The space complexity remains constant since the algorithm does not use any additional space.\n\n---\n\n### Approach 3: Product of Three Numbers\n\n#### Intuition\n\nThe solution can be simplified even further if we recognize a property of products: a product is only odd if all the numbers being multiplied are odd. So, if the product of three consecutive numbers is odd, then all three numbers are odd.\n\nSimilar to Approach 1, we'll go through the list and examine groups of three elements. If the product is odd, we have found three consecutive odd elements and can return `true`. If we complete the iteration without finding any odd products, we can return `false`.\n\n> Note: Be cautious of overflow when you are taking the product of two or more elements. In our problem, the numbers are constrained to $10^3$, so the maximum product is $10^9$, which can fit in a 32-bit integer. However, if the constraints were larger, we would need to consider using a larger data type.\n\n#### Algorithm\n \n- Loop over the array `arr` till the third last element:\n  - Calculate `product` as the product of the current and the next two elements.\n  - If `product` is odd, return `true`.\n- Return `false`.\n\n#### Implementation#### Complexity Analysis\n\nLet $n$ be the length of the array `arr`.\n\n* Time complexity: $O(n)$\n\n    The time complexity remains linear, as the loop traverses the array only once.\n\n* Space complexity: $O(1)$\n\n    We do not use any additional space, so the space complexity is constant.\n\n---"
}