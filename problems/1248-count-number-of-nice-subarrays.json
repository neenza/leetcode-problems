{
  "title": "Count Number of Nice Subarrays",
  "problem_id": "1370",
  "frontend_id": "1248",
  "difficulty": "Medium",
  "problem_slug": "count-number-of-nice-subarrays",
  "topics": [
    "Array",
    "Hash Table",
    "Math",
    "Sliding Window",
    "Prefix Sum"
  ],
  "description": "Given an array of integers nums and an integer k. A continuous subarray is called nice if there are k odd numbers on it.\nReturn the number of nice sub-arrays.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: nums = [1,1,2,1,1], k = 3\nOutput: 2\nExplanation: The only sub-arrays with 3 odd numbers are [1,1,2,1] and [1,2,1,1].",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input: nums = [2,4,6], k = 1\nOutput: 0\nExplanation: There are no odd numbers in the array.",
      "images": []
    },
    {
      "example_num": 3,
      "example_text": "Input: nums = [2,2,2,1,2,2,1,2,2,2], k = 2\nOutput: 16",
      "images": []
    }
  ],
  "constraints": [
    "1 <= nums.length <= 50000",
    "1 <= nums[i] <= 10^5",
    "1 <= k <= nums.length"
  ],
  "follow_ups": [],
  "hints": [
    "After replacing each even by zero and every odd by one can we use prefix sum to find answer ?",
    "Can we use two pointers to count number of sub-arrays ?",
    "Can we store the indices of odd numbers and for each k indices count the number of sub-arrays that contains them ?"
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    int numberOfSubarrays(vector<int>& nums, int k) {\n        \n    }\n};",
    "java": "class Solution {\n    public int numberOfSubarrays(int[] nums, int k) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def numberOfSubarrays(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\n        ",
    "c": "int numberOfSubarrays(int* nums, int numsSize, int k) {\n    \n}",
    "csharp": "public class Solution {\n    public int NumberOfSubarrays(int[] nums, int k) {\n        \n    }\n}",
    "javascript": "/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number}\n */\nvar numberOfSubarrays = function(nums, k) {\n    \n};",
    "typescript": "function numberOfSubarrays(nums: number[], k: number): number {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @param Integer $k\n     * @return Integer\n     */\n    function numberOfSubarrays($nums, $k) {\n        \n    }\n}",
    "swift": "class Solution {\n    func numberOfSubarrays(_ nums: [Int], _ k: Int) -> Int {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun numberOfSubarrays(nums: IntArray, k: Int): Int {\n        \n    }\n}",
    "dart": "class Solution {\n  int numberOfSubarrays(List<int> nums, int k) {\n    \n  }\n}",
    "golang": "func numberOfSubarrays(nums []int, k int) int {\n    \n}",
    "ruby": "# @param {Integer[]} nums\n# @param {Integer} k\n# @return {Integer}\ndef number_of_subarrays(nums, k)\n    \nend",
    "scala": "object Solution {\n    def numberOfSubarrays(nums: Array[Int], k: Int): Int = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn number_of_subarrays(nums: Vec<i32>, k: i32) -> i32 {\n        \n    }\n}",
    "racket": "(define/contract (number-of-subarrays nums k)\n  (-> (listof exact-integer?) exact-integer? exact-integer?)\n  )",
    "erlang": "-spec number_of_subarrays(Nums :: [integer()], K :: integer()) -> integer().\nnumber_of_subarrays(Nums, K) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec number_of_subarrays(nums :: [integer], k :: integer) :: integer\n  def number_of_subarrays(nums, k) do\n    \n  end\nend"
  },
  "solution": "[TOC]\n\n## Solution\n\n---\n\n### Approach 1: Hashing\n\n#### Intuition\n\nSince we only need to find the number of subarrays that contain a certain count of odd elements, we can ignore the numerical values of the elements and replace all odd values with `1` and even values with `0`. \n\nNow, all we need to do is identify sequences of elements within the array whose sum equals the number of odd elements needed to make a nice array. Solutions that require sequences of elements to meet criteria often utilize prefix sums, also sometimes referred to as cumulative sums. \n\n**Note:** If you aren't aware of this concept we recommend you first solve this problem [560. Subarray Sum Equals K](https://leetcode.com/problems/subarray-sum-equals-k/).\n\nUtilizing prefix sums simplifies our approach and lets us avoid determining the sum of elements for every new subarray considered. Using the prefix sums approach, we can calculate the sum of elements between two indices, subtracting the prefix sum corresponding to the two indices to obtain the sum directly instead of iterating over the subarray to find the sum.\n\nWe'll use this approach to calculate how many odd numbers are between two indices in the array. Let's call the two indices `start` and `end`. If the number of odd numbers between `start` and `end` equals `k`, we have found a nice subarray. We will calculate this by finding the difference between the `end` and `start` indices. \n\nBased on these thoughts, we use a hashmap to store the prefix sum of indices as keys and their frequency of occurrence as values. Instead of modifying nums, we can apply the modulo 2 operation when storing values in the hashmap.\n\nWe traverse the array `nums` to compute the prefix sum up to each element modulo 2. Each unique sum encountered is recorded in a hashmap. If a sum repeats, we increment its corresponding count in the hashmap. Also, for each sum encountered, we find the number of times `sum - k` has appeared before, as this count indicates how many subarrays with sum `k` exist up to the current index. We increase the count by that same amount.\n\n#### Algorithm\n\n1. Initialize integers `currSum = 0`,`subarrays = 0` and a hashmap `prefixSum`. \n2. Initialize `prefixSum[0]` with 1 to account for the initial value of `currSum`.\n2. Iterate over all the elements of `nums`:\n    - Compute `currSum` as `currSum = currSum + nums[i] % 2`.\n    - If `currSum - k` exists in the hashmap:\n        - Increment the value of `subarrays` with `prefixSum[currSum - k]`.\n    - Increment `prefixSum[currSum]` by 1. \n3. Return `subarrays`.\n\n#### Implementation#### Complexity Analysis\n\nLet $n$ be the number of elements in `nums`.\n\n- Time complexity: $O(n)$\n\n    We iterate through the array exactly once. In each iteration, we perform insertion and search operations in the hashmap that take $O(1)$ time. Therefore, the time complexity can be stated as $O(n)$.\n\n- Space complexity: $O(n)$\n\n    In each iteration, we insert a key-value pair in the hashmap. The space complexity is $O(n)$ because the size of the hashmap is proportional to the size of the list after $n$ iterations.\n\n---\n\n### Approach 2: Sliding Window using Queue\n\n#### Intuition\n\nSince all of the elements in the modified `nums` array in the previous approach are non-negative, we can also try to use the sliding window approach. This pattern is applicable in scenarios where achieving a goal involves using subarrays, and individual values cannot be selected independently.\n\nThe concept behind the sliding window pattern is to maintain a window that continuously expands from the right by adding elements until the conditions are not satisfied. Then, we adjust the window by shrinking it from the left until the condition is met again.\n\n> If the `nums` array contains any negative numbers, the sliding window approach will not work effectively. This is because when negative numbers are included, extending the window by adding more elements can decrease the sum, complicating the process of determining the optimal subarray. With non-negative numbers, the sum of the elements in the window either increases or stays the same as the window expands, allowing for a straightforward evaluation of subarrays.\n\nFor this problem, we will simulate the process using a queue. A queue is suitable to simulate a sliding window because it efficiently adds and removes elements from both ends. The queue represents all unique windows that contain `k` odd elements and start and end with an odd element. \n\nDo these windows account for all the subarrays possible in `nums`? No, because there might be some `0`s before and after the window that will increase the number of subarrays.\n\nThe number of subarrays for a fixed endpoint is given by the number of `0`s that could be inserted at the beginning of the window plus one (if no `0`s in the beginning). If we insert any additional `0`s at the end of this window, the subarrays would increase by this number. See the example below:\n\n![figA](../Figures/1248/Slide1.PNG)\n\nWe iterate through the array `nums`. If we encounter an odd number, we push its index in the `oddIndices` queue. If the queue size exceeds `k`, we pop elements from it. If the queue has exactly `k` odd numbers, we can increment our answer by the number of `0`s at the beginning of the subarray.\n\n#### Algorithm\n\n1. Initialize integers `subarrays = 0`, `lastPopped = -1`, `initialGap = 0` and a queue `oddIndices`.\n2. Iterate over all the elements of `nums`:\n    - If the current element is odd:\n        - Push the current index in `oddIndices`.\n    - If the size of the queue is greater than `k`:\n        - Store the front of the queue in `lastPopped`.\n        - Pop the front of the queue.\n    - If size of the queue is `k`:\n        - Set `initialGap` as the difference between the front of the queue and `lastPopped`.\n        - Increment `subarrays` by `initialGap`.\n3. Return `subarrays`.\n\n!?!../Documents/1248/slideshow1.json:960,540!?!\n\n#### Implementation#### Complexity Analysis\n\nLet $n$ be the number of elements in the array `nums`.\n\n- Time complexity: $O(n)$\n\n    We iterate through the array exactly once. In each iteration of the array, we perform queue operations such as push, pop, and accessing the front element that takes $O(1)$ time. Therefore, the time complexity can be stated as $O(n)$.\n\n- Space complexity: $O(n)$\n\n    In each iteration, we perform one push operation in the queue. The space complexity is $O(n)$ because the queue size is proportional to the size of the list after $n$ iterations.\n\n---\n\n### Approach 3: Sliding Window (Space Optimisation of queue-based approach)\n\n#### Intuition\n\nIs it possible to avoid the queue in the previous approach? We only need the frequency of `0`s at the start to calculate the answer, so we can optimize the algorithm by calculating this value without using an additional $O(n)$ memory.\n\nWhile iterating through all possible endpoints of the windows, keep track of the count of odd values using an integer `qsize`. If `qsize` reaches `k`, adjust the `start` pointer to skip over even values at the beginning of the subarray until an odd value is encountered.\n\nNow, we add the number of even values covered by the `start` pointer, given by `initialGap`, to the answer. We will add this value to the answer for every subsequent even value.\n\n#### Algorithm\n\n1. Initialize integers `subarrays = 0`, `qsize = 0`, `initialGap = 0` and `start = 0`.\n2. Iterate over all the elements of `nums`:\n    - If the current element is odd:\n        - Increment `qsize` by 1.\n    - If `qsize` is equal to `k`:\n        - Set `initialGap` as 0.\n        - While `qsize` is `k`:\n            - Decrease `qsize` by 1 if element at `start` is odd.\n            - Increment `initialGap` by 1.\n            - Increment `start` by 1. \n    - Increment `subarrays` by `initialGap`.\n3. Return `subarrays`.\n\n!?!../Documents/1248/slideshow2.json:960,540!?!\n\n#### Implementation#### Complexity Analysis\n\nLet $n$ be the number of elements in the array `nums`.\n\n- Time complexity: $O(n)$\n\n    We iterate through the array exactly once. The `start` pointer can move at most `n` steps through all iterations. Therefore, the time complexity can be stated as $O(n)$.\n\n- Space complexity: $O(1)$\n\n    We do not allocate any additional auxiliary memory in our algorithm. Therefore, overall space complexity is given by $O(1)$.\n\n---\n\n### Approach 4: Sliding Window (subarray sum at most k)\n\n#### Intuition\n\nIs it possible to find the number of subarrays with sum at most `k` for an array with non-negative elements? We can use the sliding window approach to do this. However, for this problem, we need to calculate the number of subarrays with a sum exactly `k` (from Approach 1), not at most `k`. Observe that if we calculate the number of subarrays with sum at most `k` and at most `k-1`, their difference would give us the number of subarrays with sum exactly `k`.\n\nFor a subarray with a fixed `end` index, let `start` be the first index where the subarray from `start` to `end` contains exactly `k` odd elements. Any subarray that starts at an index after `start` and ends at `end` will contain at most `k` odd elements.\n\nWe iterate over the array `nums` for all possible values of `end`. Once we find the `start` value, the number of subarrays with at most `k` odd elements is calculated as `end - start + 1`(window size). We accumulate this value to the final answer across all end values.\n\n#### Algorithm\n\n**Main Function**: `numberOfSubarrays(nums, k)`\n\n1. Return the difference of `atMost(nums, k)` and `atMost(nums, k - 1)`\n\n**Function**: `atMost(nums, k)`\n\n1. Initialize integers `subarrays = 0`, `windowSize = 0` and `start = 0`.\n2. Iterate over all the elements of `nums`:\n    - If the current element is odd:\n        - Increment `windowSize` by 1.\n    - While `windowSize` is greater than `k`:\n        - Decrease `windowSize` by 1 if the current element is odd.\n        - Increment `start` by 1. \n    - Increment `subarrays` with `end - start + 1`, where `end` is the current index.\n3. Return `subarrays`.\n\n#### Implementation#### Complexity Analysis\n\nLet $n$ be the number of elements in the array `nums`.\n\n- Time complexity: $O(n)$\n\n    We call the `atMost` function 2 times. We iterate through the array exactly once in the function. The `start` pointer can move atmost `n` steps through all iterations. Therefore, the time complexity can be stated as $O(n)$.\n\n- Space complexity: $O(1)$\n  \n    We do not allocate any additional auxiliary memory in our algorithm. Therefore, overall space complexity is given by $O(1)$.\n\n---"
}