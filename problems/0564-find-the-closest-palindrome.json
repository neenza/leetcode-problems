{
  "title": "Find the Closest Palindrome",
  "problem_id": "564",
  "frontend_id": "564",
  "difficulty": "Hard",
  "problem_slug": "find-the-closest-palindrome",
  "topics": [
    "Math",
    "String"
  ],
  "description": "Given a string n representing an integer, return the closest integer (not including itself), which is a palindrome. If there is a tie, return the smaller one.\nThe closest is defined as the absolute difference minimized between two integers.\nExample 1:\nExample 2:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: n = \"123\"\nOutput: \"121\"",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input: n = \"1\"\nOutput: \"0\"\nExplanation: 0 and 2 are the closest palindromes but we return the smallest which is 0.",
      "images": []
    }
  ],
  "constraints": [
    "1 <= n.length <= 18",
    "n consists of only digits.",
    "n does not have leading zeros.",
    "n is representing an integer in the range [1, 1018 - 1]."
  ],
  "follow_ups": [],
  "hints": [
    "Will brute force work for this problem? Think of something else.",
    "Take some examples like 1234, 999,1000, etc and check their closest palindromes. How many different cases are possible?",
    "Do we have to consider only left half or right half of the string or both?",
    "Try to find the closest palindrome of these numbers- 12932, 99800, 12120. Did you observe something?"
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    string nearestPalindromic(string n) {\n        \n    }\n};",
    "java": "class Solution {\n    public String nearestPalindromic(String n) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def nearestPalindromic(self, n):\n        \"\"\"\n        :type n: str\n        :rtype: str\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def nearestPalindromic(self, n: str) -> str:\n        ",
    "c": "char* nearestPalindromic(char* n) {\n    \n}",
    "csharp": "public class Solution {\n    public string NearestPalindromic(string n) {\n        \n    }\n}",
    "javascript": "/**\n * @param {string} n\n * @return {string}\n */\nvar nearestPalindromic = function(n) {\n    \n};",
    "typescript": "function nearestPalindromic(n: string): string {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param String $n\n     * @return String\n     */\n    function nearestPalindromic($n) {\n        \n    }\n}",
    "swift": "class Solution {\n    func nearestPalindromic(_ n: String) -> String {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun nearestPalindromic(n: String): String {\n        \n    }\n}",
    "dart": "class Solution {\n  String nearestPalindromic(String n) {\n    \n  }\n}",
    "golang": "func nearestPalindromic(n string) string {\n    \n}",
    "ruby": "# @param {String} n\n# @return {String}\ndef nearest_palindromic(n)\n    \nend",
    "scala": "object Solution {\n    def nearestPalindromic(n: String): String = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn nearest_palindromic(n: String) -> String {\n        \n    }\n}",
    "racket": "(define/contract (nearest-palindromic n)\n  (-> string? string?)\n  )",
    "erlang": "-spec nearest_palindromic(N :: unicode:unicode_binary()) -> unicode:unicode_binary().\nnearest_palindromic(N) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec nearest_palindromic(n :: String.t) :: String.t\n  def nearest_palindromic(n) do\n    \n  end\nend"
  },
  "solution": "[TOC]\n\n## Solution\n\n---\n\n### Approach 1: Find Previous and Next Palindromes\n\n#### Intuition\n\nThe problem asks us to find the closest palindrome to a given integer `n` represented as a string. The string length is at most 18, meaning `n` can be as large as 999,999,999,999,999,999. The goal is to return the nearest palindrome to `n` that is not equal to `n` itself, minimizing the absolute difference.\n\nTo solve this, we can think of a palindrome as a number where the first half is mirrored to create the second half. For example, the palindrome for `12321` is formed by reversing the first half (`12`) and appending it to itself (`12` -> `12321`). This observation is key to finding the closest palindrome.\n\nIf we consider changing the second half of `n` to match the reverse of the first half, we might obtain a palindrome close to `n`. However, there are cases where this method might not give us the optimal answer, particularly for odd-length strings or when small adjustments to the first half could yield a closer palindrome.\n\nFor instance, consider `n = 139`. If we mirror the first half (`13`), we get `131`, but a closer palindrome is `141`. Therefore, it's important to also check palindromes formed by slightly adjusting the first half of `n`:\n\n1. Same Half: Create a palindrome by mirroring the first half.\n2. Decremented Half: Create a palindrome by decrementing the first half by 1 and mirroring it.\n3. Incremented Half: Create a palindrome by incrementing the first half by 1 and mirroring it.\n\n> Note: Adding +1 or subtracting -1 to/from the first half ensures that we stay as close as possible to the original number while creating new potential palindromes. If we were to add or subtract a larger value, such as +2 or -2, the resulting palindrome would be farther away from the original number, potentially missing a closer palindrome, and it's given that we need to find the closest palindrome.\n\n\nIn addition to these cases, we must handle edge cases where `n` is close to numbers like `1000`, `10000`, etc., or very small numbers like `11` or `9`. These can produce palindromes like `99`, `999`, or `101`, `1001`, which might be closer to `n`.\n\nTo summarize, we need to check the following five candidates:\n- Palindrome formed from the first half of `n`.\n- Palindrome formed from the first half decremented by 1.\n- Palindrome formed from the first half incremented by 1.\n- Nearest palindrome of the form `99`, `999`, etc.\n- Nearest palindrome of the form `101`, `1001`, etc.\n\nAfter generating these candidates, we compare them to `n` and choose the one with the smallest absolute difference.\n\n#### Algorithm\n\nMain Function - `nearestPalindromic(n)`\n\n1. Calculate the length of `n` and determine the midpoint.\n2. Extract the first half of the number.\n3. Generate possible palindromic candidates and append them to `possibilities` list:\n    - Mirror the first half and append it to the string.\n    - Mirror the first half incremented by 1 and append it to the string.\n    - Mirror the first half decremented by 1 and append it to the string.\n    - Add the form 999....\n    - Add the form 100...001.\n4. Find the nearest palindromic number by comparing absolute differences.\n5. Return the closest palindrome.\n\nHelper Function - `halfToPalindrome(left, even)`\n\n1. Initialize `res` with `left`.\n2. If the length is odd, divide `left` by 10.\n3. Mirror the digits of `left` to form a palindrome.\n4. Return the palindrome `res`.\n\n![approach1](../Figures/564/approach1.png)\n\n#### Implementation#### Complexity Analysis\n\nLet $n$ be the number of digits in the input number.\n\n- Time complexity: $O(n)$\n    \n    We perform operations on exactly 5 strings. The palindrome construction for each string takes $O(n)$ time. Therefore, total time complexity is given by $O(n)$.\n\n- Space complexity: $O(n)$\n    \n    We store the 5 possible candidates in the `possibilities` array. Apart from this, the built-in functions used to make the `firstHalf` can potentially lead to $O(n)$ space complexity, as they copy the characters into a new String. Therefore, the total space complexity is $O(n)$.\n\n---\n\n### Approach 2: Binary Search\n\n#### Intuition\n\nAnother way to solve the problem is by using binary search. The task is to find the smallest palindrome greater than `n` and the largest palindrome smaller than `n`, then return the one with the smallest absolute difference. Since this is a minimization/maximization, we can try to use binary search to solve this problem. But, our search space should be sorted to apply binary search. Observe that when you construct the palindromes using the first half for two integers, then the greater integer would always have it's constructed palindrome greater. Therefore, our search space is sorted in a non-decreasing order.\n\nGiven that palindromes are symmetric numbers, we can search within a specific range by leveraging binary search. The key is to first determine potential palindromes by constructing them based on the first half of `n`.\n\nFinding the Next Palindrome:\n- Start with the left boundary as `n + 1` and the right boundary as an infinitely large value.\n- Perform binary search within this range. For each midpoint value, construct the palindrome by mirroring its first half.\n- If the constructed palindrome is greater than `n`, shift the search to the left (smaller values). Otherwise, move to the right.\n\nFinding the Previous Palindrome:\n- Start with the left boundary as `0` and the right boundary as `n - 1`.\n- Perform binary search, constructing palindromes as above.\n- If the constructed palindrome is smaller than `n`, shift the search to the right (larger values). Otherwise, move to the left.\n\nBinary search efficiently narrows down the range of possible palindromes, finding the closest one that is greater and the closest one that is smaller. Once we have these two candidates, we simply compare their differences with `n` to determine the closest palindrome.\n\nThis approach is particularly useful when `n` is large, as it reduces the search space compared to checking all potential candidates directly.\n\n#### Algorithm\n\n`convert(num)`\n\n1. Convert the number `num` to a string `s`.\n2. Identify the midpoint indices `l (left)` and `r (right)`.\n3. Mirror the left half of the string s onto the right half to create a palindrome.\n4. Return the palindrome as a long integer.\n\n`nextPalindrome(num)`\n\n1. Initialize `left` to 0 and `right` to `num`.\n2. Use binary search to find the next palindrome greater than `num`:\n    - Calculate `mid` as the midpoint between `left` and `right`.\n    - Convert `mid` to a palindrome using `convert(mid)`.\n    - If the palindrome is less than `num`, update `ans` to the palindrome and set `left` to `mid + 1`.\n    - Otherwise, set `right` to `mid - 1`.\n3. Return the result `ans`.\n\n`previousPalindrome(num)`\n\n1. Initialize `left` to `num` and `right` to a large value `(1e18)`.\n2. Use binary search to find the previous palindrome smaller than `num`:\n    - Calculate `mid` as the midpoint between `left` and `right`.\n    - Convert `mid` to a palindrome using `convert(mid)`.\n    - If the palindrome is greater than `num`, update `ans` to the palindrome and set `right` to `mid - 1`.\n    - Otherwise, set `left` to `mid + 1`.\n3. Return the result `ans`.\n\nMain Function - `nearestPalindromic(n)`\n\n1. Convert the input string `n` to a long integer `num`.\n2. Call `nextPalindrome(num)` to find the next palindrome greater than `num`.\n3. Call `previousPalindrome(num)` to find the previous palindrome smaller than `num`.\n4. Compare the differences between `num` and the two palindromes found:\n    - If the difference with the next palindrome is less than or equal to the difference with the previous palindrome, return the next palindrome. Otherwise, return the previous palindrome as a string.\n\n#### Implementation#### Complexity Analysis\n\nLet $m$ be the input number and $n$ be the number of digits in it.\n\n- Time complexity: $O(n \\cdot log(m))$\n    \n    We perform two binary search operations on a search space of size `m`, and in each operation iterate through all the digits. Therefore, the total time complexity is given by $O(n \\cdot log(m))$.\n\n- Space complexity: $O(n)$\n\n    The space complexity is primarily determined by the storage needed for the string representation of the number and the intermediate list or character array used for manipulation. Since these data structures are proportional to the number of digits in $O(n)$, the total space complexity is $O(n)$.\n\n    For C++: `to_string(num)` - Converts the number to a string, which requires space proportional to the number of digits in $O(n)$, i.e., $O(n)$.\n    For Java: `Long.toString(num)` - Converts the number to a string, requiring $O(n)$ space.\n    For Python: `''.join(s_list)` - Creates a new string from the list, requiring $O(n)$ space.\n\n---"
}