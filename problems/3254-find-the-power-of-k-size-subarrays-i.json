{
  "title": "Find the Power of K-Size Subarrays I",
  "problem_id": "3522",
  "frontend_id": "3254",
  "difficulty": "Medium",
  "problem_slug": "find-the-power-of-k-size-subarrays-i",
  "topics": [
    "Array",
    "Sliding Window"
  ],
  "description": "You are given an array of integers nums of length n and a positive integer k.\nThe power of an array is defined as:\nYou need to find the power of all subarrays of nums of size k.\nReturn an integer array results of size n - k + 1, where results[i] is the power of nums[i..(i + k - 1)].\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: nums = [1,2,3,4,3,2,5], k = 3\nOutput: [3,4,-1,-1,-1]\nExplanation:\nThere are 5 subarrays of nums of size 3:",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input: nums = [2,2,2,2,2], k = 4\nOutput: [-1,-1]",
      "images": []
    },
    {
      "example_num": 3,
      "example_text": "Input: nums = [3,2,3,2,3,2], k = 2\nOutput: [-1,3,-1,3,-1]",
      "images": []
    }
  ],
  "constraints": [
    "1 <= n == nums.length <= 500",
    "1 <= nums[i] <= 105",
    "1 <= k <= n"
  ],
  "follow_ups": [],
  "hints": [
    "Can we use a brute force solution with nested loops and HashSet?"
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    vector<int> resultsArray(vector<int>& nums, int k) {\n        \n    }\n};",
    "java": "class Solution {\n    public int[] resultsArray(int[] nums, int k) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def resultsArray(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def resultsArray(self, nums: List[int], k: int) -> List[int]:\n        ",
    "c": "/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nint* resultsArray(int* nums, int numsSize, int k, int* returnSize) {\n    \n}",
    "csharp": "public class Solution {\n    public int[] ResultsArray(int[] nums, int k) {\n        \n    }\n}",
    "javascript": "/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number[]}\n */\nvar resultsArray = function(nums, k) {\n    \n};",
    "typescript": "function resultsArray(nums: number[], k: number): number[] {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @param Integer $k\n     * @return Integer[]\n     */\n    function resultsArray($nums, $k) {\n        \n    }\n}",
    "swift": "class Solution {\n    func resultsArray(_ nums: [Int], _ k: Int) -> [Int] {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun resultsArray(nums: IntArray, k: Int): IntArray {\n        \n    }\n}",
    "dart": "class Solution {\n  List<int> resultsArray(List<int> nums, int k) {\n    \n  }\n}",
    "golang": "func resultsArray(nums []int, k int) []int {\n    \n}",
    "ruby": "# @param {Integer[]} nums\n# @param {Integer} k\n# @return {Integer[]}\ndef results_array(nums, k)\n    \nend",
    "scala": "object Solution {\n    def resultsArray(nums: Array[Int], k: Int): Array[Int] = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn results_array(nums: Vec<i32>, k: i32) -> Vec<i32> {\n        \n    }\n}",
    "racket": "(define/contract (results-array nums k)\n  (-> (listof exact-integer?) exact-integer? (listof exact-integer?))\n  )",
    "erlang": "-spec results_array(Nums :: [integer()], K :: integer()) -> [integer()].\nresults_array(Nums, K) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec results_array(nums :: [integer], k :: integer) :: [integer]\n  def results_array(nums, k) do\n    \n  end\nend"
  },
  "solution": "[TOC]\n\n## Solution\n\n---\n\n### Approach 1: Brute Force\n\n#### Intuition\n\nA logical approach is to check every possible subarray of size `k` within the given array. Our goal is to determine if these subarrays contain consecutive integers in ascending order and their power.\n\nFor each starting index $i$, we extract the subarray of elements from $nums[i]$ to $nums[i + k - 1]$. We then need to verify two conditions: the elements must be sorted in ascending order, and they must be consecutive integers.\n\nTo check the consecutive property, we iterate through the elements in the subarray and compare each element with the next. If two adjacent elements are not consecutive (meaning the next element is not equal to the current element plus one), we mark the subarray as invalid. If the subarray passes both checks, we take the last element as the maximum, as the elements are sorted.\n\n#### Algorithm\n\n- Initialize `length` to the size of `nums`.\n- Create an integer array `result` with size `length - k + 1` to store the output.\n\n- Iterate through each starting position of the subarray in `nums` using `start`:\n  - Set `isConsecutiveAndSorted` to `true` to assume the subarray is valid initially.\n\n  - Check if the current subarray (of size `k`) is sorted and consecutive:\n    - Loop through each element in the subarray (from `start` to `start + k - 2`):\n      - If the next element is not exactly `1` greater than the current element, set `isConsecutiveAndSorted` to `false` and break out of the loop.\n\n  - After the loop, if `isConsecutiveAndSorted` is still `true`:\n    - Set `result[start]` to the maximum element in the subarray, which is `nums[start + k - 1]`.\n  - Otherwise, set `result[start]` to `-1`.\n\n- Return `result`, where indices with valid sequences contain the last element of the sequence, and others remain `-1`.\n\n#### Implementation#### Complexity Analysis\n\nLet $n$ be the length of the input array `nums` and $k$ be the length of the subarrays we are checking.\n\n- Time complexity: $O(n \\cdot k)$\n\n    The outer loop iterates $n - k + 1$ times, as we are checking each possible starting point for subarrays of length $k$ within `nums`.\n    \n    For each starting position, the inner loop iterates $k - 1$ times to verify if the subarray is consecutive and sorted.\n    \n    Therefore, the total time complexity is $O((n - k + 1) \\cdot (k - 1))$, which simplifies to $O(n \\cdot k)$.\n\n- Space complexity: $O(1)$\n\n    The `result` array has a size of $n - k + 1$, which is required to store the output. However, since this is the required output (stated in the problem statement), it does not count as auxiliary space.\n\n---\n\n### Approach 2: Sliding Window with Deque\n\n#### Intuition\n\nFor a more efficient approach, we can use the sliding window technique to avoid rechecking the entire subarray from scratch each time we move the window.\n\nWe use a deque to store the indices of elements in the valid sequence. We'll maintain a window of size `k` to slide through the array, focusing on two aspects: keeping track of the current valid window, and ensuring the consecutive property holds.\n\nAs we move to a new element, we first check if it breaks the consecutive sequence with the last inserted element in the deque. If it does, we invalidate the entire window and clear the deque. Otherwise, we add the current element’s index to the deque.\n\nWhen our window size reaches `k`, we examine the size of the deque. If the deque contains exactly `k` indices, we conclude that we have a valid subarray, and we can retrieve the maximum element efficiently from the end of the deque. If the deque does not have `k` elements, we set the result for that position to -1.\n\n#### Algorithm\n\n- Initialize `length` to the size of the `nums` array and `result` array of size `length - k + 1`.\n- Create a deque `indexDeque` to store indices within the sliding window.\n\n- Loop through each index `currentIndex` in `nums`:\n  - If `indexDeque` is not empty and the index at the front of `indexDeque` is out of the window range, remove it to maintain the sliding window size.\n  \n  - If `indexDeque` is not empty and `nums[currentIndex]` does not follow the consecutive and sorted condition (i.e., `nums[currentIndex]` is not `nums[currentIndex - 1] + 1`), clear `indexDeque` as the current sequence is invalid.\n  \n  - Add `currentIndex` to the end of `indexDeque`.\n\n  - If `currentIndex` has reached at least `k - 1` (window has a full size of `k`):\n    - If `indexDeque` contains exactly `k` elements, set `result[currentIndex - k + 1]` to the value at `nums[indexDeque.peekLast()]` since the window is valid.\n    - Otherwise, set `result[currentIndex - k + 1]` to `-1` as it indicates an invalid window.\n\n- Return `result`, where indices with valid sequences contain the last element of the sequence, and others remain -1.\n\n#### Implementation#### Complexity Analysis\n\nLet $n$ be the length of the input array `nums` and $k$ be the length of the subarrays we are checking.\n\n- Time complexity: $O(n)$\n\n    The `for` loop iterates over each element in `nums`, making it $O(n)$.\n    \n    Inside the loop:\n      - Removing elements from the `indexDeque` and clearing it takes $O(1)$ since the `Deque` operations are all constant-time operations.\n      - Each index is added and removed from the `indexDeque` at most once, resulting in $O(n)$ total operations for managing the `Deque`.\n    \n    Thus, the overall time complexity is $O(n)$.\n\n- Space complexity: $O(k)$\n\n    The space complexity is primarily due to the `indexDeque`, which can hold at most $k$ elements at any time, as elements that are out of the window are removed from the `Deque`.\n        \n    Thus, the auxiliary space complexity is $O(k)$.\n\n---\n\n\n### Approach 3: Optimized Via Counter\n\n#### Intuition\n\nIn the previous approach, we used a deque to track a sequence of size `k` and check if each new element is consecutive with the last element added to the deque. However, this raises an important question: why use a deque at all if we’re only interested in checking whether the current element follows directly from the last one we examined?\n\nThis leads us to a simpler approach: we can replace the deque with a simple counter that tracks the length of the consecutive sequence. As we go through the array, we check each element with the one that follows it. If they are consecutive, we increase our counter. Otherwise, we reset the counter to 1 since the sequence is broken.\n\nWhen our counter reaches `k`, it signals that we’ve found a valid subarray of size `k`. At this point, we store the last element of this sequence as the result. For any indices that don’t meet the consecutive condition, we set their result to -1.\n\n\n![Optimized Via Counter](../Figures/3254/3254_approach3.png)\n\n\n#### Algorithm\n\n- If `k` is 1, return `nums` directly, as each single element is a valid subarray.\n\n- Initialize `length` to the length of `nums` and create an array `result` of size `length - k + 1`.\n  - Fill `result` with -1 to represent non-matching positions.\n\n- Initialize `consecutiveCount` to 1, which keeps track of consecutive elements.\n\n- Loop through `nums` from the start to `length - 1`:\n  - If `nums[index] + 1` equals `nums[index + 1]`, increment `consecutiveCount`.\n  - If the elements are not consecutive, reset `consecutiveCount` to 1.\n\n  - If `consecutiveCount` reaches or exceeds `k`, update `result` at position `index - k + 2` with `nums[index + 1]`.\n    - This indicates that a valid sequence of length `k` ending at `nums[index + 1]` was found.\n\n- Return `result`, where indices with valid sequences contain the last element of the sequence, and others remain -1.\n\n#### Implementation#### Complexity Analysis\n\nLet $n$ be the length of the input array `nums` and $k$ be the length of the subarrays we are checking.\n\n- Time complexity: $O(n)$\n\n    The filling of the array with -1 takes $O(n)$ since it initializes the `result` array.\n    \n    The `for` loop iterates over each element in `nums` once (up to `length - 1`), making the primary loop $O(n)$.\n    \n    Inside the loop:\n      - We perform a constant-time check to determine if the current element is consecutive with the next element and increment or reset `consecutiveCount`.\n      - The `result` array is updated in constant time as well when a valid subarray of size $k$ is found.\n    \n    Thus, the overall time complexity is $O(n)$.\n\n- Space complexity: $O(1)$\n\n    The `result` array has a size of $n - k + 1$, which is required to store the output. However, since this is the required output(stated in the problem statement), it does not count as auxiliary space.\n\n---"
}