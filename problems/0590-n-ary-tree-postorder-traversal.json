{
  "title": "N-ary Tree Postorder Traversal",
  "problem_id": "776",
  "frontend_id": "590",
  "difficulty": "Easy",
  "problem_slug": "n-ary-tree-postorder-traversal",
  "topics": [
    "Stack",
    "Tree",
    "Depth-First Search"
  ],
  "description": "Given the root of an n-ary tree, return the postorder traversal of its nodes' values.\nNary-Tree input serialization is represented in their level order traversal. Each group of children is separated by the null value (See examples)\nExample 1:\nExample 2:\nConstraints:\nFollow up: Recursive solution is trivial, could you do it iteratively?",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: root = [1,null,3,2,4,null,5,6]\nOutput: [5,6,3,2,4,1]",
      "images": [
        "https://assets.leetcode.com/uploads/2018/10/12/narytreeexample.png"
      ]
    },
    {
      "example_num": 2,
      "example_text": "Input: root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]\nOutput: [2,6,14,11,7,3,12,8,4,13,9,10,5,1]",
      "images": [
        "https://assets.leetcode.com/uploads/2019/11/08/sample_4_964.png"
      ]
    }
  ],
  "constraints": [
    "The number of nodes in the tree is in the range [0, 104].",
    "0 <= Node.val <= 104",
    "The height of the n-ary tree is less than or equal to 1000."
  ],
  "follow_ups": [
    "Recursive solution is trivial, could you do it iteratively?"
  ],
  "hints": [],
  "code_snippets": {
    "cpp": "/*\n// Definition for a Node.\nclass Node {\npublic:\n    int val;\n    vector<Node*> children;\n\n    Node() {}\n\n    Node(int _val) {\n        val = _val;\n    }\n\n    Node(int _val, vector<Node*> _children) {\n        val = _val;\n        children = _children;\n    }\n};\n*/\n\nclass Solution {\npublic:\n    vector<int> postorder(Node* root) {\n        \n    }\n};",
    "java": "/*\n// Definition for a Node.\nclass Node {\n    public int val;\n    public List<Node> children;\n\n    public Node() {}\n\n    public Node(int _val) {\n        val = _val;\n    }\n\n    public Node(int _val, List<Node> _children) {\n        val = _val;\n        children = _children;\n    }\n}\n*/\n\nclass Solution {\n    public List<Integer> postorder(Node root) {\n        \n    }\n}",
    "python": "\"\"\"\n# Definition for a Node.\nclass Node(object):\n\tdef __init__(self, val: Optional[int] = None, children: Optional[List['Node']] = None):\n        self.val = val\n        self.children = children\n\"\"\"\n\nclass Solution(object):\n    def postorder(self, root):\n        \"\"\"\n        :type root: Node\n        :rtype: List[int]\n        \"\"\"\n        ",
    "python3": "\"\"\"\n# Definition for a Node.\nclass Node:\n    def __init__(self, val: Optional[int] = None, children: Optional[List['Node']] = None):\n        self.val = val\n        self.children = children\n\"\"\"\n\nclass Solution:\n    def postorder(self, root: 'Node') -> List[int]:\n        ",
    "c": "/**\n * Definition for a Node.\n * struct Node {\n *     int val;\n *     int numChildren;\n *     struct Node** children;\n * };\n */\n\n/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nint* postorder(struct Node* root, int* returnSize) {\n    \n}",
    "csharp": "/*\n// Definition for a Node.\npublic class Node {\n    public int val;\n    public IList<Node> children;\n\n    public Node() {}\n\n    public Node(int _val) {\n        val = _val;\n    }\n\n    public Node(int _val, IList<Node> _children) {\n        val = _val;\n        children = _children;\n    }\n}\n*/\n\npublic class Solution {\n    public IList<int> Postorder(Node root) {\n        \n    }\n}",
    "javascript": "/**\n * // Definition for a _Node.\n * function _Node(val,children) {\n *    this.val = val;\n *    this.children = children;\n * };\n */\n\n/**\n * @param {_Node|null} root\n * @return {number[]}\n */\nvar postorder = function(root) {\n    \n};",
    "typescript": "/**\n * Definition for node.\n * class _Node {\n *     val: number\n *     children: _Node[]\n *     constructor(val?: number) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.children = []\n *     }\n * }\n */\n\nfunction postorder(root: _Node | null): number[] {\n\n};",
    "php": "/**\n * Definition for a Node.\n * class Node {\n *     public $val = null;\n *     public $children = null;\n *     function __construct($val = 0) {\n *         $this->val = $val;\n *         $this->children = array();\n *     }\n * }\n */\n\nclass Solution {\n    /**\n     * @param Node $root\n     * @return integer[]\n     */\n    function postorder($root) {\n        \n    }\n}",
    "swift": "/**\n * Definition for a Node.\n * public class Node {\n *     public var val: Int\n *     public var children: [Node]\n *     public init(_ val: Int) {\n *         self.val = val\n *         self.children = []\n *     }\n * }\n */\n\nclass Solution {\n    func postorder(_ root: Node?) -> [Int] {\n    \t\n    }\n}",
    "kotlin": "/**\n * Definition for a Node.\n * class Node(var `val`: Int) {\n *     var children: List<Node?> = listOf()\n * }\n */\n\nclass Solution {\n    fun postorder(root: Node?): List<Int> {\n        \n    }\n}",
    "golang": "/**\n * Definition for a Node.\n * type Node struct {\n *     Val int\n *     Children []*Node\n * }\n */\n\nfunc postorder(root *Node) []int {\n    \n}",
    "ruby": "# Definition for a Node.\n# class Node\n#     attr_accessor :val, :children\n#     def initialize(val)\n#         @val = val\n#         @children = []\n#     end\n# end\n\n# @param {Node} root\n# @return {List[int]}\ndef postorder(root)\n    \nend",
    "scala": "/**\n * Definition for a Node.\n * class Node(var _value: Int) {\n *   var value: Int = _value\n *   var children: List[Node] = List()\n * }\n */\n\nobject Solution {\n    def postorder(root: Node): List[Int] = {\n        \n    }\n}"
  },
  "solution": "[TOC]\n\n## Solution\n\n---\n\n### Overview\n\nThe N-ary tree is a generalization of a binary tree where each node can have more than two children. In postorder traversal, the traversal order is as follows:\n\n1. Visit all the children of a node from left to right.\n2. After all the children have been visited, visit the node itself.\n\nThe problem provides the tree in a level-order traversal format, where children of a node are grouped and separated by a null value.\n\nIf you are completely unfamiliar with N-ary trees, check out this LeetCode [Explore Card](https://leetcode.com/explore/learn/card/n-ary-tree/) for an in-depth discussion.\n    \n---\n\n### Approach 1: Recursive\n\n#### Intuition\n\nBefore we explore the solution, let's visualize the postorder traversal in this slideshow:\n\n!?!../Documents/590/slideshow.json:934,902!?!\n\nLet's walk through the process using a recursive function `traversePostorder`. This function will call itself for each child of the current node, effectively breaking down the traversal into smaller, manageable subproblems. The key idea here is that recursion allows us to naturally explore the entire depth of each subtree before moving on to the next sibling subtree.\n\n1. Base Case: If the node has no children (i.e., it's a leaf node), the function simply adds the node's value to the result list.\n2. Recursive Step: For a non-leaf node, the function iterates over all its children, recursively calling `traversePostorder` on each one. After all children have been processed, the function adds the current node's value to the result list.\n\nFor example, consider an n-ary tree where the root has three children. The function will:\n- Traverse all the subtrees rooted at the first child.\n- After finishing with the first subtree, it moves to the second child and repeats the process.\n- Finally, after all subtrees have been traversed, the function adds the root nodeâ€™s value to the result list.\n\nThe result list now contains the nodes' values in the correct postorder sequence.\n\nThis approach effectively mimics the natural recursive nature of postorder traversal, where the exploration of each subtree is completed before moving to the next.\n\n#### Algorithm\n\nMain method `postorder`:\n\n- Initialize a list `result` to store the postorder traversal of the nodes' values.\n- If the input `root` node is `null`, return the empty `result` list immediately. \n- Invoke the helper method `traversePostorder` to perform the postorder traversal.\n- Return `result` as our answer.\n\nHelper method `traversePostorder`:\n\n- Define a method `traversePostorder` with parameters: `currentNode` and the `postorderList` to store the result.\n- If `currentNode` is `null`, return.\n- Loop over each `childNode` of `currentNode`:\n  - Recursively call `traversePostorder` on each `childNode`.\n- Add the value of `currentNode` to `postorderList`.\n\n#### Implementation#### Complexity Analysis\n\nLet $m$ be the number of nodes in the tree.\n\n- Time complexity: $O(m)$\n\n    The method `traversePostorder` visits each node in the tree exactly once. Thus, the time complexity of the algorithm is $O(m)$.\n\n- Space complexity: $O(m)$\n\n    The `traversePostorder` method uses recursion, and the maximum depth of the recursion is the height of the tree, which is $O(m)$ in the worst case (for a skewed tree).  \n\n    Thus, the space complexity of the algorithm is also $O(m)$.\n\n---\n\n### Approach 2: Iterative (Explicit Reversal)\n\n#### Intuition\n\nIn contrast to the recursive method, implementing an iterative approach for postorder traversal in an n-ary tree presents a challenge. The recursive method naturally processes nodes in a bottom-up manner, but this behavior doesn't translate directly to an iterative stack-based approach, since a stack processes elements in a last-in-first-out (LIFO) order.\n\nTo achieve postorder traversal iteratively, we can adopt a method that initially resembles preorder traversal but with some modifications.\n\n1. Simulate Preorder with Stack: We start by pushing the root node onto the stack. As long as the stack isnâ€™t empty, we pop the top element, add it to the result list, and then push all its children onto the stack from left to right.\n   \n   - This order means that when children are popped from the stack for further evaluation, they come out in the reverse order (right to left). Thus, at this point, our traversal order is root -> right-to-left children.\n\n2. Reverse the Result: After the entire tree has been processed, and the stack is empty, the result list will reflect the reverse of what we want. By reversing this result list, we obtain the correct postorder traversal, where each nodeâ€™s children are fully processed before the node itself.\n\nThis approach leverages the stack to mimic the recursive behavior, but because of the LIFO nature of the stack, we reverse the result at the end to achieve the desired postorder sequence. Although this method doesn't traverse the tree in a strict postorder manner, it remains a valid solution since the problem only requires the correct order in the final result.\n\n#### Algorithm\n \n- Create a list `result` to store the postorder traversal of the nodes' values.\n- If the input `root` node is `null`, return the empty result list immediately.\n- Initialize a `stack` and push the root node onto it. This stack will be used to traverse the tree.\n- While the `stack` is not empty:\n  - Pop a node from `stack` and assign it to a variable `currentNode`.\n  - Add the value of `currentNode` to `result`.\n  - Iterate through the `children` of `currentNode`. For each `child` node:\n    - Push `child` onto the `stack`.\n- Reverse the `result` list.\n- Return `result` as our answer.\n\n#### Implementation#### Complexity Analysis\n\nLet $m$ be the number of nodes in the tree.\n\n* Time complexity: $O(m)$\n\n    The main loop iterates over every node in the tree, taking $O(m)$ time. Each stack operation inside the loop takes constant time. Reversing the `result` list takes an additional linear time.\n\n    Thus, the overall time complexity of the algorithm is $O(m)$.\n\n* Space complexity: $O(m)$\n\n    In the worst case, if the tree is highly unbalanced (e.g., a skewed tree), the stack can grow to store all nodes at once, contributing $O(m)$ to the space complexity. No other additional data structures are used. \n\n    Thus, the space complexity of the algorithm is $O(m)$.\n---\n\n### Approach 3: Iterative (Two Stacks)\n\n#### Intuition\n\nThis approach refines the iterative method by utilizing two stacks to better manage the order in which nodes are processed, ultimately eliminating the need to reverse the result at the end. \n\nIn this method, we use two stacks: `nodeStack` for the main traversal and `reverseStack` to temporarily hold the nodes in reverse order before they are added to the final result. \n\nWe start by pushing the `root` node onto the `nodeStack`. As long as `nodeStack` is not empty, we proceed with the following steps.\n   \nWe pop the top node from `nodeStack`. Instead of adding it directly to the result list (as its children haven't been processed yet), we push it onto `reverseStack`. This postpones the addition of the node to the final result, allowing us to process its children first.\n\nNow we iterate over the children of the current node from left to right, pushing each child onto `nodeStack`. Due to the LIFO nature of stacks, these children will be popped and processed in the reverse order (right to left). As a result, the nodes in `reverseStack` will eventually be ordered such that when we pop them, we get the correct postorder sequence: children from left to right, followed by their parent node.\n\nAfter processing all nodes, `reverseStack` will contain the nodes in postorder, but in reverse order. We then simply pop elements from `reverseStack` one by one and add them to our result list. This ensures that the final list is in the correct postorder sequence.\n\n#### Algorithm\n \n- Initialize a list `result` to store the postorder traversal of the nodes' values.\n- If the input `root` node is `null`, return the empty `result` list immediately.\n- Initialize two stacks: `nodeStack` for traversal and `reverseStack` to store nodes in reverse order.\n- Push `root` onto the `nodeStack` to start the traversal.\n- While `nodeStack` is not empty:\n  - Pop a node `currentNode` from the `nodeStack`.\n  - Push `currentNode` onto `reverseStack`.\n  - Iterate through the `children` of `currentNode`. For each node `child`:\n    - Push each `child` onto `nodeStack` to ensure they are processed in the subsequent iterations.\n- While `reverseStack` is not empty:\n  - Pop a node from `reverseStack` and assign it to `currentNode`.\n  - Add the value of `currentNode` to `result`.\n- Return the `result` list.\n\n#### Implementation#### Complexity Analysis\n\nLet $m$ be the number of nodes in the tree.\n\n* Time complexity: $O(m)$\n\n    The first loop iterates over each node in the tree exactly once. Each node is pushed onto `nodeStack` and then moved to `reverseStack`. Since each node is processed exactly once, the time complexity for this loop is $O(m)$.\n\n    The second loop also processes each node exactly once, adding their values to the `result` list. This loop has a time complexity of $O(m)$.\n\n    Thus, the overall time complexity of the algorithm is $O(m) + O(m) = O(m)$.\n\n* Space complexity: $O(m)$\n\n    The `nodeStack` and `reverseStack` can each hold up to $m$ nodes in the worst case. This makes the space complexity of the algorithm $O(m)$.\n\n---\n\n### Approach 4: Iterative (Without Reverse)\n\n#### Intuition\n\nIn this approach, we aim to closely mimic the natural flow of recursion using a single stack, avoiding the need to reverse the final result by carefully managing when nodes are added to the result list.\n\nTo replicate the recursive process, we need to simulate the behavior where each node is visited twice: first when we encounter it initially and later after all its children have been processed. The key idea here is to use a flag to track whether a node has been visited once before adding it to the result list.\n\nWe start by pushing the root node onto the stack with a `visited` flag set to `false`. This flag indicates whether the node has been fully processed (i.e., whether its children have been visited).\n\nAs we iterate, we pop the top element from the stack and check its `visited` flag:\n   - First Encounter (`visited` = `false`): If this is the first time we're seeing this node, we update its flag to `true` and push it back onto the stack. Then, we push all its children onto the stack from right to left. This ensures that when we revisit these nodes, they will be processed in left-to-right order.\n   \n   - Second Encounter (`visited` = `true`): When the node is encountered again (after its children have been processed), we add it to the result list. This step corresponds to the natural postorder sequence, where a node is added to the result after all its children have been visited.\n\nBy the time the stack is empty, all nodes will have been processed in the correct postorder sequence, and the result list will reflect the correct traversal without the need for any additional reversal.\n\n#### Algorithm\n \n- Create a list `result` to store the postorder traversal of the nodes' values.\n- If the input `root` node is `null`, return the empty `result` list immediately.\n- Create a stack `nodeStack` of type `NodeVisitPair` that will hold pairs of nodes and their visit status.\n- Push the `root` node onto the stack with `isVisited` set to `false`, indicating that the node has not yet been fully processed.\n- While `nodeStack` is not empty:\n  - Pop a pair from the `nodeStack` and assign it to `currentPair`.\n  - If `currentPair.isVisited` is `true`, add the node's value to `result`.\n  - Else, set `currentPair.isVisited` to `true` and push `currentPair` back onto the stack.\n  - Retrieve the children of the current node and set it to a list `children`.\n  - Iterate over `children` in reverse order and push each child onto the stack.\n- Return `result`.\n\n#### Implementation#### Complexity Analysis\n\nLet $m$ be the number of nodes in the tree.\n\n* Time complexity: $O(m)$\n\n    Each node is pushed onto the stack twice: once with `isVisited = false` and once with `isVisited = true`. Consequently, each node is popped from the stack twice. Overall, this makes the time complexity of the algorithm $O(4 \\cdot m) = O(m)$.\n\n* Space complexity: $O(m)$\n\n    The `nodeStack` will, in the worst case (for a skewed tree), contain all `m` nodes of the tree. Each entry in the stack takes constant space. \n\n    Thus, the space complexity of the algorithm is $O(m)$.\n\n---"
}