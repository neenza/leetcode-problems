{
  "title": "Rotate String",
  "problem_id": "812",
  "frontend_id": "796",
  "difficulty": "Easy",
  "problem_slug": "rotate-string",
  "topics": [
    "String",
    "String Matching"
  ],
  "description": "Given two strings s and goal, return true if and only if s can become goal after some number of shifts on s.\nA shift on s consists of moving the leftmost character of s to the rightmost position.\nExample 1:\nExample 2:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: s = \"abcde\", goal = \"cdeab\"\nOutput: true",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input: s = \"abcde\", goal = \"abced\"\nOutput: false",
      "images": []
    }
  ],
  "constraints": [
    "1 <= s.length, goal.length <= 100",
    "s and goal consist of lowercase English letters."
  ],
  "follow_ups": [],
  "hints": [],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    bool rotateString(string s, string goal) {\n        \n    }\n};",
    "java": "class Solution {\n    public boolean rotateString(String s, String goal) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def rotateString(self, s, goal):\n        \"\"\"\n        :type s: str\n        :type goal: str\n        :rtype: bool\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def rotateString(self, s: str, goal: str) -> bool:\n        ",
    "c": "bool rotateString(char* s, char* goal) {\n    \n}",
    "csharp": "public class Solution {\n    public bool RotateString(string s, string goal) {\n        \n    }\n}",
    "javascript": "/**\n * @param {string} s\n * @param {string} goal\n * @return {boolean}\n */\nvar rotateString = function(s, goal) {\n    \n};",
    "typescript": "function rotateString(s: string, goal: string): boolean {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param String $s\n     * @param String $goal\n     * @return Boolean\n     */\n    function rotateString($s, $goal) {\n        \n    }\n}",
    "swift": "class Solution {\n    func rotateString(_ s: String, _ goal: String) -> Bool {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun rotateString(s: String, goal: String): Boolean {\n        \n    }\n}",
    "dart": "class Solution {\n  bool rotateString(String s, String goal) {\n    \n  }\n}",
    "golang": "func rotateString(s string, goal string) bool {\n    \n}",
    "ruby": "# @param {String} s\n# @param {String} goal\n# @return {Boolean}\ndef rotate_string(s, goal)\n    \nend",
    "scala": "object Solution {\n    def rotateString(s: String, goal: String): Boolean = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn rotate_string(s: String, goal: String) -> bool {\n        \n    }\n}",
    "racket": "(define/contract (rotate-string s goal)\n  (-> string? string? boolean?)\n  )",
    "erlang": "-spec rotate_string(S :: unicode:unicode_binary(), Goal :: unicode:unicode_binary()) -> boolean().\nrotate_string(S, Goal) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec rotate_string(s :: String.t, goal :: String.t) :: boolean\n  def rotate_string(s, goal) do\n    \n  end\nend"
  },
  "solution": "[TOC]\n\n## Solution\n\n---\n\n### Approach 1: Brute Force\n\n#### Intuition\n\nA rotation shifts the characters of the string to the right, one by one. The simplest way to solve this problem is to simulate each possible rotation of the string `s` and compare the result to the `goal`. \n\nIf the lengths of `s` and `goal` are not equal, there's no way `s` can be rotated to become `goal`. This is the base case. If they are of equal length, we can then proceed with checking each rotation.\n\nTo simulate a rotation, we move the first character of `s` to the end and compare the new string with `goal`. We repeat this process for every possible rotation. If at any point, `s` matches `goal`, we can conclude that the rotation works, and we return `true`. If none of the rotations match the `goal`, we return `false`.\n\n#### Algorithm\n\n- Check if the lengths of `s` and `goal` are different:\n  - If they are not equal, return `false` since one string cannot be a rotation of the other.\n\n- Initialize `length` to store the length of string `s`.\n\n- Use a loop to attempt all possible rotations of `s`:\n  - For each possible rotation count from `0` to `length - 1`:\n    - Perform one left rotation on `s`, moving the first character to the end of the string.\n    - Check if the rotated string `s` is equal to `goal`:\n      - If they are equal, return `true`, indicating that `goal` is a rotation of `s`.\n\n- If all rotations have been checked and none match `goal`, return `false`.\n\n#### Implementation#### Complexity Analysis\n\nLet $n$ be the size of string $s$ (and also the size of string $goal$, since they must be of equal length to be rotations).\n\n- Time complexity: $O(n^2)$\n\n    Checking if the lengths of both strings are different takes $O(n)$.\n    \n    The loop iterates $n$ times (for each possible rotation).\n    \n    Inside the loop, the `rotate` function performs a rotation, which takes $O(n)$, and comparing two strings $s$ and $goal$ also takes $O(n)$.\n\n    Therefore, for each of the $n$ rotations, we are performing operations that take $O(n)$, leading to an overall time complexity of $O(n^2)$.\n\n- Space complexity: $O(n)$ or $O(1)$\n  \n    Each rotation creates a new string $s$ of length $n$, so the additional space for each new string is $O(n)$.\n    \n    Java and Python’s string immutability means that every new rotation stores a new string in memory, leading to $O(n)$ space complexity for each rotation.\n\n    Therefore, the overall space complexity is $O(n)$ for Java and Python, as we maintain the current rotated string in memory and for CPP its $O(1)$.\n\n---\n\n### Approach 2: Concatenation Check \n\n#### Intuition\n\nInstead of rotating the string and checking after each rotation, we can observe a relationship between `s` and `goal`. If `goal` can be formed by rotating `s`, it must be possible to find `goal` as a substring in some version of `s`.\n\nA clever way to exploit this is by concatenating `s` with itself. Why? Because this effectively creates a string that contains all possible rotations of `s` within it. For example, if `s = \"abcde\"`, then `s + s = \"abcdeabcde\"`. Notice how every possible rotation of `s` appears somewhere in this concatenated string.\n\nSo, if `goal` can be obtained by rotating `s`, it must be a substring of `s + s`. To implement this, we simply check if `goal` is a substring of the concatenated string. If it is, we return `true`; otherwise, we return `false`.\n\n![Concatenation Check](../Figures/796/796_rotate.png)\n\n#### Algorithm\n\n- Check if the lengths of strings `s` and `goal` are different:\n  - If they are, return `false` because a rotation of `s` cannot match `goal`.\n\n- Create a new string `doubledString` by concatenating `s` with itself.\n\n- Use a string search method to find the substring `goal` within `doubledString`:\n  - If `goal` is found, check if this index is less than the length of `doubledString`.\n  - If it is, return `true`, indicating that `goal` is a valid rotation of `s`. Otherwise, return `false`.\n\n#### Implementation#### Complexity Analysis\n\nLet $n$ be the size of string $s$ (and also the size of string $goal$, since they must be of equal length to be rotations).\n\n- Time complexity: $O(n)$\n\n    Checking if the lengths of both strings are different takes $O(n)$.\n    \n    Concatenating the string $s$ with itself to create `doubledString` takes $O(n)$ because we are creating a new string that is twice the length of $s$.\n    \n    The substring find function is typically implemented using an algorithm that runs in $O(n)$. This involves scanning the `doubledString` of length $2n$ for the substring `goal` of length $n$. Since the search occurs in a string of size $2n$, the overall complexity for this operation remains $O(n)$.\n\n    Overall, the most significant operations are linear in terms of $n$, resulting in a total time complexity of $O(n)$.\n\n- Space complexity: $O(n)$\n\n    The space used for the `doubledString` is $O(n)$ since it stores a string that is double the size of $s$ (specifically, $O(2 \\cdot n) \\approx O(n)$).\n    \n    Thus, the overall space complexity is $O(n)$ due to the concatenated string.\n\n---\n\n### Approach 3: KMP Algorithm\n\n#### Intuition\n \nWe can refine the substring search using the [Knuth-Morris-Pratt (KMP) algorithm](https://en.wikipedia.org/wiki/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm). This follows the same intuition as the concatenation approach but improves how we search for `goal` within the concatenated string `s + s`.\n\nThe KMP algorithm allows us to search for substrings in linear time by preprocessing the pattern (in this case, `goal`) to identify where matches might fail early. The idea is to avoid rechecking characters we’ve already confirmed don’t match.\n\nFirst, we preprocess `goal` to create the longest prefix suffix (LPS) array. The LPS array stores the lengths of the longest proper prefix of the substring that matches a proper suffix for every prefix of `goal`. For example, if a mismatch occurs after matching a certain number of characters, the LPS array tells us how many characters we can skip and where to resume checking in the pattern. This way we don't need to start from the beginning of `goal` each time a mismatch happens.\n\nOnce the LPS array is ready, we scan through the concatenated string `s + s` and use the LPS array to efficiently find the `goal`. As we iterate through `s + s`, we compare characters from `goal` against the characters of the concatenated string. If we find a match, we continue comparing; however, if a mismatch occurs, we use the value from the LPS array to determine the next position in `goal` to check. \n\n> Note: This approach doesn't change much in terms of time complexity and space complexity compared to the previous approach, but we included it as we thought it could be a good problem to demonstrate the use of KMP in general.\n\n#### Algorithm\n\n- Check if the lengths of strings `s` and `goal` are different:\n  - If they are, return `false` (they can't be rotations).\n\n- Concatenate `s` with itself to create `doubledString`, which contains all possible rotations of `s`.\n\n- Call the `kmpSearch` function to check if `goal` is a substring of `doubledString`.\n\n- In the `kmpSearch` function:\n  - Precompute the LPS (Longest Prefix Suffix) array for the `pattern` (which is `goal`).\n  \n  - Initialize indices `textIndex` and `patternIndex` to track positions in `text` and `pattern`, respectively.\n  \n  - Loop through `text`:\n    - If the characters at `text[textIndex]` and `pattern[patternIndex]` match:\n      - Increment both indices.\n      - If `patternIndex` equals the length of the pattern, return `true` (the pattern has been found).\n      \n    - If there's a mismatch after some matches:\n      - Use the LPS array to update `patternIndex` to skip unnecessary comparisons.\n      \n    - If there are no matches:\n      - Move `textIndex` to the next character.\n\n  - If the loop finishes without finding the pattern, return `false`.\n\n- In the `computeLPS` function:\n  - Initialize the LPS array with zeros.\n  \n  - Build the LPS array to store the lengths of the longest prefix that is also a suffix for each position in the pattern:\n    - While the `index` is less than the length of the pattern:\n      - If characters match, increment the length and set the corresponding LPS value.\n      - If there's a mismatch, update the length using the previous LPS value.\n      - If there's no match and the length is zero, set the LPS value to zero.\n\n- Return the constructed LPS array.\n\n#### Implementation#### Complexity Analysis\n\nLet $n$ be the size of string $s$ (and also the size of string $goal$, since they must be of equal length to be rotations).\n\n- Time complexity: $O(n)$\n\n    Checking if the lengths of both strings are different takes $O(n)$.\n\n    Concatenating the string $s$ with itself to create `doubledString` takes $O(n)$ because we are creating a new string that is twice the length of $s$.\n    \n    The KMP substring search involves computing the LPS array for the `goal`, which takes $O(n)$, and the search process itself also runs in $O(n)$. Thus, the total time for KMP is $O(n)$.\n\n    Overall, the most significant operation is linear in terms of $n$, resulting in a total time complexity of $O(n)$.\n\n- Space complexity: $O(n)$\n\n    The space used for the `doubledString` is $O(n)$ since it stores a string that is double the size of $s$.\n    \n    The LPS array in the `computeLPS` function is of size $n$, which contributes $O(n)$ space.\n    \n    Thus, the overall space complexity is $O(n)$ due to the concatenated string and the LPS array.\n\n---"
}