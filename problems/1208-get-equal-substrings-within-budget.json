{
  "title": "Get Equal Substrings Within Budget",
  "problem_id": "1321",
  "frontend_id": "1208",
  "difficulty": "Medium",
  "problem_slug": "get-equal-substrings-within-budget",
  "topics": [
    "String",
    "Binary Search",
    "Sliding Window",
    "Prefix Sum"
  ],
  "description": "You are given two strings s and t of the same length and an integer maxCost.\nYou want to change s to t. Changing the ith character of s to ith character of t costs |s[i] - t[i]| (i.e., the absolute difference between the ASCII values of the characters).\nReturn the maximum length of a substring of s that can be changed to be the same as the corresponding substring of t with a cost less than or equal to maxCost. If there is no substring from s that can be changed to its corresponding substring from t, return 0.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: s = \"abcd\", t = \"bcdf\", maxCost = 3\nOutput: 3\nExplanation: \"abc\" of s can change to \"bcd\".\nThat costs 3, so the maximum length is 3.",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input: s = \"abcd\", t = \"cdef\", maxCost = 3\nOutput: 1\nExplanation: Each character in s costs 2 to change to character in t,  so the maximum length is 1.",
      "images": []
    },
    {
      "example_num": 3,
      "example_text": "Input: s = \"abcd\", t = \"acde\", maxCost = 0\nOutput: 1\nExplanation: You cannot make any change, so the maximum length is 1.",
      "images": []
    }
  ],
  "constraints": [
    "1 <= s.length <= 105",
    "t.length == s.length",
    "0 <= maxCost <= 106",
    "s and t consist of only lowercase English letters."
  ],
  "follow_ups": [],
  "hints": [
    "Calculate the differences between s[i] and t[i].",
    "Use a sliding window to track the longest valid substring."
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    int equalSubstring(string s, string t, int maxCost) {\n        \n    }\n};",
    "java": "class Solution {\n    public int equalSubstring(String s, String t, int maxCost) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def equalSubstring(self, s, t, maxCost):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :type maxCost: int\n        :rtype: int\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def equalSubstring(self, s: str, t: str, maxCost: int) -> int:\n        ",
    "c": "int equalSubstring(char* s, char* t, int maxCost) {\n    \n}",
    "csharp": "public class Solution {\n    public int EqualSubstring(string s, string t, int maxCost) {\n        \n    }\n}",
    "javascript": "/**\n * @param {string} s\n * @param {string} t\n * @param {number} maxCost\n * @return {number}\n */\nvar equalSubstring = function(s, t, maxCost) {\n    \n};",
    "typescript": "function equalSubstring(s: string, t: string, maxCost: number): number {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param String $s\n     * @param String $t\n     * @param Integer $maxCost\n     * @return Integer\n     */\n    function equalSubstring($s, $t, $maxCost) {\n        \n    }\n}",
    "swift": "class Solution {\n    func equalSubstring(_ s: String, _ t: String, _ maxCost: Int) -> Int {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun equalSubstring(s: String, t: String, maxCost: Int): Int {\n        \n    }\n}",
    "dart": "class Solution {\n  int equalSubstring(String s, String t, int maxCost) {\n    \n  }\n}",
    "golang": "func equalSubstring(s string, t string, maxCost int) int {\n    \n}",
    "ruby": "# @param {String} s\n# @param {String} t\n# @param {Integer} max_cost\n# @return {Integer}\ndef equal_substring(s, t, max_cost)\n    \nend",
    "scala": "object Solution {\n    def equalSubstring(s: String, t: String, maxCost: Int): Int = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn equal_substring(s: String, t: String, max_cost: i32) -> i32 {\n        \n    }\n}",
    "racket": "(define/contract (equal-substring s t maxCost)\n  (-> string? string? exact-integer? exact-integer?)\n  )",
    "erlang": "-spec equal_substring(S :: unicode:unicode_binary(), T :: unicode:unicode_binary(), MaxCost :: integer()) -> integer().\nequal_substring(S, T, MaxCost) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec equal_substring(s :: String.t, t :: String.t, max_cost :: integer) :: integer\n  def equal_substring(s, t, max_cost) do\n    \n  end\nend"
  },
  "solution": "## Solution\n\n---\n\n### Approach: Sliding Window\n\n#### Intuition\n\nWe are given two strings, `s` and `t`, of the same length, `N`. In one operation, we can choose an index `i` and convert the character `s[i]` to `t[i]`; the cost of this operation will be `|s[i] - t[i]|`. We can perform as many operations as we want as long as the total cost of all operations is less than or equal to `maxCost`. We need to return the maximum length of a substring in `s` that can be converted to the corresponding substring in `t`.\n\nThe naive way to solve this problem is to generate all substrings of `s` and their corresponding substring in `t`. Then, find the cost of converting each substring from `s` to `t`. If the cost is less than `maxCost`, then we can update the maximum length with the current substring length. However, this approach is inefficient as we would need to use nested loops to generate each substring and find the cost, leading to a time complexity of $O(N^3)$.\n\nThe key observation here is that we can only apply one operation at a given index of strings `s` and `t`; i.e., we can only convert the character `s[i]` to `t[i]` and not any other index of `t`. If we create a new costs array with the value at the `ith` index as `s[i] - t[i]`, then the problem transforms to finding the maximum subarray with a sum less than or equal to `maxCost`. This is because each index in this new array is the cost of converting the `ith` character in `s` to `t`. Thus, the sum of the subarray is the total cost of converting the substring in `s` to `t`.\n\nThis is somewhat similar to the problem [209. Minimum Size Subarray Sum](https://leetcode.com/problems/minimum-size-subarray-sum/) that can be solved using a sliding window. The sliding window pattern is applicable when the problem involves achieving a goal using subarrays or substrings, and individual elements cannot be independently selected. The concept behind the sliding window pattern is to maintain a window that meets the condition by continuously expanding from the right. If the condition ceases to be met, we adjust the window by shrinking it from the left until the condition is met again.\n\nTo save space, we can apply the sliding window pattern to track the cost of the substrings instead of creating a separate cost array. We use the variable `start` to track the left end of the window and `i` to track the right end. The condition is when the cost of the current window is less than or equal to the `maxCost`.\n\nWe can process `s` using a sliding window. We will keep adding the element on the right to the current cost, `currCost`. If the `currCost` becomes more than the `maxCost`, we will remove the elements from the left end. Then, we can compare the length of the current substring (from the left end `start` to the current index `i`) with the maximum length we have found so far and update the variable `maxLen` accordingly.\n\n!?!../Documents/1208-re/1208_Get_Equal_Substrings_Within_Budget.json:960,720!?!#### Algorithm\n\n1. Initialize the variables:\n\n    - `maxLen` to `0`'; this will be the maximum length of a substring with a cost less than or equal to `maxCost` we have seen so far.\n    - `start` to `0`; this is the left end of the current substring.\n    - `currCost` to `0`; this will be the cost of converting the current window substring in `s` to `t`.\n\n2. Iterate over the indices from `0` to `N - 1` and for each index `i`:\n\n    - Add the cost to convert `s[i]` to `t[i]` to the variable `currCost`\n    - Keep removing the elements from the left end by decrementing the cost required for the character at index `start` until `currCost` becomes less than or equal to `maxCost`.\n    - Compare the length of the current window `i - start + 1` with the `maxLen` and update it accordingly.\n\n3. Return `maxLen`.\n\n#### Implementation#### Complexity Analysis\n\nHere, $N$ is the length of the strings `s` and `t`.\n\n* Time complexity: $O(N)$\n\n  We will process each index of `s` and `t` at most twice. This is because we iterate over the character while extending the window from the right side, and again while contracting the window from the left end. Therefore, the total time complexity is equal to $O(N)$.\n\n* Space complexity: $O(1)$\n\n  We do not need any extra space apart from some variables, and hence, the space complexity is constant.\n\n---"
}