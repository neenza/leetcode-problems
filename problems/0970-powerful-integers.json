{
  "title": "Powerful Integers",
  "problem_id": "1010",
  "frontend_id": "970",
  "difficulty": "Medium",
  "problem_slug": "powerful-integers",
  "topics": [
    "Hash Table",
    "Math",
    "Enumeration"
  ],
  "description": "Given three integers x, y, and bound, return a list of all the powerful integers that have a value less than or equal to bound.\nAn integer is powerful if it can be represented as xi + yj for some integers i >= 0 and j >= 0.\nYou may return the answer in any order. In your answer, each value should occur at most once.\nExample 1:\nExample 2:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: x = 2, y = 3, bound = 10\nOutput: [2,3,4,5,7,9,10]\nExplanation:\n2 = 20 + 30\n3 = 21 + 30\n4 = 20 + 31\n5 = 21 + 31\n7 = 22 + 31\n9 = 23 + 30\n10 = 20 + 32",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input: x = 3, y = 5, bound = 15\nOutput: [2,4,6,8,10,14]",
      "images": []
    }
  ],
  "constraints": [
    "1 <= x, y <= 100",
    "0 <= bound <= 106"
  ],
  "follow_ups": [],
  "hints": [],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    vector<int> powerfulIntegers(int x, int y, int bound) {\n        \n    }\n};",
    "java": "class Solution {\n    public List<Integer> powerfulIntegers(int x, int y, int bound) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def powerfulIntegers(self, x, y, bound):\n        \"\"\"\n        :type x: int\n        :type y: int\n        :type bound: int\n        :rtype: List[int]\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def powerfulIntegers(self, x: int, y: int, bound: int) -> List[int]:\n        ",
    "c": "/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nint* powerfulIntegers(int x, int y, int bound, int* returnSize) {\n    \n}",
    "csharp": "public class Solution {\n    public IList<int> PowerfulIntegers(int x, int y, int bound) {\n        \n    }\n}",
    "javascript": "/**\n * @param {number} x\n * @param {number} y\n * @param {number} bound\n * @return {number[]}\n */\nvar powerfulIntegers = function(x, y, bound) {\n    \n};",
    "typescript": "function powerfulIntegers(x: number, y: number, bound: number): number[] {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param Integer $x\n     * @param Integer $y\n     * @param Integer $bound\n     * @return Integer[]\n     */\n    function powerfulIntegers($x, $y, $bound) {\n        \n    }\n}",
    "swift": "class Solution {\n    func powerfulIntegers(_ x: Int, _ y: Int, _ bound: Int) -> [Int] {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun powerfulIntegers(x: Int, y: Int, bound: Int): List<Int> {\n        \n    }\n}",
    "dart": "class Solution {\n  List<int> powerfulIntegers(int x, int y, int bound) {\n    \n  }\n}",
    "golang": "func powerfulIntegers(x int, y int, bound int) []int {\n    \n}",
    "ruby": "# @param {Integer} x\n# @param {Integer} y\n# @param {Integer} bound\n# @return {Integer[]}\ndef powerful_integers(x, y, bound)\n    \nend",
    "scala": "object Solution {\n    def powerfulIntegers(x: Int, y: Int, bound: Int): List[Int] = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn powerful_integers(x: i32, y: i32, bound: i32) -> Vec<i32> {\n        \n    }\n}",
    "racket": "(define/contract (powerful-integers x y bound)\n  (-> exact-integer? exact-integer? exact-integer? (listof exact-integer?))\n  )",
    "erlang": "-spec powerful_integers(X :: integer(), Y :: integer(), Bound :: integer()) -> [integer()].\npowerful_integers(X, Y, Bound) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec powerful_integers(x :: integer, y :: integer, bound :: integer) :: [integer]\n  def powerful_integers(x, y, bound) do\n    \n  end\nend"
  },
  "solution": "[TOC]\n\n## Solution\n\n---\n\n### Overview\n\nWe rarely come across problems where the simplest solution, a brute-force solution, is the optimal one. Luckily for us, this is one of those problems! As we can see from the description given for the first example, both the numbers have powers that range from `0` to a certain higher value. E.g. in the case where `x = 2`, `y = 3`, and `bound = 10`, the power of `x` ranges from `0..3` and the power of `y` ranges from `0..2`. More specifically we have\n\n$$\nx^a + y^b <= bound\n$$\n\nIf we know the bounds for `a` and `b`, then we can simply use a nested loop to find all possible powerful integers. It all boils down to determining these bounds. **Note** that the problem statement asks us to find *all* powerful integers. Had the problem statement been to find *how many* powerful integers there are, we might have been able to use some mathematical formula to find the exact count. However, because the problem asks us to list all the values, we have to use a nested-loop-based brute-force solution to find and list all such values.---\n\n### Approach: Logartihmic Bounds\n\n**Intuition**\n\nOur approach here will only focus on finding the bounds for numbers `x` and `y`. One way to get the bounds on the powers is to have nested loops that iterate from $$[0 \\cdots \\text{bound}]$$. However, this is very inefficient because the `bound` can be an extremely large value and a nested-loop over this `bound` will take forever to finish. Also, we don't need to iterate over all of the values and combinations.  There is a way to find a much smaller bound for the powers. \n\n$$\nm^n <= \\text{bound}\n$$\n\nThis formula implies that\n\n$$\nn <= \\log_m \\text{bound}\n$$\n\n> We can use the log function to determine the bounds for the powers of \"x\" and \"y\".\n\n**Algorithm**\n\n1. Let's define `a` as the power bound for the number `x`. Thus $$\\text{a} = \\log_x \\text{bound}$$.\n2. Similarly, let's define `b` as the power bound for the number `y`. Thus $$\\text{b} = \\log_y \\text{bound}$$.\n3. Now we will have our nested for-loop structure where the outer loop will iterate from $$[0 \\cdots a]$$ and the inner loop will iterate from $$[0 \\cdots b]$$.\n4. We will use a set to store our results. This is because we might generate the same value multiple times. E.g. `2^1 + 3^2 = 11` and `2^3 + 3^1 = 11`. We only need to include the value `11` once and hence, we will use a set called `powerfulIntegers` to store our answers.\n5. At each step, we calculate `x^a + y^b` and check if this value is less than or equal to `bound`. If it is, then this is a powerful integer and we add it to our set of answers.\n6. We need special break conditions to handle the scenario when `x` or `y` is `1`. This is because if the number `x` or `y` is `1`, then their power-bound will be equal to `bound` itself. Also, it doesn't matter what their power-bound is because $$1^N$$ is always $$1$$. Thus, when the number is `1`, we don't need to loop from $$[0 \\cdots N]$$ and we can break early.\n7. Finally, convert the set to a list and return.\n\n**Implementation****Complexity Analysis**\n\n* Time Complexity: Let $$N$$ be $$\\text{log}_x \\text{bound}$$ and $$M$$ be $$\\text{log}_y \\text{bound}$$. Then the overall time complexity is $$O(N \\times M)$$ because we used a nested loop structure to calculate all of the powerful integers.\n\n* Space Complexity: $$O(N \\times M)$$ because we use a set to omit duplicates. We could just use our result list to check membership before adding values. However, that would be costly in terms of time complexity because it would require a full scan of the result list to see if the value already exists.---"
}