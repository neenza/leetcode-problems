{
  "title": "Maximum Number of Integers to Choose From a Range I",
  "problem_id": "2640",
  "frontend_id": "2554",
  "difficulty": "Medium",
  "problem_slug": "maximum-number-of-integers-to-choose-from-a-range-i",
  "topics": [
    "Array",
    "Hash Table",
    "Binary Search",
    "Greedy",
    "Sorting"
  ],
  "description": "You are given an integer array banned and two integers n and maxSum. You are choosing some number of integers following the below rules:\nReturn the maximum number of integers you can choose following the mentioned rules.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: banned = [1,6,5], n = 5, maxSum = 6\nOutput: 2\nExplanation: You can choose the integers 2 and 4.\n2 and 4 are from the range [1, 5], both did not appear in banned, and their sum is 6, which did not exceed maxSum.",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input: banned = [1,2,3,4,5,6,7], n = 8, maxSum = 1\nOutput: 0\nExplanation: You cannot choose any integer while following the mentioned conditions.",
      "images": []
    },
    {
      "example_num": 3,
      "example_text": "Input: banned = [11], n = 7, maxSum = 50\nOutput: 7\nExplanation: You can choose the integers 1, 2, 3, 4, 5, 6, and 7.\nThey are from the range [1, 7], all did not appear in banned, and their sum is 28, which did not exceed maxSum.",
      "images": []
    }
  ],
  "constraints": [
    "1 <= banned.length <= 104",
    "1 <= banned[i], n <= 104",
    "1 <= maxSum <= 109"
  ],
  "follow_ups": [],
  "hints": [
    "Keep the banned numbers that are less than or equal to n in a set.",
    "Loop over the numbers from 1 to n and if the number is not banned, use it.",
    "Keep adding numbers while they are not banned, and their sum is less than or equal to k."
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    int maxCount(vector<int>& banned, int n, int maxSum) {\n        \n    }\n};",
    "java": "class Solution {\n    public int maxCount(int[] banned, int n, int maxSum) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def maxCount(self, banned, n, maxSum):\n        \"\"\"\n        :type banned: List[int]\n        :type n: int\n        :type maxSum: int\n        :rtype: int\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def maxCount(self, banned: List[int], n: int, maxSum: int) -> int:\n        ",
    "c": "int maxCount(int* banned, int bannedSize, int n, int maxSum) {\n    \n}",
    "csharp": "public class Solution {\n    public int MaxCount(int[] banned, int n, int maxSum) {\n        \n    }\n}",
    "javascript": "/**\n * @param {number[]} banned\n * @param {number} n\n * @param {number} maxSum\n * @return {number}\n */\nvar maxCount = function(banned, n, maxSum) {\n    \n};",
    "typescript": "function maxCount(banned: number[], n: number, maxSum: number): number {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param Integer[] $banned\n     * @param Integer $n\n     * @param Integer $maxSum\n     * @return Integer\n     */\n    function maxCount($banned, $n, $maxSum) {\n        \n    }\n}",
    "swift": "class Solution {\n    func maxCount(_ banned: [Int], _ n: Int, _ maxSum: Int) -> Int {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun maxCount(banned: IntArray, n: Int, maxSum: Int): Int {\n        \n    }\n}",
    "dart": "class Solution {\n  int maxCount(List<int> banned, int n, int maxSum) {\n    \n  }\n}",
    "golang": "func maxCount(banned []int, n int, maxSum int) int {\n    \n}",
    "ruby": "# @param {Integer[]} banned\n# @param {Integer} n\n# @param {Integer} max_sum\n# @return {Integer}\ndef max_count(banned, n, max_sum)\n    \nend",
    "scala": "object Solution {\n    def maxCount(banned: Array[Int], n: Int, maxSum: Int): Int = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn max_count(banned: Vec<i32>, n: i32, max_sum: i32) -> i32 {\n        \n    }\n}",
    "racket": "(define/contract (max-count banned n maxSum)\n  (-> (listof exact-integer?) exact-integer? exact-integer? exact-integer?)\n  )",
    "erlang": "-spec max_count(Banned :: [integer()], N :: integer(), MaxSum :: integer()) -> integer().\nmax_count(Banned, N, MaxSum) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec max_count(banned :: [integer], n :: integer, max_sum :: integer) :: integer\n  def max_count(banned, n, max_sum) do\n    \n  end\nend"
  },
  "solution": "[TOC]\n\n## Solution\n\n---\n\n### Overview\n\nOur goal is to select the largest possible set of positive integers whose sum doesn't exceed `maxSum`. The selection must follow these constraints: we cannot use any numbers present in the `banned` array, each number in the selection must be unique, and we can only choose numbers between `1` and `n`.\n\nLet's look at an example to understand this better. Say we have:\n- `n = 10`\n- `maxSum = 16` \n- banned: `[1, 2, 3, 6, 10]`\n\nSome valid answers would be: \n1. 4, 8\n2. 4, 5, 7\n3. 9\n\nAll of these options have integers less than `n` and avoid numbers that are part of the `banned` array. Among these, we get the maximum number of integers with the set `(4, 5, 7)`. No matter what other combinations we try, we cannot select more than 3 numbers that satisfy all our conditions. So, our answer is 3. \n    \n---\n\n### Approach 1: Binary Search\n\n#### Intuition\n\nSay we have a budget of `maxSum` and we want to buy as many items as possible from a list of numbers ranging from `1` to `n`. However, some items on this list are banned and can't be purchased. How do we maximize the number of items we can buy without exceeding our budget?\n\nA straightforward approach would be to start with the smallest numbers first. By starting with the smallest numbers, we are ensuring that we are fitting as many items as possible into the budget. If we were to start with larger numbers, we would quickly exhaust our budget and be able to purchase fewer items. Starting with the smallest numbers maximizes the number of items we can include before reaching our budget limit.\n\nTo implement this, we would check each number from `1` to `n` in order and add it to our shopping list if it's not banned. For each number, we would need to scan through the `banned` array to verify if it's available. However, this method is slow because we have to check the entire `banned` array for each number we consider.\n\nThe most time-consuming part of this algorithm is the repeated checking of the `banned` array. To make this process faster, we need a more efficient search method. One such method is [Binary search ðŸ”—](https://leetcode.com/explore/learn/card/binary-search/).\n\nBefore we can use binary search, we need to sort the `banned` array. Then, for each number, we perform a binary search: we initialize two pointers, `left` and `right`, to the start and end of the `banned` array, respectively. We repeatedly calculate the midpoint `mid` and compare the number with the midpoint value. If the number is found (equal to the midpoint value), it is banned and we skip it. If the number is less than the midpoint value, we move the `right` pointer to `mid - 1`; if greater, we move the `left` pointer to `mid + 1`. \n\nThis process continues until `left` exceeds `right`, indicating the number is not banned. If not banned, we subtract the number from `maxSum` and count it as included. If subtracting a number causes `maxSum` to drop to `0` or below, we return the count of included numbers as our answer.\n\n#### Algorithm\n\n> Note: Most programming languages already have binary search built into their standard libraries, which you can easily use. However, we've written our own binary search method here for the sake of clarity and completeness.\n\n- Sort the `banned` array in ascending order to enable binary search on it.\n- Initialize a variable `count` to `0` to keep track of how many numbers we select.\n- Iterate through each number from `1` to `n`:\n  - For each number, check if it exists in `banned` using binary search.\n  - If the number exists, skip to the next iteration.\n  - If the number is not banned, subtract it from `maxSum`.\n  - If `maxSum` becomes negative, break the loop as we cannot add more numbers.\n  - If `maxSum` is still non-negative, increment `count` by `1`.\n- Return the final `count` as our answer.\n\nHelper method `customBinarySearch(arr, target)`:\n\n- Initialize two pointers `left` and `right` pointing to the start and end of `arr` respectively.\n- While the `left` pointer is less than or equal to the `right` pointer:\n  - Calculate `mid` as the midpoint between `left` and `right`.\n  - If `mid` equals target, return `true`.\n  - If `mid` is greater than `target`, move `right` to `mid - 1`.\n  - If `mid` is less than `target`, move `left` to `mid + 1`.\n- If the loop completes without finding `target`, return `false`.\n\n#### Implementation#### Complexity Analysis\n\nLet $m$ be the length of the `banned` array.\n\n- Time complexity: $O((m + n) \\cdot \\log m)$\n\n    The algorithm iterates through numbers from $1$ to $n$, and for each number, performs a binary search on the `banned` array. The binary search takes $O(\\log m)$ time, and we do this $n$ times. The initial sorting of `banned` takes $O(m \\cdot \\log m)$ time. \n    \n    Thus, the total time complexity of the algorithm is $O(n \\cdot \\log m) + O(m \\cdot \\log m) = O((m + n) \\cdot \\log m)$.\n\n- Space complexity: $O(S)$\n\n    The space taken by the sorting algorithm ($S$) depends on the language of implementation:\n    - In Java, `Arrays.sort()` is implemented using a variant of the Quick Sort algorithm which has a space complexity of $O(\\log m)$.\n    - In C++, the `sort()` function is implemented as a hybrid of Quick Sort, Heap Sort, and Insertion Sort, with a worst-case space complexity of $O(\\log m)$.\n    - In Python, the `sort()` method sorts a list using the Timsort algorithm which is a combination of Merge Sort and Insertion Sort and has a space complexity of $O(m)$.\n\n    The few other variables used only take constant space. Thus, the space complexity is $O(S)$.\n\n---\n\n### Approach 2: Sweep\n\n#### Intuition\n\nTo optimize our solution, we can use the relationship between the numbers being checked and the `banned` array. Since we iterate through numbers from `1` to `n` in ascending order and the `banned` array is also sorted, we can take advantage of this ordering to streamline the process.\n\nAs we iterate through the numbers from `1` to `n`, we can maintain a pointer (let's call it `bannedIdx`) that tracks our current position in the `banned` array. This pointer allows us to efficiently determine whether the current number is banned by comparing it with the next unprocessed banned number, rather than scanning the entire `banned` array for each number.\n\nSimilar to the previous approach, we'll loop from `1` to `n` and progressively add integers to our series. For each number, we first check if it is banned by comparing it with the value at the current `bannedIdx`. If it is banned, we move to the next integer and also advance `bannedIdx` to the next value in `banned`. Otherwise, we subtract the current value from `maxSum` and increment our counter. If this reduction causes `maxSum` to drop below or equal to `0`, we have found the maximum number of integers, and we return the current count as our answer.\n\nThe slideshow below visualizes the algorithm:\n\n!?!../Documents/2554/slideshow.json:702,642!?!\n\n#### Algorithm\n \n- Sort the `banned` array in ascending order.\n- Initialize:\n  - `bannedIdx` to `0` to track the current position in the `banned` array.\n  - `count` to `0` to track the number of valid integers chosen.\n- Iterate through each number from `1` to `n` while `maxSum` remains non-negative:\n  - For each number, check if it matches the current banned number (using `bannedIdx`).\n    - If the current number is banned:\n      - Skip all duplicate occurrences of this banned number by incrementing `bannedIdx`.\n    - If the current number is not banned:\n      - Subtract the current number from `maxSum`.\n    - If `maxSum` remains non-negative:\n      - Increment `count` by `1`.\n- Return the final `count` as the answer.\n\n#### Implementation#### Complexity Analysis\n\nLet $m$ be the length of the `banned` array.\n\n- Time complexity: $O(n + m \\cdot \\log m)$\n\n    The algorithm first sorts the `banned` array which takes $O(m \\cdot \\log m)$ time. Then it performs a single pass through numbers $1$ to $n$ and skips over banned numbers. Since each banned number is processed at most once and we only move forward in both sequences, the iteration part takes $O(n + m)$ time. \n    \n    The total time complexity is therefore $O(m \\cdot \\log m + n + m)$ which simplifies to $O(n + m \\cdot \\log m)$.\n\n- Space complexity: $O(S)$\n\n    The space complexity of the sorting algorithm ($S$) depends on the language of implementation:\n    - In Java, `Arrays.sort()` is implemented using a variant of the Quick Sort algorithm which has a space complexity of $O(\\log m)$.\n    - In C++, the `sort()` function is implemented as a hybrid of Quick Sort, Heap Sort, and Insertion Sort, with a worst-case space complexity of $O(\\log m)$.\n    - In Python, the `sort()` method sorts a list using the Timsort algorithm which is a combination of Merge Sort and Insertion Sort and has a space complexity of $O(m)$.\n  \n    The few other variables used by the algorithm take constant space. Thus, the space complexity is $O(S)$.\n\n---\n\n### Approach 3: Hash Set\n\n#### Intuition\n\nAt each step of the loop, we are essentially checking whether a number exists in the `banned` array or not. A suitable data structure for efficiently performing the \"find\" operation is a hash set. Hash sets allow us to determine whether a number is in the collection in constant time. \n\nFirst, we populate a hash set called `bannedSet` with the elements from the `banned` array. Then, we iterate from `1` to `n`. For each number, we check if it is present in `bannedSet`. If it is, we skip that number. Otherwise, we add the number to our series and update `maxSum` and our counter accordingly. If `maxSum` ever drops below `0`, we return the current count as the answer.\n\n> For a more comprehensive understanding of hash set, explore the [Hash Set Explore Card ðŸ”—](https://leetcode.com/explore/learn/card/hash-table/). This resource provides an in-depth look at hash sets, explaining their key concepts and applications with a variety of problems to solidify understanding of the pattern.\n\n#### Algorithm\n\n- Create an empty hash set `bannedSet` to store banned numbers.\n- Iterate through the `banned` array, adding each number to `bannedSet`.\n- Initialize a variable `count` to `0` to track the number of valid integers chosen.\n- Iterate through each number from `1` to `n`:\n  - Check if the current number is in `bannedSet`.\n  - If it is, skip to the next iteration.\n  - If subtracting the current number from `maxSum` would make it negative:\n    - Return the current `count` immediately.\n  - Otherwise:\n    - Subtract the current number from `maxSum`.\n    - Increment `count` by `1`.\n- Return the final `count` as the answer.\n\n#### Implementation#### Complexity Analysis\n\nLet $m$ be the length of the `banned` array.\n\n- Time complexity: $O(m + n)$\n\n    The algorithm makes a single pass through the `banned` array to populate the hash set, taking $O(m)$ time. Then it iterates through numbers from $1$ to $n$, where for each number, we perform a constant time $O(1)$ lookup in the hash set. Therefore, the iteration takes $O(n)$ time. \n    \n    Thus, the overall time complexity of the algorithm is $O(m) + O(n) = O(m + n)$.\n\n- Space complexity: $O(m)$\n\n    The algorithm uses a hash set to store all banned numbers. In the worst case, all numbers in the `banned` array are unique and within the valid range, requiring $O(m)$ space. Besides the hash set, only a constant amount of extra space is used for variables like `count` and `maxSum`. \n    \n    Thus, the total space complexity is $O(m)$.\n\n---"
}