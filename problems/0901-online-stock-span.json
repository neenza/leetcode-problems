{
  "title": "Online Stock Span",
  "problem_id": "937",
  "frontend_id": "901",
  "difficulty": "Medium",
  "problem_slug": "online-stock-span",
  "topics": [
    "Stack",
    "Design",
    "Monotonic Stack",
    "Data Stream"
  ],
  "description": "Design an algorithm that collects daily price quotes for some stock and returns the span of that stock's price for the current day.\nThe span of the stock's price in one day is the maximum number of consecutive days (starting from that day and going backward) for which the stock price was less than or equal to the price of that day.\nImplement the StockSpanner class:\nExample 1:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input\n[\"StockSpanner\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\"]\n[[], [100], [80], [60], [70], [60], [75], [85]]\nOutput\n[null, 1, 1, 1, 2, 1, 4, 6]\n\nExplanation\nStockSpanner stockSpanner = new StockSpanner();\nstockSpanner.next(100); // return 1\nstockSpanner.next(80);  // return 1\nstockSpanner.next(60);  // return 1\nstockSpanner.next(70);  // return 2\nstockSpanner.next(60);  // return 1\nstockSpanner.next(75);  // return 4, because the last 4 prices (including today's price of 75) were less than or equal to today's price.\nstockSpanner.next(85);  // return 6",
      "images": []
    }
  ],
  "constraints": [
    "1 <= price <= 105",
    "At most 104 calls will be made to next."
  ],
  "follow_ups": [],
  "hints": [],
  "code_snippets": {
    "cpp": "class StockSpanner {\npublic:\n    StockSpanner() {\n        \n    }\n    \n    int next(int price) {\n        \n    }\n};\n\n/**\n * Your StockSpanner object will be instantiated and called as such:\n * StockSpanner* obj = new StockSpanner();\n * int param_1 = obj->next(price);\n */",
    "java": "class StockSpanner {\n\n    public StockSpanner() {\n        \n    }\n    \n    public int next(int price) {\n        \n    }\n}\n\n/**\n * Your StockSpanner object will be instantiated and called as such:\n * StockSpanner obj = new StockSpanner();\n * int param_1 = obj.next(price);\n */",
    "python": "class StockSpanner(object):\n\n    def __init__(self):\n        \n\n    def next(self, price):\n        \"\"\"\n        :type price: int\n        :rtype: int\n        \"\"\"\n        \n\n\n# Your StockSpanner object will be instantiated and called as such:\n# obj = StockSpanner()\n# param_1 = obj.next(price)",
    "python3": "class StockSpanner:\n\n    def __init__(self):\n        \n\n    def next(self, price: int) -> int:\n        \n\n\n# Your StockSpanner object will be instantiated and called as such:\n# obj = StockSpanner()\n# param_1 = obj.next(price)",
    "c": "\n\n\ntypedef struct {\n    \n} StockSpanner;\n\n\nStockSpanner* stockSpannerCreate() {\n    \n}\n\nint stockSpannerNext(StockSpanner* obj, int price) {\n    \n}\n\nvoid stockSpannerFree(StockSpanner* obj) {\n    \n}\n\n/**\n * Your StockSpanner struct will be instantiated and called as such:\n * StockSpanner* obj = stockSpannerCreate();\n * int param_1 = stockSpannerNext(obj, price);\n \n * stockSpannerFree(obj);\n*/",
    "csharp": "public class StockSpanner {\n\n    public StockSpanner() {\n        \n    }\n    \n    public int Next(int price) {\n        \n    }\n}\n\n/**\n * Your StockSpanner object will be instantiated and called as such:\n * StockSpanner obj = new StockSpanner();\n * int param_1 = obj.Next(price);\n */",
    "javascript": "\nvar StockSpanner = function() {\n    \n};\n\n/** \n * @param {number} price\n * @return {number}\n */\nStockSpanner.prototype.next = function(price) {\n    \n};\n\n/** \n * Your StockSpanner object will be instantiated and called as such:\n * var obj = new StockSpanner()\n * var param_1 = obj.next(price)\n */",
    "typescript": "class StockSpanner {\n    constructor() {\n        \n    }\n\n    next(price: number): number {\n        \n    }\n}\n\n/**\n * Your StockSpanner object will be instantiated and called as such:\n * var obj = new StockSpanner()\n * var param_1 = obj.next(price)\n */",
    "php": "class StockSpanner {\n    /**\n     */\n    function __construct() {\n        \n    }\n  \n    /**\n     * @param Integer $price\n     * @return Integer\n     */\n    function next($price) {\n        \n    }\n}\n\n/**\n * Your StockSpanner object will be instantiated and called as such:\n * $obj = StockSpanner();\n * $ret_1 = $obj->next($price);\n */",
    "swift": "\nclass StockSpanner {\n\n    init() {\n        \n    }\n    \n    func next(_ price: Int) -> Int {\n        \n    }\n}\n\n/**\n * Your StockSpanner object will be instantiated and called as such:\n * let obj = StockSpanner()\n * let ret_1: Int = obj.next(price)\n */",
    "kotlin": "class StockSpanner() {\n\n    fun next(price: Int): Int {\n        \n    }\n\n}\n\n/**\n * Your StockSpanner object will be instantiated and called as such:\n * var obj = StockSpanner()\n * var param_1 = obj.next(price)\n */",
    "dart": "class StockSpanner {\n\n  StockSpanner() {\n    \n  }\n  \n  int next(int price) {\n    \n  }\n}\n\n/**\n * Your StockSpanner object will be instantiated and called as such:\n * StockSpanner obj = StockSpanner();\n * int param1 = obj.next(price);\n */",
    "golang": "type StockSpanner struct {\n    \n}\n\n\nfunc Constructor() StockSpanner {\n    \n}\n\n\nfunc (this *StockSpanner) Next(price int) int {\n    \n}\n\n\n/**\n * Your StockSpanner object will be instantiated and called as such:\n * obj := Constructor();\n * param_1 := obj.Next(price);\n */",
    "ruby": "class StockSpanner\n    def initialize()\n        \n    end\n\n\n=begin\n    :type price: Integer\n    :rtype: Integer\n=end\n    def next(price)\n        \n    end\n\n\nend\n\n# Your StockSpanner object will be instantiated and called as such:\n# obj = StockSpanner.new()\n# param_1 = obj.next(price)",
    "scala": "class StockSpanner() {\n\n    def next(price: Int): Int = {\n        \n    }\n\n}\n\n/**\n * Your StockSpanner object will be instantiated and called as such:\n * val obj = new StockSpanner()\n * val param_1 = obj.next(price)\n */",
    "rust": "struct StockSpanner {\n\n}\n\n\n/** \n * `&self` means the method takes an immutable reference.\n * If you need a mutable reference, change it to `&mut self` instead.\n */\nimpl StockSpanner {\n\n    fn new() -> Self {\n        \n    }\n    \n    fn next(&self, price: i32) -> i32 {\n        \n    }\n}\n\n/**\n * Your StockSpanner object will be instantiated and called as such:\n * let obj = StockSpanner::new();\n * let ret_1: i32 = obj.next(price);\n */",
    "racket": "(define stock-spanner%\n  (class object%\n    (super-new)\n    \n    (init-field)\n    \n    ; next : exact-integer? -> exact-integer?\n    (define/public (next price)\n      )))\n\n;; Your stock-spanner% object will be instantiated and called as such:\n;; (define obj (new stock-spanner%))\n;; (define param_1 (send obj next price))",
    "erlang": "-spec stock_spanner_init_() -> any().\nstock_spanner_init_() ->\n  .\n\n-spec stock_spanner_next(Price :: integer()) -> integer().\nstock_spanner_next(Price) ->\n  .\n\n\n%% Your functions will be called as such:\n%% stock_spanner_init_(),\n%% Param_1 = stock_spanner_next(Price),\n\n%% stock_spanner_init_ will be called before every test case, in which you can do some necessary initializations.",
    "elixir": "defmodule StockSpanner do\n  @spec init_() :: any\n  def init_() do\n    \n  end\n\n  @spec next(price :: integer) :: integer\n  def next(price) do\n    \n  end\nend\n\n# Your functions will be called as such:\n# StockSpanner.init_()\n# param_1 = StockSpanner.next(price)\n\n# StockSpanner.init_ will be called before every test case, in which you can do some necessary initializations."
  }
}