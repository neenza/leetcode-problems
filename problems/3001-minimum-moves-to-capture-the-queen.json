{
  "title": "Minimum Moves to Capture The Queen",
  "problem_id": "3270",
  "frontend_id": "3001",
  "difficulty": "Medium",
  "problem_slug": "minimum-moves-to-capture-the-queen",
  "topics": [
    "Math",
    "Enumeration"
  ],
  "description": "There is a 1-indexed 8 x 8 chessboard containing 3 pieces.\nYou are given 6 integers a, b, c, d, e, and f where:\nGiven that you can only move the white pieces, return the minimum number of moves required to capture the black queen.\nNote that:\nExample 1:\nExample 2:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: a = 1, b = 1, c = 8, d = 8, e = 2, f = 3\nOutput: 2\nExplanation: We can capture the black queen in two moves by moving the white rook to (1, 3) then to (2, 3).\nIt is impossible to capture the black queen in less than two moves since it is not being attacked by any of the pieces at the beginning.",
      "images": [
        "https://assets.leetcode.com/uploads/2023/12/21/ex1.png"
      ]
    },
    {
      "example_num": 2,
      "example_text": "Input: a = 5, b = 3, c = 3, d = 4, e = 5, f = 2\nOutput: 1\nExplanation: We can capture the black queen in a single move by doing one of the following: \n- Move the white rook to (5, 2).\n- Move the white bishop to (5, 2).",
      "images": [
        "https://assets.leetcode.com/uploads/2023/12/21/ex2.png"
      ]
    }
  ],
  "constraints": [
    "1 <= a, b, c, d, e, f <= 8",
    "No two pieces are on the same square."
  ],
  "follow_ups": [],
  "hints": [
    "The minimum number of moves can be either <code>1</code> or <code>2</code>.",
    "The answer will be <code>1</code> if the queen is on the path of the rook or bishop and none of them is in between."
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    int minMovesToCaptureTheQueen(int a, int b, int c, int d, int e, int f) {\n        \n    }\n};",
    "java": "class Solution {\n    public int minMovesToCaptureTheQueen(int a, int b, int c, int d, int e, int f) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def minMovesToCaptureTheQueen(self, a, b, c, d, e, f):\n        \"\"\"\n        :type a: int\n        :type b: int\n        :type c: int\n        :type d: int\n        :type e: int\n        :type f: int\n        :rtype: int\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def minMovesToCaptureTheQueen(self, a: int, b: int, c: int, d: int, e: int, f: int) -> int:\n        ",
    "c": "int minMovesToCaptureTheQueen(int a, int b, int c, int d, int e, int f) {\n    \n}",
    "csharp": "public class Solution {\n    public int MinMovesToCaptureTheQueen(int a, int b, int c, int d, int e, int f) {\n        \n    }\n}",
    "javascript": "/**\n * @param {number} a\n * @param {number} b\n * @param {number} c\n * @param {number} d\n * @param {number} e\n * @param {number} f\n * @return {number}\n */\nvar minMovesToCaptureTheQueen = function(a, b, c, d, e, f) {\n    \n};",
    "typescript": "function minMovesToCaptureTheQueen(a: number, b: number, c: number, d: number, e: number, f: number): number {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param Integer $a\n     * @param Integer $b\n     * @param Integer $c\n     * @param Integer $d\n     * @param Integer $e\n     * @param Integer $f\n     * @return Integer\n     */\n    function minMovesToCaptureTheQueen($a, $b, $c, $d, $e, $f) {\n        \n    }\n}",
    "swift": "class Solution {\n    func minMovesToCaptureTheQueen(_ a: Int, _ b: Int, _ c: Int, _ d: Int, _ e: Int, _ f: Int) -> Int {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun minMovesToCaptureTheQueen(a: Int, b: Int, c: Int, d: Int, e: Int, f: Int): Int {\n        \n    }\n}",
    "dart": "class Solution {\n  int minMovesToCaptureTheQueen(int a, int b, int c, int d, int e, int f) {\n    \n  }\n}",
    "golang": "func minMovesToCaptureTheQueen(a int, b int, c int, d int, e int, f int) int {\n    \n}",
    "ruby": "# @param {Integer} a\n# @param {Integer} b\n# @param {Integer} c\n# @param {Integer} d\n# @param {Integer} e\n# @param {Integer} f\n# @return {Integer}\ndef min_moves_to_capture_the_queen(a, b, c, d, e, f)\n    \nend",
    "scala": "object Solution {\n    def minMovesToCaptureTheQueen(a: Int, b: Int, c: Int, d: Int, e: Int, f: Int): Int = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn min_moves_to_capture_the_queen(a: i32, b: i32, c: i32, d: i32, e: i32, f: i32) -> i32 {\n        \n    }\n}",
    "racket": "(define/contract (min-moves-to-capture-the-queen a b c d e f)\n  (-> exact-integer? exact-integer? exact-integer? exact-integer? exact-integer? exact-integer? exact-integer?)\n  )",
    "erlang": "-spec min_moves_to_capture_the_queen(A :: integer(), B :: integer(), C :: integer(), D :: integer(), E :: integer(), F :: integer()) -> integer().\nmin_moves_to_capture_the_queen(A, B, C, D, E, F) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec min_moves_to_capture_the_queen(a :: integer, b :: integer, c :: integer, d :: integer, e :: integer, f :: integer) :: integer\n  def min_moves_to_capture_the_queen(a, b, c, d, e, f) do\n    \n  end\nend"
  }
}