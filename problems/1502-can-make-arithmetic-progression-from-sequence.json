{
  "title": "Can Make Arithmetic Progression From Sequence",
  "problem_id": "1626",
  "frontend_id": "1502",
  "difficulty": "Easy",
  "problem_slug": "can-make-arithmetic-progression-from-sequence",
  "topics": [
    "Array",
    "Sorting"
  ],
  "description": "A sequence of numbers is called an arithmetic progression if the difference between any two consecutive elements is the same.\nGiven an array of numbers arr, return true if the array can be rearranged to form an arithmetic progression. Otherwise, return false.\nExample 1:\nExample 2:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: arr = [3,5,1]\nOutput: true\nExplanation: We can reorder the elements as [1,3,5] or [5,3,1] with differences 2 and -2 respectively, between each consecutive elements.",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input: arr = [1,2,4]\nOutput: false\nExplanation: There is no way to reorder the elements to obtain an arithmetic progression.",
      "images": []
    }
  ],
  "constraints": [
    "2 <= arr.length <= 1000",
    "-106 <= arr[i] <= 106"
  ],
  "follow_ups": [],
  "hints": [
    "Consider that any valid arithmetic progression will be in sorted order.",
    "Sort the array, then check if the differences of all consecutive elements are equal."
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    bool canMakeArithmeticProgression(vector<int>& arr) {\n        \n    }\n};",
    "java": "class Solution {\n    public boolean canMakeArithmeticProgression(int[] arr) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def canMakeArithmeticProgression(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: bool\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def canMakeArithmeticProgression(self, arr: List[int]) -> bool:\n        ",
    "c": "bool canMakeArithmeticProgression(int* arr, int arrSize) {\n    \n}",
    "csharp": "public class Solution {\n    public bool CanMakeArithmeticProgression(int[] arr) {\n        \n    }\n}",
    "javascript": "/**\n * @param {number[]} arr\n * @return {boolean}\n */\nvar canMakeArithmeticProgression = function(arr) {\n    \n};",
    "typescript": "function canMakeArithmeticProgression(arr: number[]): boolean {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param Integer[] $arr\n     * @return Boolean\n     */\n    function canMakeArithmeticProgression($arr) {\n        \n    }\n}",
    "swift": "class Solution {\n    func canMakeArithmeticProgression(_ arr: [Int]) -> Bool {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun canMakeArithmeticProgression(arr: IntArray): Boolean {\n        \n    }\n}",
    "dart": "class Solution {\n  bool canMakeArithmeticProgression(List<int> arr) {\n    \n  }\n}",
    "golang": "func canMakeArithmeticProgression(arr []int) bool {\n    \n}",
    "ruby": "# @param {Integer[]} arr\n# @return {Boolean}\ndef can_make_arithmetic_progression(arr)\n    \nend",
    "scala": "object Solution {\n    def canMakeArithmeticProgression(arr: Array[Int]): Boolean = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn can_make_arithmetic_progression(arr: Vec<i32>) -> bool {\n        \n    }\n}",
    "racket": "(define/contract (can-make-arithmetic-progression arr)\n  (-> (listof exact-integer?) boolean?)\n  )",
    "erlang": "-spec can_make_arithmetic_progression(Arr :: [integer()]) -> boolean().\ncan_make_arithmetic_progression(Arr) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec can_make_arithmetic_progression(arr :: [integer]) :: boolean\n  def can_make_arithmetic_progression(arr) do\n    \n  end\nend"
  }
}