{
  "title": "Convert an Array Into a 2D Array With Conditions",
  "problem_id": "2724",
  "frontend_id": "2610",
  "difficulty": "Medium",
  "problem_slug": "convert-an-array-into-a-2d-array-with-conditions",
  "topics": [
    "Array",
    "Hash Table"
  ],
  "description": "You are given an integer array nums. You need to create a 2D array from nums satisfying the following conditions:\nReturn the resulting array. If there are multiple answers, return any of them.\nNote that the 2D array can have a different number of elements on each row.\nExample 1:\nExample 2:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: nums = [1,3,4,1,2,3,1]\nOutput: [[1,3,4,2],[1,3],[1]]\nExplanation: We can create a 2D array that contains the following rows:\n- 1,3,4,2\n- 1,3\n- 1\nAll elements of nums were used, and each row of the 2D array contains distinct integers, so it is a valid answer.\nIt can be shown that we cannot have less than 3 rows in a valid array.",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input: nums = [1,2,3,4]\nOutput: [[4,3,2,1]]\nExplanation: All elements of the array are distinct, so we can keep all of them in the first row of the 2D array.",
      "images": []
    }
  ],
  "constraints": [
    "1 <= nums.length <= 200",
    "1 <= nums[i] <= nums.length"
  ],
  "follow_ups": [],
  "hints": [
    "Process the elements in the array one by one in any order and only create a new row in the matrix when we cannot put it into the existing rows",
    "We can simply iterate over the existing rows of the matrix to see if we can place each element."
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    vector<vector<int>> findMatrix(vector<int>& nums) {\n        \n    }\n};",
    "java": "class Solution {\n    public List<List<Integer>> findMatrix(int[] nums) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def findMatrix(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def findMatrix(self, nums: List[int]) -> List[List[int]]:\n        ",
    "c": "/**\n * Return an array of arrays of size *returnSize.\n * The sizes of the arrays are returned as *returnColumnSizes array.\n * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().\n */\nint** findMatrix(int* nums, int numsSize, int* returnSize, int** returnColumnSizes) {\n    \n}",
    "csharp": "public class Solution {\n    public IList<IList<int>> FindMatrix(int[] nums) {\n        \n    }\n}",
    "javascript": "/**\n * @param {number[]} nums\n * @return {number[][]}\n */\nvar findMatrix = function(nums) {\n    \n};",
    "typescript": "function findMatrix(nums: number[]): number[][] {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @return Integer[][]\n     */\n    function findMatrix($nums) {\n        \n    }\n}",
    "swift": "class Solution {\n    func findMatrix(_ nums: [Int]) -> [[Int]] {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun findMatrix(nums: IntArray): List<List<Int>> {\n        \n    }\n}",
    "dart": "class Solution {\n  List<List<int>> findMatrix(List<int> nums) {\n    \n  }\n}",
    "golang": "func findMatrix(nums []int) [][]int {\n    \n}",
    "ruby": "# @param {Integer[]} nums\n# @return {Integer[][]}\ndef find_matrix(nums)\n    \nend",
    "scala": "object Solution {\n    def findMatrix(nums: Array[Int]): List[List[Int]] = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn find_matrix(nums: Vec<i32>) -> Vec<Vec<i32>> {\n        \n    }\n}",
    "racket": "(define/contract (find-matrix nums)\n  (-> (listof exact-integer?) (listof (listof exact-integer?)))\n  )",
    "erlang": "-spec find_matrix(Nums :: [integer()]) -> [[integer()]].\nfind_matrix(Nums) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec find_matrix(nums :: [integer]) :: [[integer]]\n  def find_matrix(nums) do\n    \n  end\nend"
  },
  "solution": "[TOC]\n\n## Solution\n\n---\n\n### Approach: Frequency Counter\n\n**Intuition**\n\nThe first thing to observe here is how many rows we need at least to ensure each row has distinct integers. Each repeated integer in the original array `nums` needs to be placed in a separate row. Therefore, we need at least as many rows as the maximum frequency of integers in the array `nums`.\n\n\n\nNow, we know that if an integer has $K$ instances, it would be kept in $K$ different rows. So we can keep placing each instance in the row with an index equal to the current frequency. The $0-\\text{th}$ instance of this integer will kept at row index `0`, the $1-\\text{st}$ instance at row index `1`, and so on till the $(K - 1)-\\text{th}$ instance at the row index `K - 1`. Note that, if there is one integer with $K1$ instances and another integer with $K2$ instances, we need $max(K1, K2)$ rows but not $K1 + K2$ rows. This is because we can have just $max(K1, K2)$ rows and the other integer with fewer instances can be also stored in these rows.\n\nWe generally use a HashMap to store the frequencies. However, as mentioned in the problem, the values in the array would be up to the length of the array (which can be up to `200`). Since we know the range of the values, it's efficient to use an array with a size of `N + 1`, where $N$ is the length of `nums`. We will be using the array `freq` for this purpose. Now, we will iterate over the integers in the array `nums` and retrieve the current frequency of the integer from `freq`. \n\nIf the frequency of the current integer is greater than the current size of the two-dimensional array `ans`, indicating that we need to start a new row to store this element, so we add a row and insert the element into the new row.\n\nThen we increment the frequency of this integer.\n\n!?!../Documents/2610-re/2610_Convert_an_Array_Into_a_2D_Array_With_Conditions.json:960,720!?!\n\n**Algorithm**\n\n1. Create an array `freq` of size `nums.size() + 1` to store the frequency of integers in the array `nums`.\n2. Create an empty 2D array `ans` to store the answer array.\n3. Iterate over the array `nums` and for each integer `c`:\n\n   a. If the frequency of the integer is greater than or equal to the current rows count in `ans`, then add a row to `ans`.\n\n   b. Insert the integer `c` at the row `freq[c]`.\n\n   c. Increment the frequency of `c` in `freq`.\n4. Return `ans`.\n\n**Implementation****Complexity Analysis**\n\nHere, $N$ is the size of array `nums`.\n\n* Time complexity: $O(N)$\n\n  We iterate over the array `nums` once to insert them into the 2D array `ans`. Accessing `freq` and incrementing it takes $O(1)$. Hence, the total time complexity is equal to $O(N)$.\n\n* Space complexity: $O(N)$\n\n  The size of the frequency array `freq` is equal to `nums.size() + 1` as the value of integers in the array `nums` can be up to `nums.size()`. Hence, the total space complexity is equal to $O(N)$.---"
}