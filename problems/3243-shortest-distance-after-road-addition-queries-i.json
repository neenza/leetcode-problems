{
  "title": "Shortest Distance After Road Addition Queries I",
  "problem_id": "3517",
  "frontend_id": "3243",
  "difficulty": "Medium",
  "problem_slug": "shortest-distance-after-road-addition-queries-i",
  "topics": [
    "Array",
    "Breadth-First Search",
    "Graph"
  ],
  "description": "You are given an integer n and a 2D integer array queries.\nThere are n cities numbered from 0 to n - 1. Initially, there is a unidirectional road from city i to city i + 1 for all 0 <= i < n - 1.\nqueries[i] = [ui, vi] represents the addition of a new unidirectional road from city ui to city vi. After each query, you need to find the length of the shortest path from city 0 to city n - 1.\nReturn an array answer where for each i in the range [0, queries.length - 1], answer[i] is the length of the shortest path from city 0 to city n - 1 after processing the first i + 1 queries.\nExample 1:\nExample 2:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: n = 5, queries = [[2,4],[0,2],[0,4]]\nOutput: [3,2,1]\nExplanation:\n\nAfter the addition of the road from 2 to 4, the length of the shortest path from 0 to 4 is 3.\n\nAfter the addition of the road from 0 to 2, the length of the shortest path from 0 to 4 is 2.\n\nAfter the addition of the road from 0 to 4, the length of the shortest path from 0 to 4 is 1.",
      "images": [
        "https://assets.leetcode.com/uploads/2024/06/28/image8.jpg",
        "https://assets.leetcode.com/uploads/2024/06/28/image9.jpg",
        "https://assets.leetcode.com/uploads/2024/06/28/image10.jpg"
      ]
    },
    {
      "example_num": 2,
      "example_text": "Input: n = 4, queries = [[0,3],[0,2]]\nOutput: [1,1]\nExplanation:\n\nAfter the addition of the road from 0 to 3, the length of the shortest path from 0 to 3 is 1.\n\nAfter the addition of the road from 0 to 2, the length of the shortest path remains 1.",
      "images": [
        "https://assets.leetcode.com/uploads/2024/06/28/image11.jpg",
        "https://assets.leetcode.com/uploads/2024/06/28/image12.jpg"
      ]
    }
  ],
  "constraints": [
    "3 <= n <= 500",
    "1 <= queries.length <= 500",
    "queries[i].length == 2",
    "0 <= queries[i][0] < queries[i][1] < n",
    "1 < queries[i][1] - queries[i][0]",
    "There are no repeated roads among the queries."
  ],
  "follow_ups": [],
  "hints": [
    "Maintain the graph and use an efficient shortest path algorithm after each update.",
    "We use BFS/Dijkstra for each query."
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    vector<int> shortestDistanceAfterQueries(int n, vector<vector<int>>& queries) {\n        \n    }\n};",
    "java": "class Solution {\n    public int[] shortestDistanceAfterQueries(int n, int[][] queries) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def shortestDistanceAfterQueries(self, n, queries):\n        \"\"\"\n        :type n: int\n        :type queries: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def shortestDistanceAfterQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        ",
    "c": "/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nint* shortestDistanceAfterQueries(int n, int** queries, int queriesSize, int* queriesColSize, int* returnSize) {\n    \n}",
    "csharp": "public class Solution {\n    public int[] ShortestDistanceAfterQueries(int n, int[][] queries) {\n        \n    }\n}",
    "javascript": "/**\n * @param {number} n\n * @param {number[][]} queries\n * @return {number[]}\n */\nvar shortestDistanceAfterQueries = function(n, queries) {\n    \n};",
    "typescript": "function shortestDistanceAfterQueries(n: number, queries: number[][]): number[] {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param Integer $n\n     * @param Integer[][] $queries\n     * @return Integer[]\n     */\n    function shortestDistanceAfterQueries($n, $queries) {\n        \n    }\n}",
    "swift": "class Solution {\n    func shortestDistanceAfterQueries(_ n: Int, _ queries: [[Int]]) -> [Int] {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun shortestDistanceAfterQueries(n: Int, queries: Array<IntArray>): IntArray {\n        \n    }\n}",
    "dart": "class Solution {\n  List<int> shortestDistanceAfterQueries(int n, List<List<int>> queries) {\n    \n  }\n}",
    "golang": "func shortestDistanceAfterQueries(n int, queries [][]int) []int {\n    \n}",
    "ruby": "# @param {Integer} n\n# @param {Integer[][]} queries\n# @return {Integer[]}\ndef shortest_distance_after_queries(n, queries)\n    \nend",
    "scala": "object Solution {\n    def shortestDistanceAfterQueries(n: Int, queries: Array[Array[Int]]): Array[Int] = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn shortest_distance_after_queries(n: i32, queries: Vec<Vec<i32>>) -> Vec<i32> {\n        \n    }\n}",
    "racket": "(define/contract (shortest-distance-after-queries n queries)\n  (-> exact-integer? (listof (listof exact-integer?)) (listof exact-integer?))\n  )",
    "erlang": "-spec shortest_distance_after_queries(N :: integer(), Queries :: [[integer()]]) -> [integer()].\nshortest_distance_after_queries(N, Queries) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec shortest_distance_after_queries(n :: integer, queries :: [[integer]]) :: [integer]\n  def shortest_distance_after_queries(n, queries) do\n    \n  end\nend"
  },
  "solution": "[TOC]\n\n## Solution\n\n---\n\n### Overview\n\nAccording to the problem statement:\n\n-   There are $n$ cities, numbered from $0$ to $n-1$.\n-   Initially, each pair of consecutive cities is connected by a one-way road.\n    -   Formally, for each $i$ where $0 \\leq i \\leq n-2$, there exists a directed and unweighted edge from city $i$ to city $i+1$.\n\nAdditionally, we are given an array of length $q$, called $queries$, where each element represents a new road to be added:\n\n-   Each element in $queries$ is defined as $\\text{queries}[i] = [u_i, v_i]$, where:\n    -   $u_i$ and $v_i$ are the cities between which a new directed and unweighted road will be added at step $i$.\n    -   It is guaranteed that $u_i < v_i$.\n\nAfter adding each road in $queries$, we have to determine the length of the shortest path between city $0$ and city $n-1$. Then we will return the result as an array of length $q$, where each element corresponds to the shortest path length after each step.\n\n---\n\n### Approach 1: Breadth First Search (BFS)\n\n#### Intuition\n\nThe problem statement naturally suggests a graphical representation, where cities are modeled as nodes and the roads connecting them are represented as edges. This transforms our task into a well-known graph problem: finding the shortest path between two nodes.\n\nHowever, there's an important distinction: our graph is dynamic, with new edges added at each step. A logical approach is to update the graph with each new road and apply a path-finding algorithm at each step to find the shortest path.\n\nTo select the appropriate algorithm, we need to consider the properties of our graph. One notable characteristic is that the edges are unweighted. This implies that the total cost of a path is equivalent to the number of steps taken to reach the destination, or, in other words, the number of layers of nodes that must be explored.\n\nThis understanding leads us to implement the [Breadth-First Search (BFS)](https://leetcode.com/explore/learn/card/graph/620/breadth-first-search-in-graph/) algorithm, which is particularly suited for this type of problem.\n\n!?!../Documents/3243/3243_Approach1.json:960,540!?!\n\nIf you need a refresher on how BFS works, you can refer to the classic problem [994. Rotting Oranges](https://leetcode.com/problems/rotting-oranges/description).\n\n#### Algorithm\n\n-   Define a helper function `bfs` that, given the number of nodes `n` and the graph's adjacency list `adjList`, returns the number of edges in the shortest path between node `0` and node `n - 1`.\n\n    -   Initialize a boolean array `visited` to mark the processed nodes.\n    -   Initialize a queue `nodeQueue`.\n    -   Push node `0` into the queue and mark it as visited.\n    -   Initialize a variable `currentLayerNodeCount` to `1` (since node `0` is already in the queue), `nextLayerNodeCount` to `0`, and `layersExplored` to `0`.\n    -   Perform BFS until the queue is empty:\n        -   Iterate over the nodes in the current layer, with `i` ranging from `0` to `currentLayerNodeCount - 1`:\n            -   Pop the first node, called `currentNode`, from the queue and check whether it is the target node (`n - 1`).\n                -   If the condition is true, return `layersExplored`.\n            -   For every `neighbor` in `adjList[currentNode]`:\n                -   If `neighbor` has already been visited, continue.\n                -   Otherwise:\n                    -   Push `neighbor` into the queue.\n                    -   Increment `nextLayerNodeCount` by `1`.\n                    -   Mark `neighbor` as visited.\n        -   When the loop is over and all nodes in the current layer are processed:\n            -   Set `currentLayerNodeCount = nextLayerNodeCount`.\n            -   Set `nextLayerNodeCount = 0`.\n            -   Increment `layersExplored` by `1`.\n    -   Since the initial constraint that every two consecutive nodes are connected guarantees that there is always a path between node `0` and node `n - 1`, the algorithm will never exit the BFS loop without having found and returned the shortest path length. Here, simply return a random value, e.g., `-1`.\n\n-   In the main function `shortestDistanceAfterQueries`:\n    -   Initialize the result array `answer`.\n    -   Initialize a 2D array `adjList`.\n    -   Iterate over the first `n - 1` nodes with `i` ranging from `0` to `n - 2`:\n        -   Push `i + 1` to `adjList[i]`.\n    -   Enter a new loop to process each query `query[i] = [u, v]`:\n        -   Push `v` to `adjList[u]`.\n        -   Run `bfs` and push the result to the `answer` array.\n    -   Finally, return `answer`.\n\n#### Implementation#### Complexity Analysis\n\nLet $n$ be the number of cities and $q$ the number of queries.\n\n-   Time Complexity: $O(q \\times (n + q))$.\n\n    At first glance, the `bfs` function appears to contain three nested loops, which might suggest a time complexity of $O(n^3)$. However, this is misleading. A closer look shows that each part of the BFS algorithm runs in relation to the nodes and edges in the graph after each road (edge) addition.\n\n    -   Node Processing (first inner loop): Each node is added to and removed from the queue exactly once, giving a time complexity of $O(n)$ for processing all nodes.\n    -   Edge Exploration (second inner loop): For each dequeued node, the algorithm checks all its neighbors. Each edge is examined only once, so the total time for edge exploration is $O(e)$, where $e$ is the number of edges in the graph.\n\n    Combining these, the time complexity of each BFS run is $O(n + e)$.\n\n    -   Layer-wise Node Processing (outer loop): The outer loop runs based on the number of graph layers rather than the number of nodes, ensuring the BFS explores nodes systematically. This does not increase the overall complexity, which remains $O(n + e)$.\n\n    Each BFS after adding a road incrementally increases the edge count. The time complexity across all $q$ queries is thus:\n\n    1. After the 1st road: $O(n + n)$.\n    2. After the 2nd road: $O(n + n + 1)$.\n    3. …\n    4. After the $q$-th road: $O(n + n + q - 1)$.\n\n    Summing these yields:\n\n    $$\n    \\begin{aligned}\n        O(n + n) + O(n + n + 1) + \\dots + O(n + n + q - 1) \\\\\n        = O(2qn + \\frac{q(q-1)}{2}) \\\\\n        = O(q \\times (n + q))\n    \\end{aligned}\n    $$\n\n-   Space Complexity: $O(n+q)$.\n\n    To represent our graph, we create and continuously update its adjacency list in the form of a 2D array. Initially, this array contains $n-1$ elements, representing the edges between every two consecutive nodes. After processing all queries, the array will contain $n + q - 1$ elements, contributing $O(n + q)$ to the total space complexity.\n\n    In addition to the adjacency list, the `bfs` function creates a 1D array, named `visited` and a queue, called `nodeQueue`, both of which can have a maximum size of $n$.\n\n    Therefore, the overall space complexity remains $O(n+q)$.\n\n---\n\n### Approach 2: Recursive Dynamic Programming (Top-Down)\n\n#### Intuition\n\nUpon closer examination of the graph, we can determine that it is a Directed Acyclic Graph (DAG). This means:\n\n-   Directed Edges: Each road in the graph has a specific direction (is unidirectional).\n\n-   No Cycles: A key characteristic of a DAG is that it does not contain any cycles. In this graph, every road's destination node has a value greater than that of its source node. This property ensures that it is impossible to return to a starting node by following the directed edges.\n\nUsing the language of the problem, we can say that for every node $v_i$, the distance to the final node $v_{n-1}$ only depends on two factors:\n\n-   The distance from $v_i$ to the subsequent nodes $v_{i+1}$, $v_{i+2}$, ..., $v_{n-1}$.\n-   The distance from the subsequent nodes $v_{i+1}$, $v_{i+2}$, ..., $v_{n-1}$ to the final node $v_{n-1}$.\n\nSpecifically the relationship can be expressed as, $distance_{v_i, v_{n-1}} = \\min_{j} (distance_{v_i, v_j}+ distance_{v_j, v_{n-1}})$.\n\nIn our calculations, we notice that some states overlap, meaning they are needed in various computations but are independent of one another. This characteristic indicates that dynamic programming could help us solve this problem efficiently.\n\n#### Algorithm\n\n-   Define a recursive function `findMinDistance` that, given the number of nodes `n`, the graph's adjacency list `adjList`, the memoization array `dp`, and the node `currentNode`, returns the number of edges in the shortest path from node `currentNode` to node `n - 1`.\n\n    -   Base case: if `currentNode == n - 1`, return `0`.\n    -   Computed case: if `dp[currentNode] != -1`, return `dp[currentNode]`.\n    -   Initialize a variable `minDistance` to `n`.\n    -   For every `neighbor` of `currentNode`:\n        -   Set `minDistace = min(minDistance, 1 + findMinDistance(..., neighbor))`.\n    -   Store the computed `minDistance`; set `dp[currentNode] = minDistance`.\n    -   Return `minDistance`.\n\n-   In the main function `shortestDistanceAfterQueries`:\n    -   Initialize an empty result array `answer`.\n    -   Initialize a memoization array `dp` of size `n`. Initially set all `dp` values to `-1`.\n    -   Initialize a 2D array `adjList` to represent the graph.\n    -   Iterate over the first `n - 1` nodes, with `i` ranging from `0` to `n - 2`:\n        -   Add `i+1` to `adjList[i]` to create initial consecutive edges.\n    -   Process each query `query[i] = [u, v]` in a loop:\n        -   Add `v` to `adjList[u]` to represent the new edge.\n        -   Run `findMinDistance` for node `0` and append the result to the `answer` array.\n        -   Reset all values in the `dp` array to `-1`.\n    -   Finally, return `answer`.\n\n#### Implementation#### Complexity Analysis\n\nLet $n$ be the number of cities and $q$ the number of queries.\n\n-   Time Complexity: $O(q \\times (n+q))$.\n\n-   Time Complexity: $O(q \\times (n+q))$.\n\n    The `findMinDistance` function is called on the starting node (node `0`) each time a query is processed. If the distance for a node is already computed, the function returns the cached value from the `dp` array, avoiding redundant calculations.\n\n    During its first call for node `0`, `findMinDistance` explores all neighbors, iterating over all outgoing edges. Each node is processed only once for distance calculation due to caching in the `dp` array.\n\n    The time complexity of a single `findMinDistance` call on node `0` is $O(e)$, where $e$ represents the current number of edges in the graph. Since each edge is visited exactly once, the computation scales linearly with the number of edges.\n\n    Thus, the total time complexity sums to:\n\n    $$\n    \\begin{aligned}\n        O(n) +  O(n+1) + \\ldots +  O(n+q-1) \\\\\n        = O(q \\times (n+q))\n    \\end{aligned}\n    $$\n\n-   Space Complexity: $O(n+q)$.\n\n    Once again, we choose to represent our graph using an adjacency list, the maximum size of which is $O(n + q)$. Additionally, we create a 1D memoization array, called `dp`, with a fixed size of $n$ and we also invoke a recursive function `findMinDistance`, whose depth is $O(n)$, as well. Combining the above, we conclude that the total space complexity is $O(n+q)$.\n\n---\n\n### Approach 3: Iterative Dynamic Programming (Bottom-Up)\n\n#### Intuition\n\nWhile the top-down dynamic programming approach is often intuitive, it can become less effective in certain situations, particularly due to uncontrolled recursion depth. This is especially true for larger input sizes, where deep recursion can lead to stack overflow errors. To avoid this risk, it is generally considered a good idea to convert recursive dynamic programming solutions into iterative ones.\n\nIn an iterative approach, we essentially take each line from the previous recursive algorithm and translate it into its iterative equivalent. A key consideration in this translation is that when we compute `dp[u]`, it represents the result of the `findMinDistance` function for node `u`. Thus, both the return value and the runtime complexity of `findMinDistance(u)` can be directly replaced with `dp[u]`.\n\nTo implement the iterative approach effectively, we need to recognize the relationship between the calls in the recursive function. We begin our computation at the base case, which occurs when `currentNode` equals `n - 1`, and work our way up to `currentNode = 0`. This means that our bottom-up approach should process nodes in reverse order, starting from `currentNode = n - 1` and building our results incrementally until we reach `currentNode = 0`. By doing so, we ensure that all necessary values are calculated before they are needed.\n\n!?!../Documents/3243/3243_Approach3.json:960,540!?!\n\n#### Algorithm\n\n-   Define a function `findMinDistance` that, given the number of nodes `n` and the graph's adjacency list `adjList`, returns the number of edges in the shortest path from node `0` to node `n - 1`.\n\n    -   Initialize a 1D array of size `n`, called `dp`.\n    -   Base case: set `dp[n-1] = 0`.\n    -   Iterate over the first `n - 1` nodes in reversed order, with `currentNode` from `n - 2` to `0`. On each iteration:\n        -   Initialize `minDistance` to `n`.\n        -   For each `neighbor` of `currentNode`:\n            -   Set `minDistance = min(minDistance, dp[neighbor] + 1)`.\n        -   After exiting the inner loop, set `dp[currentNode] = minDistance`.\n    -   Return `dp[0]`.\n\n-   In the main function `shortestDistanceAfterQueries`:\n    -   Initialize an empty result array `answer`.\n    -   Initialize a 2D array `adjList` to represent the graph.\n    -   Iterate over the first `n-1` nodes, with `i` ranging from `0` to `n-2`:\n        -   Add `i+1` to `adjList[i]` to create initial consecutive edges.\n    -   Process each query `query[i] = [u, v]` in a loop:\n        -   Add `v` to `adjList[u]` to represent the new edge.\n        -   Run `findMinDistance` and append the result to the `answer` array.\n    -   Finally, return `answer`.\n\n#### Implementation#### Complexity Analysis\n\nLet $n$ be the number of cities and $q$ the number of queries.\n\n-   Time Complexity: $O(q \\times (n+q))$.\n\n    The `findMinDistance` function iterates over each edge exactly once, so its time complexity for a graph with $e$ edges is $O(e)$.\n\n    Therefore, like the previous approaches, the total time complexity of the algorithm can be expressed as:\n\n    $$\n    \\begin{aligned}\n        O(n) +  O(n+1) + ... +  O(n+q-1) = \\\\\n        O(q \\times (n+q)).\n    \\end{aligned}\n    $$\n\n-   Space Complexity: $O(n+q)$.\n\n    The total space complexity is once again determined by the size of the adjacency list which is at most $O(n+q)$.\n\n---"
}