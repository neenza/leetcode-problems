{
  "title": "Minimum Number of Days to Make m Bouquets",
  "problem_id": "1605",
  "frontend_id": "1482",
  "difficulty": "Medium",
  "problem_slug": "minimum-number-of-days-to-make-m-bouquets",
  "topics": [
    "Array",
    "Binary Search"
  ],
  "description": "You are given an integer array bloomDay, an integer m and an integer k.\nYou want to make m bouquets. To make a bouquet, you need to use k adjacent flowers from the garden.\nThe garden consists of n flowers, the ith flower will bloom in the bloomDay[i] and then can be used in exactly one bouquet.\nReturn the minimum number of days you need to wait to be able to make m bouquets from the garden. If it is impossible to make m bouquets return -1.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: bloomDay = [1,10,3,10,2], m = 3, k = 1\nOutput: 3\nExplanation: Let us see what happened in the first three days. x means flower bloomed and _ means flower did not bloom in the garden.\nWe need 3 bouquets each should contain 1 flower.\nAfter day 1: [x, _, _, _, _]   // we can only make one bouquet.\nAfter day 2: [x, _, _, _, x]   // we can only make two bouquets.\nAfter day 3: [x, _, x, _, x]   // we can make 3 bouquets. The answer is 3.",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input: bloomDay = [1,10,3,10,2], m = 3, k = 2\nOutput: -1\nExplanation: We need 3 bouquets each has 2 flowers, that means we need 6 flowers. We only have 5 flowers so it is impossible to get the needed bouquets and we return -1.",
      "images": []
    },
    {
      "example_num": 3,
      "example_text": "Input: bloomDay = [7,7,7,7,12,7,7], m = 2, k = 3\nOutput: 12\nExplanation: We need 2 bouquets each should have 3 flowers.\nHere is the garden after the 7 and 12 days:\nAfter day 7: [x, x, x, x, _, x, x]\nWe can make one bouquet of the first three flowers that bloomed. We cannot make another bouquet from the last three flowers that bloomed because they are not adjacent.\nAfter day 12: [x, x, x, x, x, x, x]\nIt is obvious that we can make two bouquets in different ways.",
      "images": []
    }
  ],
  "constraints": [
    "bloomDay.length == n",
    "1 <= n <= 105",
    "1 <= bloomDay[i] <= 109",
    "1 <= m <= 106",
    "1 <= k <= n"
  ],
  "follow_ups": [],
  "hints": [
    "If we can make m or more bouquets at day x, then we can still make m or more bouquets at any day y > x.",
    "We can check easily if we can make enough bouquets at day x if we can get group adjacent flowers at day x."
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    int minDays(vector<int>& bloomDay, int m, int k) {\n        \n    }\n};",
    "java": "class Solution {\n    public int minDays(int[] bloomDay, int m, int k) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def minDays(self, bloomDay, m, k):\n        \"\"\"\n        :type bloomDay: List[int]\n        :type m: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        ",
    "c": "int minDays(int* bloomDay, int bloomDaySize, int m, int k) {\n    \n}",
    "csharp": "public class Solution {\n    public int MinDays(int[] bloomDay, int m, int k) {\n        \n    }\n}",
    "javascript": "/**\n * @param {number[]} bloomDay\n * @param {number} m\n * @param {number} k\n * @return {number}\n */\nvar minDays = function(bloomDay, m, k) {\n    \n};",
    "typescript": "function minDays(bloomDay: number[], m: number, k: number): number {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param Integer[] $bloomDay\n     * @param Integer $m\n     * @param Integer $k\n     * @return Integer\n     */\n    function minDays($bloomDay, $m, $k) {\n        \n    }\n}",
    "swift": "class Solution {\n    func minDays(_ bloomDay: [Int], _ m: Int, _ k: Int) -> Int {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun minDays(bloomDay: IntArray, m: Int, k: Int): Int {\n        \n    }\n}",
    "dart": "class Solution {\n  int minDays(List<int> bloomDay, int m, int k) {\n    \n  }\n}",
    "golang": "func minDays(bloomDay []int, m int, k int) int {\n    \n}",
    "ruby": "# @param {Integer[]} bloom_day\n# @param {Integer} m\n# @param {Integer} k\n# @return {Integer}\ndef min_days(bloom_day, m, k)\n    \nend",
    "scala": "object Solution {\n    def minDays(bloomDay: Array[Int], m: Int, k: Int): Int = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn min_days(bloom_day: Vec<i32>, m: i32, k: i32) -> i32 {\n        \n    }\n}",
    "racket": "(define/contract (min-days bloomDay m k)\n  (-> (listof exact-integer?) exact-integer? exact-integer? exact-integer?)\n  )",
    "erlang": "-spec min_days(BloomDay :: [integer()], M :: integer(), K :: integer()) -> integer().\nmin_days(BloomDay, M, K) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec min_days(bloom_day :: [integer], m :: integer, k :: integer) :: integer\n  def min_days(bloom_day, m, k) do\n    \n  end\nend"
  },
  "solution": "## Solution\n\n---\n\n### Approach: Binary Search\n\n#### Intuition\n\nIn this problem, we need to return the number of days required to make a certain number of bouquets, or return -1 if it's not possible to make that many. The flowers for a bouquet must be consecutive in the garden and fully bloomed.\n\nThe naive approach would be to iterate through each day, starting from day 1, and check if we can make `m` bouquets on that day. This method is inefficient since it requires iterating over all possible days and all `N` flowers for each day.\n\nTo optimize the solution, we observe a crucial property: once a flower blooms, it remains bloomed. This means that the number of bloomed flowers stays the same or increases as the days progress. The same goes for the number of bouquets that can possibly be made.\n\nThis observation leads us to consider using a binary search algorithm. One clue that binary search can be applied is that we are searching for a specific value that satisfies a condition (the earliest day). Another clue is that the condition exhibits an \"ordered property\" â€“ if the condition is satisfied on a particular day, it will also be satisfied on all of the following days.\n\nThe observation that the number of bloomed flowers stays the same or increases as the days progress allows us to define a search space between 1 and the maximum value in the `bloomDay` array. For each midpoint day in the search space, we calculate the number of bouquets that can be made on that day by counting the consecutive bloomed flowers.\n\nIf the number of bouquets we can make on the midpoint day is greater than or equal to the number required by the problem (`m`), then we can potentially find an earlier day that satisfies the requirement. Since we want to return the minimum number of days we need to wait, we update the search space to the left half to see if we can reduce our wait time. Conversely, if the number of bouquets is less than `m`, we update the search space to the right half to continue our search for a day that we can make the required number of bouquets.\n\nBy repeatedly narrowing down the search space through binary search, we can determine whether or not we can make the required number of bouquets.\n\n![fig](../Figures/1482/1482A.png)\n\n#### Algorithm\n\n1. Initialize `start` to `0` and `end` to the highest value in the array `bloomDay`.\n2. Do the following while the search space (`start` to `end`) doesn't become empty:\n\n    - Initialize `mid` to `start + end / 2`.\n    - Find the number of bouquets possible on day `mid` using a helper function `getNumOfBouquets` as follows:\n\n        - Initialize the variable `numOfBouquets` to `0`.\n        - Iterate over the array `bloomDay` and for each index `i`\n\n            - If the value `bloomDay[i]` is less than or equal to `mid`, increment the `count`; else, reset it to `0`.\n            - If the value of `count` is equal to `k`, make a bouquet by incrementing `numOfBouquets` and reset `count` to `0`.\n        - Return `numOfBouquets`.\n    - If `numOfBouquets` is more than or equal to `m` store `mid` as an answer in `ans`. Shift to the left of the search space by setting `end` to `mid - 1`.\n    - Otherwise, shift to the right of the search space by setting `start` to `mid + 1`.\n3. Return `ans`.\n\n\n#### Implementation#### Complexity Analysis\n\nHere, $N$ is the number of flowers and $D$ is the highest value in the array `bloomDay`.\n\n* Time complexity: $O(N \\log D)$.\n\n  The search space is from $1$ to $D$ and for each of the chosen values of `mid` in the binary search we will iterate over the $N$ flowers. Therefore the time complexity is equal to $O(N \\log D)$.\n\n* Space complexity: $O(1)$\n\n  No extra space is required apart from a few variables and hence the space complexity is constant.\n---"
}