{
  "title": "Construct the Lexicographically Largest Valid Sequence",
  "problem_id": "1819",
  "frontend_id": "1718",
  "difficulty": "Medium",
  "problem_slug": "construct-the-lexicographically-largest-valid-sequence",
  "topics": [
    "Array",
    "Backtracking"
  ],
  "description": "Given an integer n, find a sequence with elements in the range [1, n] that satisfies all of the following:\nThe distance between two numbers on the sequence, a[i] and a[j], is the absolute difference of their indices, |j - i|.\nReturn the lexicographically largest sequence. It is guaranteed that under the given constraints, there is always a solution.\nA sequence a is lexicographically larger than a sequence b (of the same length) if in the first position where a and b differ, sequence a has a number greater than the corresponding number in b. For example, [0,1,9,0] is lexicographically larger than [0,1,5,6] because the first position they differ is at the third number, and 9 is greater than 5.\nExample 1:\nExample 2:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: n = 3\nOutput: [3,1,2,3,2]\nExplanation: [2,3,2,1,3] is also a valid sequence, but [3,1,2,3,2] is the lexicographically largest valid sequence.",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input: n = 5\nOutput: [5,3,1,4,3,5,2,4,2]",
      "images": []
    }
  ],
  "constraints": [
    "1 <= n <= 20"
  ],
  "follow_ups": [],
  "hints": [
    "Heuristic algorithm may work."
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    vector<int> constructDistancedSequence(int n) {\n        \n    }\n};",
    "java": "class Solution {\n    public int[] constructDistancedSequence(int n) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def constructDistancedSequence(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def constructDistancedSequence(self, n: int) -> List[int]:\n        ",
    "c": "/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nint* constructDistancedSequence(int n, int* returnSize) {\n    \n}",
    "csharp": "public class Solution {\n    public int[] ConstructDistancedSequence(int n) {\n        \n    }\n}",
    "javascript": "/**\n * @param {number} n\n * @return {number[]}\n */\nvar constructDistancedSequence = function(n) {\n    \n};",
    "typescript": "function constructDistancedSequence(n: number): number[] {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param Integer $n\n     * @return Integer[]\n     */\n    function constructDistancedSequence($n) {\n        \n    }\n}",
    "swift": "class Solution {\n    func constructDistancedSequence(_ n: Int) -> [Int] {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun constructDistancedSequence(n: Int): IntArray {\n        \n    }\n}",
    "dart": "class Solution {\n  List<int> constructDistancedSequence(int n) {\n    \n  }\n}",
    "golang": "func constructDistancedSequence(n int) []int {\n    \n}",
    "ruby": "# @param {Integer} n\n# @return {Integer[]}\ndef construct_distanced_sequence(n)\n    \nend",
    "scala": "object Solution {\n    def constructDistancedSequence(n: Int): Array[Int] = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn construct_distanced_sequence(n: i32) -> Vec<i32> {\n        \n    }\n}",
    "racket": "(define/contract (construct-distanced-sequence n)\n  (-> exact-integer? (listof exact-integer?))\n  )",
    "erlang": "-spec construct_distanced_sequence(N :: integer()) -> [integer()].\nconstruct_distanced_sequence(N) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec construct_distanced_sequence(n :: integer) :: [integer]\n  def construct_distanced_sequence(n) do\n    \n  end\nend"
  },
  "solution": "[TOC]\n\n## Solution\n\n---\n\n### Overview\n\nGiven an integer `n`, we need to find the lexicographically largest sequence that satisfies all of these conditions:\n- The integer `1` occurs once in the sequence.\n- All other integers from `2` to `n` occur exactly twice, and the distance between these occurrences is equal to the value of this integer.\n\nThe distance between two integers is defined as the difference in the indices of both the integers. For example: in the array `nums = [1,2,3,1,2]`, the distance between both occurences of 1 is given by 3.\n\n> A sequence `a` is lexicographically larger than a sequence `b` (of the same length) if in the first position where `a` and `b` differ, sequence `a` has a number greater than the corresponding number in `b`. For example, `[0,1,9,0]` is lexicographically larger than `[0,1,5,6]` because the first position they differ is at the third number, and 9 is greater than 5.\n\n---\n\n### Approach: Backtracking\n\n#### Intuition\n\nObserve the lexicographically largest sequences for smaller values of `n`:\n\n- For `n = 1`: `[1]`\n- For `n = 2`: `[2, 1, 2]`\n- For `n = 3`: `[3, 1, 2, 3, 2]`\n- For `n = 4`: `[4, 2, 3, 2, 4, 3, 1]`\n\nIdentifying an intuitive pattern for these sequences is challenging. Given that `n` lies in the range `1 <= n <= 20`, we can generate all possible valid sequences and find the lexicographically largest among them using backtracking. We'll use a recursive boolean function to determine whether the current sequence is valid. If it's not, we can terminate the recursive process early. \n\nLet's represent the recursive function as `bool findLargestSequence(currentIndex, resultSequence, isNumberUsed, targetNumber)`, where we start with an empty sequence `resultSequence` and assign values from `1` to `n` one by one at the `currentIndex`. However, since we want to find the lexicographically maximum sequence, we can start assigning the values from `n` to `1`, in decreasing order. This would help us assign greater values at the beginning of the list. Therefore, the first valid list created would be the lexicographically greatest one.\n\nThe base case occurs when `currentIndex` reaches the end of the sequence, signaling that a valid solution has been constructed. We return `true` and save the current sequence as the answer.\n\nWe will try to place all the values from `n` to `1` at the `currentIndex`. If the value to be assigned, `numberToPlace`, is not `1`, we must assign this value at an index located `numberToPlace` positions away to create a valid sequence. If that position, given by `numberToPlace + currentIndex`, already contains a value, the current sequence is invalid, and we cannot assign the current value to this index. So we move to the next possible value for `numberToPlace` and check if it can be assigned to the current index. For `numberToPlace = 1`, we can proceed directly to the next index.\n\nAfter assigning `numberToPlace`, we recursively attempt to fill subsequent positions by passing the modified sequence and incrementing the `currentIndex` in the recursive state. However, backtracking requires that we undo the assignments at both `currentIndex` and `currentIndex + numberToPlace` to explore other valid sequences. So we unassign the values at both these indices and repeat the process for other values of `numberToPlace`.\n\n#### Algorithm\n\nRecursive Helper Function `findLexicographicallyLargestSequence(currentIndex, resultSequence, isNumberUsed, targetNumber)`:\n\n- If `currentIndex` equals the size of `resultSequence`, return `true` as the sequence is fully constructed.  \n- If `resultSequence[currentIndex]` is not zero, recursively call the function for `currentIndex + 1`.  \n- Loop through numbers from `targetNumber` down to `1` to ensure a lexicographically largest result.  \n  - If `isNumberUsed[numberToPlace] == true`, continue to the next number.  \n  - Mark the number as used by setting `isNumberUsed[numberToPlace] = true`.  \n  - Place `numberToPlace` at `currentIndex` in `resultSequence`.  \n  - If `numberToPlace == 1`, directly move to the next index and recursively call the function. If the recursion returns `true`, return `true`.  \n  - For larger numbers, check if `currentIndex + numberToPlace` is a valid index and that position is empty. If valid:  \n    - Place `numberToPlace` at `currentIndex + numberToPlace`.  \n    - Recursively call the function and return `true` if the recursion succeeds.  \n    - Undo the placement at `currentIndex + numberToPlace` for backtracking.  \n  - Undo the current placement and mark `numberToPlace` as unused.  \n- Return `false` if no valid placement is found.\n\nMain Function:\n\n- Initialize `resultSequence` as a vector of size `2 * targetNumber - 1`, filled with zeros, to store the final sequence.\n- Create a boolean vector `isNumberUsed` of size `targetNumber + 1`, initialized to `false`, to track the numbers already placed in the sequence.\n- Call the recursive helper function `findLexicographicallyLargestSequence(0, resultSequence, isNumberUsed, targetNumber)` to construct the sequence.\n\n#### Implementation#### Complexity Analysis\n\nLet $n$ be the target number.\n\n- Time Complexity: $O(n!)$\n\n    The recursive function generates permutations by exploring all possible ways to arrange a set of numbers. For a given target number `n`, the function places each number from `n` down to 1 at every valid index in the sequence. Since there are `n` possible choices for the first number, `n-1` choices for the second, and so on, the total number of possible arrangements is the factorial of `n`, denoted as $O(n!)$. This is because each recursive call explores a new possibility by reducing the problem size by 1 until all positions are filled, creating a tree-like structure with `n!` leaves at the deepest level.\n\n    However, while the theoretical time complexity is $O(n!)$, the actual runtime is often much lower in practice. This is due to early pruning of invalid states during the backtracking process. The algorithm can stop as soon as it finds the lexicographically largest valid permutation or an invalid permutation, avoiding further exploration of unnecessary branches. This reduces the number of recursive calls significantly, as many permutations are discarded without fully exploring their subtrees.\n\n- Space Complexity: $O(n)$\n\n    The recursion depth is bounded by `n` due to backtracking. Additional space is required for the `resultSequence` and `isNumberUsed` lists, both of size $O(n)$. Therefore, the total space complexity is given by $O(n)$.\n\n---"
}