{
  "title": "Maximum Score Words Formed by Letters",
  "problem_id": "1381",
  "frontend_id": "1255",
  "difficulty": "Hard",
  "problem_slug": "maximum-score-words-formed-by-letters",
  "topics": [
    "Array",
    "String",
    "Dynamic Programming",
    "Backtracking",
    "Bit Manipulation",
    "Bitmask"
  ],
  "description": "Given a list of words, list of  single letters (might be repeating) and score of every character.\nReturn the maximum score of any valid set of words formed by using the given letters (words[i] cannot be used two or more times).\nIt is not necessary to use all characters in letters and each letter can only be used once. Score of letters 'a', 'b', 'c', ... ,'z' is given by score[0], score[1], ... , score[25] respectively.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: words = [\"dog\",\"cat\",\"dad\",\"good\"], letters = [\"a\",\"a\",\"c\",\"d\",\"d\",\"d\",\"g\",\"o\",\"o\"], score = [1,0,9,5,0,0,3,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0]\nOutput: 23\nExplanation:\nScore  a=1, c=9, d=5, g=3, o=2\nGiven letters, we can form the words \"dad\" (5+1+5) and \"good\" (3+2+2+5) with a score of 23.\nWords \"dad\" and \"dog\" only get a score of 21.",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input: words = [\"xxxz\",\"ax\",\"bx\",\"cx\"], letters = [\"z\",\"a\",\"b\",\"c\",\"x\",\"x\",\"x\"], score = [4,4,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,0,10]\nOutput: 27\nExplanation:\nScore  a=4, b=4, c=4, x=5, z=10\nGiven letters, we can form the words \"ax\" (4+5), \"bx\" (4+5) and \"cx\" (4+5) with a score of 27.\nWord \"xxxz\" only get a score of 25.",
      "images": []
    },
    {
      "example_num": 3,
      "example_text": "Input: words = [\"leetcode\"], letters = [\"l\",\"e\",\"t\",\"c\",\"o\",\"d\"], score = [0,0,1,1,1,0,0,0,0,0,0,1,0,0,1,0,0,0,0,1,0,0,0,0,0,0]\nOutput: 0\nExplanation:\nLetter \"e\" can only be used once.",
      "images": []
    }
  ],
  "constraints": [
    "1 <= words.length <= 14",
    "1 <= words[i].length <= 15",
    "1 <= letters.length <= 100",
    "letters[i].length == 1",
    "score.length == 26",
    "0 <= score[i] <= 10",
    "words[i], letters[i] contains only lower case English letters."
  ],
  "follow_ups": [],
  "hints": [
    "Note that words.length is small. This means you can iterate over every subset of words (2^N)."
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    int maxScoreWords(vector<string>& words, vector<char>& letters, vector<int>& score) {\n        \n    }\n};",
    "java": "class Solution {\n    public int maxScoreWords(String[] words, char[] letters, int[] score) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def maxScoreWords(self, words, letters, score):\n        \"\"\"\n        :type words: List[str]\n        :type letters: List[str]\n        :type score: List[int]\n        :rtype: int\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def maxScoreWords(self, words: List[str], letters: List[str], score: List[int]) -> int:\n        ",
    "c": "int maxScoreWords(char** words, int wordsSize, char* letters, int lettersSize, int* score, int scoreSize) {\n    \n}",
    "csharp": "public class Solution {\n    public int MaxScoreWords(string[] words, char[] letters, int[] score) {\n        \n    }\n}",
    "javascript": "/**\n * @param {string[]} words\n * @param {character[]} letters\n * @param {number[]} score\n * @return {number}\n */\nvar maxScoreWords = function(words, letters, score) {\n    \n};",
    "typescript": "function maxScoreWords(words: string[], letters: string[], score: number[]): number {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param String[] $words\n     * @param String[] $letters\n     * @param Integer[] $score\n     * @return Integer\n     */\n    function maxScoreWords($words, $letters, $score) {\n        \n    }\n}",
    "swift": "class Solution {\n    func maxScoreWords(_ words: [String], _ letters: [Character], _ score: [Int]) -> Int {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun maxScoreWords(words: Array<String>, letters: CharArray, score: IntArray): Int {\n        \n    }\n}",
    "dart": "class Solution {\n  int maxScoreWords(List<String> words, List<String> letters, List<int> score) {\n    \n  }\n}",
    "golang": "func maxScoreWords(words []string, letters []byte, score []int) int {\n    \n}",
    "ruby": "# @param {String[]} words\n# @param {Character[]} letters\n# @param {Integer[]} score\n# @return {Integer}\ndef max_score_words(words, letters, score)\n    \nend",
    "scala": "object Solution {\n    def maxScoreWords(words: Array[String], letters: Array[Char], score: Array[Int]): Int = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn max_score_words(words: Vec<String>, letters: Vec<char>, score: Vec<i32>) -> i32 {\n        \n    }\n}",
    "racket": "(define/contract (max-score-words words letters score)\n  (-> (listof string?) (listof char?) (listof exact-integer?) exact-integer?)\n  )",
    "erlang": "-spec max_score_words(Words :: [unicode:unicode_binary()], Letters :: [char()], Score :: [integer()]) -> integer().\nmax_score_words(Words, Letters, Score) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec max_score_words(words :: [String.t], letters :: [char], score :: [integer]) :: integer\n  def max_score_words(words, letters, score) do\n    \n  end\nend"
  },
  "solution": "[TOC]\n\n## Solution\n\n--- \n\n### Overview\n\nGiven a list of `words`, we need to find the maximum subset score using the given set of `letters`. Each letter has a score tied to it, which is provided in `score`. Each entry in `words` can only be used once, although the same word can occur as multiple entries. Each character in `letters` can be used at most once.\n\nThis problem tests your ability to implement an algorithm that efficiently maintains a maximum score over all subsets of a set of words. The two main ways to do this are using an iterative loop and a recursive search method.\n\n---\n\n### Approach 1: Iterative Loop for Every Subset\n\n\n#### Intuition\n\nSince the size of the input is very small, a brute-force solution is feasible. We can check all subsets of `words` and return the largest score among subsets that can be constructed with the given `letters`.\n\nLet's create a frequency array `freq` that stores the frequency of each letter in `letters`, which is needed to track how many copies of each letter we can use. For every subset of words, let's also create a `subsetLetters` array that stores the frequency of each letter of every word in the subset. The `subsetLetters` array is used to track the current state of words and how many copies of each letter are needed to build the current subset. Specifically, this subset can be constructed if and only if `freq[c] <= subsetLetters[c]` for all letters `c`. If a subset is valid, its score is equal to the sum of `subsetLetters[c] * score[c]` for all `c`.\n\nNow that we have a strategy to check the validity and score of a subset, we need to generate and check the subsets. For this approach, we'll use a for loop that iterates through every integer `mask` whose binary representation corresponds to a subset of `words`. The $i^{\\texttt{th}}$ bit in `mask` equals `1` if this subset contains `words[i]`, and `0` otherwise.\n\nExample binary representations of subsets:\n\n\n![figA](../Figures/1255/1255_words_example_updated.png)\n\n#### Algorithm\n\n1. Generate a frequency array where `freq[c]` is the number of times letter `c` appears in `letters`.\n2. Initialize `maxScore` to store the largest score among valid subsets.\n3. Use a for loop that goes from $0$ (inclusive) to $2^W$ (exclusive) where $W$ is the length of `words` to iterate over every subset using masks. For each mask, word $i$ is in this subset if the $i^{\\texttt{th}}$ bit is set in the current mask.\n4. For each word in the current subset, increment `subsetLetters[c]` for each letter `c` in the word.\n5. Declare a helper function, `subsetScore,` that checks if the subset can be built out of the given letters and calculates the score:\n    - Initialize a variable `totalScore` to `0`.\n    - For each character in the alphabet, compute the score of this subset by adding `score[c]` for every occurrence of `c` in this subset, and add it to `totalScore`.  If `freq[c] < subsetLetters[c]` holds true for any letter `c`, then return $0$, as this subset is impossible to construct with the given letters.\n    - Return `totalScore`.\n6. If `maxScore` is less than the result of `subsetScore`, update `maxScore`.\n7. Return `maxScore` after all subsets are checked.\n\n#### Implementation#### Complexity Analysis\n\nLet $W$ be the length of `words`, $L$ be the maximum length of any word in `words`, and $A$ be the size of the alphabet (in this case, $A = 26$).\n\n* Time complexity: $O(2^W \\cdot (WL + A))$.\n\nFor each subset, we need to iterate through every string in this subset, which takes $WL$ time. Additionally, $A$ operations are needed to populate the `subsetLetters` array for each subset. \n\nWe have two choices for each word: it belongs in the subset, or it doesn't. This gives a total of $2^W$ possible subsets for $W$ words. Therefore, this yields a complexity of $O(2^W(WL + A))$.\n\n* Space complexity: $O(A)$.\n\nIn this implementation, only two arrays of length $A$ are created: the `freq` array, which stores the frequencies of characters in `letters`, and the `subsetLetters` array, which stores letter frequencies for the current subset.\n\n---\n\n### Approach 2: Backtracking\n\n\n#### Intuition\n\nSuppose the set of usable letters in a given input does not contain the letter \"d\", and the set of words is `[\"abcd\", \"acc\", \"abb\", \"bc\"]`. Note that any subset containing the word \"abcd\" is always invalid, because the word contains letter \"d\". The iterative approach will continue to check every subset that contains \"abcd\", which results in a considerable amount of unnecessary computation. What if we had a way to prune all subsets containing the word \"abcd\"? This is where a recursive solution comes into play.\n\nRather than iteratively checking every subset of words, we can use a recursive function to choose whether we include or exclude the current word in a candidate subset. If we pass the `subsetLetters` array as a parameter throughout every recursive call, after the addition of a word to a subset, we can check if there is a letter `c` where `subsetLetters[c]` exceeds `freq[c]` (see the `isValidWord` method). Once a recursive call terminates, we can roll back any changes made by the current recursive call to extensively search for all possibilities.\n\nThis approach is called backtracking, which is a search strategy that visits states and rolls back changes to return to a previous state. Doing so allows you to explore all branches from one state. For more details, see our [backtracking explore card](https://leetcode.com/explore/learn/card/recursion-ii/472/backtracking/).\n\nThe base case is when all words have been considered for the subset, which is handled by comparing `maxScore` with `totalScore` and updating `maxScore` if `totalScore` is larger. The recursive case considers two choices: adding the $i^{\\texttt{th}}$ word or not adding the $i^{\\texttt{th}}$ word. This generates the subsets that will eventually either reach the base case or get pruned because that subset is not valid.\n\n\nOne notable merit of this backtracking solution lies in the pruning of bad subsets. If there is a set of subsets that share the same words that break the limits imposed by the given letters, the recursive algorithm can choose not to continue the search down this branch. For example, if the first word cannot be constructed, this recursive algorithm would immediately cut out any subset containing the first word, whereas an iterative solution would still check every subset that contains the first word.\n\n#### Algorithm\n\n1. Generate a frequency array where `freq[c]` is the number of times letter `c` appears in `letters`.\n2. Initialize `maxScore` to store the largest score among valid subsets.\n3. Call a recursive subroutine `check` that passes `w` (the index of the current word), `words`, `score`, `subsetLetters`, and `totalScore` (the sum of word scores in the subset) as parameters. Steps 4-10 describe the `check` method.\n4. If `w` equals $-1$, all words have been considered, and we should update `maxScore` to `totalScore` if `maxScore` is less than `totalScore`.\n5. Otherwise, we need to consider two possible recursive calls: one that adds `words[w]` to the subset, and one that doesn't.\n6. To account for not adding a word, call `check(w - 1, words, score, subsetLetters, totalScore)`.\n7. To add `words[w]` to the subset, update `subsetLetters` and `totalScore` to include the word.\n8. If the addition of `words[w]` does not violate letter limits imposed by `freq`, make the recursive call `check(w - 1, words, score, subsetLetters, totalScore)`. To check for validity, we define the `isValidWord` method as follows:\n    - For each character in the alphabet, check if `freq[c] < subsetLetters[c]`. If there exists such `c`, return `false`.\n    - Return `true` if the subset can be built out of the given letters.\n9. Roll back the changes to `subsetLetters` and `totalScore` immediately after making this recursive call.\n10. Call `check(W - 1, words, score, subsetLetters, 0)`, where `subsetLetters` is initially all zeros.\n11. Return `maxScore` as the result.\n\n#### Implementation#### Complexity Analysis\n\nLet $W$ be the length of `words`, $L$ be the maximum length of any word in `words`, and $A$ be the size of the alphabet (in this case, $A = 26$).\n\n* Time complexity: $O(2^W \\cdot (L + A))$.\n\nThere are a total of $2^W$ subsets that could be checked, and the `check` function could be called for each one, or up to $2^W$ times. Inside the `check` function, we iterate through the current word's letters to determine if the subset it currently belongs in is valid, which takes $L$ time. Additionally, the `isValidWord` function takes $A$ time because we compare the count of each letter in the alphabet with the frequency. This yields a complexity of $O(2^W(L + A)$.\n\nWhile the worst-case runtime of backtracking matches the worst-case runtime of the iterative solution, in practice, the backtracking solution will prune many subset possibilities that break the limits imposed by the given letters and will run significantly faster than the iterative solution.\n\n* Space complexity: $O(A + W)$.\n\nIn this implementation, only two arrays of length $A$ are created: the `freq` array that stores the frequencies of characters in `letters`, and the `subsetLetters` array that stores letter frequencies for the current subset. Additionally, the `check` method is called with and without each element in `words`, which incurs $O(W)$ space on the recursive call stack."
}