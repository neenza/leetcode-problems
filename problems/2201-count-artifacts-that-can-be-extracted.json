{
  "title": "Count Artifacts That Can Be Extracted",
  "problem_id": "1312",
  "frontend_id": "2201",
  "difficulty": "Medium",
  "problem_slug": "count-artifacts-that-can-be-extracted",
  "topics": [
    "Array",
    "Hash Table",
    "Simulation"
  ],
  "description": "There is an n x n 0-indexed grid with some artifacts buried in it. You are given the integer n and a 0-indexed 2D integer array artifacts describing the positions of the rectangular artifacts where artifacts[i] = [r1i, c1i, r2i, c2i] denotes that the ith artifact is buried in the subgrid where:\nYou will excavate some cells of the grid and remove all the mud from them. If the cell has a part of an artifact buried underneath, it will be uncovered. If all the parts of an artifact are uncovered, you can extract it.\nGiven a 0-indexed 2D integer array dig where dig[i] = [ri, ci] indicates that you will excavate the cell (ri, ci), return the number of artifacts that you can extract.\nThe test cases are generated such that:\nExample 1:\nExample 2:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: n = 2, artifacts = [[0,0,0,0],[0,1,1,1]], dig = [[0,0],[0,1]]\nOutput: 1\nExplanation: \nThe different colors represent different artifacts. Excavated cells are labeled with a 'D' in the grid.\nThere is 1 artifact that can be extracted, namely the red artifact.\nThe blue artifact has one part in cell (1,1) which remains uncovered, so we cannot extract it.\nThus, we return 1.",
      "images": [
        "https://assets.leetcode.com/uploads/2019/09/16/untitled-diagram.jpg"
      ]
    },
    {
      "example_num": 2,
      "example_text": "Input: n = 2, artifacts = [[0,0,0,0],[0,1,1,1]], dig = [[0,0],[0,1],[1,1]]\nOutput: 2\nExplanation: Both the red and blue artifacts have all parts uncovered (labeled with a 'D') and can be extracted, so we return 2.",
      "images": [
        "https://assets.leetcode.com/uploads/2019/09/16/untitled-diagram-1.jpg"
      ]
    }
  ],
  "constraints": [
    "1 <= n <= 1000",
    "1 <= artifacts.length, dig.length <= min(n2, 105)",
    "artifacts[i].length == 4",
    "dig[i].length == 2",
    "0 <= r1i, c1i, r2i, c2i, ri, ci <= n - 1",
    "r1i <= r2i",
    "c1i <= c2i",
    "No two artifacts will overlap.",
    "The number of cells covered by an artifact is at most 4.",
    "The entries of dig are unique."
  ],
  "follow_ups": [],
  "hints": [
    "Check if each coordinate of each artifact has been excavated. How can we do this quickly without iterating over the dig array every time?",
    "Consider marking all excavated cells in a 2D boolean array."
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    int digArtifacts(int n, vector<vector<int>>& artifacts, vector<vector<int>>& dig) {\n        \n    }\n};",
    "java": "class Solution {\n    public int digArtifacts(int n, int[][] artifacts, int[][] dig) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def digArtifacts(self, n, artifacts, dig):\n        \"\"\"\n        :type n: int\n        :type artifacts: List[List[int]]\n        :type dig: List[List[int]]\n        :rtype: int\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def digArtifacts(self, n: int, artifacts: List[List[int]], dig: List[List[int]]) -> int:\n        ",
    "c": "int digArtifacts(int n, int** artifacts, int artifactsSize, int* artifactsColSize, int** dig, int digSize, int* digColSize) {\n    \n}",
    "csharp": "public class Solution {\n    public int DigArtifacts(int n, int[][] artifacts, int[][] dig) {\n        \n    }\n}",
    "javascript": "/**\n * @param {number} n\n * @param {number[][]} artifacts\n * @param {number[][]} dig\n * @return {number}\n */\nvar digArtifacts = function(n, artifacts, dig) {\n    \n};",
    "typescript": "function digArtifacts(n: number, artifacts: number[][], dig: number[][]): number {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param Integer $n\n     * @param Integer[][] $artifacts\n     * @param Integer[][] $dig\n     * @return Integer\n     */\n    function digArtifacts($n, $artifacts, $dig) {\n        \n    }\n}",
    "swift": "class Solution {\n    func digArtifacts(_ n: Int, _ artifacts: [[Int]], _ dig: [[Int]]) -> Int {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun digArtifacts(n: Int, artifacts: Array<IntArray>, dig: Array<IntArray>): Int {\n        \n    }\n}",
    "dart": "class Solution {\n  int digArtifacts(int n, List<List<int>> artifacts, List<List<int>> dig) {\n    \n  }\n}",
    "golang": "func digArtifacts(n int, artifacts [][]int, dig [][]int) int {\n    \n}",
    "ruby": "# @param {Integer} n\n# @param {Integer[][]} artifacts\n# @param {Integer[][]} dig\n# @return {Integer}\ndef dig_artifacts(n, artifacts, dig)\n    \nend",
    "scala": "object Solution {\n    def digArtifacts(n: Int, artifacts: Array[Array[Int]], dig: Array[Array[Int]]): Int = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn dig_artifacts(n: i32, artifacts: Vec<Vec<i32>>, dig: Vec<Vec<i32>>) -> i32 {\n        \n    }\n}",
    "racket": "(define/contract (dig-artifacts n artifacts dig)\n  (-> exact-integer? (listof (listof exact-integer?)) (listof (listof exact-integer?)) exact-integer?)\n  )",
    "erlang": "-spec dig_artifacts(N :: integer(), Artifacts :: [[integer()]], Dig :: [[integer()]]) -> integer().\ndig_artifacts(N, Artifacts, Dig) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec dig_artifacts(n :: integer, artifacts :: [[integer]], dig :: [[integer]]) :: integer\n  def dig_artifacts(n, artifacts, dig) do\n    \n  end\nend"
  }
}