{
  "title": "Count Good Meals",
  "problem_id": "1830",
  "frontend_id": "1711",
  "difficulty": "Medium",
  "problem_slug": "count-good-meals",
  "topics": [
    "Array",
    "Hash Table"
  ],
  "description": "A good meal is a meal that contains exactly two different food items with a sum of deliciousness equal to a power of two.\nYou can pick any two different foods to make a good meal.\nGiven an array of integers deliciousness where deliciousness[i] is the deliciousness of the i​​​​​​th​​​​​​​​ item of food, return the number of different good meals you can make from this list modulo 109 + 7.\nNote that items with different indices are considered different even if they have the same deliciousness value.\nExample 1:\nExample 2:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: deliciousness = [1,3,5,7,9]\nOutput: 4\nExplanation: The good meals are (1,3), (1,7), (3,5) and, (7,9).\nTheir respective sums are 4, 8, 8, and 16, all of which are powers of 2.",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input: deliciousness = [1,1,1,3,3,3,7]\nOutput: 15\nExplanation: The good meals are (1,1) with 3 ways, (1,3) with 9 ways, and (1,7) with 3 ways.",
      "images": []
    }
  ],
  "constraints": [
    "1 <= deliciousness.length <= 105",
    "0 <= deliciousness[i] <= 220"
  ],
  "follow_ups": [],
  "hints": [
    "Note that the number of powers of 2 is at most 21 so this turns the problem to a classic find the number of pairs that sum to a certain value but for 21 values",
    "You need to use something fasters than the NlogN approach since there is already the log of iterating over the powers so one idea is two pointers"
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    int countPairs(vector<int>& deliciousness) {\n        \n    }\n};",
    "java": "class Solution {\n    public int countPairs(int[] deliciousness) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def countPairs(self, deliciousness):\n        \"\"\"\n        :type deliciousness: List[int]\n        :rtype: int\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def countPairs(self, deliciousness: List[int]) -> int:\n        ",
    "c": "int countPairs(int* deliciousness, int deliciousnessSize) {\n    \n}",
    "csharp": "public class Solution {\n    public int CountPairs(int[] deliciousness) {\n        \n    }\n}",
    "javascript": "/**\n * @param {number[]} deliciousness\n * @return {number}\n */\nvar countPairs = function(deliciousness) {\n    \n};",
    "typescript": "function countPairs(deliciousness: number[]): number {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param Integer[] $deliciousness\n     * @return Integer\n     */\n    function countPairs($deliciousness) {\n        \n    }\n}",
    "swift": "class Solution {\n    func countPairs(_ deliciousness: [Int]) -> Int {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun countPairs(deliciousness: IntArray): Int {\n        \n    }\n}",
    "dart": "class Solution {\n  int countPairs(List<int> deliciousness) {\n    \n  }\n}",
    "golang": "func countPairs(deliciousness []int) int {\n    \n}",
    "ruby": "# @param {Integer[]} deliciousness\n# @return {Integer}\ndef count_pairs(deliciousness)\n    \nend",
    "scala": "object Solution {\n    def countPairs(deliciousness: Array[Int]): Int = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn count_pairs(deliciousness: Vec<i32>) -> i32 {\n        \n    }\n}",
    "racket": "(define/contract (count-pairs deliciousness)\n  (-> (listof exact-integer?) exact-integer?)\n  )",
    "erlang": "-spec count_pairs(Deliciousness :: [integer()]) -> integer().\ncount_pairs(Deliciousness) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec count_pairs(deliciousness :: [integer]) :: integer\n  def count_pairs(deliciousness) do\n    \n  end\nend"
  }
}