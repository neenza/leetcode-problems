{
  "title": "Verbal Arithmetic Puzzle",
  "problem_id": "1429",
  "frontend_id": "1307",
  "difficulty": "Hard",
  "problem_slug": "verbal-arithmetic-puzzle",
  "topics": [
    "Array",
    "Math",
    "String",
    "Backtracking"
  ],
  "description": "Given an equation, represented by words on the left side and the result on the right side.\nYou need to check if the equation is solvable under the following rules:\nReturn true if the equation is solvable, otherwise return false.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: words = [\"SEND\",\"MORE\"], result = \"MONEY\"\nOutput: true\nExplanation: Map 'S'-> 9, 'E'->5, 'N'->6, 'D'->7, 'M'->1, 'O'->0, 'R'->8, 'Y'->'2'\nSuch that: \"SEND\" + \"MORE\" = \"MONEY\" ,  9567 + 1085 = 10652",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input: words = [\"SIX\",\"SEVEN\",\"SEVEN\"], result = \"TWENTY\"\nOutput: true\nExplanation: Map 'S'-> 6, 'I'->5, 'X'->0, 'E'->8, 'V'->7, 'N'->2, 'T'->1, 'W'->'3', 'Y'->4\nSuch that: \"SIX\" + \"SEVEN\" + \"SEVEN\" = \"TWENTY\" ,  650 + 68782 + 68782 = 138214",
      "images": []
    },
    {
      "example_num": 3,
      "example_text": "Input: words = [\"LEET\",\"CODE\"], result = \"POINT\"\nOutput: false\nExplanation: There is no possible mapping to satisfy the equation, so we return false.\nNote that two different characters cannot map to the same digit.",
      "images": []
    }
  ],
  "constraints": [
    "2 <= words.length <= 5",
    "1 <= words[i].length, result.length <= 7",
    "words[i], result contain only uppercase English letters.",
    "The number of different characters used in the expression is at most 10."
  ],
  "follow_ups": [],
  "hints": [
    "Use Backtracking and pruning to solve this problem.",
    "If you set the values of some digits (from right to left), the other digits will be constrained."
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    bool isSolvable(vector<string>& words, string result) {\n        \n    }\n};",
    "java": "class Solution {\n    public boolean isSolvable(String[] words, String result) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def isSolvable(self, words, result):\n        \"\"\"\n        :type words: List[str]\n        :type result: str\n        :rtype: bool\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def isSolvable(self, words: List[str], result: str) -> bool:\n        ",
    "c": "bool isSolvable(char** words, int wordsSize, char* result) {\n    \n}",
    "csharp": "public class Solution {\n    public bool IsSolvable(string[] words, string result) {\n        \n    }\n}",
    "javascript": "/**\n * @param {string[]} words\n * @param {string} result\n * @return {boolean}\n */\nvar isSolvable = function(words, result) {\n    \n};",
    "typescript": "function isSolvable(words: string[], result: string): boolean {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param String[] $words\n     * @param String $result\n     * @return Boolean\n     */\n    function isSolvable($words, $result) {\n        \n    }\n}",
    "swift": "class Solution {\n    func isSolvable(_ words: [String], _ result: String) -> Bool {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun isSolvable(words: Array<String>, result: String): Boolean {\n        \n    }\n}",
    "dart": "class Solution {\n  bool isSolvable(List<String> words, String result) {\n    \n  }\n}",
    "golang": "func isSolvable(words []string, result string) bool {\n    \n}",
    "ruby": "# @param {String[]} words\n# @param {String} result\n# @return {Boolean}\ndef is_solvable(words, result)\n    \nend",
    "scala": "object Solution {\n    def isSolvable(words: Array[String], result: String): Boolean = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn is_solvable(words: Vec<String>, result: String) -> bool {\n        \n    }\n}",
    "racket": "(define/contract (is-solvable words result)\n  (-> (listof string?) string? boolean?)\n  )",
    "erlang": "-spec is_solvable(Words :: [unicode:unicode_binary()], Result :: unicode:unicode_binary()) -> boolean().\nis_solvable(Words, Result) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec is_solvable(words :: [String.t], result :: String.t) :: boolean\n  def is_solvable(words, result) do\n    \n  end\nend"
  }
}