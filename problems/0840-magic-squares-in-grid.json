{
  "title": "Magic Squares In Grid",
  "problem_id": "870",
  "frontend_id": "840",
  "difficulty": "Medium",
  "problem_slug": "magic-squares-in-grid",
  "topics": [
    "Array",
    "Hash Table",
    "Math",
    "Matrix"
  ],
  "description": "A 3 x 3 magic square is a 3 x 3 grid filled with distinct numbers from 1 to 9 such that each row, column, and both diagonals all have the same sum.\nGiven a row x col grid of integers, how many 3 x 3 magic square subgrids are there?\nNote: while a magic square can only contain numbers from 1 to 9, grid may contain numbers up to 15.\nExample 1:\nExample 2:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: grid = [[4,3,8,4],[9,5,1,9],[2,7,6,2]]\nOutput: 1\nExplanation: \nThe following subgrid is a 3 x 3 magic square:\n\nwhile this one is not:\n\nIn total, there is only one magic square inside the given grid.",
      "images": [
        "https://assets.leetcode.com/uploads/2020/09/11/magic_main.jpg"
      ]
    },
    {
      "example_num": 2,
      "example_text": "Input: grid = [[8]]\nOutput: 0",
      "images": [
        "https://assets.leetcode.com/uploads/2020/09/11/magic_invalid.jpg"
      ]
    }
  ],
  "constraints": [
    "row == grid.length",
    "col == grid[i].length",
    "1 <= row, col <= 10",
    "0 <= grid[i][j] <= 15"
  ],
  "follow_ups": [],
  "hints": [],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    int numMagicSquaresInside(vector<vector<int>>& grid) {\n        \n    }\n};",
    "java": "class Solution {\n    public int numMagicSquaresInside(int[][] grid) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def numMagicSquaresInside(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def numMagicSquaresInside(self, grid: List[List[int]]) -> int:\n        ",
    "c": "int numMagicSquaresInside(int** grid, int gridSize, int* gridColSize) {\n    \n}",
    "csharp": "public class Solution {\n    public int NumMagicSquaresInside(int[][] grid) {\n        \n    }\n}",
    "javascript": "/**\n * @param {number[][]} grid\n * @return {number}\n */\nvar numMagicSquaresInside = function(grid) {\n    \n};",
    "typescript": "function numMagicSquaresInside(grid: number[][]): number {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param Integer[][] $grid\n     * @return Integer\n     */\n    function numMagicSquaresInside($grid) {\n        \n    }\n}",
    "swift": "class Solution {\n    func numMagicSquaresInside(_ grid: [[Int]]) -> Int {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun numMagicSquaresInside(grid: Array<IntArray>): Int {\n        \n    }\n}",
    "dart": "class Solution {\n  int numMagicSquaresInside(List<List<int>> grid) {\n    \n  }\n}",
    "golang": "func numMagicSquaresInside(grid [][]int) int {\n    \n}",
    "ruby": "# @param {Integer[][]} grid\n# @return {Integer}\ndef num_magic_squares_inside(grid)\n    \nend",
    "scala": "object Solution {\n    def numMagicSquaresInside(grid: Array[Array[Int]]): Int = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn num_magic_squares_inside(grid: Vec<Vec<i32>>) -> i32 {\n        \n    }\n}",
    "racket": "(define/contract (num-magic-squares-inside grid)\n  (-> (listof (listof exact-integer?)) exact-integer?)\n  )",
    "erlang": "-spec num_magic_squares_inside(Grid :: [[integer()]]) -> integer().\nnum_magic_squares_inside(Grid) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec num_magic_squares_inside(grid :: [[integer]]) :: integer\n  def num_magic_squares_inside(grid) do\n    \n  end\nend"
  },
  "solution": "[TOC]\n\n## Solution\n\n---\n\n### Overview\n\nLet's start by clarifying some common points of confusion over this problem description. Note that:  \n1. The given grid may contain integers above `9`, but a magic grid may only contain integers `1` to `9`. \n2. The given grid may contain duplicate values, but every value in a magic grid must be distinct. In other words, no duplicate values are allowed. \n\nWith the given `grid`, you want to find the number of subarrays in `grid` that are magic squares. A `3 x 3` magic square is defined as a `3 x 3` array containing distinct integers from `1` to `9` whose rows, columns, and diagonals all have the same sum.\n\n---\n\n### Approach 1: Manual Scan\n\n### Intuition\n\nOne brute-force approach is to consider each `3 x 3` subarray of the `grid` and manually check if each subarray satisfies the definition of a `3 x 3` magic square.  \n\nWe iterate through the entire grid, examining each possible `3 x 3` subarray. For each subarray, we'll check each element to make sure that it is within the allowed range and that it isn't a duplicate. Then, we verify that the sums of all three rows, three columns, and the two diagonals are equal. If all these conditions are met, then the subarray is a magic square.\n\n### Algorithm\n\n1. Initialize `ans` to `0`, representing the total count of magic squares. \n2. Define a helper function `isMagicSquare(grid, row, col)` that determines if the subarray of `grid` starting at index `(row, col)` is a magic square:\n    * For each element `num` of the subarray:\n        * If it falls outside the allowed range (`num > 9` or `num < 1`), return `false`\n        * If we have seen `num` in the previous iteration, that means the values aren't distinct, so return `false`\n    * Initialize `diagonal1` and `diagonal2` as the sums for the 2 diagonals.\n    * If `diagonal1 != diagonal2`, return `false`\n    * Initialize `row1`, `row2`, and `row3` as the sums for the 3 rows.\n    * If any of the row sums don't equal `diagonal1`, then there are different sums for the rows and columns, so return `false` \n    * Initialize `col1`, `col2`, and `col3` as the sums for the 3 columns.\n    * Similarly, if any of the column sums don't equal `diagonal1`, return `false`\n3. For each index `(row, col)` of `grid`:\n    * If `isSquareMagic(grid, row col)` is `true`, then increment `ans`.\n4. Return `ans`.\n\n### Implementation### Time Complexity\n\nLet `M` and `N` be the number of rows and columns of `grid`, respectively.\n\n* Time Complexity: $O(M \\cdot N)$\n\n    The number of `3 x 3` subarrays to check for `grid` is linearly proportional to the size of `grid`, which is $M \\cdot N$. For each `3 x 3` subarray of `grid`, we iterate through all its values to check that they are distinct and within range, which takes constant time. We also perform the sum calculations that involve additional array indexing into a `grid`, which also takes constant time. Thus, the total time complexity is $O(M \\cdot N)$.\n\n* Space Complexity: $O(1)$\n\n    `isMagicSquare` uses an array to keep track of which values the current subarray of `grid` contains. However, this array has a constant size of $10$, so the space complexity is $O(1)$\n\n\n### Approach 2: Check Unique Properties of Magic Square\n\n### Intuition\n\nIn Approach 1, we determined whether each subarray of `grid` is a magic square by explicitly checking each criterion of the magic square definition given in the problem statement.\n\nWe can dive deeper into the definition of a `3 x 3` magic square to find additional properties that can help us simplify the logic for determining if a subarray is a magic square:\n\n**Constant Sum**\n\nBy definition, every row has the same sum $S$. Furthermore, the definition states that a magic grid **can** only contain values `1` to `9` and each value must be distinct. Since every `3 x 3` magic grid will contain exactly `9` squares, we can see that every magic grid **will** have exactly one of each allowed value. Thus, we can see that the total sum of an entire `3 x 3` magic square is $1 + 2 + 3 + ... + 9 = 45$.\n\nBecause each magic square consists of $3$ rows, we can say that $3S = 45$ and thus $S = 15$. This means that every row sum, and in turn every column sum and diagonal sum, equals $15$.\n\n**Limited Number of Arrangements** \n\nIf every row, column, and diagonal has to sum up to $15$ and can only contain distinct values from $1$ to $9$, then there are only a limited number of arrangements to form a magic square. Listed below are all possible combinations of 3-part sums that add up to $15$, where each value is between $1$ and $9$:\n\n$1 + 5 + 9$\n\n$1 + 6 + 8$\n\n$2 + 4 + 9$\n\n$2 + 5 + 8$\n\n$2 + 6 + 7$\n\n$3 + 4 + 8$\n\n$3 + 5 + 7$\n\n$4 + 5 + 6$\n\nWe can see that there are 8 different ways, which map directly to the 8 3-part sums in the magic square (3 rows + 3 columns + 2 diagonals = 8 total sums). We can explore further constraints on arranging the possible magic squares.\n\n**Constraint 1 - Middle element** \n\n5 appears in exactly 4 of these sums. The only element that would appear in 4 sums is the middle element of the magic square. Specifically, the middle element appears in the sums for the middle row, the middle column, and both diagonals. Thus, we know that for a subarray to be a magic square, its middle element has to be 5.\n\n![Middle element 5 appearing in 4 sums](../Figures/840/5_as_middle_element.png)\n\n**Constraint 2 - Even numbers**\n\n Moreover, the even numbers (2, 4, 6, and 8) each appear in exactly 3 of the sums. Only the corner elements of the grid can appear in exactly 3 sums. Specifically, they appear in the sum for one row, one column, and one diagonal. Thus, we know the corner elements have to be even numbers.\n\n![Even numbers in the corners](../Figures/840/even_numbers.png)\n\n**Constraint 3 - Odd numbers** \n\nFinally, the only numbers remaining are the odd numbers (1, 3, 7, and 9). They each appear in exactly 2 of the sums. The remaining elements on the edges of the grid also appear in exactly 2 sums: the sums for one row and one column. Thus, we know the remaining edge elements have to be odd numbers.\n\n![Odd numbers in the remaining edges](../Figures/840/odd_numbers.png)\n\nUsing these constraints, we can more easily generate all the possible arrangements for a `3 x 3` magic square:\n\n![All possible magic squares](../Figures/840/all_possible_squares.png)\n\nWe observe that for all possible arrangements, the elements around the border (the even/odd numbers from constraints 2/3 above) all follow the ordered sequence \n\n$2, 9, 4, 3, 8, 1, 6, 7$\n\neither moving clockwise or counter-clockwise around the border, starting at a corner element.\n\nThus, we know that a subarray is a magic square if and only if it satisfies the 2 following properties:\n\n1. The middle element is 5\n2. The bordering elements follow the $2, 9, 4, 3, 8, 1, 6, 7$ sequence, starting at some corner element and going either clockwise or counter-clockwise.\n\n\n### Algorithm \n\n1. Initialize `ans` to `0`, representing the total count of magic squares. \n2. Define a helper function `isMagicSquare(grid, row, col)` that determines if the subarray of `grid` starting at index `(row, col)` is a magic square:\n    * Initialize the magic sequence `sequence` to `2943816729438167`.\n    * Also initialize the reversed sequence `reversedSequence` to `7618349276183492` to account for the opposite direction. \n    * Initialize a string `S`.\n    * Starting from the first element `grid[row][col]`, append all bordering elements in clockwise order to `S`.\n    * If `S` is contained in either `sequence` or `reversedSequence`, the first element is even, and the middle element is $5$, then the subarray is a magic square so return `true`\n    * Otherwise, return `false`\n3. For each index `(row, col)` of `grid`:\n    * If `isMagicSquare(grid, row col)` is `true`, then increment `ans`.\n4. Return `ans`.\n\n### Implementation### Time Complexity\n\nLet `M` and `N` be the number of rows and columns of `grid`, respectively.\n\n* Time Complexity: $O(M \\cdot N)$\n\n    Similar to Approach 1, the pattern checking in `isMagicSquare` is done in constant time. This function is called $O(M \\cdot N)$ times, so the total time complexity is $O(M \\cdot N)$.\n\n* Space Complexity: $O(1)$\n\n    The only auxiliary data structure used is a string storing our bordering pattern, which is a constant size. Thus, the space complexity is $O(1)$."
}