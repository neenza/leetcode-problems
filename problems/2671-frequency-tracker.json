{
  "title": "Frequency Tracker",
  "problem_id": "2778",
  "frontend_id": "2671",
  "difficulty": "Medium",
  "problem_slug": "frequency-tracker",
  "topics": [
    "Hash Table",
    "Design"
  ],
  "description": "Design a data structure that keeps track of the values in it and answers some queries regarding their frequencies.\nImplement the FrequencyTracker class.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input\n[\"FrequencyTracker\", \"add\", \"add\", \"hasFrequency\"]\n[[], [3], [3], [2]]\nOutput\n[null, null, null, true]\n\nExplanation\nFrequencyTracker frequencyTracker = new FrequencyTracker();\nfrequencyTracker.add(3); // The data structure now contains [3]\nfrequencyTracker.add(3); // The data structure now contains [3, 3]\nfrequencyTracker.hasFrequency(2); // Returns true, because 3 occurs twice",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input\n[\"FrequencyTracker\", \"add\", \"deleteOne\", \"hasFrequency\"]\n[[], [1], [1], [1]]\nOutput\n[null, null, null, false]\n\nExplanation\nFrequencyTracker frequencyTracker = new FrequencyTracker();\nfrequencyTracker.add(1); // The data structure now contains [1]\nfrequencyTracker.deleteOne(1); // The data structure becomes empty []\nfrequencyTracker.hasFrequency(1); // Returns false, because the data structure is empty",
      "images": []
    },
    {
      "example_num": 3,
      "example_text": "Input\n[\"FrequencyTracker\", \"hasFrequency\", \"add\", \"hasFrequency\"]\n[[], [2], [3], [1]]\nOutput\n[null, false, null, true]\n\nExplanation\nFrequencyTracker frequencyTracker = new FrequencyTracker();\nfrequencyTracker.hasFrequency(2); // Returns false, because the data structure is empty\nfrequencyTracker.add(3); // The data structure now contains [3]\nfrequencyTracker.hasFrequency(1); // Returns true, because 3 occurs once",
      "images": []
    }
  ],
  "constraints": [
    "1 <= number <= 105",
    "1 <= frequency <= 105",
    "At most, 2 * 105 calls will be made to add, deleteOne, and hasFrequency in total."
  ],
  "follow_ups": [],
  "hints": [
    "Put all the numbers in a hash map (or just an integer array given the number range is small) to maintain each number’s frequency dynamically.",
    "Put each frequency in another hash map (or just an integer array given the range is small, note there are only 200000 calls in total) to maintain each kind of frequency dynamically.",
    "Keep the 2 hash maps in sync."
  ],
  "code_snippets": {
    "cpp": "class FrequencyTracker {\npublic:\n    FrequencyTracker() {\n        \n    }\n    \n    void add(int number) {\n        \n    }\n    \n    void deleteOne(int number) {\n        \n    }\n    \n    bool hasFrequency(int frequency) {\n        \n    }\n};\n\n/**\n * Your FrequencyTracker object will be instantiated and called as such:\n * FrequencyTracker* obj = new FrequencyTracker();\n * obj->add(number);\n * obj->deleteOne(number);\n * bool param_3 = obj->hasFrequency(frequency);\n */",
    "java": "class FrequencyTracker {\n\n    public FrequencyTracker() {\n        \n    }\n    \n    public void add(int number) {\n        \n    }\n    \n    public void deleteOne(int number) {\n        \n    }\n    \n    public boolean hasFrequency(int frequency) {\n        \n    }\n}\n\n/**\n * Your FrequencyTracker object will be instantiated and called as such:\n * FrequencyTracker obj = new FrequencyTracker();\n * obj.add(number);\n * obj.deleteOne(number);\n * boolean param_3 = obj.hasFrequency(frequency);\n */",
    "python": "class FrequencyTracker(object):\n\n    def __init__(self):\n        \n\n    def add(self, number):\n        \"\"\"\n        :type number: int\n        :rtype: None\n        \"\"\"\n        \n\n    def deleteOne(self, number):\n        \"\"\"\n        :type number: int\n        :rtype: None\n        \"\"\"\n        \n\n    def hasFrequency(self, frequency):\n        \"\"\"\n        :type frequency: int\n        :rtype: bool\n        \"\"\"\n        \n\n\n# Your FrequencyTracker object will be instantiated and called as such:\n# obj = FrequencyTracker()\n# obj.add(number)\n# obj.deleteOne(number)\n# param_3 = obj.hasFrequency(frequency)",
    "python3": "class FrequencyTracker:\n\n    def __init__(self):\n        \n\n    def add(self, number: int) -> None:\n        \n\n    def deleteOne(self, number: int) -> None:\n        \n\n    def hasFrequency(self, frequency: int) -> bool:\n        \n\n\n# Your FrequencyTracker object will be instantiated and called as such:\n# obj = FrequencyTracker()\n# obj.add(number)\n# obj.deleteOne(number)\n# param_3 = obj.hasFrequency(frequency)",
    "c": "\n\n\ntypedef struct {\n    \n} FrequencyTracker;\n\n\nFrequencyTracker* frequencyTrackerCreate() {\n    \n}\n\nvoid frequencyTrackerAdd(FrequencyTracker* obj, int number) {\n    \n}\n\nvoid frequencyTrackerDeleteOne(FrequencyTracker* obj, int number) {\n    \n}\n\nbool frequencyTrackerHasFrequency(FrequencyTracker* obj, int frequency) {\n    \n}\n\nvoid frequencyTrackerFree(FrequencyTracker* obj) {\n    \n}\n\n/**\n * Your FrequencyTracker struct will be instantiated and called as such:\n * FrequencyTracker* obj = frequencyTrackerCreate();\n * frequencyTrackerAdd(obj, number);\n \n * frequencyTrackerDeleteOne(obj, number);\n \n * bool param_3 = frequencyTrackerHasFrequency(obj, frequency);\n \n * frequencyTrackerFree(obj);\n*/",
    "csharp": "public class FrequencyTracker {\n\n    public FrequencyTracker() {\n        \n    }\n    \n    public void Add(int number) {\n        \n    }\n    \n    public void DeleteOne(int number) {\n        \n    }\n    \n    public bool HasFrequency(int frequency) {\n        \n    }\n}\n\n/**\n * Your FrequencyTracker object will be instantiated and called as such:\n * FrequencyTracker obj = new FrequencyTracker();\n * obj.Add(number);\n * obj.DeleteOne(number);\n * bool param_3 = obj.HasFrequency(frequency);\n */",
    "javascript": "\nvar FrequencyTracker = function() {\n    \n};\n\n/** \n * @param {number} number\n * @return {void}\n */\nFrequencyTracker.prototype.add = function(number) {\n    \n};\n\n/** \n * @param {number} number\n * @return {void}\n */\nFrequencyTracker.prototype.deleteOne = function(number) {\n    \n};\n\n/** \n * @param {number} frequency\n * @return {boolean}\n */\nFrequencyTracker.prototype.hasFrequency = function(frequency) {\n    \n};\n\n/** \n * Your FrequencyTracker object will be instantiated and called as such:\n * var obj = new FrequencyTracker()\n * obj.add(number)\n * obj.deleteOne(number)\n * var param_3 = obj.hasFrequency(frequency)\n */",
    "typescript": "class FrequencyTracker {\n    constructor() {\n        \n    }\n\n    add(number: number): void {\n        \n    }\n\n    deleteOne(number: number): void {\n        \n    }\n\n    hasFrequency(frequency: number): boolean {\n        \n    }\n}\n\n/**\n * Your FrequencyTracker object will be instantiated and called as such:\n * var obj = new FrequencyTracker()\n * obj.add(number)\n * obj.deleteOne(number)\n * var param_3 = obj.hasFrequency(frequency)\n */",
    "php": "class FrequencyTracker {\n    /**\n     */\n    function __construct() {\n        \n    }\n  \n    /**\n     * @param Integer $number\n     * @return NULL\n     */\n    function add($number) {\n        \n    }\n  \n    /**\n     * @param Integer $number\n     * @return NULL\n     */\n    function deleteOne($number) {\n        \n    }\n  \n    /**\n     * @param Integer $frequency\n     * @return Boolean\n     */\n    function hasFrequency($frequency) {\n        \n    }\n}\n\n/**\n * Your FrequencyTracker object will be instantiated and called as such:\n * $obj = FrequencyTracker();\n * $obj->add($number);\n * $obj->deleteOne($number);\n * $ret_3 = $obj->hasFrequency($frequency);\n */",
    "swift": "\nclass FrequencyTracker {\n\n    init() {\n        \n    }\n    \n    func add(_ number: Int) {\n        \n    }\n    \n    func deleteOne(_ number: Int) {\n        \n    }\n    \n    func hasFrequency(_ frequency: Int) -> Bool {\n        \n    }\n}\n\n/**\n * Your FrequencyTracker object will be instantiated and called as such:\n * let obj = FrequencyTracker()\n * obj.add(number)\n * obj.deleteOne(number)\n * let ret_3: Bool = obj.hasFrequency(frequency)\n */",
    "kotlin": "class FrequencyTracker() {\n\n    fun add(number: Int) {\n        \n    }\n\n    fun deleteOne(number: Int) {\n        \n    }\n\n    fun hasFrequency(frequency: Int): Boolean {\n        \n    }\n\n}\n\n/**\n * Your FrequencyTracker object will be instantiated and called as such:\n * var obj = FrequencyTracker()\n * obj.add(number)\n * obj.deleteOne(number)\n * var param_3 = obj.hasFrequency(frequency)\n */",
    "dart": "class FrequencyTracker {\n\n  FrequencyTracker() {\n    \n  }\n  \n  void add(int number) {\n    \n  }\n  \n  void deleteOne(int number) {\n    \n  }\n  \n  bool hasFrequency(int frequency) {\n    \n  }\n}\n\n/**\n * Your FrequencyTracker object will be instantiated and called as such:\n * FrequencyTracker obj = FrequencyTracker();\n * obj.add(number);\n * obj.deleteOne(number);\n * bool param3 = obj.hasFrequency(frequency);\n */",
    "golang": "type FrequencyTracker struct {\n    \n}\n\n\nfunc Constructor() FrequencyTracker {\n    \n}\n\n\nfunc (this *FrequencyTracker) Add(number int)  {\n    \n}\n\n\nfunc (this *FrequencyTracker) DeleteOne(number int)  {\n    \n}\n\n\nfunc (this *FrequencyTracker) HasFrequency(frequency int) bool {\n    \n}\n\n\n/**\n * Your FrequencyTracker object will be instantiated and called as such:\n * obj := Constructor();\n * obj.Add(number);\n * obj.DeleteOne(number);\n * param_3 := obj.HasFrequency(frequency);\n */",
    "ruby": "class FrequencyTracker\n    def initialize()\n        \n    end\n\n\n=begin\n    :type number: Integer\n    :rtype: Void\n=end\n    def add(number)\n        \n    end\n\n\n=begin\n    :type number: Integer\n    :rtype: Void\n=end\n    def delete_one(number)\n        \n    end\n\n\n=begin\n    :type frequency: Integer\n    :rtype: Boolean\n=end\n    def has_frequency(frequency)\n        \n    end\n\n\nend\n\n# Your FrequencyTracker object will be instantiated and called as such:\n# obj = FrequencyTracker.new()\n# obj.add(number)\n# obj.delete_one(number)\n# param_3 = obj.has_frequency(frequency)",
    "scala": "class FrequencyTracker() {\n\n    def add(number: Int): Unit = {\n        \n    }\n\n    def deleteOne(number: Int): Unit = {\n        \n    }\n\n    def hasFrequency(frequency: Int): Boolean = {\n        \n    }\n\n}\n\n/**\n * Your FrequencyTracker object will be instantiated and called as such:\n * val obj = new FrequencyTracker()\n * obj.add(number)\n * obj.deleteOne(number)\n * val param_3 = obj.hasFrequency(frequency)\n */",
    "rust": "struct FrequencyTracker {\n\n}\n\n\n/** \n * `&self` means the method takes an immutable reference.\n * If you need a mutable reference, change it to `&mut self` instead.\n */\nimpl FrequencyTracker {\n\n    fn new() -> Self {\n        \n    }\n    \n    fn add(&self, number: i32) {\n        \n    }\n    \n    fn delete_one(&self, number: i32) {\n        \n    }\n    \n    fn has_frequency(&self, frequency: i32) -> bool {\n        \n    }\n}\n\n/**\n * Your FrequencyTracker object will be instantiated and called as such:\n * let obj = FrequencyTracker::new();\n * obj.add(number);\n * obj.delete_one(number);\n * let ret_3: bool = obj.has_frequency(frequency);\n */",
    "racket": "(define frequency-tracker%\n  (class object%\n    (super-new)\n    \n    (init-field)\n    \n    ; add : exact-integer? -> void?\n    (define/public (add number)\n      )\n    ; delete-one : exact-integer? -> void?\n    (define/public (delete-one number)\n      )\n    ; has-frequency : exact-integer? -> boolean?\n    (define/public (has-frequency frequency)\n      )))\n\n;; Your frequency-tracker% object will be instantiated and called as such:\n;; (define obj (new frequency-tracker%))\n;; (send obj add number)\n;; (send obj delete-one number)\n;; (define param_3 (send obj has-frequency frequency))",
    "erlang": "-spec frequency_tracker_init_() -> any().\nfrequency_tracker_init_() ->\n  .\n\n-spec frequency_tracker_add(Number :: integer()) -> any().\nfrequency_tracker_add(Number) ->\n  .\n\n-spec frequency_tracker_delete_one(Number :: integer()) -> any().\nfrequency_tracker_delete_one(Number) ->\n  .\n\n-spec frequency_tracker_has_frequency(Frequency :: integer()) -> boolean().\nfrequency_tracker_has_frequency(Frequency) ->\n  .\n\n\n%% Your functions will be called as such:\n%% frequency_tracker_init_(),\n%% frequency_tracker_add(Number),\n%% frequency_tracker_delete_one(Number),\n%% Param_3 = frequency_tracker_has_frequency(Frequency),\n\n%% frequency_tracker_init_ will be called before every test case, in which you can do some necessary initializations.",
    "elixir": "defmodule FrequencyTracker do\n  @spec init_() :: any\n  def init_() do\n    \n  end\n\n  @spec add(number :: integer) :: any\n  def add(number) do\n    \n  end\n\n  @spec delete_one(number :: integer) :: any\n  def delete_one(number) do\n    \n  end\n\n  @spec has_frequency(frequency :: integer) :: boolean\n  def has_frequency(frequency) do\n    \n  end\nend\n\n# Your functions will be called as such:\n# FrequencyTracker.init_()\n# FrequencyTracker.add(number)\n# FrequencyTracker.delete_one(number)\n# param_3 = FrequencyTracker.has_frequency(frequency)\n\n# FrequencyTracker.init_ will be called before every test case, in which you can do some necessary initializations."
  }
}