{
  "title": "Height of Binary Tree After Subtree Removal Queries",
  "problem_id": "2545",
  "frontend_id": "2458",
  "difficulty": "Hard",
  "problem_slug": "height-of-binary-tree-after-subtree-removal-queries",
  "topics": [
    "Array",
    "Tree",
    "Depth-First Search",
    "Breadth-First Search",
    "Binary Tree"
  ],
  "description": "You are given the root of a binary tree with n nodes. Each node is assigned a unique value from 1 to n. You are also given an array queries of size m.\nYou have to perform m independent queries on the tree where in the ith query you do the following:\nReturn an array answer of size m where answer[i] is the height of the tree after performing the ith query.\nNote:\nExample 1:\nExample 2:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: root = [1,3,4,2,null,6,5,null,null,null,null,null,7], queries = [4]\nOutput: [2]\nExplanation: The diagram above shows the tree after removing the subtree rooted at node with value 4.\nThe height of the tree is 2 (The path 1 -> 3 -> 2).",
      "images": [
        "https://assets.leetcode.com/uploads/2022/09/07/binaryytreeedrawio-1.png"
      ]
    },
    {
      "example_num": 2,
      "example_text": "Input: root = [5,8,9,2,1,3,7,4,6], queries = [3,2,4,8]\nOutput: [3,2,3,2]\nExplanation: We have the following queries:\n- Removing the subtree rooted at node with value 3. The height of the tree becomes 3 (The path 5 -> 8 -> 2 -> 4).\n- Removing the subtree rooted at node with value 2. The height of the tree becomes 2 (The path 5 -> 8 -> 1).\n- Removing the subtree rooted at node with value 4. The height of the tree becomes 3 (The path 5 -> 8 -> 2 -> 6).\n- Removing the subtree rooted at node with value 8. The height of the tree becomes 2 (The path 5 -> 9 -> 3).",
      "images": [
        "https://assets.leetcode.com/uploads/2022/09/07/binaryytreeedrawio-2.png"
      ]
    }
  ],
  "constraints": [
    "The number of nodes in the tree is n.",
    "2 <= n <= 105",
    "1 <= Node.val <= n",
    "All the values in the tree are unique.",
    "m == queries.length",
    "1 <= m <= min(n, 104)",
    "1 <= queries[i] <= n",
    "queries[i] != root.val"
  ],
  "follow_ups": [],
  "hints": [
    "Try pre-computing the answer for each node from 1 to n, and answer each query in O(1).",
    "The answers can be precomputed in a single tree traversal after computing the height of each subtree."
  ],
  "code_snippets": {
    "cpp": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    vector<int> treeQueries(TreeNode* root, vector<int>& queries) {\n        \n    }\n};",
    "java": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public int[] treeQueries(TreeNode root, int[] queries) {\n        \n    }\n}",
    "python": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def treeQueries(self, root, queries):\n        \"\"\"\n        :type root: Optional[TreeNode]\n        :type queries: List[int]\n        :rtype: List[int]\n        \"\"\"\n        ",
    "python3": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def treeQueries(self, root: Optional[TreeNode], queries: List[int]) -> List[int]:\n        ",
    "c": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     struct TreeNode *left;\n *     struct TreeNode *right;\n * };\n */\n/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nint* treeQueries(struct TreeNode* root, int* queries, int queriesSize, int* returnSize) {\n    \n}",
    "csharp": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public int val;\n *     public TreeNode left;\n *     public TreeNode right;\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\npublic class Solution {\n    public int[] TreeQueries(TreeNode root, int[] queries) {\n        \n    }\n}",
    "javascript": "/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @param {number[]} queries\n * @return {number[]}\n */\nvar treeQueries = function(root, queries) {\n    \n};",
    "typescript": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nfunction treeQueries(root: TreeNode | null, queries: number[]): number[] {\n    \n};",
    "php": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     public $val = null;\n *     public $left = null;\n *     public $right = null;\n *     function __construct($val = 0, $left = null, $right = null) {\n *         $this->val = $val;\n *         $this->left = $left;\n *         $this->right = $right;\n *     }\n * }\n */\nclass Solution {\n\n    /**\n     * @param TreeNode $root\n     * @param Integer[] $queries\n     * @return Integer[]\n     */\n    function treeQueries($root, $queries) {\n        \n    }\n}",
    "swift": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public var val: Int\n *     public var left: TreeNode?\n *     public var right: TreeNode?\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\n *         self.val = val\n *         self.left = left\n *         self.right = right\n *     }\n * }\n */\nclass Solution {\n    func treeQueries(_ root: TreeNode?, _ queries: [Int]) -> [Int] {\n        \n    }\n}",
    "kotlin": "/**\n * Example:\n * var ti = TreeNode(5)\n * var v = ti.`val`\n * Definition for a binary tree node.\n * class TreeNode(var `val`: Int) {\n *     var left: TreeNode? = null\n *     var right: TreeNode? = null\n * }\n */\nclass Solution {\n    fun treeQueries(root: TreeNode?, queries: IntArray): IntArray {\n        \n    }\n}",
    "dart": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *   int val;\n *   TreeNode? left;\n *   TreeNode? right;\n *   TreeNode([this.val = 0, this.left, this.right]);\n * }\n */\nclass Solution {\n  List<int> treeQueries(TreeNode? root, List<int> queries) {\n    \n  }\n}",
    "golang": "/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\nfunc treeQueries(root *TreeNode, queries []int) []int {\n    \n}",
    "ruby": "# Definition for a binary tree node.\n# class TreeNode\n#     attr_accessor :val, :left, :right\n#     def initialize(val = 0, left = nil, right = nil)\n#         @val = val\n#         @left = left\n#         @right = right\n#     end\n# end\n# @param {TreeNode} root\n# @param {Integer[]} queries\n# @return {Integer[]}\ndef tree_queries(root, queries)\n    \nend",
    "scala": "/**\n * Definition for a binary tree node.\n * class TreeNode(_value: Int = 0, _left: TreeNode = null, _right: TreeNode = null) {\n *   var value: Int = _value\n *   var left: TreeNode = _left\n *   var right: TreeNode = _right\n * }\n */\nobject Solution {\n    def treeQueries(root: TreeNode, queries: Array[Int]): Array[Int] = {\n        \n    }\n}",
    "rust": "// Definition for a binary tree node.\n// #[derive(Debug, PartialEq, Eq)]\n// pub struct TreeNode {\n//   pub val: i32,\n//   pub left: Option<Rc<RefCell<TreeNode>>>,\n//   pub right: Option<Rc<RefCell<TreeNode>>>,\n// }\n// \n// impl TreeNode {\n//   #[inline]\n//   pub fn new(val: i32) -> Self {\n//     TreeNode {\n//       val,\n//       left: None,\n//       right: None\n//     }\n//   }\n// }\nuse std::rc::Rc;\nuse std::cell::RefCell;\nimpl Solution {\n    pub fn tree_queries(root: Option<Rc<RefCell<TreeNode>>>, queries: Vec<i32>) -> Vec<i32> {\n        \n    }\n}",
    "racket": "; Definition for a binary tree node.\n#|\n\n; val : integer?\n; left : (or/c tree-node? #f)\n; right : (or/c tree-node? #f)\n(struct tree-node\n  (val left right) #:mutable #:transparent)\n\n; constructor\n(define (make-tree-node [val 0])\n  (tree-node val #f #f))\n\n|#\n\n(define/contract (tree-queries root queries)\n  (-> (or/c tree-node? #f) (listof exact-integer?) (listof exact-integer?))\n  )",
    "erlang": "%% Definition for a binary tree node.\n%%\n%% -record(tree_node, {val = 0 :: integer(),\n%%                     left = null  :: 'null' | #tree_node{},\n%%                     right = null :: 'null' | #tree_node{}}).\n\n-spec tree_queries(Root :: #tree_node{} | null, Queries :: [integer()]) -> [integer()].\ntree_queries(Root, Queries) ->\n  .",
    "elixir": "# Definition for a binary tree node.\n#\n# defmodule TreeNode do\n#   @type t :: %__MODULE__{\n#           val: integer,\n#           left: TreeNode.t() | nil,\n#           right: TreeNode.t() | nil\n#         }\n#   defstruct val: 0, left: nil, right: nil\n# end\n\ndefmodule Solution do\n  @spec tree_queries(root :: TreeNode.t | nil, queries :: [integer]) :: [integer]\n  def tree_queries(root, queries) do\n    \n  end\nend"
  },
  "solution": "[TOC]\n\n## Solution\n\n---\n\n### Overview\n\nThe approaches outlined below have similar time and space complexities. Rather than representing significant improvements over one another, they offer different methods and perspectives for solving the problem. You can either review all of them and choose the one that appeals to you, or explore each one in detail to understand the various ways to tackle the problem.\n    \n---\n\n### Approach 1: Left and Right Traversal\n\n#### Intuition\n\nThe problem asks us to find the height of a tree (the longest path from the root) after removing a subtree rooted at nodes listed in `queries`.\n\nA brute force solution would process each query separately by removing the specified subtree and recalculating the height of the remaining tree. However, this approach is inefficient due to its high time complexity.\n\nTo optimize, we can track the tree's height as we traverse from the root. For any node, the height after removing its subtree is simply the height of the tree before reaching that node. This allows us to avoid recalculating the height repeatedly.\n\nWe’ll perform a preorder traversal, tracking the maximum distance from the root. However, if the maximum height is achieved in the right subtree, we may miss it when traversing the left. To address this, we perform a second traversal in reverse preorder (root, right, left).\n\nWe maintain an array `heights` where `heights[i]` stores the tree height after removing the subtree rooted at node `i`. During the first traversal, we update `heights` with the height at each node as we explore its left and right subtrees. In the reverse traversal, we update `heights` if the current height is greater than the stored value.\n\nFinally, we iterate over `queries` and return the corresponding heights for each specified node.\n\n#### Algorithm\n\n- Initialize:\n  - a static array `maxHeightAfterRemoval` to store the maximum height of the tree after removing each node.\n  - a variable `currentMaxHeight` to 0, which will track the current maximum height during traversals.\n  \nMain method `treeQueries`:\n- Call the `traverseLeftToRight` method with the root node and initial height 0.\n- Reset `currentMaxHeight` to 0 for the second traversal.\n- Now call the `traverseRightToLeft` method with the root node and initial height 0.\n- Initialize an array `queryResults` to store the results of the queries.\n- Iterate through the queries:\n  - For each query, retrieve the corresponding maximum height from `maxHeightAfterRemoval`.\n  - Store this height in `queryResults`.\n- Return the `queryResults` array.\n\n- Define a method `traverseLeftToRight`:\n  - If the current node is `null`, return.\n  - Store the current `currentMaxHeight` in `maxHeightAfterRemoval` for the current node's value.\n  - Update `currentMaxHeight` to be the maximum of itself and the current height.\n  - Recursively call `traverseLeftToRight` for the left and right child, incrementing the height.\n\n- Define a method `traverseRightToLeft`:\n  - If the current node is `null`, return.\n  - Update `maxHeightAfterRemoval` for the current node's value to be the maximum of its current value and `currentMaxHeight`.\n  - Update `currentMaxHeight` to be the maximum of the current height and itself.\n  - Recursively call `traverseRightToLeft` for the right and left child, incrementing the height.\n\n#### Implementation#### Complexity Analysis\n\nLet $n$ be the number of nodes in the tree, and $q$ be the number of queries.\n\n- Time complexity: $O(n + q)$\n\n    The solution performs two traversals of the binary tree, followed by processing the queries. In both the traversals, each node in the tree is visited exactly once. Thus, the traversals take linear time.\n\n    To process the queries, the algorithm iterates through the queries array once, taking $O(q)$ time.\n\n    Thus, the overall time complexity is $2 \\cdot O(n) + O(q) = O(n + q)$. \n\n- Space complexity: $O(n)$\n\n    The space complexity is determined by mainly 2 factors:\n    1. The `maxHeightAfterRemoval` array, which has a fixed size of $100,001$. This contributes $O(1)$ to the space complexity as it's constant regardless of input size.\n    2. The recursion stack used in the tree traversals. In the worst case (a completely unbalanced tree), this could reach a depth of $n$, resulting in $O(n)$ space.\n   \n    Combining these factors, the overall space complexity of the algorithm is $O(n)$.\n\n    > Note: The size of the output array is not included in the space complexity calculations since it is a part of the output space.\n\n---\n\n### Approach 2: Single Traversal\n\n#### Intuition\n\nLet's optimize our solution to use just one traversal. We'll perform a preorder traversal starting from the root, similar to our previous approach. During this traversal, we’ll track a variable `maxVal` representing the maximum height encountered so far.\n\nFor each node, we store its corresponding answer (the `maxVal` at that point) in a `resultMap` for quick lookups during queries. We’ll also keep track of the depth as we traverse.\n\nTo determine the maximum height if a node is removed, we consider two values:\n1. The current `maxVal` on the path from the root to the node.\n2. The node’s depth plus one (to include itself) and the height of its sibling subtree.\n\nTo calculate the height of a sibling subtree, we’ll use a memoized helper function that finds the maximum distance from a given node to its leaf nodes.\n\nStarting the DFS from the root, we populate `resultMap` with heights for each node. Once the traversal completes, we can answer queries using the information stored in `resultMap`.\n\n#### Algorithm\n\n- Initialize a map:\n  - `resultMap` to store the maximum height of the tree after removing each node.\n  - `heightCache` to store pre-computed heights of subtrees.\n- Call the `dfs` method with initial parameters: root node, `depth` 0, `maxVal` 0, `resultMap`, and `heightCache`.\n- Initialize an array `result` to store the final query results.\n- Iterate through the queries:\n  - For each query, retrieve the corresponding maximum height from `resultMap`.\n  - Store this height in the `result` array.\n- Return the `result` array.\n\n- Define the `height` method to calculate the height of a tree:\n  - If the node is `null`, return -1.\n  - If the height of the node is already in `heightCache`, return the cached value.\n  - Calculate the height recursively as 1 plus the maximum of left and right subtree heights.\n  - Store the calculated height in `heightCache`.\n  - Return the calculated height.\n\n- Define the `dfs` method for the depth-first search:\n  - If the current node is `null`, return.\n  - Store the current `maxVal` in `resultMap` for the current node's value.\n  - Recursively call `dfs` for the left child:\n    - Increment the depth.\n    - Update maxVal as the maximum of current maxVal and (depth + 1 + height of right subtree).\n  - Recursively call `dfs` for the right child:\n    - Increment the depth.\n    - Update maxVal as the maximum of current maxVal and (depth + 1 + height of left subtree).\n\n#### Implementation#### Complexity Analysis\n\nLet $n$ be the number of nodes in the tree, and $q$ be the number of queries.\n\n* Time complexity: $O(n + q)$\n\n    The main `dfs` function visits each node in the tree exactly once. For each node, it calls the `height` function (which uses memoization) to calculate the heights of the subtrees. In the worst case, when we first encounter a node, we might need to calculate its height by traversing its entire subtree. However, subsequent calls for the same node or its ancestors will use the memoized value. Given that each node is visited once by `dfs`, and each node's height is calculated once and then cached, the overall time complexity for processing the tree is $O(n)$.\n\n    The algorithm also iterates over the `queries` array to create the result, taking $O(q)$ time.\n\n    Thus, the time complexity of the algorithm is $O(n + q)$.\n\n* Space complexity: $O(n)$\n\n    The `resultMap` and `heightCache` each take $O(n)$ space. The recursion stack for the DFS can go as deep as the height of the tree, which is $O(n)$ in the worst case.\n\n    Thus, the space complexity is $O(n)$.\n\n---\n\n### Approach 3: Subtree Size\n\n#### Intuition\n\nIn a preorder traversal of a tree, a subtree starts at its root's index and ends at the index equal to the start index plus the subtree's size. If we know the index and size of the subtree to be removed, we can remove this section from the traversal list. The maximum depth in the remaining traversal then represents the tree’s maximum height after removal.\n\nFor example, given the indices and depths of nodes, removing a subtree will leave us with the highest depth among the remaining nodes as our answer. To understand this better, have a look at the visualization below:\n\n![](../Figures/2458_re/preorderdepth_fix.png)\n\nTo implement this, we’ll perform a preorder traversal to:\n1. Assign an index to each node\n2. Track the depth of each node\n\nWe then create two arrays, `maxDepthsFromLeft` and `maxDepthsFromRight`, to store the maximum depth to the left and right of each index, respectively. These arrays are filled by iterating through the nodes and updating each index with the maximum of the previous result and the current node’s depth.\n\nFinally, to process each query, we compute the result as the maximum of:\n1. The maximum depth from the left up to the starting index\n2. The maximum depth from the right beyond the ending index, if available.\n\n#### Algorithm\n\n- Initialize a map:\n  - `nodeIndexMap` to store the index of each node value.\n  - `subtreeSize` to store the number of nodes in the subtree for each node.\n- Initialize lists `nodeDepths`, `maxDepthFromLeft`, and `maxDepthFromRight` to store node depths and maximum depths from left and right.\n- Call the `dfs` method to populate `nodeIndexMap` and `nodeDepths`.\n- Store the total number of nodes in `totalNodes`.\n- Call `calculateSubtreeSize` method to populate the `subtreeSize` map.\n- Initialize `maxDepthFromLeft` and `maxDepthFromRight` with the first and last node depths respectively.\n- Iterate through the nodes to calculate `maxDepthFromLeft` and `maxDepthFromRight`:\n  - Update `maxDepthFromLeft` with the maximum of the previous max and current depth.\n  - Update `maxDepthFromRight` with the maximum of the previous max and current depth (in reverse order).\n- Reverse the `maxDepthFromRight` list.\n- Initialize an array `results` to store the query results.\n- Process each query. For each query node:\n  - Calculate the end index as the node's index minus 1.\n  - Calculate the start index as the end index plus the subtree size plus 1.\n  - Initialize `maxDepth` with the value from `maxDepthFromLeft` at the end index.\n  - If the start index is within bounds, update `maxDepth` with the maximum of current `maxDepth` and the value from `maxDepthFromRight` at the start index.\n  - Store the `maxDepth` in the `results` array.\n- Return the `results` array.\n\n- Define a method `dfs` for the depth-first search:\n  - If the current node is null, return.\n  - Add the current node's value and index to `nodeIndexMap`.\n  - Add the current depth to `nodeDepths`.\n  - Recursively call `dfs` for left and right children, incrementing the depth.\n\n- Define a method `calculateSubtreeSize` :\n  - If the current node is `null`, return 0.\n  - Recursively calculate the size of left and right subtrees.\n  - Calculate the total size as left size plus right size plus 1.\n  - Store the total size in `subtreeSize` for the current node.\n  - Return the total size.\n\n#### Implementation#### Complexity Analysis\n\nLet $n$ be the number of nodes in the tree, and $q$ be the number of queries.\n\n* Time complexity: $O(n + q)$\n\n    This solution employs a four-step approach to solve the problem:\n    1. The initial depth-first search traverses each node once, populating `nodeIndexMap` and `nodeDepths`. This takes $O(n)$ time.\n    2. The calculation of subtree sizes (`calculateSubtreeSize` method) also visits each node once, taking $O(n)$ time.\n    3. Computing `maxDepthFromLeft` and `maxDepthFromRight` involves iterating through the `nodeDepths` list once, which takes $O(n)$ time.\n    4. Processing the queries and populating the result array takes $O(q)$ time. \n\n    Summing up the parts, the algorithm has a time complexity of $3 \\cdot O(n) + O(q) = O(n + q)$.\n\n* Space complexity: $O(n)$\n\n    The `nodeIndexMap` and `subtreeSize` maps each store information for every node, taking $O(n)$ space each. The `nodeDepths`, `maxDepthFromLeft`, and `maxDepthFromRight` lists each contain an entry for every node, also taking $O(n)$ space each.\n\n    Similar to the previous approach, the recursion stack has a $O(n)$ complexity.\n\n    Thus, the space complexity remains $O(n)$.\n\n---\n\n### Approach 4: Eulerian Tour\n\n#### Intuition\n\nThe previous approach can be generalized using an Eulerian tour. An Eulerian tour traverses the tree such that each node is visited twice, once when first encountered, and again when leaving after exploring all its subtrees.\n\n![](../Figures/2458_re/eulertour_fix.png)\n\nIn this tour, a subtree is bounded by the first and last occurrences of its root node. To find the maximum height of the tree after removing a subtree, we can simply look at the maximum depth before the first occurrence and after the last occurrence of the subtree's root node.\n\nTo create the Eulerian tour, we perform a DFS over the tree, recording the first and last occurrences of each node in the `firstOccurrence` and `lastOccurrence` maps, respectively, while tracking each node's depth. \n\nLike the previous approach, we calculate `maxDepthLeft` and `maxDepthRight` for each node for quick access. For each query, we can then retrieve the maximum depths at the first and last occurrences of the queried node and return the greater of the two as our answer.\n\n#### Algorithm\n\n- Initialize a list `eulerTour` to store the Euler tour of the tree.\n- Initialize maps `nodeHeights`, `firstOccurrence`, and `lastOccurrence` to store information about each node.\n- Call the `dfs` function to build the Euler tour and populate the maps.\n- Set `tourSize` to the size of `eulerTour`.\n- Initialize arrays `maxDepthLeft` and `maxDepthRight` of size `tourSize`.\n- Set the first element of `maxDepthLeft` and last element of `maxDepthRight` to the height of the root node.\n- Iterate from 1 to `tourSize - 1`:\n  - Set `maxDepthLeft[i]` to the maximum of the previous max height and the current node's height.\n- Iterate backward from `tourSize - 2` to 0:\n  - Set `maxDepthRight[i]` to the maximum of the next max height and the current node's height.\n- Initialize an array `results` with the same length as `queries`.\n- For each query in `queries`:\n  - Set `queryNode` to the current query value.\n  - Calculate `leftMax` and `rightMax` as the max height to the left and right of the node's first occurrence, respectively.\n  - Store the maximum of `leftMax` and `rightMax` in `results`.\n- Return the `results` array.\n\n- Define the `dfs` function:\n  - If the current node is `null`, return.\n  - Add the current node's height to `nodeHeights`.\n  - Set the first occurrence of the current node in `firstOccurrence`.\n  - Add the current node's value to `eulerTour`.\n  - Recursively call `dfs` for left and right children, incrementing the height.\n  - Set the last occurrence of the current node in `lastOccurrence`.\n  - Add the current node's value to `eulerTour` again.\n\n#### Implementation#### Complexity Analysis\n\nLet $n$ be the number of nodes in the tree, and $q$ be the number of queries.\n\n* Time complexity: $O(n + q)$\n\n    The `dfs` method traverses each node twice (down and up) to construct the Euler tour, which takes $O(n)$ time. The `maxDepthLeft` and `maxDepthRight` arrays are then built by iterating over the Euler tour in both directions and since the tour has a length of $2n$, this step also takes $O(n)$ time.\n\n    Processing the queries takes $O(q)$ time, making the total time complexity $O(n + q)$.\n \n\n* Space complexity: $O(n)$\n\n    The Euler tour, stored in a list, contains $2 \\cdot n$ elements and occupies $O(n)$ space. Three maps - `nodeHeights`, `firstOccurrence`, and `lastOccurrence` - each store information for every node, also taking $O(n)$ space. Two arrays, `maxDepthLeft` and `maxDepthRight`, mirror the Euler tour's length and consume $O(n)$ space each. Additionally, the recursion stack, as is typical, requires $O(n)$ space.\n\n    Thus, the overall space complexity is $O(n)$.\n\n---\n\n### Approach 5: Two Largest Cousins\n\n#### Intuition\n\nAt any node, the longest path through it is the sum of its depth and the height of its subtree. For each depth, the maximum tree height at that level will be the depth plus the maximum height of any node at that depth.\n\n![](../Figures/2458_re/cousinheights_fix.png)\n\nTo optimize this, we organize nodes by their depths and precalculate their heights. If a query removes a node, we find the maximum height at that depth, excluding the removed node.\n\nTo streamline further, the maximum height from a given depth can be found using two precomputed values:\n1. The maximum height at that depth, excluding the current node.\n2. The second-highest height at that depth, if the maximum height subtree is removed.\n\nThus, we only need the two largest heights at each depth. We maintain two lists, `firstLargestHeight` and `secondLargestHeight`, where each index stores the two largest heights for each depth. We then use DFS to populate these lists, along with each node's depth and height. For each query, if a node’s height matches the largest height at its depth, we return the second-largest height at that level; otherwise, we return the largest height.\n\n#### Algorithm\n \n- Initialize a map: \n  - `nodeDepths` to store the depth of each node.\n  - `subtreeHeights` to store the height of the subtree rooted at each node.\n- Initialize maps `firstLargestHeight` and `secondLargestHeight` to store the first and second largest heights at each level.\n- Call the `dfs` function to populate these maps.\n- Initialize an array `results` with the same length as `queries`.\n- For each query in `queries`:\n  - Set `queryNode` to the current query value.\n  - Set `nodeLevel` to the depth of the query node.\n  - If the height of the query node's subtree equals the first largest height at its level:\n    - Set the result to the sum of node level and second largest height at that level, minus 1.\n- Otherwise:\n    - Set the result to the sum of node level and first largest height at that level, minus 1.\n- Return the `results` array.\n\n- Define the `dfs` function:\n  - If the current node is `null`, return 0.\n  - Add the current node's depth to `nodeDepths`.\n  - Recursively call `dfs` for left and right children, incrementing the level.\n  - Calculate `currentHeight` as 1 plus the maximum of left and right subtree heights.\n  - Add the current node's subtree height to `subtreeHeights`.\n  - Set `currentFirstLargest` to the first largest height at the current level.\n  - If `currentHeight` is greater than `currentFirstLargest`:\n    - Update `secondLargestHeight` at the current level with `currentFirstLargest`.\n    - Update `firstLargestHeight` at the current level with `currentHeight`.\n  - Else if `currentHeight` is greater than the second largest height at the current level:\n    - Update `secondLargestHeight` at the current level with `currentHeight`.\n  - Return `currentHeight`.\n\n> Note: The C++ implementation opts for vectors instead of unordered_maps. This choice stems from unordered_maps' reputation for slower performance in certain scenarios.\n\n#### Implementation#### Complexity Analysis\n\nLet $n$ be the number of nodes in the tree, and $q$ be the number of queries.\n\n* Time complexity: $O(n + q)$\n\n    The `dfs` method traverses each node in the tree exactly once. For each node, it performs several comparison and update operations, all of which take constant time. So, this step takes $O(n)$ time.\n\n    To process each query, the algorithm does some map lookups and a comparison, both taking constant time. Thus, processing all the queries requires $O(q)$ time.\n\n    Thus, the overall time complexity of the algorithm is $O(n + q)$.\n\n* Space complexity: $O(n)$\n\n    The `nodeDepths` and `subtreeHeights` maps store information for every node, taking $O(n)$ space each.\n\n    The `firstLargestHeight` and `secondLargestHeight` maps typically store $log n$ (balanced trees) elements, but in the worst case (skewed trees), could store information for all $n$ levels. Thus, these take a further $O(n)$ space.\n\n    The recursion stack goes as deep as the height of the tree, which can be $n$ in the worst case.\n\n    Thus, the overall space complexity is $O(n)$.\n\n---"
}