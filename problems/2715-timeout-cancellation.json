{
  "title": "Timeout Cancellation",
  "problem_id": "2821",
  "frontend_id": "2715",
  "difficulty": "Easy",
  "problem_slug": "timeout-cancellation",
  "topics": [],
  "description": "Given a function fn, an array of arguments args, and a timeout t in milliseconds, return a cancel function cancelFn.\nAfter a delay of cancelTimeMs, the returned cancel function cancelFn will be invoked.\nInitially, the execution of the function fn should be delayed by t milliseconds.\nIf, before the delay of t milliseconds, the function cancelFn is invoked, it should cancel the delayed execution of fn. Otherwise, if cancelFn is not invoked within the specified delay t, fn should be executed with the provided args as arguments.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "setTimeout(cancelFn, cancelTimeMs)",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input: fn = (x) => x * 5, args = [2], t = 20\nOutput: [{\"time\": 20, \"returned\": 10}]\nExplanation: \nconst cancelTimeMs = 50;\nconst cancelFn = cancellable((x) => x * 5, [2], 20);\nsetTimeout(cancelFn, cancelTimeMs);\n\nThe cancellation was scheduled to occur after a delay of cancelTimeMs (50ms), which happened after the execution of fn(2) at 20ms.",
      "images": []
    },
    {
      "example_num": 3,
      "example_text": "Input: fn = (x) => x**2, args = [2], t = 100\nOutput: []\nExplanation: \nconst cancelTimeMs = 50;\nconst cancelFn = cancellable((x) => x**2, [2], 100);\nsetTimeout(cancelFn, cancelTimeMs);\n\nThe cancellation was scheduled to occur after a delay of cancelTimeMs (50ms), which happened before the execution of fn(2) at 100ms, resulting in fn(2) never being called.",
      "images": []
    },
    {
      "example_num": 4,
      "example_text": "Input: fn = (x1, x2) => x1 * x2, args = [2,4], t = 30\nOutput: [{\"time\": 30, \"returned\": 8}]\nExplanation: \nconst cancelTimeMs = 100;\nconst cancelFn = cancellable((x1, x2) => x1 * x2, [2,4], 30);\nsetTimeout(cancelFn, cancelTimeMs);\n\nThe cancellation was scheduled to occur after a delay of cancelTimeMs (100ms), which happened after the execution of fn(2,4) at 30ms.",
      "images": []
    }
  ],
  "constraints": [
    "fn is a function",
    "args is a valid JSON array",
    "1 <= args.length <= 10",
    "20 <= t <= 1000",
    "10 <= cancelTimeMs <= 1000"
  ],
  "follow_ups": [],
  "hints": [],
  "code_snippets": {
    "javascript": "/**\n * @param {Function} fn\n * @param {Array} args\n * @param {number} t\n * @return {Function}\n */\nvar cancellable = function(fn, args, t) {\n    \n};\n\n/**\n *  const result = [];\n *\n *  const fn = (x) => x * 5;\n *  const args = [2], t = 20, cancelTimeMs = 50;\n *\n *  const start = performance.now();\n *\n *  const log = (...argsArr) => {\n *      const diff = Math.floor(performance.now() - start);\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr)});\n *  }\n *       \n *  const cancel = cancellable(log, args, t);\n *\n *  const maxT = Math.max(t, cancelTimeMs);\n *           \n *  setTimeout(cancel, cancelTimeMs);\n *\n *  setTimeout(() => {\n *      console.log(result); // [{\"time\":20,\"returned\":10}]\n *  }, maxT + 15)\n */",
    "typescript": "type JSONValue = null | boolean | number | string | JSONValue[] | { [key: string]: JSONValue };\ntype Fn = (...args: JSONValue[]) => void\n\nfunction cancellable(fn: Fn, args: JSONValue[], t: number): Function {\n    \n};\n\n/**\n *  const result = [];\n *\n *  const fn = (x) => x * 5;\n *  const args = [2], t = 20, cancelTimeMs = 50;\n *\n *  const start = performance.now();\n *\n *  const log = (...argsArr) => {\n *      const diff = Math.floor(performance.now() - start);\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr)});\n *  }\n *       \n *  const cancel = cancellable(log, args, t);\n *\n *  const maxT = Math.max(t, cancelTimeMs);\n *           \n *  setTimeout(cancel, cancelTimeMs);\n *\n *  setTimeout(() => {\n *      console.log(result); // [{\"time\":20,\"returned\":10}]\n *  }, maxT + 15)\n */"
  },
  "solution": "[TOC]\n\n\n## Overview:\nWe need to implement a function `cancellable` that executes a given function (let's call it `fn`) after a specified delay (`t` milliseconds), unless a cancel function (`cancelFn`) is called before the delay expires. The cancel function should prevent the execution of the delayed function.\n\nIn other words, we have a task `fn` we want to do, but we want to wait for a bit (`t` milliseconds) before doing it. However, if we change our mind and want to cancel this task before the wait time is up, we can use a cancel function (`cancelFn`). If we don't cancel, the task will happen after the delay.\n\n---\n\n### Closures:\nIn JavaScript, a closure is a combination of a function and the lexical environment within which that function was declared. The lexical environment consists of the variables, functions, and scopes available at the time of the closure's creation.\n\n**Working:**\n\n* When a function is defined inside another function, a closure is created. The inner function retains a reference to the variables and scope of its outer function.\n* When the outer function finishes executing and returns, the closure is still intact with its captured variables and scope chain.\n* The closure allows the inner function to access and manipulate the variables of its outer function, even if the outer function's execution has been completed.\n* This behavior is possible because the closure maintains a reference to its outer function's variables and scope chain, preventing them from being garbage collected.\n\n> For a more detailed explanation of closures, check out the [Counter editorial](https://leetcode.com/problems/counter/editorial/).\n\nIn the context of the problem, closures are used to maintain a reference to the timer variable even after the function that creates the closure has returned. This allows the `cancelFn` function to access and modify the timer variable, effectively canceling the execution of the delayed function.\n\n### setTimeout:\n`setTimeout` is a built-in function in JavaScript that allows you to schedule the execution of a function after a specified delay. It can take an infinite number of arguments but usually, its first two arguments are always a function to be executed and a delay time in milliseconds.\n> **Note:** `setTimeout` is a [variadic function that can accept an infinite number of arguments](https://developer.mozilla.org/en-US/docs/Web/API/setTimeout).\n\nHere's an example of how to use `setTimeout`:\n```js\nfunction delayedFunction() {\n  console.log(\"Delayed function executed!\");\n}\n\nconst delay = 2000;\n\nconst timerId = setTimeout(delayedFunction, delay);\n\n// To cancel the execution before the delay expires:\nclearTimeout(timerId);\n```\n\n**Working:**\n* When `setTimeout` is called, it starts a timer and sets it to run after the specified delay.\n* After the delay expires, the JavaScript event loop puts the specified function in the execution queue.\n* Once the call stack is empty, the function is executed, and any associated code inside it is run.\n* If the `setTimeout` function is canceled before the delay expires, the scheduled function will not be executed.\n\n> For a deeper understanding of `setTimeout`, refer to the following editorials: [Cache With Time Limit Editorial](https://leetcode.com/problems/cache-with-time-limit/editorial/), [Debounce Editorial](https://leetcode.com/problems/debounce/editorial/), and [Throttle Editorial](https://leetcode.com/problems/throttle/editorial/).\n\nIn the context of the problem, `setTimeout` is used inside the `cancellable` function to schedule the execution of the delayed function (`fn`) after the specified delay (`t`).\n\nOverall, `closures` and `setTimeout` work together in this problem to create a cancelable delayed function execution mechanism. The closure preserves the reference to the `timeoutId` variable, and `setTimeout` schedules the execution of the function after the specified delay.\n\n---\n\n## Approach 1: Using Closure\n\n### Intuition:\nWe use the `setTimeout` function to schedule the execution of the delayed function `fn` after the specified timeout `t`. Then, we use the `apply` method to pass the arguments from the `args` array to `fn`.\n\nWhen we call `fn.apply(null, args)`, we're telling JS to execute the `fn` function with the arguments in the `args` array. The `null` argument specifies that the function should be executed in the global scope rather than in the scope of some other object. This is useful because we want to call a function defined in the global scope from within another function.\n\nAlso, by storing the timer ID returned by `setTimeout` in the `timeoutId` variable, we can cancel the execution of the delayed function by calling `clearTimeout` with the `timeoutId`.\n\n### Algorithm:\n* Inside the `cancellable` function, we use `setTimeout` to schedule the execution of `fn` after the specified timeout `t`. The `fn` function is invoked using the `apply` method, with `null` as the context and `args` as the arguments. Additionally, the `setTimeout` function returns a timer ID, which is stored in the `timeoutId` variable.\n* Afterward, a `cancelFn` function is defined, which calls `clearTimeout` with the `timeoutId` to cancel the execution of the delayed function.\n* Finally, return the `cancelFn` from the `cancellable` function.\n\n### Implementation:### Complexity Analysis:\n\n* **Time complexity:** $O(1)$\n\n* **Space complexity:** $O(1)$\n\n> While the time and space complexity of the cancellable function itself is $O(1)$, it's important to note that the time complexity of the function `fn` that is passed as an argument can have some different complexity.\n\n---\n\n## Approach 2: Using Boolean flag\n\n### Intuition:\nWe can use a boolean variable that decides whether calling function `fn` is allowed or not.\n\n### Algorithm:\n* Initialize a boolean variable `isCancelled` as `false` to track the cancellation status.\n* Use `setTimeout()` to schedule the execution of `fn` after a delay of `t` milliseconds, but only if `isCancelled` is `false`.\n* Return a function that flips the value of `isCancelled` to `true`, canceling the execution of `fn`. The cancellation function ensures that `fn` will never be called if it is invoked before the delay expires.\n\n> While this approach does prevent the `fn` function from being executed if the cancel function is invoked, it's worth noting that the `setTimeout` callback still gets executed when the delay is over. This means that even when canceled, the function still uses up a slot in the JavaScript event loop queue. As such, in terms of computational efficiency, this approach might be slightly less efficient than Approach 1, which cancels the `setTimeout` entirely.\n\n### Implementation:### Complexity Analysis:\n\n* **Time complexity:** $O(1)$\n\n* **Space complexity:** $O(1)$\n\n> While the time and space complexity of the cancellable function itself is $O(1)$, it's important to note that the time complexity of the function `fn` that is passed as an argument can have some different complexity.\n\n---\n\n## Interview Tips:Can you explain the role of the `apply` method used in the `setTimeout` callback?Theapplymethod is used to invoke the delayed functionfnwith the providedargsarray as its arguments. It allows us to dynamically pass the arguments from theargsarray tofn. This ensures that the correct arguments are passed whenfnis eventually executed.Additionally, usingapplywithnullas the first argument allows us to invoke the function without specifying a specific context (thisvalue). Since the delayed function execution doesn't rely on a specific context, usingnullis appropriate.How can you handle scenarios where the delayed function requires a specific context (this value) for execution?In cases where the delayed function relies on a specific context (thisvalue), you can use thebindmethod tobindthe desired context tofn. This creates a new function with the specified context, and you can then pass the bound function tosetTimeoutfor delayed execution.Is it possible to modify the implementation to allow for multiple delayed function executions with different timeouts?Yes, it is possible to modify the solution to handle multiple delayed function executions. You can create an array to store the timeoutId values for each scheduled execution. The cancellation function can then clear all the timeout IDs in the array, effectively canceling all pending executions.What are some potential use cases for a cancellable function with a delay?A cancellable function with delay can be useful in scenarios where an action needs to be scheduled after a certain delay, but there may also be conditions under which that action should be prevented from executing. For instance, in a user interface, a notification scheduled to display after a delay can be canceled if the user performs an action that makes the notification irrelevant.Another scenario could be in a gaming context, where an action is scheduled to occur after a delay, but intervening user actions or game events might necessitate canceling that scheduled action. It's important to note that these use cases differ from debouncing or throttling scenarios, which aim to control the rate of function invocation rather than scheduling and possibly canceling actions.What are the potential drawbacks or limitations of using `setTimeout` for scheduling the delayed function execution?One limitation is thatsetTimeoutis not precise and can be affected by other factors like system load. If precise timing is required, alternative methods like Web Workers or the Web Animation API are used in some cases but they serve different purposes and cannot always be used as direct substitutes forsetTimeout.A more precise timing control could be achieved using theperformance.now()method, which provides timestamps with a sub-millisecond resolution for measurements, but it still wouldn't be able to guarantee that a function will run exactly after a specified delay due to the single-threaded nature of JavaScript.Is it possible to modify the cancellable function to support a delay that can be dynamically changed during execution?Yes, it is possible to enhance the cancellable function to support dynamic changes in the delay. You can modify the implementation to store the timeout ID and useclearTimeoutbefore setting a new timeout with the updated delay.Can you explain the concept of \"debouncing\" and how it relates to the cancellable function with a delay?Debouncing is a programming practice used to ensure that time-consuming tasks do not fire so often, which can be especially valuable in situations such as the handling of user input events where an event might fire frequently and rapidly. The core concept of debouncing is setting a delay before executing the function and then resetting that delay every time the function is requested before the delay expires.While a cancellable function with a delay shares similarities with debouncing, as both involve a delayed function execution that can be prevented, they are not inherently linked. A cancellable function is better suited to scenarios where an action or computation can be made obsolete before it's executed. On the other hand, debouncing typically does not involve the explicit creation of a cancellable function; instead, it clears and resets the timer directly within the function.---"
}