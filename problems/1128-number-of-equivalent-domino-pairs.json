{
  "title": "Number of Equivalent Domino Pairs",
  "problem_id": "1227",
  "frontend_id": "1128",
  "difficulty": "Easy",
  "problem_slug": "number-of-equivalent-domino-pairs",
  "topics": [
    "Array",
    "Hash Table",
    "Counting"
  ],
  "description": "Given a list of dominoes, dominoes[i] = [a, b] is equivalent to dominoes[j] = [c, d] if and only if either (a == c and b == d), or (a == d and b == c) - that is, one domino can be rotated to be equal to another domino.\nReturn the number of pairs (i, j) for which 0 <= i < j < dominoes.length, and dominoes[i] is equivalent to dominoes[j].\nExample 1:\nExample 2:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: dominoes = [[1,2],[2,1],[3,4],[5,6]]\nOutput: 1",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input: dominoes = [[1,2],[1,2],[1,1],[1,2],[2,2]]\nOutput: 3",
      "images": []
    }
  ],
  "constraints": [
    "1 <= dominoes.length <= 4 * 104",
    "dominoes[i].length == 2",
    "1 <= dominoes[i][j] <= 9"
  ],
  "follow_ups": [],
  "hints": [
    "For each domino j, find the number of dominoes you've already seen (dominoes i with i < j) that are equivalent.",
    "You can keep track of what you've seen using a hashmap."
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    int numEquivDominoPairs(vector<vector<int>>& dominoes) {\n        \n    }\n};",
    "java": "class Solution {\n    public int numEquivDominoPairs(int[][] dominoes) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def numEquivDominoPairs(self, dominoes):\n        \"\"\"\n        :type dominoes: List[List[int]]\n        :rtype: int\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\n        ",
    "c": "int numEquivDominoPairs(int** dominoes, int dominoesSize, int* dominoesColSize) {\n    \n}",
    "csharp": "public class Solution {\n    public int NumEquivDominoPairs(int[][] dominoes) {\n        \n    }\n}",
    "javascript": "/**\n * @param {number[][]} dominoes\n * @return {number}\n */\nvar numEquivDominoPairs = function(dominoes) {\n    \n};",
    "typescript": "function numEquivDominoPairs(dominoes: number[][]): number {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param Integer[][] $dominoes\n     * @return Integer\n     */\n    function numEquivDominoPairs($dominoes) {\n        \n    }\n}",
    "swift": "class Solution {\n    func numEquivDominoPairs(_ dominoes: [[Int]]) -> Int {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun numEquivDominoPairs(dominoes: Array<IntArray>): Int {\n        \n    }\n}",
    "dart": "class Solution {\n  int numEquivDominoPairs(List<List<int>> dominoes) {\n    \n  }\n}",
    "golang": "func numEquivDominoPairs(dominoes [][]int) int {\n    \n}",
    "ruby": "# @param {Integer[][]} dominoes\n# @return {Integer}\ndef num_equiv_domino_pairs(dominoes)\n    \nend",
    "scala": "object Solution {\n    def numEquivDominoPairs(dominoes: Array[Array[Int]]): Int = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn num_equiv_domino_pairs(dominoes: Vec<Vec<i32>>) -> i32 {\n        \n    }\n}",
    "racket": "(define/contract (num-equiv-domino-pairs dominoes)\n  (-> (listof (listof exact-integer?)) exact-integer?)\n  )",
    "erlang": "-spec num_equiv_domino_pairs(Dominoes :: [[integer()]]) -> integer().\nnum_equiv_domino_pairs(Dominoes) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec num_equiv_domino_pairs(dominoes :: [[integer]]) :: integer\n  def num_equiv_domino_pairs(dominoes) do\n    \n  end\nend"
  },
  "solution": "[TOC]\n\n## Solution\n\n--- \n\n### Approach: Tuple Representation + Counting\n\n#### Intuition\n\nIn this problem, we need to count all equivalent dominoes, where dominoes are represented by pairs. The definition of \"equivalent\" is that, under the condition of allowing the flip of two pairs, their elements correspond and are equal one by one.\n\nSo we might as well directly convert each binary pair into the specified format, that is, the first dimension must not be greater than the second dimension. Two pairs are equivalent if they contain the same two numbers, regardless of order.\n\nNoticing that the elements in the pairs are all not greater than $9$, we can concatenate each binary pair into a two-digit positive integer, i.e., $(x, y) \\to 10x + y$. In this way, there is no need to use a hash table to count the number of elements, but we can directly use an array of length $100$.\n\n#### Implementation#### Complexity Analysis\n\nLet $n$ be the number of dominoes.\n\n- Time complexity: $O(n)$\n\nWe only need to traverse the array once.\n\n- Space complexity: $O(1)$\n\nWe only need constant space to store a few variables."
}