{
  "title": "Find the Punishment Number of an Integer",
  "problem_id": "2802",
  "frontend_id": "2698",
  "difficulty": "Medium",
  "problem_slug": "find-the-punishment-number-of-an-integer",
  "topics": [
    "Math",
    "Backtracking"
  ],
  "description": "Given a positive integer n, return the punishment number of n.\nThe punishment number of n is defined as the sum of the squares of all integers i such that:\nExample 1:\nExample 2:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: n = 10\nOutput: 182\nExplanation: There are exactly 3 integers i in the range [1, 10] that satisfy the conditions in the statement:\n- 1 since 1 * 1 = 1\n- 9 since 9 * 9 = 81 and 81 can be partitioned into 8 and 1 with a sum equal to 8 + 1 == 9.\n- 10 since 10 * 10 = 100 and 100 can be partitioned into 10 and 0 with a sum equal to 10 + 0 == 10.\nHence, the punishment number of 10 is 1 + 81 + 100 = 182",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input: n = 37\nOutput: 1478\nExplanation: There are exactly 4 integers i in the range [1, 37] that satisfy the conditions in the statement:\n- 1 since 1 * 1 = 1. \n- 9 since 9 * 9 = 81 and 81 can be partitioned into 8 + 1. \n- 10 since 10 * 10 = 100 and 100 can be partitioned into 10 + 0. \n- 36 since 36 * 36 = 1296 and 1296 can be partitioned into 1 + 29 + 6.\nHence, the punishment number of 37 is 1 + 81 + 100 + 1296 = 1478",
      "images": []
    }
  ],
  "constraints": [
    "1 <= n <= 1000"
  ],
  "follow_ups": [],
  "hints": [
    "Can we generate all possible partitions of a number?",
    "Use a recursive algorithm that splits the number into two parts, generates all possible partitions of each part recursively, and then combines them in all possible ways."
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    int punishmentNumber(int n) {\n        \n    }\n};",
    "java": "class Solution {\n    public int punishmentNumber(int n) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def punishmentNumber(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def punishmentNumber(self, n: int) -> int:\n        ",
    "c": "int punishmentNumber(int n) {\n    \n}",
    "csharp": "public class Solution {\n    public int PunishmentNumber(int n) {\n        \n    }\n}",
    "javascript": "/**\n * @param {number} n\n * @return {number}\n */\nvar punishmentNumber = function(n) {\n    \n};",
    "typescript": "function punishmentNumber(n: number): number {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param Integer $n\n     * @return Integer\n     */\n    function punishmentNumber($n) {\n        \n    }\n}",
    "swift": "class Solution {\n    func punishmentNumber(_ n: Int) -> Int {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun punishmentNumber(n: Int): Int {\n        \n    }\n}",
    "dart": "class Solution {\n  int punishmentNumber(int n) {\n    \n  }\n}",
    "golang": "func punishmentNumber(n int) int {\n    \n}",
    "ruby": "# @param {Integer} n\n# @return {Integer}\ndef punishment_number(n)\n    \nend",
    "scala": "object Solution {\n    def punishmentNumber(n: Int): Int = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn punishment_number(n: i32) -> i32 {\n        \n    }\n}",
    "racket": "(define/contract (punishment-number n)\n  (-> exact-integer? exact-integer?)\n  )",
    "erlang": "-spec punishment_number(N :: integer()) -> integer().\npunishment_number(N) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec punishment_number(n :: integer) :: integer\n  def punishment_number(n) do\n    \n  end\nend"
  },
  "solution": "[TOC]\n\n## Solution\n\n---\n\n### Overview\n\nWe are given a positive integer `n`, and our task is to return its **punishment number**.  \n\nThe **punishment number** is the sum of the squares of all integers `i` that satisfy two conditions:  \n1. **Range**: `i` must be within the range `1 <= i <= n`.  \n2. **Partition**: The decimal representation of `i * i` can be partitioned into contiguous substrings such that the sum of these substrings equals `i`.  \n\nIn other words, for each integer in the range `[1, n]`, we check whether the digits of its squared value can be split so that the resulting sum matches the original number. \n\nLet's look at examples where the squared integer's digits can be partitioned as described:  \n\n![description](../Figures/2698/2698.png)  \n\nAs we can see, multiple ways exist to split the digits of a squared integer, leading to different summations. Our goal is to find at least one valid partition for each integer in the given range and sum up the squares of all numbers that satisfy the condition.\n\n---\n\n### Approach 1: Memoization\n\n#### Intuition\n\nWe need to find whether a numberâ€™s square can be split into contiguous substrings that add to the original number. If such a partition exists, we add the square to the final punishment sum. To break this down, we need to establish the core relationship: for each number `currentNum` in the range `[1, n]`, we compute its square (say `squareNum`) and check whether we can split its digits in a way that the sum of those partitions equals `currentNum`. The challenge is to explore all possible ways to partition the number while ensuring we do not perform unnecessary computations.\n\nA brute-force approach would involve generating every possible partition of `squareNum`, computing the sum for each partition, and checking if it equals `currentNum`. However, this results in exponential complexity since the number of ways to split a string grows exponentially with its length. Instead, we adopt a **recursive backtracking approach** where we attempt to build valid partitions step by step.  \n\nThe key observation is that at any given position in the string representation of `squareNum`, we can take a substring of any length starting from that position, convert it into an integer, and add it to a running sum (`sum`). If at any point `sum` exceeds `currentNum`, we stop exploring that branch early. If we reach the end of the string and `sum` equals `currentNum`, we confirm that a valid partition exists. This naturally leads to a recursive function that explores different partitioning options.  \n\nHowever, recursion alone would lead to redundant calculations. If we repeatedly attempt to partition the same substring from the same index with the same accumulated sum, we are performing unnecessary recomputation. This is where **dynamic programming (DP) with memoization** helps. We use a 2D array `memo[startIndex][sum]` to store the results of previously computed states. Here, `startIndex` represents our current position in the string, and `sum` represents the accumulated sum of selected partitions. If a state has already been computed, we can return the stored result immediately, avoiding redundant calculations.  \n\nWith this strategy in mind, we iterate through numbers from `1` to `n`, square each number, and check if it can be partitioned using the recursive function `findPartitions()`. Before each call, we reset the DP array to ensure we do not mix results across different numbers. Then, our recursive function attempts to extract substrings, add them to the sum, and continue exploring further partitions. If a valid partition is found, we add `squareNum` to our total punishment sum.  \n\n#### Algorithm\n\n1. Initialize an integer `punishmentNum`, which represents the punishment number of the range `[1, n]`.\n2. Create the `findPartitions()` function, which takes integers `startIndex`, `sum`, and `target`, a string `stringNum`, and a 2D array `memo` as parameters and returns a boolean value.\n    * If we reach the end of the string, return `true` if the `sum` of the current partition equals `target`.\n    * If the `sum` is greater than `target`, return `false`, indicating that the current permutation does not add up to `target`.\n    * If `memo[startIndex][sum]` is not `-1`, return the stored result since it has already been computed.\n    * Initialize a boolean value, `partitionFound`, to `false`.\n    * Iterate through the digits from indices `startIndex` up to the size of `stringNum`. For each index, `currIndex`:\n        * Get the substring of `stringNum` starting to the right of `currentIndex`.\n        * Recursively call `findPartitions()` to check if the summation of the current partition added to the current `sum` equals `target`.\n        * If any valid partition is found, return `true`.\n    * Memoize the result for future reference and return the result.\n3. Iterate through the integers from index `0` to `n`:\n    * For each number, `currentNum`, calculate the squared value of `currentNum` and store it as `squareNum`.\n    * Create a 2D array, `memoArray` to store all the partitions of `squareNum`, and initialize all of its values to `-1`.\n    * Input `0`, `0`, the string version of `squareNum`, `currentNum`, and `memoArray` into the function `findPartitions()` as the `startIndex`, `sum`, `stringNum`, `target`, and `memo` parameters, respectively.\n    * If `findPartitions()` returns `true`, add `currentNum` to `punishmentNum`.\n4. After all the iterations are completed, return `punishmentNum`.\n\n#### Implementation#### Complexity Analysis\n\nLet $n$ represent an integer in the range `[1, n]`.\n\n* Time Complexity: $O(n \\cdot 2^{\\log_{10}(n)})$\n\n    We iterate through $n$ integers only once. For each integer, we recursively traverse all the possible ways to split the number. The number of recursion calls is dependent on how many times we have to partition a number, `n`. This is proportional to the number of digits in the squared number, which can be calculated as ${\\log_{10}(n^2)}$, or simply $\\log_{10}(n)$.\n\n    At each digit, we are given the option to either break a partition or continue adding to the partition, giving us 2 options at each digit. The number of times we have to make this decision to exhaust all possible options is proportional to the number of digits in the squared number. As a result, this leads to a time complexity for the recursive function of $O(2^{\\log_{10}(n)})$.\n\n    Since we iterate through this process $n$ times, we multiply this time complexity by a factor of $n$. This leads to an overall time complexity of $O(n \\cdot 2^{\\log_{10}(n)})$.\n\n* Space Complexity: $O(n \\cdot {\\log_{10}(n)} + {\\log_{10}(n)})$\n\n    The space complexity is determined by the `memo` array and recursion stack. \n\n    The depth of the recursion stack is proportional to the current integer. In the worst case, a recursive call can continue until each digit is explored individually in a partition.\n\n    As a result, the maximum size of the stack is proportional to the number of digits in the squared number, which can be calculated as ${\\log_{10}(n^2)}$. This leads to a time complexity for the recursive stack of $O({\\log_{10}(n^2)})$, which can be simplified to $O({\\log_{10}(n)})$.\n\n    As for the `memo` array, its size equals the number of digits that can be explored, multiplied by the number of potential values for $n$, to store all possible permutations. As a result, this creates a space complexity of $O(n \\cdot {\\log_{10}(n)})$.\n\n    Combining these data structures, the overall space complexity of the solution is $O(n \\cdot {\\log_{10}(n)} + {\\log_{10}(n)})$\n\n---\n\n### Approach 2: Recursion of Strings\n\n#### Intuition\n\nThe primary source of memory usage in the previous solution is the `memo` array, which stores the results of all possible partitions. This array consumes significant space, but we only need to determine whether a valid partition exists for each number. This eliminates the need to track every potential partition for future reference, making it unnecessary to store intermediate results. Thus, we can reduce the overall space complexity by removing the dependency on the `memo` array.\n\nWith this realization, we can refactor the solution to rely entirely on **backtracking**. We traverse all possible substrings and attempt to add them to see if we can match the original number. As soon as we find a valid partition, we return `true` and stop further exploration. \n\nThe rest of the solution follows the same logic as the memoization approach: for each number in the range `[1, n]`, we compute its square and check if any partition of the square sums up to the number itself. If we find a valid partition, we add the square to the punishment number. \n\n#### Algorithm\n\n1. Initialize an integer `punishmentNum`, which represents the punishment number of the range `[1, num]`.\n2. Create the function `canPartition()`, which takes a string `stringNum` and an integer `target` parameter and returns a boolean value.\n    * If the string is empty and the target equals `0`, return `true`, indicating that a valid partition that adds up to the target was found.\n    * If the target is less than 0, return false, indicating that the current partition is invalid.\n    * Iterate through the string `stringNum`. For each index `index`:\n        * Let string `left` represent the substring up to `index`, and `right` represent the remainder of the string.\n        * Recursively call `canPartition()`to check if `right` can be partitioned to match `target - leftNum`.\n    * If any recursive branch of `canPartition()` returns `true`, return `true`; else return `false`.\n3. Iterate through the integers from index `0` to `num`:\n    * For each number, `currentNum`, calculate the squared value of `currentNum` and store it as `squareNum`.\n    * Input the string version of `currentNum`, and `squareNum` into the function `canPartition()` as the `num` and `target` parameters, respectively.\n    * If `canPartition()` returns `true`, add `currentNum` to `punishmentNum`.\n4. After all the iterations are completed, return `punishmentNum`.\n\n#### Implementation#### Complexity Analysis\n\nLet $n$ represent an integer in the range `[1, n]`.\n\n* Time Complexity: $O(n \\cdot 2^{\\log_{10}(n)})$\n\n    We iterate through $n$ integers only once. For each integer, we recursively traverse all the possible ways to split the number. The number of recursion calls is dependent on how many times we have to partition a number, `n`. This is proportional to the number of digits in the squared number, which can be calculated as ${\\log_{10}(n^2)}$, or simply $\\log_{10}(n)$.\n\n    At each digit, we are given the option to either break a partition or continue adding to the partition, giving us 2 options at each digit. The number of times we have to make this decision to exhaust all possible options is proportional to the number of digits in the squared number. As a result, this leads to a time complexity for the recursive function of $O(2^{\\log_{10}(n)})$.\n\n    Since we iterate through this process $n$ times, we multiply this time complexity by a factor of $n$. This leads to an overall time complexity of $O(n \\cdot 2^{\\log_{10}(n)})$. \n\n* Space Complexity: $O({\\log_{10}(n)})$\n\n    The space complexity is determined by the recursion stack. \n\n    The depth of the recursion stack is proportional to the current integer. In the worst case, a recursive call can iterate within itself when each digit is explored individually in a partition.\n\n    As a result, the max size of the stack is proportional to the number of digits in the squared number, which can be calculated as ${\\log_{10}(n^2)}$. This leads to a time complexity for the recursive stack of $O({\\log_{10}(n^2)})$, which can be simplified to $O({\\log_{10}(n)})$.\n\n---\n\n### Approach 3: Recursion of Integers\n\n#### Intuition\n\nIn the previous approaches, we used string manipulation to get the answer. Now, instead of treating the problem as a sequence of string-based substrings, we can focus on partitioning the digits of a number using integer operations. This allows us to avoid the overhead of converting numbers to strings and directly work with the numeric properties of the number.\n\nWe can use the **modulo** and **division** operations to extract different parts of a number. These operations let us break the number down into individual digits or groups of digits, which we can then use to test if their sum matches the target value.\n\nTo understand this better, let's consider an example: the number `634`. Using the modulo operation, we can extract the digits or groups of digits as follows:\n- `634 % 10 = 4` (extracts the last digit)\n- `634 % 100 = 34` (extracts the last two digits)\n- `634 % 1000 = 634` (extracts the entire number)\n\nNow, using the division operation, we can continually reduce the number by removing its rightmost digits:\n- `634 / 10 = 63` (removes the last digit)\n- `634 / 100 = 6` (removes the last two digits)\n- `634 / 1000 = 0` (number is fully reduced)\n\nBy performing these operations, we can generate permutations of the number from the rightmost side. This is a key observation: we start from the rightmost digits, using the modulo operation to extract the current part of the number and division to reduce the number progressively. When partitioning the number into its components, we want to break it down from the least significant digit (the rightmost side) to the most significant one.\n\nMore specifically, when processing from the right, we are naturally ensuring that smaller partitions (from right to left) are handled first. For instance, `634` can be partitioned as: `4`, `34`, and `634`. If we try to partition from left to right, we're forced to consider all permutations of the number starting with the largest unit (which can quickly escalate into complex cases).\n\n#### Algorithm\n\n1. Initialize an integer `punishmentNum`, which represents the punishment number of the range `[1, num]`.\n2. Create the function `canPartition()`, which takes integer parameters `num` and `target` and returns a boolean value.\n    * If `target` is less than `0` or `num` is less than `target`, return `false`, indicating that the current partition of `num` does not add up to `target`.\n    * If `num` equals `target`, return true, indicating that the current partition of `num` adds up to `target`.\n    * Otherwise, recursively check the digit combinations starting from the right side of the number to find any that make the summation equal to `target`, returning `true` if any are found.\n        * Check each possible combination of digits, removing them from `num` and subtracting them from `target`.\n        * Since `target` is bound by the constraint `1 <= num <= 1000`, we only have to check multiples of 10s, 100s, and 1000s.\n3. Iterate through the integers from index `0` to `num`:\n    * For each number, `currentNum`, calculate the squared value of `currentNum` and store it as `squareNum`.\n    * Input the `currentNum` and `squareNum` into the function `canPartition()` as the `num` and `target` parameters, respectively.\n    * If `canPartition()` returns `true`, add `currentNum` to `punishmentNum`.\n4. After all the iterations are completed, return `punishmentNum`.\n\n#### Implementation#### Complexity Analysis\n\nLet $n$ represent an integer in the range `[1, n]`.\n\n* Time Complexity: $O(n \\cdot 2^{\\log_{10}(n)})$\n\n    We iterate through $n$ integers only once. For each integer, we recursively traverse all the possible ways to split the number. The number of recursion calls is dependent on how many times we have to partition a number, `n`. This is proportional to the number of digits in the squared number, which can be calculated as ${\\log_{10}(n^2)}$, or simply $\\log_{10}(n)$.\n\n    At each digit, we are given the option to either break a partition or continue adding to the partition, giving us 2 options at each digit. The number of times we have to make this decision to exhaust all possible options is proportional to the number of digits in the squared number. As a result, this leads to a time complexity for the recursive function of $O(2^{\\log_{10}(n)})$.\n\n    Since we iterate through this process $n$ times, we multiply this time complexity by a factor of $n$. This leads to an overall time complexity of $O(n \\cdot 2^{\\log_{10}(n)})$.\n\n* Space Complexity: $O({\\log_{10}(n)})$\n\n    The space complexity is determined by the recursion stack. \n\n    The depth of the recursion stack is proportional to the current integer. In the worst case, a recursive call can iterate within itself when each digit is explored individually in a partition.\n\n    As a result, the max size of the stack is proportional to the number of digits in the squared number, which can be calculated as ${\\log_{10}(n^2)}$. This leads to a space complexity for the recursive stack of $O({\\log_{10}(n^2)})$, which can be simplified to $O({\\log_{10}(n)})$.\n    \n---"
}