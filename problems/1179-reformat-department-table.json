{
  "title": "Reformat Department Table",
  "problem_id": "1301",
  "frontend_id": "1179",
  "difficulty": "Easy",
  "problem_slug": "reformat-department-table",
  "topics": [
    "Database"
  ],
  "description": "Table: Department\nReformat the table such that there is a department id column and a revenue column for each month.\nReturn the result table in any order.\nThe result format is in the following example.\nExample 1:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| id          | int     |\n| revenue     | int     |\n| month       | varchar |\n+-------------+---------+\nIn SQL,(id, month) is the primary key of this table.\nThe table has information about the revenue of each department per month.\nThe month has values in [\"Jan\",\"Feb\",\"Mar\",\"Apr\",\"May\",\"Jun\",\"Jul\",\"Aug\",\"Sep\",\"Oct\",\"Nov\",\"Dec\"].",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input: \nDepartment table:\n+------+---------+-------+\n| id   | revenue | month |\n+------+---------+-------+\n| 1    | 8000    | Jan   |\n| 2    | 9000    | Jan   |\n| 3    | 10000   | Feb   |\n| 1    | 7000    | Feb   |\n| 1    | 6000    | Mar   |\n+------+---------+-------+\nOutput: \n+------+-------------+-------------+-------------+-----+-------------+\n| id   | Jan_Revenue | Feb_Revenue | Mar_Revenue | ... | Dec_Revenue |\n+------+-------------+-------------+-------------+-----+-------------+\n| 1    | 8000        | 7000        | 6000        | ... | null        |\n| 2    | 9000        | null        | null        | ... | null        |\n| 3    | null        | 10000       | null        | ... | null        |\n+------+-------------+-------------+-------------+-----+-------------+\nExplanation: The revenue from Apr to Dec is null.\nNote that the result table has 13 columns (1 for the department id + 12 for the months).",
      "images": []
    }
  ],
  "constraints": [],
  "follow_ups": [],
  "hints": [],
  "code_snippets": {
    "mysql": "# Write your MySQL query statement below\n",
    "mssql": "/* Write your T-SQL query statement below */\n",
    "oraclesql": "/* Write your PL/SQL query statement below */\n",
    "pythondata": "import pandas as pd\n\ndef reformat_table(department: pd.DataFrame) -> pd.DataFrame:\n    ",
    "postgresql": "-- Write your PostgreSQL query statement below\n"
  },
  "solution": "[TOC]\n\n## Solution\n\n---\n\n### Overview\n\n> **Problem reference:** Reformat the table by creating all month columns to represent `revenue` of each month for each `id`. If the `revenue` for the specific month is `null`, the value also would be `null`. Return the result table in any order.\n\nFrom the output table, we need to create columns representing January to December. Then, group by the `id` to represent each month's `revenue`. We call this result a **pivot table**. **Pivot** is a technique to rotate the data as columns and to show the aggregated data grouped by these reformatted columns.\n\n---\n\n### Approach 1: `GROUP BY` with a conditional statement in the aggregate function\n\n#### Intuition\n\nWe need to group the table with the `id` field because we want to know each month's `revenue` for each `id`. Also, we should use the aggregate function after grouping the table to choose the value to display. For instance, if the table looks like the one below, and if we use `GROUP BY` to group the table by `id` field, it raises an error because the database management system (DBMS) does not know which `revenue` data would be displayed because there are two `revenue` data `8000` and `6000`.\n\n```\n+------+---------+\n| id   | revenue |\n+------+---------+\n| 1    | 8000    |\n| 1    | 6000    |\n+------+---------+\n```\n\nIn this problem, we can separate each month using the conditional function in the aggregate function. For instance, if the `month` field is `\"Jan\"`, we could return the `revenue` field for January's revenue, and if not, we could return `null`. In this process, there could be more than one `null` data for each month.\n\nFor example, if we separate the month of example table with using conditional function, the result looks like the below.\n\n```\n+------+-------------+-------------+-------------+------+-------------+\n| id   | Jan_Revenue | Feb_Revenue | Mar_Revenue | ...  | Dec_Revenue |\n+------+-------------+-------------+-------------+------+-------------+\n| 1    | 8000        | null        | null        | ...  | null        |\n| 1    | null        | 7000        | null        | ...  | null        |\n| 1    | null        | null        | 6000        | ...  | null        |\n| 2    | 9000        | null        | 6000        | ...  | null        |\n| 3    | null        | 10000       | 6000        | ...  | null        |\n+------+-------------+-------------+-------------+------+-------------+\n```\n\nAs we can see, there are a lot of rows with `id = 1`. But we only need **not** `null` value for each month. An aggregate function can help us reduce them to only one row for each id.\n\nAs the table description, the group of (`id`, `month`) is the primary key. Hence, we know there could not be more than two valid `revenue` values for each month of each `id`, and we could get a `revenue` for each month by using aggregate function such as `SUM`, `MAX` or `MIN` because these functions ignore the `null` values.\n\n#### Algorithm\n\n1. Use `GROUP BY` to group the table by `id`.\n2. Create each month with the aggregate function and inner conditional function.\n\n#### Implementation\n\n##### MySQL\n\n```sql\nSELECT\n  id,\n  SUM(IF (month = \"Jan\", revenue, null)) AS Jan_Revenue,\n  SUM(IF (month = \"Feb\", revenue, null)) AS Feb_Revenue,\n  SUM(IF (month = \"Mar\", revenue, null)) AS Mar_Revenue,\n  SUM(IF (month = \"Apr\", revenue, null)) AS Apr_Revenue,\n  SUM(IF (month = \"May\", revenue, null)) AS May_Revenue,\n  SUM(IF (month = \"Jun\", revenue, null)) AS Jun_Revenue,\n  SUM(IF (month = \"Jul\", revenue, null)) AS Jul_Revenue,\n  SUM(IF (month = \"Aug\", revenue, null)) AS Aug_Revenue,\n  SUM(IF (month = \"Sep\", revenue, null)) AS Sep_Revenue,\n  SUM(IF (month = \"Oct\", revenue, null)) AS Oct_Revenue,\n  SUM(IF (month = \"Nov\", revenue, null)) AS Nov_Revenue,\n  SUM(IF (month = \"Dec\", revenue, null)) AS Dec_Revenue\nFROM\n  Department\nGROUP BY\n  id;\n```\n\n**Note:** We can use other aggregate functions to choose the `revenue` as we said the above. Also, we can use `CASE` or `IFNULL` function for the inner conditional function instead of `IF`, like one the below.\n\n```sql\nSELECT\n  id,\n  MIN(\n    CASE\n      WHEN month = \"Jan\" THEN revenue\n    END\n  ) AS Jan_Revenue,\n  ...\nFROM\n  Department\nGROUP BY\n  id;\n```\n\n### Approach 2: `LEFT JOIN`\n\n#### Intuition\n\nThis approach is inspired by [MSSQL Multiple joins, GroupBy and Pivot table solutions](https://leetcode.com/problems/reformat-department-table/discuss/382960/MSSQL-Multiple-joins-GroupBy-and-Pivot-table-solutions) authored by pogodin.\n\nWe can also join each month to the distinct `id` table. There could not be more than two joined columns because the group of (`id`, `month`) is the primary key. Thus, we do not need to group the table after using join. However, we need to use `LEFT OUTER JOIN`, not `INNER JOIN`, to display the `null` value, which means there is no revenue for that month. We can separate each month with `LEFT JOIN` and an `AS` keyword, which renames the table.\n\n#### Algorithm\n\n1. Create a temporary distinct `id` table with a subquery.\n2. Use `LEFT JOIN` to join each month to the distinct `id` table from January to December.\n\n#### Implementation\n\n##### MySQL\n\n```sql\nSELECT\n  Ids.id,\n  January.revenue AS Jan_Revenue,\n  Feburary.revenue AS Feb_Revenue,\n  March.revenue AS Mar_Revenue,\n  April.revenue AS Apr_Revenue,\n  May.revenue AS May_Revenue,\n  June.revenue AS Jun_Revenue,\n  July.revenue AS Jul_Revenue,\n  August.revenue AS Aug_Revenue,\n  September.revenue AS Sep_Revenue,\n  October.revenue AS Oct_Revenue,\n  November.revenue AS Nov_Revenue,\n  December.revenue AS Dec_Revenue\nFROM\n  (\n    SELECT DISTINCT\n      id\n    FROM\n      Department\n  ) AS Ids\n  LEFT JOIN Department AS January ON (\n    Ids.id = January.id\n    AND January.month = \"Jan\"\n  )\n  LEFT JOIN Department AS Feburary ON (\n    Ids.id = Feburary.id\n    AND Feburary.month = \"Feb\"\n  )\n  LEFT JOIN Department AS March ON (\n    Ids.id = March.id\n    AND March.month = \"Mar\"\n  )\n  LEFT JOIN Department AS April ON (\n    Ids.id = April.id\n    AND April.month = \"Apr\"\n  )\n  LEFT JOIN Department AS May ON (\n    Ids.id = May.id\n    AND May.month = \"May\"\n  )\n  LEFT JOIN Department AS June ON (\n    Ids.id = June.id\n    AND June.month = \"Jun\"\n  )\n  LEFT JOIN Department AS July ON (\n    Ids.id = July.id\n    AND July.month = \"Jul\"\n  )\n  LEFT JOIN Department AS August ON (\n    Ids.id = August.id\n    AND August.month = \"Aug\"\n  )\n  LEFT JOIN Department AS September ON (\n    Ids.id = September.id\n    AND September.month = \"Sep\"\n  )\n  LEFT JOIN Department AS October ON (\n    Ids.id = October.id\n    AND October.month = \"Oct\"\n  )\n  LEFT JOIN Department AS November ON (\n    Ids.id = November.id\n    AND November.month = \"Nov\"\n  )\n  LEFT JOIN Department AS December ON (\n    Ids.id = December.id\n    AND December.month = \"Dec\"\n  );\n```\n\n---\n\n### Conclusion\n\nWe recommend [Approach 1](#approach-1-group-by-with-a-conditional-statement-in-the-aggregate-function) due to its simplicity and performance.\n\nIf you use `JOIN` multiple times, like [Approach 2](#approach-2-left-join), the DBMS should check the tables as much as you use `JOIN`. However, if you use `GROUP BY`, it just check the table and group it once.\n\nIf you use the `EXPLAIN` keyword in front of each query to check how the DBMS works, you can compare how many rows as it needs to check to make a result. [Approach 1](#approach-1-group-by-with-a-conditional-statement-in-the-aggregate-function) takes 5 rows to make a result table with the example table. However, [Approach 2](#approach-2-left-join) takes 5 rows with every `JOIN` clause, which means it takes more than 60 rows to check because we use `JOIN` for every month, 12 times."
}