{
  "title": "Flip Equivalent Binary Trees",
  "problem_id": "988",
  "frontend_id": "951",
  "difficulty": "Medium",
  "problem_slug": "flip-equivalent-binary-trees",
  "topics": [
    "Tree",
    "Depth-First Search",
    "Binary Tree"
  ],
  "description": "For a binary tree T, we can define a flip operation as follows: choose any node, and swap the left and right child subtrees.\nA binary tree X is flip equivalent to a binary tree Y if and only if we can make X equal to Y after some number of flip operations.\nGiven the roots of two binary trees root1 and root2, return true if the two trees are flip equivalent or false otherwise.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: root1 = [1,2,3,4,5,6,null,null,null,7,8], root2 = [1,3,2,null,6,4,5,null,null,null,null,8,7]\nOutput: true\nExplanation: We flipped at nodes with values 1, 3, and 5.",
      "images": [
        "https://assets.leetcode.com/uploads/2018/11/29/tree_ex.png"
      ]
    },
    {
      "example_num": 2,
      "example_text": "Input: root1 = [], root2 = []\nOutput: true",
      "images": [
        "https://assets.leetcode.com/uploads/2018/11/29/tree_ex.png"
      ]
    },
    {
      "example_num": 3,
      "example_text": "Input: root1 = [], root2 = [1]\nOutput: false",
      "images": [
        "https://assets.leetcode.com/uploads/2018/11/29/tree_ex.png"
      ]
    }
  ],
  "constraints": [
    "The number of nodes in each tree is in the range [0, 100].",
    "Each tree will have unique node values in the range [0, 99]."
  ],
  "follow_ups": [],
  "hints": [],
  "code_snippets": {
    "cpp": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    bool flipEquiv(TreeNode* root1, TreeNode* root2) {\n        \n    }\n};",
    "java": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public boolean flipEquiv(TreeNode root1, TreeNode root2) {\n        \n    }\n}",
    "python": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def flipEquiv(self, root1, root2):\n        \"\"\"\n        :type root1: Optional[TreeNode]\n        :type root2: Optional[TreeNode]\n        :rtype: bool\n        \"\"\"\n        ",
    "python3": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def flipEquiv(self, root1: Optional[TreeNode], root2: Optional[TreeNode]) -> bool:\n        ",
    "c": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     struct TreeNode *left;\n *     struct TreeNode *right;\n * };\n */\nbool flipEquiv(struct TreeNode* root1, struct TreeNode* root2) {\n    \n}",
    "csharp": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public int val;\n *     public TreeNode left;\n *     public TreeNode right;\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\npublic class Solution {\n    public bool FlipEquiv(TreeNode root1, TreeNode root2) {\n        \n    }\n}",
    "javascript": "/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root1\n * @param {TreeNode} root2\n * @return {boolean}\n */\nvar flipEquiv = function(root1, root2) {\n    \n};",
    "typescript": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nfunction flipEquiv(root1: TreeNode | null, root2: TreeNode | null): boolean {\n    \n};",
    "php": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     public $val = null;\n *     public $left = null;\n *     public $right = null;\n *     function __construct($val = 0, $left = null, $right = null) {\n *         $this->val = $val;\n *         $this->left = $left;\n *         $this->right = $right;\n *     }\n * }\n */\nclass Solution {\n\n    /**\n     * @param TreeNode $root1\n     * @param TreeNode $root2\n     * @return Boolean\n     */\n    function flipEquiv($root1, $root2) {\n        \n    }\n}",
    "swift": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public var val: Int\n *     public var left: TreeNode?\n *     public var right: TreeNode?\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\n *         self.val = val\n *         self.left = left\n *         self.right = right\n *     }\n * }\n */\nclass Solution {\n    func flipEquiv(_ root1: TreeNode?, _ root2: TreeNode?) -> Bool {\n        \n    }\n}",
    "kotlin": "/**\n * Example:\n * var ti = TreeNode(5)\n * var v = ti.`val`\n * Definition for a binary tree node.\n * class TreeNode(var `val`: Int) {\n *     var left: TreeNode? = null\n *     var right: TreeNode? = null\n * }\n */\nclass Solution {\n    fun flipEquiv(root1: TreeNode?, root2: TreeNode?): Boolean {\n        \n    }\n}",
    "dart": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *   int val;\n *   TreeNode? left;\n *   TreeNode? right;\n *   TreeNode([this.val = 0, this.left, this.right]);\n * }\n */\nclass Solution {\n  bool flipEquiv(TreeNode? root1, TreeNode? root2) {\n    \n  }\n}",
    "golang": "/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\nfunc flipEquiv(root1 *TreeNode, root2 *TreeNode) bool {\n    \n}",
    "ruby": "# Definition for a binary tree node.\n# class TreeNode\n#     attr_accessor :val, :left, :right\n#     def initialize(val = 0, left = nil, right = nil)\n#         @val = val\n#         @left = left\n#         @right = right\n#     end\n# end\n# @param {TreeNode} root1\n# @param {TreeNode} root2\n# @return {Boolean}\ndef flip_equiv(root1, root2)\n    \nend",
    "scala": "/**\n * Definition for a binary tree node.\n * class TreeNode(_value: Int = 0, _left: TreeNode = null, _right: TreeNode = null) {\n *   var value: Int = _value\n *   var left: TreeNode = _left\n *   var right: TreeNode = _right\n * }\n */\nobject Solution {\n    def flipEquiv(root1: TreeNode, root2: TreeNode): Boolean = {\n        \n    }\n}",
    "rust": "// Definition for a binary tree node.\n// #[derive(Debug, PartialEq, Eq)]\n// pub struct TreeNode {\n//   pub val: i32,\n//   pub left: Option<Rc<RefCell<TreeNode>>>,\n//   pub right: Option<Rc<RefCell<TreeNode>>>,\n// }\n// \n// impl TreeNode {\n//   #[inline]\n//   pub fn new(val: i32) -> Self {\n//     TreeNode {\n//       val,\n//       left: None,\n//       right: None\n//     }\n//   }\n// }\nuse std::rc::Rc;\nuse std::cell::RefCell;\nimpl Solution {\n    pub fn flip_equiv(root1: Option<Rc<RefCell<TreeNode>>>, root2: Option<Rc<RefCell<TreeNode>>>) -> bool {\n        \n    }\n}",
    "racket": "; Definition for a binary tree node.\n#|\n\n; val : integer?\n; left : (or/c tree-node? #f)\n; right : (or/c tree-node? #f)\n(struct tree-node\n  (val left right) #:mutable #:transparent)\n\n; constructor\n(define (make-tree-node [val 0])\n  (tree-node val #f #f))\n\n|#\n\n(define/contract (flip-equiv root1 root2)\n  (-> (or/c tree-node? #f) (or/c tree-node? #f) boolean?)\n  )",
    "erlang": "%% Definition for a binary tree node.\n%%\n%% -record(tree_node, {val = 0 :: integer(),\n%%                     left = null  :: 'null' | #tree_node{},\n%%                     right = null :: 'null' | #tree_node{}}).\n\n-spec flip_equiv(Root1 :: #tree_node{} | null, Root2 :: #tree_node{} | null) -> boolean().\nflip_equiv(Root1, Root2) ->\n  .",
    "elixir": "# Definition for a binary tree node.\n#\n# defmodule TreeNode do\n#   @type t :: %__MODULE__{\n#           val: integer,\n#           left: TreeNode.t() | nil,\n#           right: TreeNode.t() | nil\n#         }\n#   defstruct val: 0, left: nil, right: nil\n# end\n\ndefmodule Solution do\n  @spec flip_equiv(root1 :: TreeNode.t | nil, root2 :: TreeNode.t | nil) :: boolean\n  def flip_equiv(root1, root2) do\n    \n  end\nend"
  },
  "solution": "[TOC]\n\n## Solution\n\n---\n\n### Overview\n\nWe are given the roots of two [binary trees](https://leetcode.com/explore/learn/card/data-structure-tree/) and we are asked to determine whether they are flip equivalent. To clarify, let’s break down the two key terms involved:\n\n1. Flip Operation:\n\nA flip operation involves selecting any node in the tree and swapping its left and right subtrees. The node's value and the internal structure of its subtrees remain unchanged. The only modification is that the positions of the node's direct children are swapped.\n\nFor example, consider the tree below. The tree on the left shows the initial structure, and the tree on the right shows the result after performing a flip on node 1.\n\n![Flip operation example](../Figures/951/951_flip_operation_example.png)\n\n2. Equivalent Trees:\n\nTwo binary trees are considered equivalent if they satisfy the following conditions:\n\n-   Same structure: The arrangement of nodes and their subtrees (left and right) are identical.\n-   Same node values: Every corresponding node in both trees has the same value.\n\nIn this context, we want to determine whether two given binary trees can become equivalent by applying flip operations as needed.\n\n---\n\n### Approach 1: Recursion (Top-down Traversal)\n\n#### Intuition\n\nSince binary trees are inherently recursive structures, a recursive approach is intuitive.\n\nFor each node, we have two possible options: either we swap its left and right subtrees, or we leave them as they are. We explore both possibilities for every node, starting from the root. If any sequence of flips results in the two trees becoming equivalent, our function will return `true`, indicating that the trees are flip equivalent. If no valid sequence leads to equivalence, the function returns `false`.\n\n#### Algorithm\n\n-   If both `root1` and `root2` are empty trees, they are considered flip equivalent according to the definition provided; return true.\n-   If only one of `root1` or `root2` is empty, they are **not** flip equivalent, as they do not satisfy the structural property of equivalence; return false.\n-   If `root1` and `root2` have different node values, the trees are **not** flip equivalent, since this means their corresponding nodes differ; return false.\n\n-   Recursively check two scenarios for flip equivalence:\n\n    -   No Swap: Check if the left subtree of `root1` is flip equivalent to the left subtree of `root2` and the right subtree of `root1` is flip equivalent to the right subtree of `root2`.\n    -   Swap: Check if the left subtree of `root1` is flip equivalent to the right subtree of `root2` and the right subtree of `root1` is flip equivalent to the left subtree of `root2`.\n\n-   Return `true` if either the `noSwap` or `swap` conditions are satisfied, as this confirms flip equivalence for the current nodes and their subtrees.\n\n#### Implementation#### Complexity Analysis\n\nLet $N$ be the number of nodes in the smaller tree.\n\n-   Time Complexity: $O(N)$.\n\n    This is because the recursion stops at the leaf nodes or when a mismatch occurs. In the worst case, every node in the smaller tree will be visited.\n\n-   Space Complexity: $O(N)$.\n\n    This is due to the recursion stack. In the worst case, the recursion goes as deep as the tree's height, which can be $O(N)$ in the case of a skewed tree (a tree in which every internal node has only one child). For a balanced tree, the space complexity will be $O(\\log N)$ because the tree's height would be logarithmic relative to the number of nodes.\n\n---\n\n### Approach 2: Iterative DFS (using a Stack)\n\n#### Intuition\n\nWhile a recursive method is intuitive, it can lead to issues such as stack overflow for very deep trees.\n\nBy using an iterative DFS approach with a stack, we can simulate the recursive process while maintaining control over the stack size. The idea is to push pairs of nodes onto the stack and evaluate their equivalence in a structured manner, ultimately determining if the trees can be made equivalent through flips.\n\n#### Algorithm\n\n-   Define a helper function `checkNodeValues` to verify if two nodes should be considered equivalent:\n    -   If both `node1` and `node2` are `nullptr`, return `true`.\n    -   If both nodes are not `nullptr` and their values match, return `true`.\n    -   Otherwise, return `false`.\n-   In the `flipEquiv` main function:\n    -   Initialize a stack `s` to store pairs of nodes (`node1`, `node2`) from `root1` and `root2`.\n    -   Push the root nodes of both trees onto the stack.\n-   While the stack is not empty:\n    -   Pop the top pair of nodes from the stack.\n    -   If both `node1` and `node2` are `nullptr`, continue to the next iteration.\n    -   If only one of the nodes is `nullptr`, return `false` (trees are not equivalent).\n    -   If the values of `node1` and `node2` do not match, return `false`.\n    -   Check both configurations for equivalence:\n        -   If the left child of `node1` matches the left child of `node2` and the right child of `node1` matches the right child of `node2`, push these pairs onto the stack for further examination.\n        -   If the left child of `node1` matches the right child of `node2` and the right child of `node1` matches the left child of `node2`, push these pairs onto the stack.\n    -   If neither configuration is satisfied, return `false`.\n-   If the stack is emptied without returning `false`, return `true`, indicating that the two trees are flip equivalent.\n\n#### Implementation#### Complexity Analysis\n\nLet $N$ be the number of nodes in the smaller tree.\n\n-   Time Complexity: $O(N)$.\n\n    Each node in the smaller tree will enter the stack at most twice (one with swap and one without). Therefore, the loop will run $O(N)$ times. Since the operations within the loop have a constant time complexity of $O(1)$, the overall time complexity is $O(N)$.\n\n-   Space Complexity: $O(N)$.\n\n    The size of the stack can reach at most twice the number of nodes in the smaller tree, as each node can be pushed onto the stack in up to two configurations.\n\n---\n\n### Approach 3: Canonical Forms\n\n#### Intuition\n\nWe observe that the choice of tree for the flip operation does not affect the outcome. In fact, we can simultaneously perform flips on both trees to check for flip equivalence, and the result will remain unchanged.\n\nThis raises the question: what if we could apply flip operations to transform each tree into a standardized format that makes it easier to determine whether they are equivalent? This idea underpins the solution for determining flip equivalent binary trees using their canonical forms.\n\n##### Canonical Form of a Binary Tree\n\nA binary tree is in its canonical form if, for each node, one of the following conditions holds:\n\n-   The node has no children.\n-   The node has only a left child.\n-   The left child's value is greater than the right child's value.\n\nInterestingly, it turns out that two binary trees are flip-equivalent if and only if they have the same canonical form.\n\n#### Algorithm\n\n-   `findCanonicalForm(TreeNode* root)` function:\n    -   If `root` is null, return immediately (base case).\n    -   Perform a post-order traversal:\n        -   Recursively call `findCanonicalForm` on `root->left`.\n        -   Recursively call `findCanonicalForm` on `root->right`.\n    -   If `root->right` is null, return as no further action is required.\n    -   If `root->left` is null, swap `root->left` and `root->right`, then set `root->right` to null to ensure `root->left` is non-empty. No further action is required; return.\n    -   If both `left` and `right` are non-null, swap them if `left->val` is greater than `right->val` to place them in a canonical order.\n-   `areEquivalent(TreeNode* root1, TreeNode* root2)` function:\n\n    -   If both `root1` and `root2` are null, return `true` (both trees are equivalent).\n    -   If one is null and the other is not, return `false` (they are not equivalent).\n    -   If the values of `root1` and `root2` are different, return `false` (they are not equivalent).\n    -   Recursively call `areEquivalent` for `root1->left` and `root2->left`, and for `root1->right` and `root2->right`, returning `true` only if both subtrees are equivalent.\n\n-   `flipEquiv(TreeNode* root1, TreeNode* root2)` function:\n    -   Call `findCanonicalForm` on `root1` to convert it to its canonical form.\n    -   Call `findCanonicalForm` on `root2` to convert it to its canonical form.\n    -   Return the result of `areEquivalent(root1, root2)` to determine if the two trees are equivalent.\n\n#### Implementation#### Complexity Analysis\n\nLet $N$ be the number of nodes in the bigger tree.\n\n-   Time Complexity: $O(N)$.\n\n    The `findCanonicalForm` function processes each node in the tree exactly once, and since its inner operations, such as comparisons and swaps, have constant time complexity, the overall time complexity of this function is $O(N)$.\n\n    Similarly, the `areEquivalent` function performs a depth-first search (DFS) on both trees, also visiting each node once. Therefore, its time complexity is $O(N)$.\n\n    As both functions run independently and sequentially, the overall time complexity of the algorithm remains $O(N)$.\n\n-   Space Complexity: $O(N)$.\n\n    This is due to the recursion stack. In the worst case, the recursion goes as deep as the height of the tree, which can be $O(N)$ in the case of a skewed tree (a tree in which every internal node has only one child). For a balanced tree, the space complexity will be $O(\\log N)$ because the height of the tree would be logarithmic relative to the number of nodes.\n\n---"
}