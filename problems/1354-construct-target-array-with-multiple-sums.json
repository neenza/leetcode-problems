{
  "title": "Construct Target Array With Multiple Sums",
  "problem_id": "1479",
  "frontend_id": "1354",
  "difficulty": "Hard",
  "problem_slug": "construct-target-array-with-multiple-sums",
  "topics": [
    "Array",
    "Heap (Priority Queue)"
  ],
  "description": "You are given an array target of n integers. From a starting array arr consisting of n 1's, you may perform the following procedure :\nReturn true if it is possible to construct the target array from arr, otherwise, return false.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: target = [9,3,5]\nOutput: true\nExplanation: Start with arr = [1, 1, 1] \n[1, 1, 1], sum = 3 choose index 1\n[1, 3, 1], sum = 5 choose index 2\n[1, 3, 5], sum = 9 choose index 0\n[9, 3, 5] Done",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input: target = [1,1,1,2]\nOutput: false\nExplanation: Impossible to create target array from [1,1,1,1].",
      "images": []
    },
    {
      "example_num": 3,
      "example_text": "Input: target = [8,5]\nOutput: true",
      "images": []
    }
  ],
  "constraints": [
    "n == target.length",
    "1 <= n <= 5 * 104",
    "1 <= target[i] <= 109"
  ],
  "follow_ups": [],
  "hints": [
    "Given that the sum is strictly increasing, the largest element in the target must be formed in the last step by adding the total sum in the previous step. Thus, we can simulate the process in a reversed way.",
    "Subtract the largest with the rest of the array, and put the new element into the array. Repeat until all elements become one"
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    bool isPossible(vector<int>& target) {\n        \n    }\n};",
    "java": "class Solution {\n    public boolean isPossible(int[] target) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def isPossible(self, target):\n        \"\"\"\n        :type target: List[int]\n        :rtype: bool\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def isPossible(self, target: List[int]) -> bool:\n        ",
    "c": "bool isPossible(int* target, int targetSize) {\n    \n}",
    "csharp": "public class Solution {\n    public bool IsPossible(int[] target) {\n        \n    }\n}",
    "javascript": "/**\n * @param {number[]} target\n * @return {boolean}\n */\nvar isPossible = function(target) {\n    \n};",
    "typescript": "function isPossible(target: number[]): boolean {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param Integer[] $target\n     * @return Boolean\n     */\n    function isPossible($target) {\n        \n    }\n}",
    "swift": "class Solution {\n    func isPossible(_ target: [Int]) -> Bool {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun isPossible(target: IntArray): Boolean {\n        \n    }\n}",
    "dart": "class Solution {\n  bool isPossible(List<int> target) {\n    \n  }\n}",
    "golang": "func isPossible(target []int) bool {\n    \n}",
    "ruby": "# @param {Integer[]} target\n# @return {Boolean}\ndef is_possible(target)\n    \nend",
    "scala": "object Solution {\n    def isPossible(target: Array[Int]): Boolean = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn is_possible(target: Vec<i32>) -> bool {\n        \n    }\n}",
    "racket": "(define/contract (is-possible target)\n  (-> (listof exact-integer?) boolean?)\n  )",
    "erlang": "-spec is_possible(Target :: [integer()]) -> boolean().\nis_possible(Target) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec is_possible(target :: [integer]) :: boolean\n  def is_possible(target) do\n    \n  end\nend"
  }
}