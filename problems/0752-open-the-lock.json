{
  "title": "Open the Lock",
  "problem_id": "753",
  "frontend_id": "752",
  "difficulty": "Medium",
  "problem_slug": "open-the-lock",
  "topics": [
    "Array",
    "Hash Table",
    "String",
    "Breadth-First Search"
  ],
  "description": "You have a lock in front of you with 4 circular wheels. Each wheel has 10 slots: '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'. The wheels can rotate freely and wrap around: for example we can turn '9' to be '0', or '0' to be '9'. Each move consists of turning one wheel one slot.\nThe lock initially starts at '0000', a string representing the state of the 4 wheels.\nYou are given a list of deadends dead ends, meaning if the lock displays any of these codes, the wheels of the lock will stop turning and you will be unable to open it.\nGiven a target representing the value of the wheels that will unlock the lock, return the minimum total number of turns required to open the lock, or -1 if it is impossible.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: deadends = [\"0201\",\"0101\",\"0102\",\"1212\",\"2002\"], target = \"0202\"\nOutput: 6\nExplanation: \nA sequence of valid moves would be \"0000\" -> \"1000\" -> \"1100\" -> \"1200\" -> \"1201\" -> \"1202\" -> \"0202\".\nNote that a sequence like \"0000\" -> \"0001\" -> \"0002\" -> \"0102\" -> \"0202\" would be invalid,\nbecause the wheels of the lock become stuck after the display becomes the dead end \"0102\".",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input: deadends = [\"8888\"], target = \"0009\"\nOutput: 1\nExplanation: We can turn the last wheel in reverse to move from \"0000\" -> \"0009\".",
      "images": []
    },
    {
      "example_num": 3,
      "example_text": "Input: deadends = [\"8887\",\"8889\",\"8878\",\"8898\",\"8788\",\"8988\",\"7888\",\"9888\"], target = \"8888\"\nOutput: -1\nExplanation: We cannot reach the target without getting stuck.",
      "images": []
    }
  ],
  "constraints": [
    "1 <= deadends.length <= 500",
    "deadends[i].length == 4",
    "target.length == 4",
    "target will not be in the list deadends.",
    "target and deadends[i] consist of digits only."
  ],
  "follow_ups": [],
  "hints": [
    "We can think of this problem as a shortest path problem on a graph: there are `10000` nodes (strings `'0000'` to `'9999'`), and there is an edge between two nodes if they differ in one digit, that digit differs by 1 (wrapping around, so `'0'` and `'9'` differ by 1), and if *both* nodes are not in `deadends`."
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    int openLock(vector<string>& deadends, string target) {\n        \n    }\n};",
    "java": "class Solution {\n    public int openLock(String[] deadends, String target) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def openLock(self, deadends, target):\n        \"\"\"\n        :type deadends: List[str]\n        :type target: str\n        :rtype: int\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def openLock(self, deadends: List[str], target: str) -> int:\n        ",
    "c": "int openLock(char** deadends, int deadendsSize, char* target) {\n    \n}",
    "csharp": "public class Solution {\n    public int OpenLock(string[] deadends, string target) {\n        \n    }\n}",
    "javascript": "/**\n * @param {string[]} deadends\n * @param {string} target\n * @return {number}\n */\nvar openLock = function(deadends, target) {\n    \n};",
    "typescript": "function openLock(deadends: string[], target: string): number {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param String[] $deadends\n     * @param String $target\n     * @return Integer\n     */\n    function openLock($deadends, $target) {\n        \n    }\n}",
    "swift": "class Solution {\n    func openLock(_ deadends: [String], _ target: String) -> Int {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun openLock(deadends: Array<String>, target: String): Int {\n        \n    }\n}",
    "dart": "class Solution {\n  int openLock(List<String> deadends, String target) {\n    \n  }\n}",
    "golang": "func openLock(deadends []string, target string) int {\n    \n}",
    "ruby": "# @param {String[]} deadends\n# @param {String} target\n# @return {Integer}\ndef open_lock(deadends, target)\n    \nend",
    "scala": "object Solution {\n    def openLock(deadends: Array[String], target: String): Int = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn open_lock(deadends: Vec<String>, target: String) -> i32 {\n        \n    }\n}",
    "racket": "(define/contract (open-lock deadends target)\n  (-> (listof string?) string? exact-integer?)\n  )",
    "erlang": "-spec open_lock(Deadends :: [unicode:unicode_binary()], Target :: unicode:unicode_binary()) -> integer().\nopen_lock(Deadends, Target) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec open_lock(deadends :: [String.t], target :: String.t) :: integer\n  def open_lock(deadends, target) do\n    \n  end\nend"
  },
  "solution": "[TOC]\n\n## Solution\n\n---\n\n### Overview \n\nFor simplicity, let's say any combination of any state of all wheels represents one lock combination. e.g. `'0000', '1000', '2000', ... ` etc. all represent a lock combination.   \n\nSay we are currently at combination `'0000'`, and we make one wheel turn. Now we are at combination `1000`. This combination change due to one wheel turn can be visualized as traversing a graph from node 1 (`combination '0000'`) to node 2 (`combination '1000'`).  \n\nIt can be better understood with the help of the following image:\n\n![graph_visalization](../Figures/752/Slide1.jpg)\n\nIn this graph, each node represents a lock combination, and the edge represents one wheel turn.    \n\nAccording to the problem statement, we start from the lock combination `'0000'`. We can make one wheel turn at a time and need to find the minimum steps required to reach the target lock combination.\n\nAs we observed, each lock combination is a graph's node, and each wheel turn is an edge connecting two nodes. The given problem statement can be re-worded as: \"We start from node `lock combination '0000'` and have to find the minimum number of edges to traverse to reach the target lock combination node.\" Thus, the given problem can be converted into a graph traversal problem. \n\n\nTo traverse nodes in a graph, we mainly utilize two algorithms: depth-first search (DFS), and breadth-first search (BFS). If you are new to these algorithms we recommend reading our [Depth-First Search](https://leetcode.com/explore/learn/card/graph/619/depth-first-search-in-graph/3882/) and [Breadth-First Search](https://leetcode.com/explore/learn/card/graph/620/breadth-first-search-in-graph/3883/) explore cards.\n\nWe can solve this problem using both traversals, but given the constraints, the depth-first search will result in a TLE. This is because DFS explores as deeply as possible along each branch before backtracking. It doesn't necessarily explore nodes in any particular order; it might go deep into a branch before exploring other branches.      \n\nBFS is well-suited for finding the shortest path in unweighted graphs, which makes it a good fit for this problem because BFS explores nodes level by level. It starts from the source node and explores all its neighbors before moving on to the next level of neighbors. Due to its level-order exploration strategy, BFS guarantees that the first time it reaches a node, it has found the shortest path to that node.\n\n![dfs_vs_bfs](../Figures/752/Slide2.jpg)**Note:** Being familiar with level-order traversal using breadth-first search will help you solve this problem. If you need to brush up, you can practice these LeetCode problems first:\n- [102. Binary Tree Level Order Traversal](https://leetcode.com/problems/binary-tree-level-order-traversal/) \n- [429. N-ary Tree Level Order Traversal](https://leetcode.com/problems/n-ary-tree-level-order-traversal/) \n- [637. Average of Levels in Binary Tree](https://leetcode.com/problems/average-of-levels-in-binary-tree/) \n\n---\n\n### Approach: Breadth-First Search\n\n#### Intuition  \n\nWe will keep a queue, `pending_combinations`, containing the lock combinations yet to be visited using BFS.    \nInitially, it will contain the starting combination `'0000'`.\n\nWe will visit each combination stored in the queue one by one. If the current popped combination is the target combination, we will return the number of edges traversed (number of wheel turns we made) to reach this combination. BFS guarantees the shortest path in an unweighted graph, so as soon as we find an answer, we know it is the optimal one.     \nOtherwise, we will generate new combinations from the current combination, by rotating each of the four wheels to the next slot digit and the previous slot digit one by one. Then we will push the new combinations into the queue.\n\n![wheel_turn](../Figures/752/Slide3.jpg)\n\nWe will keep two additional data structures to quickly fetch the next and the previous slot digits for the current slot digits whenever needed.Notice that we might reach the same lock combinations, again and again, using different paths, and these duplicate combinations will always generate the same next combinations.\n\n![duplicate](../Figures/752/Slide4.jpg)\n\nSo, we will keep one additional data structure to mark visited combinations to avoid traversing on a combination more than once.   \nWe also have some dead-end combinations from which we can't proceed further. We can consider these combinations as visited combinations because we cannot generate new combinations using these combinations.    \n\nThus, we will keep a hash set `visited_combinations`, insert the dead-end combinations in it initially, and will insert the visited combinations while doing the BFS.\n\n#### Algorithm\n\n1. Initialization:\n    - Create two character maps, `next_slot` to map the current slot digit with its next slot digit, and `prev_slot` to map the current slot digit with its previous slot digit.\n    - Create a hash set `visited_combinations`, initially containing all `deadends` array combinations.\n    - Create a queue `pending_combinations` to traverse all combinations in level-wise BFS.\n    - Create an integer variable `turns` initially storing `0`, to denote the number of wheel turns made.\n\n2. If `visited_combinations` contains the starting combination `'0000'` then we can never reach the target combination and will return `-1`.\n\n3. Insert the starting combination `'0000'` in the queue and mark it as visited.\n\n4. While there are elements in the queue, iterate on all current level combinations using a for loop:\n    - Pop the current combination from the front of the queue.\n    - If the current combination is the target combination return `turns`.\n    - Otherwise, iterate on all four wheels; for each wheel, generate the new combination by turning the respective wheel to the next slot and the previous slot. If the new combination is not present in `visited_combinations` then push it in the queue and mark it as visited.\n    - After iterating on all current level combinations increment `turns` by `1`.\n\n5. If we never reach the target combination, then, return `-1`.\n\n\n#### Implementation#### Complexity Analysis\n\nHere, $n = 10$ is the number of slots on a wheel, $w = 4$ is the number of wheels, and $d$ is the number of elements in the `deadends` array.\n\n* Time complexity: $O(4(d + 10^4))$  \n    - Initializing the hash maps with $n$ key-value pairs, and the hash set with $d$ combinations of length $w$ will take $O(2 \\cdot n)$ and $O(d \\cdot w)$ time respectively.\n    - In the worst case, we might iterate on all $n^w$ unique combinations, and for each combination, we perform $2 \\cdot w$ turns. Thus, it will take $O(n^w \\cdot 2 \\cdot w) = O(n^w \\cdot w)$ time.\n    - So, this approach will take $O(n + (d + n^w) \\cdot w) = O(10 + (d + 10^4) \\cdot 4) = O(4(d + 10^4))$ time.\n* Space complexity: $O(4(d + 10^4))$  \n    - The hash maps with $n$ key-value pairs, and the hash set with $d$ combinations of length $w$ will take $O(2 \\cdot n)$ and $O(d \\cdot w)$ space respectively.\n    - In the worst case, we might push all $n^w$ unique combinations of length $w$ in the queue and the hash set. Thus, it will take $O(n^w \\cdot w)$ space.\n    - So, this approach will take $O(n + (d + n^w) \\cdot w) = O(4(d + 10^4))$ space."
}