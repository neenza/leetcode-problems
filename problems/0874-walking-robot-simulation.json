{
  "title": "Walking Robot Simulation",
  "problem_id": "906",
  "frontend_id": "874",
  "difficulty": "Medium",
  "problem_slug": "walking-robot-simulation",
  "topics": [
    "Array",
    "Hash Table",
    "Simulation"
  ],
  "description": "A robot on an infinite XY-plane starts at point (0, 0) facing north. The robot receives an array of integers commands, which represents a sequence of moves that it needs to execute. There are only three possible types of instructions the robot can receive:\nSome of the grid squares are obstacles. The ith obstacle is at grid point obstacles[i] = (xi, yi). If the robot runs into an obstacle, it will stay in its current location (on the block adjacent to the obstacle) and move onto the next command.\nReturn the maximum squared Euclidean distance that the robot reaches at any point in its path (i.e. if the distance is 5, return 25).\nNote:\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: commands = [4,-1,3], obstacles = []\nOutput: 25\nExplanation:\nThe robot starts at (0, 0) :\nThe furthest point the robot ever gets from the origin is (3, 4) , which squared is 3 2 + 4 2 = 25 units away.",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input: commands = [4,-1,4,-2,4], obstacles = [[2,4]]\nOutput: 65\nExplanation:\nThe robot starts at (0, 0) :\nThe furthest point the robot ever gets from the origin is (1, 8) , which squared is 1 2 + 8 2 = 65 units away.",
      "images": []
    },
    {
      "example_num": 3,
      "example_text": "Input: commands = [6,-1,-1,6], obstacles = [[0,0]]\nOutput: 36\nExplanation:\nThe robot starts at (0, 0) :\nThe furthest point the robot ever gets from the origin is (0, 6) , which squared is 6 2 = 36 units away.",
      "images": []
    }
  ],
  "constraints": [
    "1 <= commands.length <= 104",
    "commands[i] is either -2, -1, or an integer in the range [1, 9].",
    "0 <= obstacles.length <= 104",
    "-3 * 104 <= xi, yi <= 3 * 104",
    "The answer is guaranteed to be less than 231."
  ],
  "follow_ups": [],
  "hints": [],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    int robotSim(vector<int>& commands, vector<vector<int>>& obstacles) {\n        \n    }\n};",
    "java": "class Solution {\n    public int robotSim(int[] commands, int[][] obstacles) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def robotSim(self, commands, obstacles):\n        \"\"\"\n        :type commands: List[int]\n        :type obstacles: List[List[int]]\n        :rtype: int\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def robotSim(self, commands: List[int], obstacles: List[List[int]]) -> int:\n        ",
    "c": "int robotSim(int* commands, int commandsSize, int** obstacles, int obstaclesSize, int* obstaclesColSize) {\n    \n}",
    "csharp": "public class Solution {\n    public int RobotSim(int[] commands, int[][] obstacles) {\n        \n    }\n}",
    "javascript": "/**\n * @param {number[]} commands\n * @param {number[][]} obstacles\n * @return {number}\n */\nvar robotSim = function(commands, obstacles) {\n    \n};",
    "typescript": "function robotSim(commands: number[], obstacles: number[][]): number {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param Integer[] $commands\n     * @param Integer[][] $obstacles\n     * @return Integer\n     */\n    function robotSim($commands, $obstacles) {\n        \n    }\n}",
    "swift": "class Solution {\n    func robotSim(_ commands: [Int], _ obstacles: [[Int]]) -> Int {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun robotSim(commands: IntArray, obstacles: Array<IntArray>): Int {\n        \n    }\n}",
    "dart": "class Solution {\n  int robotSim(List<int> commands, List<List<int>> obstacles) {\n    \n  }\n}",
    "golang": "func robotSim(commands []int, obstacles [][]int) int {\n    \n}",
    "ruby": "# @param {Integer[]} commands\n# @param {Integer[][]} obstacles\n# @return {Integer}\ndef robot_sim(commands, obstacles)\n    \nend",
    "scala": "object Solution {\n    def robotSim(commands: Array[Int], obstacles: Array[Array[Int]]): Int = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn robot_sim(commands: Vec<i32>, obstacles: Vec<Vec<i32>>) -> i32 {\n        \n    }\n}",
    "racket": "(define/contract (robot-sim commands obstacles)\n  (-> (listof exact-integer?) (listof (listof exact-integer?)) exact-integer?)\n  )",
    "erlang": "-spec robot_sim(Commands :: [integer()], Obstacles :: [[integer()]]) -> integer().\nrobot_sim(Commands, Obstacles) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec robot_sim(commands :: [integer], obstacles :: [[integer]]) :: integer\n  def robot_sim(commands, obstacles) do\n    \n  end\nend"
  },
  "solution": "[TOC]\n\n## Solution\n\n---\n\n### Overview\n\nWe have a robot facing north at the origin `(0, 0)` of an infinite 2D grid. The robot receives a series of instructions from a given list of `commands`, where instruction can be of three types:\n\n1. `-2`: Turn left 90 degrees while staying at the current coordinate.\n2. `-1`: Turn right 90 degrees while staying at the current coordinate.\n3. Any positive integer `k` from 1 to 9: Advance `k` units in the current direction.\n\nAdditionally, we are given a list of `obstacles` containing the coordinates of various obstacles on the grid. If the robot encounters an obstacle while moving forward, it stops its motion at the coordinate just before the obstacle and proceeds to the next command.\n\nOur goal is to find the farthest squared distance from the origin that the robot reaches during its journey. In other words, we need to find the maximum value of $x \\times x + y \\times y$ that can be achieved at any point `(x, y)` visited by the robot.\n\nKeep in mind when planning your approach that the farthest traveled distance during the robot's journey is not the same as its distance from the origin at the end of its journey.\n\n> Note: An obstacle may exist at the origin (0, 0). In this case, the robot can move away from the starting point but will be unable to return to (0, 0).\n  \n---\n\n### Approach: Simulation\n\n#### Intuition\n\nThe robot's state is defined by two factors:\n1. The coordinates of the robot's position: we can use a simple integer array `[x, y]`.\n2. The direction the robot is facing: we can use an integer value (0, 1, 2, 3) representing North, East, South, and West respectively. Consequently, we need a `directions` array representing the direction of motion of the robot, where each index corresponds to [North, East, South, West].\n\nThe presence of obstacles prevents us from being able to simply loop over each command and simulate the robot's motion on the grid. A naive approach would be to loop through the obstacle array to check if the next attempted move is blocked by an obstacle. However, this results in quadratic complexity, which is inefficient given our constraints.\n\nChecking whether a given coordinate is an obstacle using hash sets allows for constant-time lookups. If you're unfamiliar with hash sets, this LeetCode [Explore Card](https://leetcode.com/explore/learn/card/hash-table/183/combination-with-other-algorithms/1130/) provides an in-depth explanation. \n\nOur challenge becomes how to look up coordinates in a hash set. \n\nWe solve this by hashing the coordinates of each obstacle to a unique integer value and storing these values in the hash set. To check if a coordinate contains an obstacle, we hash the coordinates using the same function and check if the value is present in the hash set.\n\nThere are various methods to create [hashing functions](https://en.wikipedia.org/wiki/List_of_hash_functions). For this problem, we'll create a simple one that generates a unique integer value for all coordinates within the given problem constraints.\n\n```\nhash(x, y) = x + HASH_MULTIPLIER * y\n```\n\nWhere `HASH_MULTIPLIER` is a constant slightly larger than twice the maximum possible coordinate value. In this case, we choose `60013`.\n\n> We choose `60013` because it is the smallest prime number greater than 60000 (twice the maximum possible coordinate). This helps reduce the number of potential collisions in our hash function.\n\nThe below slideshow visualizes the robot's journey for Example 2 of the problem description:\n\n!?!../Documents/874/slideshow.json:1332,1236!?!\n\n#### Algorithm\n\n- Create a constant `HASH_MULTIPLIER` to use in the hashing function.\n\n`robotSim` Function:\n\n- Convert the list of obstacles into a set of hashed coordinates for quick lookup during the simulation.\n- Define the four possible movement directions corresponding to North, East, South, and West.\n- Initialize the robot's starting position at the origin `(0, 0)` and set the initial maximum distance squared to zero.\n- Initialize the current direction of the robot facing North.\n- Iterate through the list of commands:\n  - If the command is `-1`, turn the robot 90 degrees to the right by adjusting the current direction index.\n  - If the command is `-2`, turn the robot 90 degrees to the left by adjusting the current direction index.\n  - Otherwise, for a positive command, move the robot forward step by step:\n    - Calculate the next potential position by adding the current direction vector to the robot's position.\n    - If the next position is an obstacle, stop moving forward.\n    - Otherwise, update the robot's position to the new coordinates.\n  - Update the maximum distance squared if the current position is farther from the origin than before.\n- Return the maximum distance squared as the result of the simulation.\n\n`hashCoordinates` Function:\n\n- Combine the `x` and `y` coordinates into a unique hash value by multiplying the `y` coordinate by a constant multiplier and adding the `x` coordinate.\n- Return the computed hash value to be used for obstacle lookup.\n\n#### Implementation#### Complexity Analysis\n\nLet $m$ and $n$ be the length of `commands` and `obstacles`, respectively.\n\n- Time complexity: $O(m + n)$\n\n    The algorithm initially iterates over the `obstacles` array and hashes each obstacle’s coordinates, taking $O(n)$ time.\n\n    The algorithm then loops over the `commands` array. In the worst case, each command is a positive integer `k`. Since the maximum value of `k` is limited to $9$, this step has a time complexity of $O(9 \\cdot m) = O(m)$.\n\n    Thus, the overall time complexity of the algorithm is $O(n) + O(m) = O(m + n)$.\n\n- Space complexity: $O(n)$\n\n    The only additional space used by the algorithm is the `obstacleSet`, which stores up to $n$ hashed obstacle positions. The `directions` and `currentPosition` arrays and all other primitive variables use constant space.\n\n    Thus, the space complexity of the algorithm is $O(n)$.\n\n---"
}