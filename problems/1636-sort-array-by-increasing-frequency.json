{
  "title": "Sort Array by Increasing Frequency",
  "problem_id": "1741",
  "frontend_id": "1636",
  "difficulty": "Easy",
  "problem_slug": "sort-array-by-increasing-frequency",
  "topics": [
    "Array",
    "Hash Table",
    "Sorting"
  ],
  "description": "Given an array of integers nums, sort the array in increasing order based on the frequency of the values. If multiple values have the same frequency, sort them in decreasing order.\nReturn the sorted array.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: nums = [1,1,2,2,2,3]\nOutput: [3,1,1,2,2,2]\nExplanation: '3' has a frequency of 1, '1' has a frequency of 2, and '2' has a frequency of 3.",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input: nums = [2,3,1,3,2]\nOutput: [1,3,3,2,2]\nExplanation: '2' and '3' both have a frequency of 2, so they are sorted in decreasing order.",
      "images": []
    },
    {
      "example_num": 3,
      "example_text": "Input: nums = [-1,1,-6,4,5,-6,1,4,1]\nOutput: [5,-1,4,4,-6,-6,1,1,1]",
      "images": []
    }
  ],
  "constraints": [
    "1 <= nums.length <= 100",
    "-100 <= nums[i] <= 100"
  ],
  "follow_ups": [],
  "hints": [
    "Count the frequency of each value.",
    "Use a custom comparator to compare values by their frequency. If two values have the same frequency, compare their values."
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    vector<int> frequencySort(vector<int>& nums) {\n        \n    }\n};",
    "java": "class Solution {\n    public int[] frequencySort(int[] nums) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def frequencySort(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def frequencySort(self, nums: List[int]) -> List[int]:\n        ",
    "c": "/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nint* frequencySort(int* nums, int numsSize, int* returnSize) {\n    \n}",
    "csharp": "public class Solution {\n    public int[] FrequencySort(int[] nums) {\n        \n    }\n}",
    "javascript": "/**\n * @param {number[]} nums\n * @return {number[]}\n */\nvar frequencySort = function(nums) {\n    \n};",
    "typescript": "function frequencySort(nums: number[]): number[] {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @return Integer[]\n     */\n    function frequencySort($nums) {\n        \n    }\n}",
    "swift": "class Solution {\n    func frequencySort(_ nums: [Int]) -> [Int] {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun frequencySort(nums: IntArray): IntArray {\n        \n    }\n}",
    "dart": "class Solution {\n  List<int> frequencySort(List<int> nums) {\n    \n  }\n}",
    "golang": "func frequencySort(nums []int) []int {\n    \n}",
    "ruby": "# @param {Integer[]} nums\n# @return {Integer[]}\ndef frequency_sort(nums)\n    \nend",
    "scala": "object Solution {\n    def frequencySort(nums: Array[Int]): Array[Int] = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn frequency_sort(nums: Vec<i32>) -> Vec<i32> {\n        \n    }\n}",
    "racket": "(define/contract (frequency-sort nums)\n  (-> (listof exact-integer?) (listof exact-integer?))\n  )",
    "erlang": "-spec frequency_sort(Nums :: [integer()]) -> [integer()].\nfrequency_sort(Nums) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec frequency_sort(nums :: [integer]) :: [integer]\n  def frequency_sort(nums) do\n    \n  end\nend"
  },
  "solution": "[TOC]\n\n## Solution\n\n---\n\n### Overview\n\nThe task is to sort an array of integers by their frequency, placing numbers with fewer occurrences first. If two numbers appear with the same frequency, they should be ordered by their values in descending order. Think of it as arranging a playlist by the least to most popular songs, or ranking search results to prioritize the most relevant and engaging options for a more intuitive user experience.\n\n--- \n\n### Approach: Customized Sorting\n\n#### Intuition\n\nTo sort the numbers, we first arrange them based on their frequency in ascending order. Numbers that appear less frequently will come before those with higher frequencies. We use a hashmap, `freq`, to count the occurrences of each number in the array.\n\nIf two numbers have the same frequency, we then sort them by their values in descending order. This introduces a dual sorting criterion: first by frequency and then by value.\n\nTo accomplish this, we will apply a custom sorting function using lambda expressions. These anonymous functions let us define sorting logic inline. Specifically, our lambda function ensures that numbers are compared primarily by their frequency, and secondarily by their value if frequencies match. This approach guarantees that the final sorted list adheres to both sorting criteria.\n\n##### C++ Lambda Function for Sorting by Increasing Frequency\n```\nsort(nums.begin(), nums.end(), [&](int a, int b) {\n    if (freq[a] == freq[b]) {\n        return a > b; \n    }\n    return freq[a] < freq[b];\n});\n```\n\nThe lambda `[&](int a, int b) { ... }` serves as the comparator for the `sort` function:\n\n1. `&` captures all external variables (`freq` in this case) by reference, allowing the lambda to access and use `freq`.\n2. `(int a, int b)` defines parameters for elements to compare.\n3. Comparison logic:\n   - If frequencies are equal (`freq[a] == freq[b]`), sort by value in descending order (`a > b`).\n   - Otherwise, sort by frequency in ascending order (`freq[a] < freq[b]`).\n\n##### Java Lambda Function for Sorting by Increasing Frequency\n```\nArrays.sort(numsObj, (a, b) -> {\n    if (freq.get(a).equals(freq.get(b))) {\n        return Integer.compare(b, a);\n    }\n    return Integer.compare(freq.get(a), freq.get(b));\n});\n```\n\nLambda `(a, b) -> { ... }` as comparator for `Arrays.sort`:\n\n1. Parameters `a` and `b` represent elements to compare.\n2. Comparison logic:\n   - If frequencies are equal (`freq.get(a).equals(freq.get(b))`), sort by value in descending order (`Integer.compare(b, a)`).\n   - Otherwise, sort by frequency in ascending order (`Integer.compare(freq.get(a), freq.get(b))`).\n\n##### Python Lambda Function for Sorting by Increasing Frequency\n```\nsorted(nums, key=lambda x: (freq[x], -x))\n```\n\nThe lambda function `lambda x: (freq[x], -x)` is used as the `key` parameter in the `sorted` function call.\n1.  `lambda x:` creates an anonymous function with `x` as its parameter.\n2.  `(freq[x], -x)` is the tuple that the lambda function returns.\n3. `freq[x]` is used to get the frequency of `x` from the `freq` dictionary as the main sorting criterion.\n4. `-x` ensures that values are sorted in descending order when their frequencies are the same.\n\n#### Algorithm\n\n- Initialize an unordered map `freq` to store the frequency of each integer in the input array `nums`.\n- Traverse through each integer `num` in the array `nums`.\n- Increase the count of `num` in the `freq` map using `freq[num]++`.\n- Sort the array `nums` using the `sort` function with a custom comparator:\n    - Compare two integers `a` and `b` based on their frequencies stored in the `freq` map:\n        - If `freq[a]` (frequency of `a`) equals `freq[b]` (frequency of `b`), then:\n        - Return `a > b` to ensure that in case of tie-in frequency, larger values come first (decreasing order).\n        - Otherwise, return `freq[a] < freq[b]` to sort by frequency in increasing order.\n- Return the sorted `nums` array, which now reflects the integers sorted primarily by frequency in ascending order, and by value in descending order when frequencies are tied.\n\n#### Implementation#### Complexity Analysis\n\nLet $N$ be the length of `nums`.\n\n* Time complexity: $O(N \\cdot logN)$.\n    \n    Sorting `nums` incurs a time complexity of $O(N \\cdot logN)$. Iterating over `nums` when counting frequencies incurs a time complexity of $O(N)$, which can be ignored since $O(N \\cdot logN)$ is the dominating term.\n\n* Space complexity: $O(N)$. We define a hash map to count the frequencies of each element, which incurs a space complexity of $O(N)$. Sorting also takes up some space, and the space complexity for that is detailed below:\n    \n    Some extra space is used when we sort an array of size $N$ in place. The space complexity of the sorting algorithm depends on the programming language.\n    - In Python, the `sort` method sorts a list using the Timsort algorithm which is a combination of Merge Sort and Insertion Sort and has a space complexity of $O(N)$\n    - In C++, the sort() function is implemented as a hybrid of Quick Sort, Heap Sort, and Insertion Sort, with a worst-case space complexity of $O( \\log N )$\n    - In Java, Arrays.sort() is implemented using a variant of the Quick Sort algorithm which has a space complexity of $O( \\log N)$\n\n    Overall, the worst-case time complexity will be $O(N)$ when the array `nums` is filled with unique elements.\n\n---"
}