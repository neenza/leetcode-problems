{
  "title": "Count the Number of Ideal Arrays",
  "problem_id": "2415",
  "frontend_id": "2338",
  "difficulty": "Hard",
  "problem_slug": "count-the-number-of-ideal-arrays",
  "topics": [
    "Math",
    "Dynamic Programming",
    "Combinatorics",
    "Number Theory"
  ],
  "description": "You are given two integers n and maxValue, which are used to describe an ideal array.\nA 0-indexed integer array arr of length n is considered ideal if the following conditions hold:\nReturn the number of distinct ideal arrays of length n. Since the answer may be very large, return it modulo 109 + 7.\nExample 1:\nExample 2:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: n = 2, maxValue = 5\nOutput: 10\nExplanation: The following are the possible ideal arrays:\n- Arrays starting with the value 1 (5 arrays): [1,1], [1,2], [1,3], [1,4], [1,5]\n- Arrays starting with the value 2 (2 arrays): [2,2], [2,4]\n- Arrays starting with the value 3 (1 array): [3,3]\n- Arrays starting with the value 4 (1 array): [4,4]\n- Arrays starting with the value 5 (1 array): [5,5]\nThere are a total of 5 + 2 + 1 + 1 + 1 = 10 distinct ideal arrays.",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input: n = 5, maxValue = 3\nOutput: 11\nExplanation: The following are the possible ideal arrays:\n- Arrays starting with the value 1 (9 arrays): \n   - With no other distinct values (1 array): [1,1,1,1,1] \n   - With 2nd distinct value 2 (4 arrays): [1,1,1,1,2], [1,1,1,2,2], [1,1,2,2,2], [1,2,2,2,2]\n   - With 2nd distinct value 3 (4 arrays): [1,1,1,1,3], [1,1,1,3,3], [1,1,3,3,3], [1,3,3,3,3]\n- Arrays starting with the value 2 (1 array): [2,2,2,2,2]\n- Arrays starting with the value 3 (1 array): [3,3,3,3,3]\nThere are a total of 9 + 1 + 1 = 11 distinct ideal arrays.",
      "images": []
    }
  ],
  "constraints": [
    "2 <= n <= 104",
    "1 <= maxValue <= 104"
  ],
  "follow_ups": [],
  "hints": [
    "Notice that an ideal array is non-decreasing.",
    "Consider an alternative problem: where an ideal array must also be strictly increasing. Can you use DP to solve it?",
    "Will combinatorics help to get an answer from the alternative problem to the actual problem?"
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    int idealArrays(int n, int maxValue) {\n        \n    }\n};",
    "java": "class Solution {\n    public int idealArrays(int n, int maxValue) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def idealArrays(self, n, maxValue):\n        \"\"\"\n        :type n: int\n        :type maxValue: int\n        :rtype: int\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def idealArrays(self, n: int, maxValue: int) -> int:\n        ",
    "c": "int idealArrays(int n, int maxValue) {\n    \n}",
    "csharp": "public class Solution {\n    public int IdealArrays(int n, int maxValue) {\n        \n    }\n}",
    "javascript": "/**\n * @param {number} n\n * @param {number} maxValue\n * @return {number}\n */\nvar idealArrays = function(n, maxValue) {\n    \n};",
    "typescript": "function idealArrays(n: number, maxValue: number): number {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param Integer $n\n     * @param Integer $maxValue\n     * @return Integer\n     */\n    function idealArrays($n, $maxValue) {\n        \n    }\n}",
    "swift": "class Solution {\n    func idealArrays(_ n: Int, _ maxValue: Int) -> Int {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun idealArrays(n: Int, maxValue: Int): Int {\n        \n    }\n}",
    "dart": "class Solution {\n  int idealArrays(int n, int maxValue) {\n    \n  }\n}",
    "golang": "func idealArrays(n int, maxValue int) int {\n    \n}",
    "ruby": "# @param {Integer} n\n# @param {Integer} max_value\n# @return {Integer}\ndef ideal_arrays(n, max_value)\n    \nend",
    "scala": "object Solution {\n    def idealArrays(n: Int, maxValue: Int): Int = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn ideal_arrays(n: i32, max_value: i32) -> i32 {\n        \n    }\n}",
    "racket": "(define/contract (ideal-arrays n maxValue)\n  (-> exact-integer? exact-integer? exact-integer?)\n  )",
    "erlang": "-spec ideal_arrays(N :: integer(), MaxValue :: integer()) -> integer().\nideal_arrays(N, MaxValue) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec ideal_arrays(n :: integer, max_value :: integer) :: integer\n  def ideal_arrays(n, max_value) do\n    \n  end\nend"
  },
  "solution": "[TOC]\n\n## Solution\n\n--- \n\n### Approach: Combinatorial Mathematics\n\n#### Intuition\n\nWe're given an integer `n` and a maximum allowed value `maxValue`, and we want to count how many arrays `arr` of length `n` exist such that:\n\n* Each element of the array is between `1` and `maxValue`\n* Every element divides the next one, meaning $\\text{arr}[i-1] \\mid \\text{arr}[i]$ for all $i$ from `1` to `n - 1`\n\nTo approach this, let's fix the **last** element of the array to be some number $x$ (where $x \\in [1, \\text{maxValue}]$), and count how many valid arrays of length `n` can end with $x$. The key idea is that if each element divides the next, then the entire array is a chain of divisors ending in $x$.\n\nNow, we can represent each element in the array as a product of multiplicative steps. That is, we can write:\n\n$$\n\\text{arr}[0] = k_0,\\quad \\text{arr}[1] = k_0k_1,\\quad \\ldots,\\quad \\text{arr}[n-1] = k_0k_1\\cdots k_{n-1} = x\n$$\n\nSo we’re looking for sequences of $n$ natural numbers $k_0, k_1, \\dots, k_{n-1}$ whose product is exactly $x$.\n\nThis means: for a given $x$, how many ways can we split its prime factors across `n` multiplicative positions?\n\nLet’s say the prime factorization of $x$ is:\n\n$$\nx = p_1^{a_1} \\cdot p_2^{a_2} \\cdots p_m^{a_m}\n$$\n\nEach exponent $a_j$ needs to be split into $n$ parts — one for each slot in the sequence. This is a classic \"stars and bars\" problem in combinatorics, where we’re placing $a_j$ indistinguishable items into $n$ buckets:\n\n$$\n\\text{Number of ways} = \\binom{a_j + n - 1}{a_j}\n$$\n\nBecause different prime factors are independent, we multiply the counts for each:\n\n$$\n\\text{Total sequences ending in } x = \\prod_{j=1}^{m} \\binom{a_j + n - 1}{a_j}\n$$\n\nFinally, we go through all $x \\in [1, \\text{maxValue}]$, compute the number of valid arrays that end in each $x$, and add them all up.\n\n#### Implementation#### Complexity Analysis\n\nLet $m$ be the $\\textit{maxValue}$, and $n$ be the length of the $\\textit{arr}$ array. $\\omega(m)$ represents the number of distinct prime factors of $m$, and its average order in number theory is $\\log\\log m$. For more details, please refer to the [Prime omega function](https://en.wikipedia.org/wiki/Prime_omega_function#Average_order_and_summatory_functions).\n\n- Time complexity: $O((n+\\omega(m))\\cdot\\omega(m)+m\\omega(m))$.\n\nIn preprocessing, the minimum prime factor is sieved out with $O(n\\log\\log n)$, prime factorization requires $O(n\\log n)$, and the combination number calculation requires $O((n+\\omega(m))\\cdot\\omega(m))$. In the formal solution, the time complexity for finding the number of elements in an array is $O(m\\omega(m))=O(m\\log\\log m)$.\n\n- Space complexity: $O((n+\\log(m))\\cdot\\log(m))$.\n\nWe need to save the preprocessed results of the combination numbers and the prime factorizations needed for selecting $\\log(m)$ positions from $(n + \\log(m) - 1)$ positions. Since the code allocates an array of fixed length, the number of factors is taken as the maximum value rather than the average, so the space complexity factor is $\\log(m)$ rather than $\\omega(m)$."
}