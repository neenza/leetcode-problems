{
  "title": "Merge Two 2D Arrays by Summing Values",
  "problem_id": "2707",
  "frontend_id": "2570",
  "difficulty": "Easy",
  "problem_slug": "merge-two-2d-arrays-by-summing-values",
  "topics": [
    "Array",
    "Hash Table",
    "Two Pointers"
  ],
  "description": "You are given two 2D integer arrays nums1 and nums2.\nEach array contains unique ids and is sorted in ascending order by id.\nMerge the two arrays into one array that is sorted in ascending order by id, respecting the following conditions:\nReturn the resulting array. The returned array must be sorted in ascending order by id.\nExample 1:\nExample 2:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: nums1 = [[1,2],[2,3],[4,5]], nums2 = [[1,4],[3,2],[4,1]]\nOutput: [[1,6],[2,3],[3,2],[4,6]]\nExplanation: The resulting array contains the following:\n- id = 1, the value of this id is 2 + 4 = 6.\n- id = 2, the value of this id is 3.\n- id = 3, the value of this id is 2.\n- id = 4, the value of this id is 5 + 1 = 6.",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input: nums1 = [[2,4],[3,6],[5,5]], nums2 = [[1,3],[4,3]]\nOutput: [[1,3],[2,4],[3,6],[4,3],[5,5]]\nExplanation: There are no common ids, so we just include each id with its value in the resulting list.",
      "images": []
    }
  ],
  "constraints": [
    "1 <= nums1.length, nums2.length <= 200",
    "nums1[i].length == nums2[j].length == 2",
    "1 <= idi, vali <= 1000",
    "Both arrays contain unique ids.",
    "Both arrays are in¬†strictly ascending order by id."
  ],
  "follow_ups": [],
  "hints": [
    "Use a dictionary/hash map to keep track of the indices and their sum\r\nvalues."
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    vector<vector<int>> mergeArrays(vector<vector<int>>& nums1, vector<vector<int>>& nums2) {\n        \n    }\n};",
    "java": "class Solution {\n    public int[][] mergeArrays(int[][] nums1, int[][] nums2) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def mergeArrays(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[List[int]]\n        :type nums2: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def mergeArrays(self, nums1: List[List[int]], nums2: List[List[int]]) -> List[List[int]]:\n        ",
    "c": "/**\n * Return an array of arrays of size *returnSize.\n * The sizes of the arrays are returned as *returnColumnSizes array.\n * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().\n */\nint** mergeArrays(int** nums1, int nums1Size, int* nums1ColSize, int** nums2, int nums2Size, int* nums2ColSize, int* returnSize, int** returnColumnSizes) {\n    \n}",
    "csharp": "public class Solution {\n    public int[][] MergeArrays(int[][] nums1, int[][] nums2) {\n        \n    }\n}",
    "javascript": "/**\n * @param {number[][]} nums1\n * @param {number[][]} nums2\n * @return {number[][]}\n */\nvar mergeArrays = function(nums1, nums2) {\n    \n};",
    "typescript": "function mergeArrays(nums1: number[][], nums2: number[][]): number[][] {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param Integer[][] $nums1\n     * @param Integer[][] $nums2\n     * @return Integer[][]\n     */\n    function mergeArrays($nums1, $nums2) {\n        \n    }\n}",
    "swift": "class Solution {\n    func mergeArrays(_ nums1: [[Int]], _ nums2: [[Int]]) -> [[Int]] {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun mergeArrays(nums1: Array<IntArray>, nums2: Array<IntArray>): Array<IntArray> {\n        \n    }\n}",
    "dart": "class Solution {\n  List<List<int>> mergeArrays(List<List<int>> nums1, List<List<int>> nums2) {\n    \n  }\n}",
    "golang": "func mergeArrays(nums1 [][]int, nums2 [][]int) [][]int {\n    \n}",
    "ruby": "# @param {Integer[][]} nums1\n# @param {Integer[][]} nums2\n# @return {Integer[][]}\ndef merge_arrays(nums1, nums2)\n    \nend",
    "scala": "object Solution {\n    def mergeArrays(nums1: Array[Array[Int]], nums2: Array[Array[Int]]): Array[Array[Int]] = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn merge_arrays(nums1: Vec<Vec<i32>>, nums2: Vec<Vec<i32>>) -> Vec<Vec<i32>> {\n        \n    }\n}",
    "racket": "(define/contract (merge-arrays nums1 nums2)\n  (-> (listof (listof exact-integer?)) (listof (listof exact-integer?)) (listof (listof exact-integer?)))\n  )",
    "erlang": "-spec merge_arrays(Nums1 :: [[integer()]], Nums2 :: [[integer()]]) -> [[integer()]].\nmerge_arrays(Nums1, Nums2) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec merge_arrays(nums1 :: [[integer]], nums2 :: [[integer]]) :: [[integer]]\n  def merge_arrays(nums1, nums2) do\n    \n  end\nend"
  },
  "solution": "## Solution\n\n---\n\n### Overview\n\nWe are given two arrays, `nums1` and `nums2`, each containing pairs of the form `{id, value}`. These pairs represent mappings where `id` is unique within each array, and both arrays are sorted in ascending order based on `id`.\n\nOur goal is to merge these two arrays of pairs into a single sorted array of pairs. Each entry in the result should correspond to an `id` that appears in either input array. If an `id` is present in both arrays, we sum the associated values; otherwise, we keep the existing pair as is. The final output must be sorted by `id`.\n\n##### Examples:\n1. If `nums1 = [(id1, val1)]` and `nums2 = [(id2, val2)]` with `id1 < id2`, then the final array should be `[(id1, val1), (id2, val2)]`.\n2. If `nums1 = [(id1, val1)]` and `nums2 = [(id1, val2)]`, then the final array should be `[(id1, val1 + val2)]`.\n3. If `nums1 = [(id1, val1), (id2, val2)]` and `nums2 = [(id2, val3)]` with `id1 < id2`, then the final array should be `[(id1, val1), (id2, val2 + val3)]`.\n\n---\n\n### Approach 1: HashMap\n\n#### Intuition\n\nAn intuitive approach to solving this problem is to use a data structure such as a map to store the `(key, value)` pairs. This is because the final result requires pairs where the value corresponds to an entry in either `nums1` or `nums2`. If the `id` exists in only one array, the value will be taken from that array. If the `id` appears in both arrays, the value will be the sum of the values from both arrays.\n\nWe can break the approach down into two main steps. First, we populate the map using one of the two input lists. Since each `id` is unique within a list, inserting these pairs directly into the map is straightforward. Next, we process the second array, updating the values in the map. If an `id` from the second list already exists in the map, we simply add its value to the existing value. If it does not exist, we insert it as a new entry.\n\nOne important consideration is the order of the pairs in the final result. Since the pairs must be sorted in ascending order of `id`, we can either copy the entries from the map to a list and then sort the list, or use an ordered map to maintain the order throughout the process. In the code, we have chosen to use an ordered map, which eliminates the need for sorting after the merge. However, both approaches will result in the same time complexity as inserting in a map takes $O(\\log N)$ time.\n\n> For a more comprehensive understanding of hash tables, check out the [Hash Table Explore Card üîó](https://leetcode.com/explore/learn/card/hash-table/). This resource provides an in-depth look at hash tables, explaining their key concepts and applications with a variety of problems to solidify understanding of the pattern.\n\n#### Algorithm\n\n1. Create an empty map named `keyToSum` to store the sum of values for each unique key.\n2.  Iterate through each pair `(id, value)` in `nums1` and insert the `id` as the map key and `value` as the map value.\n3. Iterate through each pair `(id, value)` in  `nums2`:\n    - If the key already exists in the map, add the value from `nums2` to the existing value.\n    - If the key does not exist in the map, insert the  pair from `nums2`.\n4.  Iterate over the map and construct a vector of pairs `mergedArray` by inserting each pair from the map into the list.\n5. Return `mergedArray`.\n\n#### Implementation#### Complexity Analysis\n\nHere, $N1$ is the number of elements in the array `nums1` and $N2$ is the number of elements in the array `nums2`.\n\n- Time complexity: $O((N1 + N2) \\log (N1 + N2))$.\n\n  Copying the `(id, value)` pairs from the array `nums1` into the ordered map will take $O(N1 \\log ‚Å°N1)$ time, as the insert operation in an ordered map has a time complexity of $O(\\log‚Å°N)$. Similarly, iterating through the pairs in the array `nums2` to either add new entries or update existing values in the map will take $O(N2 \\log ‚Å°N2)$. Finally, iterating over the entries in the map and copying them to the `mergedArray` list takes $O((N1 + N2) \\log‚Å° (N1 + N2))$. Therefore, the overall time complexity of the algorithm is $O((N1 + N2) \\log ‚Å°(N1 + N2))$.\n\n- Space complexity: $O(N1 + N2)$\n\nWe will store each entry in the map `keyToSum`, and thus there can be at most $(N1 + N2)$ entries if both arrays have unique entries. Space used to generate the output is generally not considered as part of the space complexity. Thus, the total space complexity is equal to $O(N1 + N2)$.\n\n---\n\n### Approach 2: Two Pointers\n\n#### Intuition\n\nThis problem is a slight variation of [88. Merge Sorted Array](https://leetcode.com/problems/merge-sorted-array/), except that instead of merging arrays of integers, we are merging arrays of pairs in the form `(id, value)`. In the original problem, we use a two-pointer technique, where two pointers traverse both arrays, inserting the smaller element into the result and advancing the respective pointer.  \n\nA similar approach works here because the input arrays are sorted in ascending order, and our goal is to merge them. The key distinction is that each element consists of an `(id, value)` pair. If the `id` values are identical in both arrays, we sum their corresponding `value`s and insert the merged pair into the result. Otherwise, we insert the pair with the smaller `id` and increment the corresponding pointer, following the same logic as in [88. Merge Sorted Array](https://leetcode.com/problems/merge-sorted-array/).  \n\nTo implement this, we initialize two pointers, `ptr1` and `ptr2`, at `0`, tracking the current positions in `nums1` and `nums2`, respectively. We then enter a while loop that continues until one of the pointers reaches the end of its array. Inside the loop, we compare the `id` values of the current pairs from `nums1` and `nums2`. If the `id`s differ, we insert the pair with the smaller `id` into the result list `mergedArray` and advance the corresponding pointer. If the `id`s match, we sum the `value`s and insert the combined pair into `mergedArray`.  \n\nOnce the loop finishes, one array may still contain unprocessed elements. This occurs when one array has exhausted its smaller `id` values, leaving unmatched pairs in the other. In this case, we append the remaining elements directly to `mergedArray`. Finally, we return `mergedArray` as the result.\n\n!?!../Documents/2570/2570_Merge_Two_2D_Arrays_by_Summing_Values.json:960,720!?!#### Algorithm\n\n1. Initialize ` N1` and `N2` to the size of `nums1` and `nums2`. Also, `ptr1` and `ptr2` to `0`. An empty 2D list `mergedArray` to store the result.\n2. While both `ptr1` is less than `N1` and `ptr2` is less than `N2`, continue merging:\n    - If the `id` matches:\n        - Add the key and the sum of the values from both arrays to `mergedArray`.\n        - Increment both `ptr1` and `ptr2`.\n    - If the `id` in `nums1` is smaller:\n        - Add the current pair from `nums1` to `mergedArray`.\n        - Increment `ptr1`.\n    - If the `id` in `nums2` is smaller:\n        - Add the current pair from `nums2` to `mergedArray`.\n        - Increment `ptr2`.\n3. If `ptr1` is still less than `N1` (i.e., there are remaining elements in `nums1`), add the remaining pairs to `mergedArray`.\n4. If `ptr2` is still less than `N2` (i.e., there are remaining elements in `nums2`), add the remaining pairs to `mergedArray`.\n5. Return `mergedArray`.\n\n#### Implementation#### Complexity Analysis\n\nHere, $N1$ is the number of elements in the array `nums1` and $N2$ is the number of elements in the array `nums2`.\n\n- Time complexity: $O(N1 + N2)$\n\n  In the while loop, we either increment one of the two pointers or increment both when the `id` is the same. Thus, we will iterate over each pair in the two arrays at most once. Also, all operations like insertion in the list is $O(1)$ and hence the total time complexity is equal to $O(N1 + N2)$\n\n- Space complexity: $O(N1 + N2)$\n\n  No extra space is required apart from the array required to store the result which is not considered as part of the space complexity and hence the total space complexity is equal to $O(N1 + N2)$.\n\n---"
}