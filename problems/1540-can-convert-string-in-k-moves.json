{
  "title": "Can Convert String in K Moves",
  "problem_id": "1647",
  "frontend_id": "1540",
  "difficulty": "Medium",
  "problem_slug": "can-convert-string-in-k-moves",
  "topics": [
    "Hash Table",
    "String"
  ],
  "description": "Given two strings s and t, your goal is to convert s into t in k moves or less.\nDuring the ith (1 <= i <= k) move you can:\nShifting a character means replacing it by the next letter in the alphabet (wrapping around so that 'z' becomes 'a'). Shifting a character by i means applying the shift operations i times.\nRemember that any index j can be picked at most once.\nReturn true if it's possible to convert s into t in no more than k moves, otherwise return false.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: s = \"input\", t = \"ouput\", k = 9\nOutput: true\nExplanation: In the 6th move, we shift 'i' 6 times to get 'o'. And in the 7th move we shift 'n' to get 'u'.",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input: s = \"abc\", t = \"bcd\", k = 10\nOutput: false\nExplanation: We need to shift each character in s one time to convert it into t. We can shift 'a' to 'b' during the 1st move. However, there is no way to shift the other characters in the remaining moves to obtain t from s.",
      "images": []
    },
    {
      "example_num": 3,
      "example_text": "Input: s = \"aab\", t = \"bbb\", k = 27\nOutput: true\nExplanation: In the 1st move, we shift the first 'a' 1 time to get 'b'. In the 27th move, we shift the second 'a' 27 times to get 'b'.",
      "images": []
    }
  ],
  "constraints": [
    "1 <= s.length, t.length <= 10^5",
    "0 <= k <= 10^9",
    "s, t contain only lowercase English letters."
  ],
  "follow_ups": [],
  "hints": [
    "Observe that shifting a letter x times has the same effect of shifting the letter x + 26 times.",
    "You need to check whether k is large enough to cover all shifts with the same remainder after modulo 26."
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    bool canConvertString(string s, string t, int k) {\n        \n    }\n};",
    "java": "class Solution {\n    public boolean canConvertString(String s, String t, int k) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def canConvertString(self, s, t, k):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :type k: int\n        :rtype: bool\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\n        ",
    "c": "bool canConvertString(char* s, char* t, int k) {\n    \n}",
    "csharp": "public class Solution {\n    public bool CanConvertString(string s, string t, int k) {\n        \n    }\n}",
    "javascript": "/**\n * @param {string} s\n * @param {string} t\n * @param {number} k\n * @return {boolean}\n */\nvar canConvertString = function(s, t, k) {\n    \n};",
    "typescript": "function canConvertString(s: string, t: string, k: number): boolean {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param String $s\n     * @param String $t\n     * @param Integer $k\n     * @return Boolean\n     */\n    function canConvertString($s, $t, $k) {\n        \n    }\n}",
    "swift": "class Solution {\n    func canConvertString(_ s: String, _ t: String, _ k: Int) -> Bool {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun canConvertString(s: String, t: String, k: Int): Boolean {\n        \n    }\n}",
    "dart": "class Solution {\n  bool canConvertString(String s, String t, int k) {\n    \n  }\n}",
    "golang": "func canConvertString(s string, t string, k int) bool {\n    \n}",
    "ruby": "# @param {String} s\n# @param {String} t\n# @param {Integer} k\n# @return {Boolean}\ndef can_convert_string(s, t, k)\n    \nend",
    "scala": "object Solution {\n    def canConvertString(s: String, t: String, k: Int): Boolean = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn can_convert_string(s: String, t: String, k: i32) -> bool {\n        \n    }\n}",
    "racket": "(define/contract (can-convert-string s t k)\n  (-> string? string? exact-integer? boolean?)\n  )",
    "erlang": "-spec can_convert_string(S :: unicode:unicode_binary(), T :: unicode:unicode_binary(), K :: integer()) -> boolean().\ncan_convert_string(S, T, K) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec can_convert_string(s :: String.t, t :: String.t, k :: integer) :: boolean\n  def can_convert_string(s, t, k) do\n    \n  end\nend"
  }
}