{
  "title": "Intersection of Two Arrays",
  "problem_id": "349",
  "frontend_id": "349",
  "difficulty": "Easy",
  "problem_slug": "intersection-of-two-arrays",
  "topics": [
    "Array",
    "Hash Table",
    "Two Pointers",
    "Binary Search",
    "Sorting"
  ],
  "description": "Given two integer arrays nums1 and nums2, return an array of their intersection. Each element in the result must be unique and you may return the result in any order.\nExample 1:\nExample 2:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: nums1 = [1,2,2,1], nums2 = [2,2]\nOutput: [2]",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4]\nOutput: [9,4]\nExplanation: [4,9] is also accepted.",
      "images": []
    }
  ],
  "constraints": [
    "1 <= nums1.length, nums2.length <= 1000",
    "0 <= nums1[i], nums2[i] <= 1000"
  ],
  "follow_ups": [],
  "hints": [],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\n        \n    }\n};",
    "java": "class Solution {\n    public int[] intersection(int[] nums1, int[] nums2) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def intersection(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def intersection(self, nums1: List[int], nums2: List[int]) -> List[int]:\n        ",
    "c": "/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nint* intersection(int* nums1, int nums1Size, int* nums2, int nums2Size, int* returnSize) {\n    \n}",
    "csharp": "public class Solution {\n    public int[] Intersection(int[] nums1, int[] nums2) {\n        \n    }\n}",
    "javascript": "/**\n * @param {number[]} nums1\n * @param {number[]} nums2\n * @return {number[]}\n */\nvar intersection = function(nums1, nums2) {\n    \n};",
    "typescript": "function intersection(nums1: number[], nums2: number[]): number[] {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param Integer[] $nums1\n     * @param Integer[] $nums2\n     * @return Integer[]\n     */\n    function intersection($nums1, $nums2) {\n        \n    }\n}",
    "swift": "class Solution {\n    func intersection(_ nums1: [Int], _ nums2: [Int]) -> [Int] {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun intersection(nums1: IntArray, nums2: IntArray): IntArray {\n        \n    }\n}",
    "dart": "class Solution {\n  List<int> intersection(List<int> nums1, List<int> nums2) {\n    \n  }\n}",
    "golang": "func intersection(nums1 []int, nums2 []int) []int {\n    \n}",
    "ruby": "# @param {Integer[]} nums1\n# @param {Integer[]} nums2\n# @return {Integer[]}\ndef intersection(nums1, nums2)\n    \nend",
    "scala": "object Solution {\n    def intersection(nums1: Array[Int], nums2: Array[Int]): Array[Int] = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn intersection(nums1: Vec<i32>, nums2: Vec<i32>) -> Vec<i32> {\n        \n    }\n}",
    "racket": "(define/contract (intersection nums1 nums2)\n  (-> (listof exact-integer?) (listof exact-integer?) (listof exact-integer?))\n  )",
    "erlang": "-spec intersection(Nums1 :: [integer()], Nums2 :: [integer()]) -> [integer()].\nintersection(Nums1, Nums2) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec intersection(nums1 :: [integer], nums2 :: [integer]) :: [integer]\n  def intersection(nums1, nums2) do\n    \n  end\nend"
  },
  "solution": "[TOC]\n\n## Solution\n\n---\n\n### Approach 1: Sorting and Two Pointers\n\n#### Intuition\n\nIf `nums1` and `nums2` are sorted, we can use a two pointers approach to find elements that appear in both arrays. Initialize one pointer for each array that starts at the smallest element. \n\nIf the numbers at both pointers are the same, add the number to a set that stores integers that appear in both arrays. Then, increase both pointers by $1$, since this element is already processed.  \n\nOtherwise, if the numbers at both pointers are not equal, the smaller of the two values cannot appear in the other array because both arrays are sorted. Therefore, we can increase the pointer of the smaller value.\n\n#### Algorithm\n\n1. Sort `nums1` and `nums2` arrays.\n2. Create a pointer for each array, initially set to $0$.\n3. Initialize an empty set that stores intersecting integers.\n4. If the integers at both pointers equal the same value, add this value to the intersecting set and increment both pointers.\n5. Otherwise, increment the pointer that points to the smaller integer value.\n6. Repeat steps 4 and 5 until a pointer is out of bounds.\n7. Convert the intersection set into an array.\n8. Return the resulting array.\n\n#### Implementation#### Complexity Analysis\n\n* Time complexity: $O(n \\log n + m \\log m)$, where $n$ and $m$ are the arrays' lengths. This dominating term comes from the need to sort both input arrays at the beginning of the solution.\n \n* Space complexity: $O(\\min(m, n))$ in the worst case when all elements in the smaller array are unique and present in the larger array. This space is necessary to store elements in the set `intersection`.  \n\n    - The space used to store the result array is counted in the space complexity, making the worst case $O(\\min(m, n))$.  \n    - Some extra space is used when sorting the arrays in place, and the space complexity depends on the programming language:  \n        - In Python, the `sort()` method uses the Timsort algorithm, which requires O(n) additional space in the worst case.  \n        - In Java, `Arrays.sort()` for primitive types uses a Dual-Pivot QuickSort, which has a worst-case space complexity of O(\\log n) due to recursion.  \n\n---\n\n### Approach 2: Built-in Set Intersection\n\n#### Intuition\n\nThere are built-in intersection facilities, which provide $O(n + m)$ time complexity in the average case and $O(n \\times m)$ time complexity in the worst case. \n\n> In Python it's the [intersection operator](https://wiki.python.org/moin/TimeComplexity#set), and in Java it's the [retainAll() function](https://docs.oracle.com/javase/8/docs/api/java/util/AbstractCollection.html#retainAll-java.util.Collection-).\n\n#### Algorithm\n\n1. Initialize a set `set1` and add all elements of `nums1` to it.\n2. Initialize a set `set2` and add all elements of `nums2` to it.\n3. Call the built-in set intersection method (either `retainAll()` in Java, or `&` operator in Python).\n4. Transform the resulting set into an array and return this result.\n\n#### Implementation#### Complexity Analysis\n\n* Time complexity: $O(n + m)$, where $n$ and $m$ are the arrays' lengths in the average case and $O(n \\times m)$ [in the worst case when the load factor is high enough](https://wiki.python.org/moin/TimeComplexity#set).\n \n* Space complexity: $O(m + n)$ because in the worst case, when all elements in the arrays are unique, $n$ space is used to store `set1` and $m$ space is used to store `set2`. The space used to store the result is not counted in the space complexity.\n\n---\n\n### Approach 3: Two Sets\n\n#### Intuition\n\nThe naive approach would be to iterate through the values in the first array, `nums1`, and check whether each one is in `nums2`. If yes, add the value to the output. Such an approach would result in a less efficient solution.\n\n> To solve the problem in linear time, let's use the data structure `set`, which provides `in/contains` operations in $O(1)$ time in the average case.\n\nThe idea is to convert both arrays into sets and then iterate over the smallest set while checking the presence of each element in the larger set.\n\n!?!../Documents/349_LIS.json:1000,352!?!\n\n#### Algorithm\n\n1. Initialize a set `set1` and add all elements of `nums1` to it.\n2. Initialize a set `set2` and add all elements of `nums2` to it.\n3. If `set1` has more elements than `set2`, swap them.\n4. For each element in `set1`, add it to the result array if it also appears in `set2`.\n5. Result the result array.\n\n#### Implementation#### Complexity Analysis\n\n* Time complexity: $O(n + m)$, where $n$ and $m$ are the arrays' lengths. $O(n)$ time is used to convert `nums1` into a set, $O(m)$ time is used to convert `nums2`, and `contains/in` operations are $O(1)$ in the average case.\n \n* Space complexity: $O(m + n)$ because in the worst case, when all elements in the arrays are unique, $n$ space is used to store `set1` and $m$ space is used to store `set2`.\n\n---\n\n### Approach 4: One Dictionary\n\n#### Intuition\n\nThis approach uses only one additional data structure and one pass through each of `nums1` and `nums2`. The idea is to use a dictionary/map rather than a set to store information about values that appear in each array. \n\nDefine this dictionary as `seen`, where the key is an element that exists in one or both input arrays, and the value stores either $0$ or $1$. A number `x` appears as a key in this dictionary, indicating it is present in at least one array, and the value of the key indicates if `x` has been observed in both arrays and added to the `result` array.\n\n#### Algorithm\n\n1. Initialize a dictionary/map `seen` and the `result` array.\n2. For each `x` in `nums1`, set `seen[x]` to $1$.\n3. For each `x` in `nums2`, add `x` to `result` if `seen[x]` equals $1$. Then, set `seen[x]` to $0$, as this element has already been included in the result.\n4. Result the result array.\n\n#### Implementation#### Complexity Analysis\n\nLet $n$ be the length of `nums1` and $m$ be the length of `nums2`.\n\n* Time complexity: $O(n + m)$ in the average case and $O(n \\times m)$ [in the worst case when the load factor is high enough](https://wiki.python.org/moin/TimeComplexity#set).\n \n* Space complexity: $O(n)$ because we use a map of size $n$ store the elements from `nums1`. The `result` array is just used to store the result, so it is not counted in the space complexity.\n\n---"
}