{
  "title": "Add Two Numbers II",
  "problem_id": "445",
  "frontend_id": "445",
  "difficulty": "Medium",
  "problem_slug": "add-two-numbers-ii",
  "topics": [
    "Linked List",
    "Math",
    "Stack"
  ],
  "description": "You are given two non-empty linked lists representing two non-negative integers. The most significant digit comes first and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.\nExample 1:\nExample 2:\nExample 3:\nConstraints:\nFollow up:Â Could you solve it without reversing the input lists?",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: l1 = [7,2,4,3], l2 = [5,6,4]\nOutput: [7,8,0,7]",
      "images": [
        "https://assets.leetcode.com/uploads/2021/04/09/sumii-linked-list.jpg"
      ]
    },
    {
      "example_num": 2,
      "example_text": "Input: l1 = [2,4,3], l2 = [5,6,4]\nOutput: [8,0,7]",
      "images": [
        "https://assets.leetcode.com/uploads/2021/04/09/sumii-linked-list.jpg"
      ]
    },
    {
      "example_num": 3,
      "example_text": "Input: l1 = [0], l2 = [0]\nOutput: [0]",
      "images": [
        "https://assets.leetcode.com/uploads/2021/04/09/sumii-linked-list.jpg"
      ]
    }
  ],
  "constraints": [
    "The number of nodes in each linked list is in the range [1, 100].",
    "0 <= Node.val <= 9",
    "It is guaranteed that the list represents a number that does not have leading zeros."
  ],
  "follow_ups": [
    "Could you solve it without reversing the input lists?"
  ],
  "hints": [],
  "code_snippets": {
    "cpp": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\n        \n    }\n};",
    "java": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\n        \n    }\n}",
    "python": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def addTwoNumbers(self, l1, l2):\n        \"\"\"\n        :type l1: Optional[ListNode]\n        :type l2: Optional[ListNode]\n        :rtype: Optional[ListNode]\n        \"\"\"\n        ",
    "python3": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:\n        ",
    "c": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     struct ListNode *next;\n * };\n */\nstruct ListNode* addTwoNumbers(struct ListNode* l1, struct ListNode* l2) {\n    \n}",
    "csharp": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     public int val;\n *     public ListNode next;\n *     public ListNode(int val=0, ListNode next=null) {\n *         this.val = val;\n *         this.next = next;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode AddTwoNumbers(ListNode l1, ListNode l2) {\n        \n    }\n}",
    "javascript": "/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} l1\n * @param {ListNode} l2\n * @return {ListNode}\n */\nvar addTwoNumbers = function(l1, l2) {\n    \n};",
    "typescript": "/**\n * Definition for singly-linked list.\n * class ListNode {\n *     val: number\n *     next: ListNode | null\n *     constructor(val?: number, next?: ListNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.next = (next===undefined ? null : next)\n *     }\n * }\n */\n\nfunction addTwoNumbers(l1: ListNode | null, l2: ListNode | null): ListNode | null {\n    \n};",
    "php": "/**\n * Definition for a singly-linked list.\n * class ListNode {\n *     public $val = 0;\n *     public $next = null;\n *     function __construct($val = 0, $next = null) {\n *         $this->val = $val;\n *         $this->next = $next;\n *     }\n * }\n */\nclass Solution {\n\n    /**\n     * @param ListNode $l1\n     * @param ListNode $l2\n     * @return ListNode\n     */\n    function addTwoNumbers($l1, $l2) {\n        \n    }\n}",
    "swift": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     public var val: Int\n *     public var next: ListNode?\n *     public init() { self.val = 0; self.next = nil; }\n *     public init(_ val: Int) { self.val = val; self.next = nil; }\n *     public init(_ val: Int, _ next: ListNode?) { self.val = val; self.next = next; }\n * }\n */\nclass Solution {\n    func addTwoNumbers(_ l1: ListNode?, _ l2: ListNode?) -> ListNode? {\n        \n    }\n}",
    "kotlin": "/**\n * Example:\n * var li = ListNode(5)\n * var v = li.`val`\n * Definition for singly-linked list.\n * class ListNode(var `val`: Int) {\n *     var next: ListNode? = null\n * }\n */\nclass Solution {\n    fun addTwoNumbers(l1: ListNode?, l2: ListNode?): ListNode? {\n        \n    }\n}",
    "dart": "/**\n * Definition for singly-linked list.\n * class ListNode {\n *   int val;\n *   ListNode? next;\n *   ListNode([this.val = 0, this.next]);\n * }\n */\nclass Solution {\n  ListNode? addTwoNumbers(ListNode? l1, ListNode? l2) {\n    \n  }\n}",
    "golang": "/**\n * Definition for singly-linked list.\n * type ListNode struct {\n *     Val int\n *     Next *ListNode\n * }\n */\nfunc addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode {\n    \n}",
    "ruby": "# Definition for singly-linked list.\n# class ListNode\n#     attr_accessor :val, :next\n#     def initialize(val = 0, _next = nil)\n#         @val = val\n#         @next = _next\n#     end\n# end\n# @param {ListNode} l1\n# @param {ListNode} l2\n# @return {ListNode}\ndef add_two_numbers(l1, l2)\n    \nend",
    "scala": "/**\n * Definition for singly-linked list.\n * class ListNode(_x: Int = 0, _next: ListNode = null) {\n *   var next: ListNode = _next\n *   var x: Int = _x\n * }\n */\nobject Solution {\n    def addTwoNumbers(l1: ListNode, l2: ListNode): ListNode = {\n        \n    }\n}",
    "rust": "// Definition for singly-linked list.\n// #[derive(PartialEq, Eq, Clone, Debug)]\n// pub struct ListNode {\n//   pub val: i32,\n//   pub next: Option<Box<ListNode>>\n// }\n// \n// impl ListNode {\n//   #[inline]\n//   fn new(val: i32) -> Self {\n//     ListNode {\n//       next: None,\n//       val\n//     }\n//   }\n// }\nimpl Solution {\n    pub fn add_two_numbers(l1: Option<Box<ListNode>>, l2: Option<Box<ListNode>>) -> Option<Box<ListNode>> {\n        \n    }\n}",
    "racket": "; Definition for singly-linked list:\n#|\n\n; val : integer?\n; next : (or/c list-node? #f)\n(struct list-node\n  (val next) #:mutable #:transparent)\n\n; constructor\n(define (make-list-node [val 0])\n  (list-node val #f))\n\n|#\n\n(define/contract (add-two-numbers l1 l2)\n  (-> (or/c list-node? #f) (or/c list-node? #f) (or/c list-node? #f))\n  )",
    "erlang": "%% Definition for singly-linked list.\n%%\n%% -record(list_node, {val = 0 :: integer(),\n%%                     next = null :: 'null' | #list_node{}}).\n\n-spec add_two_numbers(L1 :: #list_node{} | null, L2 :: #list_node{} | null) -> #list_node{} | null.\nadd_two_numbers(L1, L2) ->\n  .",
    "elixir": "# Definition for singly-linked list.\n#\n# defmodule ListNode do\n#   @type t :: %__MODULE__{\n#           val: integer,\n#           next: ListNode.t() | nil\n#         }\n#   defstruct val: 0, next: nil\n# end\n\ndefmodule Solution do\n  @spec add_two_numbers(l1 :: ListNode.t | nil, l2 :: ListNode.t | nil) :: ListNode.t | nil\n  def add_two_numbers(l1, l2) do\n    \n  end\nend"
  },
  "solution": "[TOC]\n\n## Solution\n\n---\n\n### Approach 1: Reverse Given Linked Lists\n\n#### Intuition\n\nWe are told that the most significant digit comes first, and that each of their nodes includes a single digit. To do a basic addition of two numbers using a sum of two digits and a carry, we must start with the least significant digits (the lowest place) and work our way up to the most significant digits.\n\nTo get the order of digits from the least significant digits to the the most significant digits, we can reverse the given lists so the least significant digits come first.\n\nWe can then iterate over the reversed lists to perform the addition of digits at corresponding places similar to the first approach.\n\nLet's understand how to reverse a linked list. This is a classical problem that you can try [here](https://leetcode.com/problems/reverse-linked-list/).\n\nTo reverse a linked list, we need three pointers. The first pointer `head` points to the current node under consideration, `temp` points to the next node, and `prev` points to the previous node. This is because while traversing the list, we change the current node's (`head`) next pointer to point to its previous element (`prev`). Since a node does not have reference to its previous node, we must store its previous element beforehand. We also need another pointer to store the next node (`temp`) before changing the reference so we don't lose it after changing `head.next`.\n\nWe start with initializing `prev` to `null`. We then loop until `head` is null, i.e., until we iterate over all the elements. We store `head.next` in `temp` to store the next node we will go to. After storing the next node, we reverse `next` of `head` to the previous element, i.e., `head.next = prev`. We then move `prev` to `head` as this becomes the previous node for the next node and also move `head` to `temp` as this becomes the new node under consideration.\n\nHere's an animation visually showing how the approach works:\n\n!?!../Documents/445/445-slides.json:601,301!?!\n\n#### Algorithm\n\n1. Create two linked lists `r1` and `r2` to store the reverse of the linked lists `l1` and `l2` respectively. \n2. Create two integers `totalSum` and `carry` to store the sum and carry of current digits.\n3. Create a new `ListNode`, `ans` that will store the sum of current digits. \n4. We will add the two numbers using the reverse list by adding the digits one by one. We continue until we cover all the nodes in `r1` and `r2`:\n    - If `r1` is not `null`, we add `r1.val` to `totalSum`.\n    - If `r2` is not `null`, we add `r2.val` to `totalSum`.\n    - Set `ans.val = totalSum % 10`.  \n    - Store the `carry` as `totalSum / 10`. \n    - Create a new `ListNode`, `newNode` that will have `val` as `carry`. Set `next` of `newNode` to `ans`. Update `ans = newNode` to use the same variable `ans` for the next iteration.\n    - Update `totalSum = carry`.\n7. If `carry == 0`, it means the `newNode` that we created in the final iteration of while loop has `val = 0`. Because we perform `ans = newNode` at the end of each while loop iteration while loop, to avoid returning a linked list with a head of `0` (leading zero), we return the next element, i.e., we return `ans.next`. Otherwise, if `carry` is not equal to `0`, the value of `ans` is non-zero. Hence, we just return `ans`.\n\n#### Implementation#### Complexity Analysis\n\nHere, $m$ and $n$ are is the number of nodes in `l1` and `l2` respectively\n\n* Time complexity: $O(m + n)$\n\n    - Reversing the list `l1` and `l2`  take $O(m)$ and $O(n)$ time respectively.\n    - We then iterate over digits of the both lists. We iterate until both the lists are fully traversed. We iterate in the while loop `max(m, n)` times. We compute `totalSum`, `carry` and create a new node in each iteration which takes $O(1)$ time. Hence, the complexity of all the while loop can be written as $O(m + n)$ time.\n\n* Space complexity: $O(m + n)$\n\n    - As we have reversed the input linked lists, we will count the space consumed by the reversed lists. The `r1` linked list takes $O(m)$ space and `r2` takes $O(n)$ space.\n    - Note: one could argue that because `r1` and `r2` are only referencing the input lists and not making copies of them, we are using $O(1)$ space. In most problems, you wouldn't count the input as part of the space complexity because the input doesn't contribute toward the algorithm. In this approach, the input is used heavily by our algorithm in terms of logic, and thus, we are counting it as part of the space complexity.\n\n---\n\n### Approach 2: Stack\n\n#### Intuition\n\nOur task is to do a basic addition of two numbers starting with the least significant digits and working our way up to the most significant digits. In the previous approach, we reversed the linked lists to access the least significant digits first. We can also use **stacks** to access the least significant digits first.\n\nThe advantage of using a stack is that when we loop over a given linked list from the first node to the last and push all the digits in the stack, the top of the stack will have the least significant digit and the bottom will contain the most significant digit.\n\nWe can add the digits at corresponding places of the linked lists using the two stacks moving from the least to the most significant digits using the stack's `pop` method.\n\nHere's a brief visual representation explaining the approach:\n\n![img](../Figures/445/445-stack.png)\n\n#### Algorithm\n\n1. Create two integer stacks `s1` and `s2` to store the integers of the linked lists `l1` and `l2` respectively. \n2. Push all the integers of `l1` in `s1` starting from the integer at the first node. The most significant comes first in the list, so it will be stored at the bottom of the stack and the least significant digit will stored at the top.\n3. Similarly, push all the integers of `l2` in `s2`.\n4. Create two integers `totalSum` and `carry` to store the sum and carry of current digits.\n5. Create a new `ListNode`, `ans` that will store the answer. \n6. We will add the two numbers present in the linked list now by adding the digits one by one. We continue until both `s1` and `s2` are empty:\n    - If `s1` is not empty, pop the first element from the stack and add it to `totalSum`.\n    - If `s2` is not empty, pop the first element from the stack and add it to `totalSum`.\n    - Set `ans.val = totalSum % 10`.  \n    - Store the `carry` as `totalSum / 10`. \n    - Create a new `ListNode`, `newNode` that will have `val` as `carry`. Set `next` of `newNode` to `ans`. Update `ans = newNode` to use the same variable `ans` for the next iteration.\n    - Update `totalSum = carry`.\n7. If `carry == 0`, it means the `newNode` that we created in the final iteration of while loop has `val = 0`. Because we perform `ans = newNode` at the end of each while loop, to avoid returning a linked list with a head of `0` (leading zero), we return the next element, i.e., we return `ans.next`. Otherwise, if `carry` is not equal to `0`, the value of `ans` is non-zero. Hence, we just return `ans`.\n\n#### Implementation#### Complexity Analysis\n\nHere, $m$ and $n$ are is the number of nodes in `l1` and `l2` respectively\n\n* Time complexity: $O(m + n)$\n\n    - Iterating over both the lists and pushing all the values in the respective stacks take $O(m + n)$ time.\n    - We then iterate over digits of the both lists. We iterate until both the stacks are empty. We iterate in the while loop `max(m, n)` times. We compute `sum`, `carry` and create a new node in each iteration which takes $O(1)$ time. Hence, the complexity of all the while loop can be written as $O(m + n)$ time.\n\n* Space complexity: $O(m + n)$\n\n    - The `s1` stack takes $O(m)$ space and the `s2` stack takes $O(n)$ space."
}