{
  "title": "Find the Length of the Longest Common Prefix",
  "problem_id": "3329",
  "frontend_id": "3043",
  "difficulty": "Medium",
  "problem_slug": "find-the-length-of-the-longest-common-prefix",
  "topics": [
    "Array",
    "Hash Table",
    "String",
    "Trie"
  ],
  "description": "You are given two arrays with positive integers arr1 and arr2.\nA prefix of a positive integer is an integer formed by one or more of its digits, starting from its leftmost digit. For example, 123 is a prefix of the integer 12345, while 234 is not.\nA common prefix of two integers a and b is an integer c, such that c is a prefix of both a and b. For example, 5655359 and 56554 have common prefixes 565 and 5655 while 1223 and 43456 do not have a common prefix.\nYou need to find the length of the longest common prefix between all pairs of integers (x, y) such that x belongs to arr1 and y belongs to arr2.\nReturn the length of the longest common prefix among all pairs. If no common prefix exists among them, return 0.\nExample 1:\nExample 2:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: arr1 = [1,10,100], arr2 = [1000]\nOutput: 3\nExplanation: There are 3 pairs (arr1[i], arr2[j]):\n- The longest common prefix of (1, 1000) is 1.\n- The longest common prefix of (10, 1000) is 10.\n- The longest common prefix of (100, 1000) is 100.\nThe longest common prefix is 100 with a length of 3.",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input: arr1 = [1,2,3], arr2 = [4,4,4]\nOutput: 0\nExplanation: There exists no common prefix for any pair (arr1[i], arr2[j]), hence we return 0.\nNote that common prefixes between elements of the same array do not count.",
      "images": []
    }
  ],
  "constraints": [
    "1 <= arr1.length, arr2.length <= 5 * 104",
    "1 <= arr1[i], arr2[i] <= 108"
  ],
  "follow_ups": [],
  "hints": [
    "Put all the possible prefixes of each element in <code>arr1</code> into a HashSet.",
    "For all the possible prefixes of each element in <code>arr2</code>, check if it exists in the HashSet."
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    int longestCommonPrefix(vector<int>& arr1, vector<int>& arr2) {\n        \n    }\n};",
    "java": "class Solution {\n    public int longestCommonPrefix(int[] arr1, int[] arr2) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def longestCommonPrefix(self, arr1, arr2):\n        \"\"\"\n        :type arr1: List[int]\n        :type arr2: List[int]\n        :rtype: int\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def longestCommonPrefix(self, arr1: List[int], arr2: List[int]) -> int:\n        ",
    "c": "int longestCommonPrefix(int* arr1, int arr1Size, int* arr2, int arr2Size) {\n    \n}",
    "csharp": "public class Solution {\n    public int LongestCommonPrefix(int[] arr1, int[] arr2) {\n        \n    }\n}",
    "javascript": "/**\n * @param {number[]} arr1\n * @param {number[]} arr2\n * @return {number}\n */\nvar longestCommonPrefix = function(arr1, arr2) {\n    \n};",
    "typescript": "function longestCommonPrefix(arr1: number[], arr2: number[]): number {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param Integer[] $arr1\n     * @param Integer[] $arr2\n     * @return Integer\n     */\n    function longestCommonPrefix($arr1, $arr2) {\n        \n    }\n}",
    "swift": "class Solution {\n    func longestCommonPrefix(_ arr1: [Int], _ arr2: [Int]) -> Int {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun longestCommonPrefix(arr1: IntArray, arr2: IntArray): Int {\n        \n    }\n}",
    "dart": "class Solution {\n  int longestCommonPrefix(List<int> arr1, List<int> arr2) {\n    \n  }\n}",
    "golang": "func longestCommonPrefix(arr1 []int, arr2 []int) int {\n    \n}",
    "ruby": "# @param {Integer[]} arr1\n# @param {Integer[]} arr2\n# @return {Integer}\ndef longest_common_prefix(arr1, arr2)\n    \nend",
    "scala": "object Solution {\n    def longestCommonPrefix(arr1: Array[Int], arr2: Array[Int]): Int = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn longest_common_prefix(arr1: Vec<i32>, arr2: Vec<i32>) -> i32 {\n        \n    }\n}",
    "racket": "(define/contract (longest-common-prefix arr1 arr2)\n  (-> (listof exact-integer?) (listof exact-integer?) exact-integer?)\n  )",
    "erlang": "-spec longest_common_prefix(Arr1 :: [integer()], Arr2 :: [integer()]) -> integer().\nlongest_common_prefix(Arr1, Arr2) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec longest_common_prefix(arr1 :: [integer], arr2 :: [integer]) :: integer\n  def longest_common_prefix(arr1, arr2) do\n    \n  end\nend"
  },
  "solution": "[TOC]\n\n## Solution\n\n---\n\n### Approach 1: Using Hash Table\n\n#### Intuition\n\nWe want to find the longest common prefix between numbers in two arrays. A prefix is formed from the digits of a number, starting from the left. To solve this, the key observation is that the prefix of a number can be reduced by removing its last digit repeatedly. By storing these reduced forms, we can efficiently check for common prefixes.\n\n> Note: In this context, a \"prefix\" refers to the sequence of digits that starts at the beginning of an integer and can be any length up to the full length of that integer. For example, 12 is a prefix of 123. A common prefix is one that appears at the start of both integers from `arr1` and `arr2`.\n\nThe idea is to first create a hash table to hold all possible prefixes of the numbers from the first array (`arr1`). For each number in `arr1`, we break it down digit by digit, storing every prefix form (by dividing it by 10). This way, the hash table contains all possible digit patterns that could match any part of a number in `arr2`.\n\nNext, for each number in `arr2`, we try to match it against the prefixes stored in the hash table. We keep reducing the number, removing digits from the end, until we find a match. Once we find a match, we compute the length of that prefix by counting its digits. The process repeats for all numbers in `arr2`, and we track the longest common prefix found across all comparisons.\n\nRather than comparing each number digit by digit across both arrays, we reduce the problem to prefix matching by storing all prefixes in a hash table and checking against it.\n\n#### Algorithm\n\n- Step 1: Build Prefixes from `arr1`:\n  - Initialize an empty set `arr1Prefixes` to store all prefixes derived from `arr1`.\n  - Iterate over each value `val` in `arr1`:\n    - While `val` is not in `arr1Prefixes` and `val` is greater than 0:\n      - Add `val` to `arr1Prefixes` (storing `val` as a prefix).\n      - Update `val` to the next shorter prefix by removing the last digit (`val /= 10`).\n\n- Step 2: Find the Longest Matching Prefix in `arr2`:\n  - Initialize `longestPrefix` to 0 to keep track of the length of the longest common prefix found.\n  - Iterate over each value `val` in `arr2`:\n    - While `val` is not in `arr1Prefixes` and `val` is greater than 0:\n      - Reduce `val` by removing the last digit (`val /= 10`).\n    - If `val` is greater than 0 (i.e., a matching prefix is found):\n      - Update `longestPrefix` to the maximum of its current value and the length of the matched prefix (calculated using `log10(val) + 1`).\n\n- Return the length of the longest common prefix found.\n\n#### Implementation#### Complexity Analysis\n\nLet $m$ be the length of `arr1`, $n$ be the length of `arr2`, $M$ be the maximum value in `arr1`, and $N$ be the maximum value in `arr2`.\n\n- Time Complexity: $O(m \\cdot \\log_{10} M + n \\cdot \\log_{10} N)$\n  \n    For each number in `arr1`, we repeatedly divide the number by 10 to generate its prefixes. Since dividing a number by 10 reduces the number of digits logarithmically, this process takes $O(\\log_{10} M)$ for each number in `arr1`. Hence, for $m$ numbers, the total time complexity is $O(m \\cdot \\log_{10} M)$.\n\n    Similarly, for each number in `arr2`, we reduce it by repeatedly dividing it by 10 to check if it matches any prefix in the set. This also takes $O(\\log_{10} N)$ for each number in `arr2`. Hence, for $n$ numbers, the total time complexity is $O(n \\cdot \\log_{10} N)$.\n\n    Overall, the total time complexity is $O(m \\cdot \\log_{10} M + n \\cdot \\log_{10} N)$.\n\n- Space Complexit: $O(m \\cdot \\log_{10} M)$\n\n    Each number in `arr1` contributes $O(\\log_{10} M)$ space to the set, as it generates prefixes proportional to the number of digits (logarithmic in the value of the number with base 10). With $m$ numbers in `arr1`, the total space complexity for the set is $O(m \\cdot \\log_{10} M)$.\n\n    The algorithm uses constant space for variables like `longestPrefix` and loop variables, so this doesnâ€™t contribute significantly to the space complexity.\n\n    Thus, the total space complexity is $O(m \\cdot \\log_{10} M)$.\n\n---\n\n### Approach 2: Trie\n\n#### Intuition\n\nInstead of using a set, we build a Trie to store all numbers from `arr1` in a trie form that allows for efficient prefix lookups.\n\nA [Trie](https://leetcode.com/explore/learn/card/trie/) can store digit sequences. Each path in the Trie represents a sequence of digits that corresponds to a prefix. As we insert each number from `arr1`, we break it down into individual digits and store them along a path in the Trie. This allows us to quickly check if a number from `arr2` shares a prefix with any number from `arr1`.\n\nFor every number in `arr2`, we traverse the Trie digit by digit. The traversal stops when a digit doesn't match, and we count how many digits we managed to match as the length of the common prefix. Like the first approach, we repeat this process for all numbers in `arr2` and track the longest common prefix.\n\nInstead of reducing numbers manually like in the first approach, the Trie helps us handle digit sequences directly, which makes the solution both elegant and efficient. It avoids the need to store all possible prefixes explicitly, focusing instead on a structured search through the Trie.\n\n![Trie](../Figures/3043/3043_trie.png)\n\n#### Algorithm\n\n- `Trie` class:\n  - Initialize the `Trie` with a root node, which is an instance of `TrieNode`.\n\n  - Inner `TrieNode` class:\n    - Each `TrieNode` has an array `children` of size 10 (for digits 0-9), initialized to null in the constructor to represent an empty node.\n\n  - Initialize the `Trie` with a root node, which is an instance of `TrieNode`.\n\n  - `insert` function:\n    - Convert the integer `num` to its string representation `numStr`.\n    - Iterate over each character `digit` in `numStr`:\n      - Convert `digit` to its integer index `idx`.\n      - If `node.children[idx]` is null, create a new `TrieNode` and assign it to `node.children[idx]`.\n      - Move to the child node at `node.children[idx]`.\n    - Insert all digits of `num` into the Trie.\n\n  - `findLongestPrefix` function:\n    - Convert the integer `num` to its string representation `numStr`.\n    - Initialize `len` to 0 to keep track of the length of the common prefix.\n    - Iterate over each character `digit` in `numStr`:\n      - Convert `digit` to its integer index `idx`.\n      - If `node.children[idx]` exists, increment `len` and move to the child node at `node.children[idx]`.\n      - If `node.children[idx]` is null, break the loop as the prefix match ends.\n    - Return `len` which represents the length of the longest common prefix.\n\n- `longestCommonPrefix` function:\n  - Create an instance of `Trie`.\n  - Insert all numbers from `arr1` into the Trie.\n  - Initialize `longestPrefix` to 0.\n  - For each number `num` in `arr2`:\n    - Call `trie.findLongestPrefix(num)` to find the length of the longest prefix for `num` in the Trie.\n    - Update `longestPrefix` with the maximum value between `longestPrefix` and the result from `findLongestPrefix`.\n  - Return `longestPrefix` as the result, which is the length of the longest common prefix between numbers in `arr1` and `arr2`.\n\n#### Implementation#### Complexity Analysis\n\nLet $m$ be the length of `arr1`, $n$ be the length of `arr2`.\n\n- Time Complexity: $O(m \\cdot d + n \\cdot d) = O(m + n)$\n  \n    For each number in `arr1`, we insert it into the Trie by processing each digit. Since each number has up to $d$ digits, inserting a single number takes $O(d)$ time. Therefore, inserting all $m$ numbers from `arr1` into the Trie takes $O(m \\cdot d)$ time.\n\n    For each number in `arr2`, we check how long its prefix matches with any prefix in the Trie. This involves traversing up to $d$ digits of the number, which takes $O(d)$ time per number. For all $n$ numbers in `arr2`, the time complexity for this step is $O(n \\cdot d)$.\n\n    Overall, the total time complexity is $O(m \\cdot d + n \\cdot d) = O(m + n)$\n\n- Space Complexity: $O(m \\cdot d) = O(m)$\n\n    Each node in the Trie represents a digit (0-9), and each number from `arr1` can contribute up to $d$ nodes. Thus, the total space used by the Trie for storing all prefixes is $O(m \\cdot d)$.\n\n    The algorithm uses constant space for variables like `longestPrefix` and loop variables, which is negligible compared to the space used by the Trie.\n\n    Thus, the total space complexity is $O(m \\cdot d) = O(m)$.\n\n---"
}