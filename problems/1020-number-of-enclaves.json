{
  "title": "Number of Enclaves",
  "problem_id": "1073",
  "frontend_id": "1020",
  "difficulty": "Medium",
  "problem_slug": "number-of-enclaves",
  "topics": [
    "Array",
    "Depth-First Search",
    "Breadth-First Search",
    "Union Find",
    "Matrix"
  ],
  "description": "You are given an m x n binary matrix grid, where 0 represents a sea cell and 1 represents a land cell.\nA move consists of walking from one land cell to another adjacent (4-directionally) land cell or walking off the boundary of the grid.\nReturn the number of land cells in grid for which we cannot walk off the boundary of the grid in any number of moves.\nExample 1:\nExample 2:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: grid = [[0,0,0,0],[1,0,1,0],[0,1,1,0],[0,0,0,0]]\nOutput: 3\nExplanation: There are three 1s that are enclosed by 0s, and one 1 that is not enclosed because its on the boundary.",
      "images": [
        "https://assets.leetcode.com/uploads/2021/02/18/enclaves1.jpg"
      ]
    },
    {
      "example_num": 2,
      "example_text": "Input: grid = [[0,1,1,0],[0,0,1,0],[0,0,1,0],[0,0,0,0]]\nOutput: 0\nExplanation: All 1s are either on the boundary or can reach the boundary.",
      "images": [
        "https://assets.leetcode.com/uploads/2021/02/18/enclaves2.jpg"
      ]
    }
  ],
  "constraints": [
    "m == grid.length",
    "n == grid[i].length",
    "1 <= m, n <= 500",
    "grid[i][j] is either 0 or 1."
  ],
  "follow_ups": [],
  "hints": [
    "Can you model this problem as a graph problem?  Create n * m + 1 nodes where n * m nodes represents each cell of the map and one extra node to represent the exterior of the map.",
    "In the map add edges between neighbors on land cells. And add edges between the exterior and land nodes which are in the boundary.\r\nReturn as answer the number of nodes that are not reachable from the exterior node."
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    int numEnclaves(vector<vector<int>>& grid) {\n        \n    }\n};",
    "java": "class Solution {\n    public int numEnclaves(int[][] grid) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def numEnclaves(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def numEnclaves(self, grid: List[List[int]]) -> int:\n        ",
    "c": "int numEnclaves(int** grid, int gridSize, int* gridColSize) {\n    \n}",
    "csharp": "public class Solution {\n    public int NumEnclaves(int[][] grid) {\n        \n    }\n}",
    "javascript": "/**\n * @param {number[][]} grid\n * @return {number}\n */\nvar numEnclaves = function(grid) {\n    \n};",
    "typescript": "function numEnclaves(grid: number[][]): number {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param Integer[][] $grid\n     * @return Integer\n     */\n    function numEnclaves($grid) {\n        \n    }\n}",
    "swift": "class Solution {\n    func numEnclaves(_ grid: [[Int]]) -> Int {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun numEnclaves(grid: Array<IntArray>): Int {\n        \n    }\n}",
    "dart": "class Solution {\n  int numEnclaves(List<List<int>> grid) {\n    \n  }\n}",
    "golang": "func numEnclaves(grid [][]int) int {\n    \n}",
    "ruby": "# @param {Integer[][]} grid\n# @return {Integer}\ndef num_enclaves(grid)\n    \nend",
    "scala": "object Solution {\n    def numEnclaves(grid: Array[Array[Int]]): Int = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn num_enclaves(grid: Vec<Vec<i32>>) -> i32 {\n        \n    }\n}",
    "racket": "(define/contract (num-enclaves grid)\n  (-> (listof (listof exact-integer?)) exact-integer?)\n  )",
    "erlang": "-spec num_enclaves(Grid :: [[integer()]]) -> integer().\nnum_enclaves(Grid) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec num_enclaves(grid :: [[integer]]) :: integer\n  def num_enclaves(grid) do\n    \n  end\nend"
  }
}