{
  "title": "Number of Good Paths",
  "problem_id": "2505",
  "frontend_id": "2421",
  "difficulty": "Hard",
  "problem_slug": "number-of-good-paths",
  "topics": [
    "Array",
    "Hash Table",
    "Tree",
    "Union Find",
    "Graph",
    "Sorting"
  ],
  "description": "There is a tree (i.e. a connected, undirected graph with no cycles) consisting of n nodes numbered from 0 to n - 1 and exactly n - 1 edges.\nYou are given a 0-indexed integer array vals of length n where vals[i] denotes the value of the ith node. You are also given a 2D integer array edges where edges[i] = [ai, bi] denotes that there exists an undirected edge connecting nodes ai and bi.\nA good path is a simple path that satisfies the following conditions:\nReturn the number of distinct good paths.\nNote that a path and its reverse are counted as the same path. For example, 0 -> 1 is considered to be the same as 1 -> 0. A single node is also considered as a valid path.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: vals = [1,3,2,1,3], edges = [[0,1],[0,2],[2,3],[2,4]]\nOutput: 6\nExplanation: There are 5 good paths consisting of a single node.\nThere is 1 additional good path: 1 -> 0 -> 2 -> 4.\n(The reverse path 4 -> 2 -> 0 -> 1 is treated as the same as 1 -> 0 -> 2 -> 4.)\nNote that 0 -> 2 -> 3 is not a good path because vals[2] > vals[0].",
      "images": [
        "https://assets.leetcode.com/uploads/2022/08/04/f9caaac15b383af9115c5586779dec5.png"
      ]
    },
    {
      "example_num": 2,
      "example_text": "Input: vals = [1,1,2,2,3], edges = [[0,1],[1,2],[2,3],[2,4]]\nOutput: 7\nExplanation: There are 5 good paths consisting of a single node.\nThere are 2 additional good paths: 0 -> 1 and 2 -> 3.",
      "images": [
        "https://assets.leetcode.com/uploads/2022/08/04/149d3065ec165a71a1b9aec890776ff.png"
      ]
    },
    {
      "example_num": 3,
      "example_text": "Input: vals = [1], edges = []\nOutput: 1\nExplanation: The tree consists of only one node, so there is one good path.",
      "images": [
        "https://assets.leetcode.com/uploads/2022/08/04/31705e22af3d9c0a557459bc7d1b62d.png"
      ]
    }
  ],
  "constraints": [
    "n == vals.length",
    "1 <= n <= 3 * 104",
    "0 <= vals[i] <= 105",
    "edges.length == n - 1",
    "edges[i].length == 2",
    "0 <= ai, bi < n",
    "ai != bi",
    "edges represents a valid tree."
  ],
  "follow_ups": [],
  "hints": [
    "Can you process nodes from smallest to largest value?",
    "Try to build the graph from nodes with the smallest value to the largest value.",
    "May union find help?"
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    int numberOfGoodPaths(vector<int>& vals, vector<vector<int>>& edges) {\n        \n    }\n};",
    "java": "class Solution {\n    public int numberOfGoodPaths(int[] vals, int[][] edges) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def numberOfGoodPaths(self, vals, edges):\n        \"\"\"\n        :type vals: List[int]\n        :type edges: List[List[int]]\n        :rtype: int\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def numberOfGoodPaths(self, vals: List[int], edges: List[List[int]]) -> int:\n        ",
    "c": "int numberOfGoodPaths(int* vals, int valsSize, int** edges, int edgesSize, int* edgesColSize) {\n    \n}",
    "csharp": "public class Solution {\n    public int NumberOfGoodPaths(int[] vals, int[][] edges) {\n        \n    }\n}",
    "javascript": "/**\n * @param {number[]} vals\n * @param {number[][]} edges\n * @return {number}\n */\nvar numberOfGoodPaths = function(vals, edges) {\n    \n};",
    "typescript": "function numberOfGoodPaths(vals: number[], edges: number[][]): number {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param Integer[] $vals\n     * @param Integer[][] $edges\n     * @return Integer\n     */\n    function numberOfGoodPaths($vals, $edges) {\n        \n    }\n}",
    "swift": "class Solution {\n    func numberOfGoodPaths(_ vals: [Int], _ edges: [[Int]]) -> Int {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun numberOfGoodPaths(vals: IntArray, edges: Array<IntArray>): Int {\n        \n    }\n}",
    "dart": "class Solution {\n  int numberOfGoodPaths(List<int> vals, List<List<int>> edges) {\n    \n  }\n}",
    "golang": "func numberOfGoodPaths(vals []int, edges [][]int) int {\n    \n}",
    "ruby": "# @param {Integer[]} vals\n# @param {Integer[][]} edges\n# @return {Integer}\ndef number_of_good_paths(vals, edges)\n    \nend",
    "scala": "object Solution {\n    def numberOfGoodPaths(vals: Array[Int], edges: Array[Array[Int]]): Int = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn number_of_good_paths(vals: Vec<i32>, edges: Vec<Vec<i32>>) -> i32 {\n        \n    }\n}",
    "racket": "(define/contract (number-of-good-paths vals edges)\n  (-> (listof exact-integer?) (listof (listof exact-integer?)) exact-integer?)\n  )",
    "erlang": "-spec number_of_good_paths(Vals :: [integer()], Edges :: [[integer()]]) -> integer().\nnumber_of_good_paths(Vals, Edges) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec number_of_good_paths(vals :: [integer], edges :: [[integer]]) :: integer\n  def number_of_good_paths(vals, edges) do\n    \n  end\nend"
  }
}