{
  "title": "Friend Requests II: Who Has the Most Friends",
  "problem_id": "602",
  "frontend_id": "602",
  "difficulty": "Medium",
  "problem_slug": "friend-requests-ii-who-has-the-most-friends",
  "topics": [
    "Database"
  ],
  "description": "Table: RequestAccepted\nWrite a solution to find the people who have the most friends and the most friends number.\nThe test cases are generated so that only one person has the most friends.\nThe result format is in the following example.\nExample 1:\nFollow up: In the real world, multiple people could have the same most number of friends. Could you find all these people in this case?",
  "examples": [
    {
      "example_num": 1,
      "example_text": "+----------------+---------+\n| Column Name    | Type    |\n+----------------+---------+\n| requester_id   | int     |\n| accepter_id    | int     |\n| accept_date    | date    |\n+----------------+---------+\n(requester_id, accepter_id) is the primary key (combination of columns with unique values) for this table.\nThis table contains the ID of the user who sent the request, the ID of the user who received the request, and the date when the request was accepted.",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input: \nRequestAccepted table:\n+--------------+-------------+-------------+\n| requester_id | accepter_id | accept_date |\n+--------------+-------------+-------------+\n| 1            | 2           | 2016/06/03  |\n| 1            | 3           | 2016/06/08  |\n| 2            | 3           | 2016/06/08  |\n| 3            | 4           | 2016/06/09  |\n+--------------+-------------+-------------+\nOutput: \n+----+-----+\n| id | num |\n+----+-----+\n| 3  | 3   |\n+----+-----+\nExplanation: \nThe person with id 3 is a friend of people 1, 2, and 4, so he has three friends in total, which is the most number than any others.",
      "images": []
    }
  ],
  "constraints": [],
  "follow_ups": [
    "In the real world, multiple people could have the same most number of friends. Could you find all these people in this case?"
  ],
  "hints": [
    "Being friends is bidirectional. If you accept someone's adding friend request, both you and the other person will have one more friend."
  ],
  "code_snippets": {
    "mysql": "# Write your MySQL query statement below\n",
    "mssql": "/* Write your T-SQL query statement below */\n",
    "oraclesql": "/* Write your PL/SQL query statement below */\n",
    "pythondata": "import pandas as pd\n\ndef most_friends(request_accepted: pd.DataFrame) -> pd.DataFrame:\n    ",
    "postgresql": "-- Write your PostgreSQL query statement below\n"
  },
  "solution": "​[TOC]\n​\n# Solution\n​\n---\n​\n## pandas### Approach: Combining DataFrames Using concat() and Finding the Top Values Using sort_values() and head()#### AlgorithmSince one person can acquire a friend by either requesting or accepting a friend request, to get how many friends each person has, we can count how many times their id appeared in either the column `requester_id` or the column `accepter_id`. It's generally a good idea to combine the two columns into one for easier calculation. \n\nLet's start by combining the two columns. We can leverage the function `concat()` to combine DataFrames just like using `UNION/UNION ALL` in MySQL, or, in this case, combine only the columns. We add the function `to_frame()` to convert the result from a Series to a DataFrame. For later calculation, we also renamed the newly created column as `id`.\n\n```python\nvalues = pd.concat([request_accepted[\"requester_id\"], request_accepted[\"accepter_id\"]]).to_frame('id')\n```\n\nWe now have the two columns `requester_id` and `accepter_id` combined into one. \n\n| id |\n| -- |\n| 1  |\n| 1  |\n| 2  |\n| 3  |\n| 2  |\n| 3  |\n| 3  |\n| 4  |\n\nNow we only need to count how many times each `id` appeared in the list and identify the `id` with the maximum count. To do this, we can apply `count()` to `id` and group the result at the `id` level. We can leverage the function `agg()` to get the aggregate value and rename the result at the same time. To look for the maximum count, we sort the list by the count (the newly created column `num`) in descending order using the function `sort_values()` and passing the parameter `ascending=False` to the function. The `id` that has the most friends is now listed at the top, and we can select this record using the function `head()`.  \n\n```python\ndf = values.groupby('id', as_index=False).agg(num=('id', 'count')).sort_values('num', ascending=False).head(1)\n```#### Implementation\n​----\n​\n​\n## Database### Approach 1: Combining Tables Using UNION ALL and Finding the Top Values Using ORDER BY + LIMIT#### AlgorithmSince one person can acquire a friend by either requesting or accepting a friend request, to get how many friends each person has, we can count how many times their id appeared in either the column `requester_id` or the column `accepter_id`. It's generally a good idea to combine the two columns into one for easier calculation. \n\nLet's start by combining the two columns. For this problem, it's important to use `UNION ALL` so all duplicate values are kept. Both columns are renamed as `id`, and we can put this step in a CTE for later usage. \n\n```sql\nWITH all_ids AS (\n   SELECT requester_id AS id \n   FROM RequestAccepted\n   UNION ALL\n   SELECT accepter_id AS id\n   FROM RequestAccepted)\n```\n\nNext, we can count how many times each `id` appeared in the list and identify the `id` with the maximum count. To do this, we can group the aggregate value `COUNT(id)` at the `id` level. To retain only the `id` that has the maximum counts, we can sort the result by the `COUNT(id)` in descending order and take only the first record using `LIMIT`. Last but not least, we rename the aggregate count to `num` for the final output. All of these steps can be achieved in the main query without creating any subqueries. \n\n\n```sql\nSELECT id, \n   COUNT(id) AS num\nFROM all_ids\nGROUP BY id\nORDER BY COUNT(id) DESC\nLIMIT 1\n```#### Implementation\n\n```mysql []\nWITH all_ids AS (\n   SELECT requester_id AS id \n   FROM RequestAccepted\n   UNION ALL\n   SELECT accepter_id AS id\n   FROM RequestAccepted)\nSELECT id, \n   COUNT(id) AS num\nFROM all_ids\nGROUP BY id\nORDER BY COUNT(id) DESC\nLIMIT 1\n```\n​### Approach 2: Combining Tables Using UNION ALL and Finding Top Values Using RANK()#### AlgorithmThe main difference between this approach and the first one is that this approach can include multiple `id`s if there is more than one person who has the most number of friends. Also, it's never a bad idea to use the window function.  \n\nSimilarly, we can start by combining the two columns into one. For this problem, it's important to use `UNION ALL` so all duplicate values are kept. Both columns are renamed as `id`, and we can put this step in a CTE for later usage. \n\n\n```sql\nWITH all_ids AS (\n   SELECT requester_id AS id \n   FROM RequestAccepted\n   UNION ALL\n   SELECT accepter_id AS id\n   FROM RequestAccepted)\n```\n\nIn the subquery, we can count how many times each `id` appeared in the list using `COUNT()` and `GROUP` the result at the `id` level. The calculated result is renamed to `num` as requested by the final output. Additionally, we can append a rank to the records per the aggregate count in descending order. \n\n```sql\n   (\n   SELECT id, \n      COUNT(id) AS num, \n      RANK () OVER(ORDER BY COUNT(id) DESC) AS rnk\n   FROM all_ids\n   GROUP BY id\n   )t0\n```\n\nNow we can select the top record, which is the `id` that has the maximum count (number of friends), in the main query. \n\n```sql\nSELECT id, num\nFROM \n   (\n   SELECT id, \n      COUNT(id) AS num, \n      RANK () OVER(ORDER BY COUNT(id) DESC) AS rnk\n   FROM all_ids\n   GROUP BY id\n   )t0\nWHERE rnk=1\n```#### Implementation\n\n```mysql []\nWITH all_ids AS (\n   SELECT requester_id AS id \n   FROM RequestAccepted\n   UNION ALL\n   SELECT accepter_id AS id\n   FROM RequestAccepted)\nSELECT id, num\nFROM \n   (\n   SELECT id, \n      COUNT(id) AS num, \n      RANK () OVER(ORDER BY COUNT(id) DESC) AS rnk\n   FROM all_ids\n   GROUP BY id\n   )t0\nWHERE rnk=1\n```\n----"
}