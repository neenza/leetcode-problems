{
  "title": "Relocate Marbles",
  "problem_id": "2834",
  "frontend_id": "2766",
  "difficulty": "Medium",
  "problem_slug": "relocate-marbles",
  "topics": [
    "Array",
    "Hash Table",
    "Sorting",
    "Simulation"
  ],
  "description": "You are given a 0-indexed integer array nums representing the initial positions of some marbles. You are also given two 0-indexed integer arrays moveFrom and moveTo of equal length.\nThroughout moveFrom.length steps, you will change the positions of the marbles. On the ith step, you will move all marbles at position moveFrom[i] to position moveTo[i].\nAfter completing all the steps, return the sorted list of occupied positions.\nNotes:\nExample 1:\nExample 2:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: nums = [1,6,7,8], moveFrom = [1,7,2], moveTo = [2,9,5]\nOutput: [5,6,8,9]\nExplanation: Initially, the marbles are at positions 1,6,7,8.\nAt the i = 0th step, we move the marbles at position 1 to position 2. Then, positions 2,6,7,8 are occupied.\nAt the i = 1st step, we move the marbles at position 7 to position 9. Then, positions 2,6,8,9 are occupied.\nAt the i = 2nd step, we move the marbles at position 2 to position 5. Then, positions 5,6,8,9 are occupied.\nAt the end, the final positions containing at least one marbles are [5,6,8,9].",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input: nums = [1,1,3,3], moveFrom = [1,3], moveTo = [2,2]\nOutput: [2]\nExplanation: Initially, the marbles are at positions [1,1,3,3].\nAt the i = 0th step, we move all the marbles at position 1 to position 2. Then, the marbles are at positions [2,2,3,3].\nAt the i = 1st step, we move all the marbles at position 3 to position 2. Then, the marbles are at positions [2,2,2,2].\nSince 2 is the only occupied position, we return [2].",
      "images": []
    }
  ],
  "constraints": [
    "1 <= nums.length <= 105",
    "1 <= moveFrom.length <= 105",
    "moveFrom.length == moveTo.length",
    "1 <= nums[i], moveFrom[i], moveTo[i] <= 109",
    "The test cases are generated such that there is at least a marble in moveFrom[i] at the moment we want to apply the ith move."
  ],
  "follow_ups": [],
  "hints": [
    "Can we solve this problem using a set or map?",
    "Sequentially process pairs from moveFrom[i] and moveTo[i]. In each step, remove the occurrence of moveFrom[i] and add moveTo[i] into the set."
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    vector<int> relocateMarbles(vector<int>& nums, vector<int>& moveFrom, vector<int>& moveTo) {\n        \n    }\n};",
    "java": "class Solution {\n    public List<Integer> relocateMarbles(int[] nums, int[] moveFrom, int[] moveTo) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def relocateMarbles(self, nums, moveFrom, moveTo):\n        \"\"\"\n        :type nums: List[int]\n        :type moveFrom: List[int]\n        :type moveTo: List[int]\n        :rtype: List[int]\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def relocateMarbles(self, nums: List[int], moveFrom: List[int], moveTo: List[int]) -> List[int]:\n        ",
    "c": "/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nint* relocateMarbles(int* nums, int numsSize, int* moveFrom, int moveFromSize, int* moveTo, int moveToSize, int* returnSize) {\n    \n}",
    "csharp": "public class Solution {\n    public IList<int> RelocateMarbles(int[] nums, int[] moveFrom, int[] moveTo) {\n        \n    }\n}",
    "javascript": "/**\n * @param {number[]} nums\n * @param {number[]} moveFrom\n * @param {number[]} moveTo\n * @return {number[]}\n */\nvar relocateMarbles = function(nums, moveFrom, moveTo) {\n    \n};",
    "typescript": "function relocateMarbles(nums: number[], moveFrom: number[], moveTo: number[]): number[] {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @param Integer[] $moveFrom\n     * @param Integer[] $moveTo\n     * @return Integer[]\n     */\n    function relocateMarbles($nums, $moveFrom, $moveTo) {\n        \n    }\n}",
    "swift": "class Solution {\n    func relocateMarbles(_ nums: [Int], _ moveFrom: [Int], _ moveTo: [Int]) -> [Int] {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun relocateMarbles(nums: IntArray, moveFrom: IntArray, moveTo: IntArray): List<Int> {\n        \n    }\n}",
    "dart": "class Solution {\n  List<int> relocateMarbles(List<int> nums, List<int> moveFrom, List<int> moveTo) {\n    \n  }\n}",
    "golang": "func relocateMarbles(nums []int, moveFrom []int, moveTo []int) []int {\n    \n}",
    "ruby": "# @param {Integer[]} nums\n# @param {Integer[]} move_from\n# @param {Integer[]} move_to\n# @return {Integer[]}\ndef relocate_marbles(nums, move_from, move_to)\n    \nend",
    "scala": "object Solution {\n    def relocateMarbles(nums: Array[Int], moveFrom: Array[Int], moveTo: Array[Int]): List[Int] = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn relocate_marbles(nums: Vec<i32>, move_from: Vec<i32>, move_to: Vec<i32>) -> Vec<i32> {\n        \n    }\n}",
    "racket": "(define/contract (relocate-marbles nums moveFrom moveTo)\n  (-> (listof exact-integer?) (listof exact-integer?) (listof exact-integer?) (listof exact-integer?))\n  )",
    "erlang": "-spec relocate_marbles(Nums :: [integer()], MoveFrom :: [integer()], MoveTo :: [integer()]) -> [integer()].\nrelocate_marbles(Nums, MoveFrom, MoveTo) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec relocate_marbles(nums :: [integer], move_from :: [integer], move_to :: [integer]) :: [integer]\n  def relocate_marbles(nums, move_from, move_to) do\n    \n  end\nend"
  }
}