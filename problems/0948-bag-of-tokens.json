{
  "title": "Bag of Tokens",
  "problem_id": "985",
  "frontend_id": "948",
  "difficulty": "Medium",
  "problem_slug": "bag-of-tokens",
  "topics": [
    "Array",
    "Two Pointers",
    "Greedy",
    "Sorting"
  ],
  "description": "You start with an initial power of power, an initial score of 0, and a bag of tokens given as an integer array tokens, where eachÂ tokens[i] denotes the value of tokeni.\nYour goal is to maximize the total score by strategically playing these tokens. In one move, you can play an unplayed token in one of the two ways (but not both for the same token):\nReturn the maximum possible score you can achieve after playing any number of tokens.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: tokens = [100], power = 50\nOutput: 0\nExplanation : Since your score is 0 initially, you cannot play the token face-down. You also cannot play it face-up since your power ( 50 ) is less than tokens[0] ( 100 ).",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input: tokens = [200,100], power = 150\nOutput: 1\nExplanation: Play token 1 ( 100 ) face-up, reducing your power to 50 and increasing your score to 1 .\nThere is no need to play token 0 , since you cannot play it face-up to add to your score. The maximum score achievable is 1 .",
      "images": []
    },
    {
      "example_num": 3,
      "example_text": "Input: tokens = [100,200,300,400], power = 200\nOutput: 2\nExplanation: Play the tokens in this order to get a score of 2 :\nThe maximum score achievable is 2 .",
      "images": []
    }
  ],
  "constraints": [
    "0 <= tokens.length <= 1000",
    "0 <= tokens[i], power < 104"
  ],
  "follow_ups": [],
  "hints": [],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    int bagOfTokensScore(vector<int>& tokens, int power) {\n        \n    }\n};",
    "java": "class Solution {\n    public int bagOfTokensScore(int[] tokens, int power) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def bagOfTokensScore(self, tokens, power):\n        \"\"\"\n        :type tokens: List[int]\n        :type power: int\n        :rtype: int\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def bagOfTokensScore(self, tokens: List[int], power: int) -> int:\n        ",
    "c": "int bagOfTokensScore(int* tokens, int tokensSize, int power) {\n    \n}",
    "csharp": "public class Solution {\n    public int BagOfTokensScore(int[] tokens, int power) {\n        \n    }\n}",
    "javascript": "/**\n * @param {number[]} tokens\n * @param {number} power\n * @return {number}\n */\nvar bagOfTokensScore = function(tokens, power) {\n    \n};",
    "typescript": "function bagOfTokensScore(tokens: number[], power: number): number {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param Integer[] $tokens\n     * @param Integer $power\n     * @return Integer\n     */\n    function bagOfTokensScore($tokens, $power) {\n        \n    }\n}",
    "swift": "class Solution {\n    func bagOfTokensScore(_ tokens: [Int], _ power: Int) -> Int {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun bagOfTokensScore(tokens: IntArray, power: Int): Int {\n        \n    }\n}",
    "dart": "class Solution {\n  int bagOfTokensScore(List<int> tokens, int power) {\n    \n  }\n}",
    "golang": "func bagOfTokensScore(tokens []int, power int) int {\n    \n}",
    "ruby": "# @param {Integer[]} tokens\n# @param {Integer} power\n# @return {Integer}\ndef bag_of_tokens_score(tokens, power)\n    \nend",
    "scala": "object Solution {\n    def bagOfTokensScore(tokens: Array[Int], power: Int): Int = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn bag_of_tokens_score(tokens: Vec<i32>, power: i32) -> i32 {\n        \n    }\n}",
    "racket": "(define/contract (bag-of-tokens-score tokens power)\n  (-> (listof exact-integer?) exact-integer? exact-integer?)\n  )",
    "erlang": "-spec bag_of_tokens_score(Tokens :: [integer()], Power :: integer()) -> integer().\nbag_of_tokens_score(Tokens, Power) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec bag_of_tokens_score(tokens :: [integer], power :: integer) :: integer\n  def bag_of_tokens_score(tokens, power) do\n    \n  end\nend"
  },
  "solution": "[TOC]\n\n## Solution\n\n---\n\n### Overview\n\nOur goal is to return the highest score possible. We gain score by placing tokens face-up, which costs power. We gain power by playing tokens face-down, which costs score. We can only play a token face-up when we have enough power, and we can only play a token face-down when we have enough score. Note that the value of each token is positive, and the initial power is also positive.\n\nA crucial insight is that we can play a token face-up to trade any amount `tokens[i]` for `1` score as long as we have at least that much power. Alternatively, we can play a token face-down to trade `1` score for any amount `tokens[i]` of power.\n\n---\n\n### Approach: Sort and Greedy\n\n#### Intuition\n\n**How do we determine which tokens to play face-up and which to play face-down?**\n\n Let's look at some examples:\n\nExample A: (Example 3 from the problem description)\n> **Input:** tokens = [100, 200, 300, 400], power = 200\n> **Output:** 2\n\nTokens played face-up: $\\text{token}_0$ (100), $\\text{token}_1$ (200), $\\text{token}_2$ (300).\nTokens played face-down: $\\text{token}3$ (400).\n\nExample B:\n> **Input:** tokens = [1, 4, 1, 1], power = 1\n> **Output:** 2\n\nTokens played face-up: $\\text{token}_0$ (1), $\\text{token}_2$ (1), $\\text{token}_3$ (1).\nTokens played face-down: $\\text{token}_1$ (4). \n\n**What patterns do we notice in how the tokens are played to maximize the score in the above examples?**\n\n- The lowest power tokens are played face-up to increase the score.\n\n- The highest power tokens are played face-down to increase power.\n\n**We can develop a strategy based on these observations:**\n\n- When you have enough power to play face-up, maximize the score by playing the lowest power tokens face-up. This way you are increasing the score without losing a significant amount of power.\n\n- When you do not have enough power to play face-up, maximize power by playing the highest power tokens face-down. This way you trade a relatively small amount of score for a relatively large amount of power.\n\n- We should play the lowest tokens face-up until we do not have enough power, then play token(s) face-down until we can play face-up again.\n\n- We continue while we can either play a token face-up or face-down.\n\n**How can we identify the lowest and highest power tokens?**\n\n We will need to do the above process repeatedly, so we will sort the array from lowest power to highest power.\n\nWe can then use two pointers, `low` and `high`. `low` will point to the lowest power token in `tokens` that hasn't been used, and `high` will point to the highest power token in `tokens` that hasn't been used. We can process the tokens in the array, one at a time.\n\nIf we have enough power to play the lowest power token face-up, we play it, increase the score and the `low` pointer, and decrease power accordingly.\n\nWhen we don't have enough power to play the lowest power token face-up, but we have at least `1` score, we play the highest power token face-down. The exception is if this is our last token remaining. Since we lose a score point every time we play a token face-up, it would not maximize our score to play a token face-down unless there is one to play after it. We increase power accordingly and decrease the score and the `high` pointer.\n\nIf we can't play face-up or down, we return the score.\n\nThis playing strategy is visualized below:\n\n!?!../Documents/948/948_bag_of_tokens_slideshow.json: 960,540!?!\n\n**How do we know this method will lead to the highest score?**\n\nAssume the greedy strategy of playing the lowest power tokens face-up, and the highest power token face-down when we can't afford to play any tokens face-up is not optimal. Then, it would be possible to obtain a higher score with a different playing strategy.\n\nLet's discuss Example A with a different playing strategy: Play the highest token we can afford face-up, and the lowest token face-down.\nInput: tokens = [100, 200, 300, 400], power = 200\nMove 1: Play $\\text{token}_1$ (200) face-up, reducing power to 0 and increasing score to 1.\nMove 2: Play $\\text{token}_0$ (100) face-down, increasing power to 100 and reducing score to 0.\nOutput: 0\n\nAfter these two moves, have neither enough score nor enough power to play either of the remaining tokens, $\\text{token}_2$ (300), and $\\text{token}_3$ (400), face-up or face-down. The greedy approach of playing the highest power tokens face-down and the lowest power tokens face-up is more effective because for each token played, the amount of score gained or lost is always `1`, but we minimize the power spent to gain score and the score spent to gain power. Therefore, the way to obtain the highest score is to play the lowest power tokens face-up.\n\n#### Algorithm\n\n1. Initializations:\n    - Initialize a pointer `low` to `0` and `high` to `tokens.length - 1`. `low` points to the first index of `tokens` and `high` points the the last index of `tokens`.\n    - Initialize a variable `score` to `0`.\n2. Sort `tokens` in ascending order.\n3. While `low` is less than or equal to `high`:\n    - If `power` is greater than or equal to `tokens[low]`, we have enough power to play a token face-up. We increment `score` by `1`, reduce `power` by `tokens[low]`, and increase `low` by `1`.\n    - Else if `score` is greater than `0`, and `low` is less than `high`, we play a token face-down. We decrease `score` by `1`, increase our power by `tokens[high]`, and decrease `high` by `1`.\n    - Otherwise, we don't have enough power to play a token face-up, and we either don't have enough score to play a token face-down or not enough tokens remain to make it worth playing a token face-down, so we return `score`.\n4. We have played all the tokens, so we return `score`.\n\n\n\n#### Implementation\n\n**Implementation 1: Two Pointer****Implementation 2: Deque**\n\nLike in the previous implementation, we will sort the array to facilitate the identification of the lowest and highest power tokens. \n\nInstead of using two pointers, we store the values of `tokens` in a deque, a double-ended queue where values can be accessed from both ends. We can pop the rear (leftmost) token to access the lowest power token and pop the front (rightmost) token to access the highest power token.  \n\nThe rest of the gameplay proceeds similarly to the above approach. When we play the lowest remaining token, we pop the leftmost value from the deque, and when we play the highest remaining token, we pop the rightmost token.The time complexity of the deque implementation is the same as the two-pointer implementation. The deque, `deque` contains all of the elements of `tokens` so it uses $n$ space. The space complexity of this implementation is $O(n)$.\n\n\n#### Complexity Analysis\n\nLet $n$ be the length of `tokens`.\n\n* Time complexity: $O(n \\log n)$\n\n    Sorting `tokens` takes $O(n \\log n)$.\n\n    We process `tokens` using the pointers `low` and `high` until they meet in the middle or we can't play any more tokens. With each iteration, `low` is incremented, or `high` is decremented, or the loop terminates because we can't make any more moves that increase our score. We handle each token in `tokens` at most once, so the time complexity is $O(n)$.\n\n    $O(n \\log n)$ is the dominating term.\n\n* Space complexity: $O(n)$ or $O( \\log n )$\n\n    Sorting uses extra space, which depends on the implementation of each programming language.\n        - In Python, the `sort` method sorts a list using the Timsort algorithm which is a combination of Merge Sort and Insertion Sort and has $O(n)$ additional space. \n        - In Java, Arrays.sort() is implemented using a variant of the Quick Sort algorithm which has a space complexity of $O( \\log n)$ for sorting an array.\n        - In C++, the sort() function is implemented as a hybrid of Quick Sort, Heap Sort, and Insertion Sort, with a worse-case space complexity of $O( \\log n )$.\n\n    Other than sorting, we use a handful of variables that use constant, $O(1)$ space, so the space used for sorting is the dominant term.\n\n---"
}