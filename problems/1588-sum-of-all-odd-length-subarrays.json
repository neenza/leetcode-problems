{
  "title": "Sum of All Odd Length Subarrays",
  "problem_id": "1693",
  "frontend_id": "1588",
  "difficulty": "Easy",
  "problem_slug": "sum-of-all-odd-length-subarrays",
  "topics": [
    "Array",
    "Math",
    "Prefix Sum"
  ],
  "description": "Given an array of positive integers arr, return the sum of all possible odd-length subarrays of arr.\nA subarray is a contiguous subsequence of the array.\nExample 1:\nExample 2:\nExample 3:\nConstraints:\nFollow up:\nCould you solve this problem in O(n) time complexity?",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: arr = [1,4,2,5,3]\nOutput: 58\nExplanation: The odd-length subarrays of arr and their sums are:\n[1] = 1\n[4] = 4\n[2] = 2\n[5] = 5\n[3] = 3\n[1,4,2] = 7\n[4,2,5] = 11\n[2,5,3] = 10\n[1,4,2,5,3] = 15\nIf we add all these together we get 1 + 4 + 2 + 5 + 3 + 7 + 11 + 10 + 15 = 58",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input: arr = [1,2]\nOutput: 3\nExplanation: There are only 2 subarrays of odd length, [1] and [2]. Their sum is 3.",
      "images": []
    },
    {
      "example_num": 3,
      "example_text": "Input: arr = [10,11,12]\nOutput: 66",
      "images": []
    }
  ],
  "constraints": [
    "1 <= arr.length <= 100",
    "1 <= arr[i] <= 1000"
  ],
  "follow_ups": [],
  "hints": [
    "You can brute force â€“ try every (i,j) pair, and if the length is odd, go through and add the sum to the answer."
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    int sumOddLengthSubarrays(vector<int>& arr) {\n        \n    }\n};",
    "java": "class Solution {\n    public int sumOddLengthSubarrays(int[] arr) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def sumOddLengthSubarrays(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: int\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def sumOddLengthSubarrays(self, arr: List[int]) -> int:\n        ",
    "c": "int sumOddLengthSubarrays(int* arr, int arrSize) {\n    \n}",
    "csharp": "public class Solution {\n    public int SumOddLengthSubarrays(int[] arr) {\n        \n    }\n}",
    "javascript": "/**\n * @param {number[]} arr\n * @return {number}\n */\nvar sumOddLengthSubarrays = function(arr) {\n    \n};",
    "typescript": "function sumOddLengthSubarrays(arr: number[]): number {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param Integer[] $arr\n     * @return Integer\n     */\n    function sumOddLengthSubarrays($arr) {\n        \n    }\n}",
    "swift": "class Solution {\n    func sumOddLengthSubarrays(_ arr: [Int]) -> Int {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun sumOddLengthSubarrays(arr: IntArray): Int {\n        \n    }\n}",
    "dart": "class Solution {\n  int sumOddLengthSubarrays(List<int> arr) {\n    \n  }\n}",
    "golang": "func sumOddLengthSubarrays(arr []int) int {\n    \n}",
    "ruby": "# @param {Integer[]} arr\n# @return {Integer}\ndef sum_odd_length_subarrays(arr)\n    \nend",
    "scala": "object Solution {\n    def sumOddLengthSubarrays(arr: Array[Int]): Int = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn sum_odd_length_subarrays(arr: Vec<i32>) -> i32 {\n        \n    }\n}",
    "racket": "(define/contract (sum-odd-length-subarrays arr)\n  (-> (listof exact-integer?) exact-integer?)\n  )",
    "erlang": "-spec sum_odd_length_subarrays(Arr :: [integer()]) -> integer().\nsum_odd_length_subarrays(Arr) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec sum_odd_length_subarrays(arr :: [integer]) :: integer\n  def sum_odd_length_subarrays(arr) do\n    \n  end\nend"
  },
  "solution": "[TOC]\n\n## Solution\n\n---\n\n### Approach 1: Brute Force\n\n#### Intuition   \n\nLet's start with brute force, the most intuitive method. We find each of the subarrays one by one, and get the sum of the current subarray if it has an odd length.#### Algorithm\n\n1) Initialize `answer = 0`.\n2) Iterate over the left index `left` of subarrays.\n3) For every subarray start at index `left`, iterate over every index `right` to fix the end of subarray.\n4) For each subarray `(left, right)`, if its length is odd:\n    - Iterate over this subarray and get its sum `current_sum`.\n    - Increment `answer` by `current_sum`.\n\n#### Implementation#### Complexity Analysis\n\nLet $$n$$ be the size of the input array `arr`.\n\n* Time complexity: $$O(n^3)$$\n\n    - We have three nested loops, the first loop for the left index `left`, the second loop for the right index `right`, and the third loop for the index `currentIndex` between `left` and `right`. \n    - For each odd-length subarray, we need to get its sum and update `answer` after the third iteration.\n    - Therefore, the overall time complexity is $$O(n^3)$$.\n    \n\n* Space complexity: $$O(1)$$\n\n    - We only need to update two variables: \n        - `current_sum` the sum of the current subarray.\n        - `answer`, the sum of all odd-length subarrays.\n    \n    which only takes constant space.---\n\n### Approach 2: Two Loops\n\n#### Intuition   \n\nLet's try a better method to reduce the workload!\n\nFor a starting index `left`, the difference between each of the two adjacent right indices is 1. In other words, if the current subarray is `[left, right]`, the next subarray (if it exists) is `[left, right + 1]`. Therefore, we can get the sum of the next subarray by adding `arr[right + 1]` to the sum of the previous subarray. If the current subarray has an odd length, we can increment `answer` by its sum, as shown in the picture below.\n\n![img](../Figures/1588/1588-1.png)#### Algorithm\n\n1) Initialize `answer` as 0.\n2) Iterate over `left`, the left index of the subarray.\n3) For every subarray start at index `left`, we initialize `current_sum = 0`. We iterate over index `right` to fix the end of each subarray, and calculate the sum of this subarray (`current_sum`) by adding `arr[right]` to the previous `current_sum`. If the current subarray has an odd length, we increment `answer` by `current_sum`.\n    \n\n#### Implementation#### Complexity Analysis\n\nLet $$n$$ be the size of the input array `arr`.\n\n* Time complexity: $$O(n^2)$$\n\n    - We have two nested loops, the first loop for the left index `left`, the second loop for the right index `right`. \n    - For each odd-length subarray, we need to increment `answer` by its sum which takes constant time.\n    - Therefore, the overall time complexity is $$O(n^2)$$.\n    \n\n* Space complexity: $$O(1)$$\n\n    - We only need to update two variables: \n        - `current_sum` the sum of the current subarray.\n        - `answer`, the sum of all odd-length subarrays.\n    \n    which only takes constant space.---\n\n### Approach 3: Check the occurrence of each index\n\n#### Intuition   \n\nInstead of finding all odd-length subarrays, we can count the number of occurrences of each integer in all odd-length subarrays. For example, if `arr[i]` has appeared `k` times, it contributes to the total sum by `arr[i] * k`.\n\n\n![img](../Figures/1588/1588-2.png)\n\n> How to calculate the occurrence of each index?\n\nLet's find the pattern behind this: since the current subarray containing `arr[i]` has an odd-length, the number of elements without `arr[i]` must be even, indicating the number of elements to the left and right side of `arr[i]` must be **both even** or **both odd**, as shown in the picture below.\n\n![img](../Figures/1588/1588-3.png)\n\nTherefore, we are looking for:\n\n- `odd_left`, the number of odd-length subarrays starting from `i` on `i`'s left.\n- `odd_right`, the number of odd-length subarrays starting from `i` on `i`'s right.\n- `even_left`, the number of even-length subarrays starting from `i` on `i`'s left.\n- `even_right`, the number of even-length subarrays starting from `i` on `i`'s right.\n\nNotice that:\n\n- There are `i + 1` such subarrays to its left where `(i + 1) / 2` of them have odd-length and the rest have even-length.s\n- There are `n - 1 - i` such subarrays to its right where `(n - i) / 2` of them have odd-length and the rest have even-length.\n\n![img](../Figures/1588/1588-4.png)\n\nOnce we find all the four numbers above, we can calculate the occurrence of `arr[i]` in odd-length arrays as `odd_left * odd_right + even_left * even_right`.#### Algorithm\n\n1) Initialize `answer` as 0.\n2) Iterate over `arr`, calculate the occurrence of each index `i`:\n   \n    - `odd_left = left / 2 + 1` \n    - `odd_right = (n - i - 1) / 2 + 1`\n    - `even_left = (i + 1) / 2`\n    - `even_right = (n - i) / 2`\n\n    Add the current element `arr[i]` `(odd_left * odd_right + even_left * even_right)` times in `answer`.\n\n\n#### Implementation#### Complexity Analysis\n\nLet $$n$$ be the size of the input array `arr`.\n\n* Time complexity: $$O(n)$$\n\n    - We only need one iteration over `arr`.\n    - At each step `i`, we need to calculate the occurrence of `arr[i]` in all the odd-length subarrays, it takes constant time.\n    - Therefore, the overall time complexity is $$O(n)$$.\n    \n\n* Space complexity: $$O(1)$$\n\n    - We only need to update one variable `answer`."
}