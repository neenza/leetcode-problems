{
  "title": "Clear Digits",
  "problem_id": "3447",
  "frontend_id": "3174",
  "difficulty": "Easy",
  "problem_slug": "clear-digits",
  "topics": [
    "String",
    "Stack",
    "Simulation"
  ],
  "description": "You are given a string s.\nYour task is to remove all digits by doing this operation repeatedly:\nReturn the resulting string after removing all digits.\nNote that the operation cannot be performed on a digit that does not have any non-digit character to its left.\nExample 1:\nExample 2:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: s = \"abc\"\nOutput: \"abc\"\nExplanation:\nThere is no digit in the string.",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input: s = \"cb34\"\nOutput: \"\"\nExplanation:\nFirst, we apply the operation on s[2] , and s becomes \"c4\" .\nThen we apply the operation on s[1] , and s becomes \"\" .",
      "images": []
    }
  ],
  "constraints": [
    "1 <= s.length <= 100",
    "s consists only of lowercase English letters and digits.",
    "The input is generated such that it is possible to delete all digits."
  ],
  "follow_ups": [],
  "hints": [
    "Process string <code>s</code> from left to right, if <code>s[i]</code> is a digit, mark the nearest unmarked non-digit index to its left.",
    "Delete all digits and all marked characters."
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    string clearDigits(string s) {\n        \n    }\n};",
    "java": "class Solution {\n    public String clearDigits(String s) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def clearDigits(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def clearDigits(self, s: str) -> str:\n        ",
    "c": "char* clearDigits(char* s) {\n    \n}",
    "csharp": "public class Solution {\n    public string ClearDigits(string s) {\n        \n    }\n}",
    "javascript": "/**\n * @param {string} s\n * @return {string}\n */\nvar clearDigits = function(s) {\n    \n};",
    "typescript": "function clearDigits(s: string): string {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param String $s\n     * @return String\n     */\n    function clearDigits($s) {\n        \n    }\n}",
    "swift": "class Solution {\n    func clearDigits(_ s: String) -> String {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun clearDigits(s: String): String {\n        \n    }\n}",
    "dart": "class Solution {\n  String clearDigits(String s) {\n    \n  }\n}",
    "golang": "func clearDigits(s string) string {\n    \n}",
    "ruby": "# @param {String} s\n# @return {String}\ndef clear_digits(s)\n    \nend",
    "scala": "object Solution {\n    def clearDigits(s: String): String = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn clear_digits(s: String) -> String {\n        \n    }\n}",
    "racket": "(define/contract (clear-digits s)\n  (-> string? string?)\n  )",
    "erlang": "-spec clear_digits(S :: unicode:unicode_binary()) -> unicode:unicode_binary().\nclear_digits(S) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec clear_digits(s :: String.t) :: String.t\n  def clear_digits(s) do\n    \n  end\nend"
  },
  "solution": "[TOC]\n\n## Solution\n\n---\n\n### Overview\n\nWe are given a string `s` containing letters and digits. Our task is to perform the following operations on every digit of the string:\n\n1. Remove the digit.\n2. Remove the last non-digit character to the left of the digit.\n\nAs we iterate through each digit in the string and apply these operations, we end up removing all digits along with some non-digit characters. In the end, we will return the final string, after processing and removing all digits.\n\n>   According to the problem's constraints, it will always be possible to remove all digits, meaning that every digit will have a corresponding non-digit character on the left.\n\n---\n\n### Approach 1: Brute Force\n\n#### Intuition\n\nIn this approach, we will simply simulate the described process until we have removed all digits from `s`.\n\nAn important observation is that as we process the string from left to right and remove digits, the part of the string we've already processed will only contain non-digit characters (or be empty). This means that the first non-digit character to the left of the current digit will always be the one immediately before it.\n\nWith this in mind, we iterate over the characters of `s` with `charIndex` from `0` to `s.length - 1`. When we encounter a digit, we remove both the digit and the non-digit character immediately before it. A key detail in the implementation is that after deleting a character, we should not increment the `charIndex`, as the next character will shift to the current position. Similarly, when deleting two characters, we should decrement the `charIndex` by `1`, as the next character to process will shift to one position left from the current one.\n\n> To check whether the current character is a digit in the implementations below, we will use the provided built-in functions. Alternatively, we could create a custom function that checks whether the ASCII value of the character falls between the ASCII values of `'0'` and `'9'`.\n\n#### Algorithm\n\n-   Initialize `charIndex` to `0`.\n-   While `charIndex` is less than the current length of `s`:\n    -   If the character at `charIndex` is a digit:\n        -   Remove the digit at `charIndex`.\n        -   Remove the character at `charIndex - 1`.\n        -   Decrement `charIndex` by `1` to account for the removed character.\n    -   Otherwise, if the character at `charIndex` is not a digit:\n        -   Move to the next character by incrementing `charIndex` by `1`.\n-   Return the modified string `s`.\n\n#### Implementation#### Complexity Analysis\n\nLet $n$ be the length of the string `s` and $m$ the number of digit characters in it.\n\n-   Time Complexity: $O(n \\times m)$ or $O(n ^ 2)$.\n\n    For each digit character, we perform one or two \"erase\" operations, each with time complexity $O(n)$. Therefore, processing $m$ digits takes $O(n \\times m)$. Non-digit characters are skipped and contribute $O((n - m) \\times 1)$ checks, which is $O(n)$. Since $m \\leq n$ the overall time complexity can be expressed as $O(n^2)$.\n\n-   Space Complexity: $O(1)$.\n\n    Excluding the input string (which does not count toward the auxiliary space complexity), we only use a single variable (`charIndex`) to track the current character's position in the string. Therefore, the space complexity of the algorithm is $O(1)$.  \n\n    > In Java, we use a StringBuilder to store a copy of the input string and perform all operations on it. Therefore, the space complexity for this implementation is $O(n)$.\n\n---\n\n### Approach 2: Stack-Like\n\n#### Intuition\n\nAs we saw, the main issue with the brute-force approach was the repeated 'erase' operations on the input string, which added a factor of $n$ to the algorithm's time complexity.\n\nTo avoid this, instead of modifying the input, we construct the answer from scratch as we iterate over the characters of `s`:\n\n-   When we encounter a non-digit character, we add it to the end of the answer, as it should appear in the final string unless a digit later removes it.\n-   When we encounter a digit, we do not add it to the final answer. Additionally, we remove the last character from the answer, as this is the last non-digit character to the left of the current digit.\n\nThe main difference to the previous approach is that removing the last character from a string takes constant time, whereas removing a character from an arbitrary position requires $O(n)$ time. \n\n> In Java, we declare the answer string as a `StringBuilder`. This is essential for improving time complexity, as removing the last character from a regular String is still a $O(n)$ operation. Similarly, in Python we will use a list to take advantage of the $O(1)$ pop operation.\n\nIn this approach, we essentially treat the answer string like a stack. We push non-digit characters onto it, and we may remove some from the end as we process the string. The key idea is that we only remove the most recently added characters, ensuring that we never need to remove a character that was added before another character that hasn't been removed yet.\n\n> For a more comprehensive understanding of Stacks, check out the [Stack Explore Card ðŸ”—](https://leetcode.com/explore/featured/card/queue-stack/). This resource provides an in-depth look at stacks, explaining their key concepts and applications with a variety of problems to solidify understanding of the pattern.\n\n!?!../Documents/3174/3174_approach2_fix.json:960,540!?!\n\n#### Algorithm\n\n-   Initialize `answer` to an empty string.\n-   Iterate over `s` with `charIndex` from `0` to `s.length - 1`:\n    -   If the character at `charIndex` is a digit:\n        -   Remove the last character from `answer`.\n    -   Otherwise, if the character at `charIndex` is not a digit:\n        -   Add it to the end of the `answer` string.\n-   Return `answer`.\n\n#### Implementation#### Complexity Analysis\n\nLet $n$ be the length of the string `s`.\n\n-   Time Complexity: $O(n)$.\n\n    We iterate over all characters in `s` and perform constant-time operations, including checks and either removing the last character of the `answer` string or adding the current character to the end of it. Therefore, the total time complexity of the algorithm is $O(n)$.\n\n-   Space Complexity: $O(n)$.\n\n    In the C++ implementation, we only need a single variable, `charIndex`, to track the position of the current character in `s`. Consequently, the algorithm uses constant ($O(1)$) extra space.\n\n    On the other hand, the Java and Python implementations require additional structures (such as a list or a StringBuilder), to simulate stack operations. Since these structures are neither part of the input nor the output of the algorithm, they contribute to its auxiliary space complexity. This complexity is $O(n)$, as these structures can grow to at most the size of the input string.\n\n---\n\n### Approach 3: In-place\n\n#### Intuition\n\nOne big advantage of the previous approach is that it does not change the input string. This is helpful in situations where the input is passed by reference (like in Java) and the algorithm runs in a multithreaded environment or when the input needs to be used again after the function call. In these cases, algorithms that modify the input directly should be avoided.\n\nHowever, when this is not the case, modifying the input can be more space-efficient. In such cases, in-place algorithms like the one weâ€™ll discuss here can be good alternatives.\n\nSo, in this approach we will integrate the \"stack\" logic directly into the input string. Instead of pushing non-digit characters into a separate structure, we overwrite the input string in place so that non-digit characters are positioned exactly where they will appear in the final result. \n\nTo achieve this, we use a variable `answerLength` to track the current length of the result. When adding a new character, we place it at the `answerLength` position in the string and increase `answerLength` by `1`. When removing a character, we decrease `answerLength` by `1`, which effectively makes the last character irrelevant and ready to be overwritten.\n\nAt the end, the result is the prefix of the modified input string up to `answerLength`.\n\n#### Algorithm\n\n-   Initialize `answerLength` to `0`.\n-   Iterate over `s` with `charIndex` from `0` to `s.length - 1`:\n    -   If the character at `charIndex` is a digit:\n        -   Decrement `answerLength` by `1`.\n    -   Otherwise, if the character at `charIndex` is not a digit:\n        -   Add it to the end of the answer, by setting `s[answerLength] = s[charIndex]`.\n        -   Increment `answerLength`.\n-   Return the first `answerLength` characters of the modified string `s`.\n\n#### Implementation#### Complexity Analysis\n\nLet $n$ be the length of the string `s`.\n\n-   Time Complexity: $O(n)$.\n\n    Like in the previous approach, we iterate over all characters in `s` and perform constant-time operations, including checks and retrievals of characters in a string. Additionally, the \"resize\" operation on the string requires $O(n)$ time and therefore the total time complexity of the algorithm is $O(n)$.\n\n-   Space Complexity: $O(1)$.\n\n    As the input string does not count as auxiliary space, the C++ implementation requires only constant extra space for the variables `answerLength` and `charIndex`. \n\n    However, the Java and Python implementations require additional structures (such as a list or a charArray), as they do not provide mutable strings. Since these structures are neither part of the input nor the output of the algorithm, they contribute to its auxiliary space complexity, which is $O(n)$.\n\n---"
}