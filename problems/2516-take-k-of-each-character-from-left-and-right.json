{
  "title": "Take K of Each Character From Left and Right",
  "problem_id": "2599",
  "frontend_id": "2516",
  "difficulty": "Medium",
  "problem_slug": "take-k-of-each-character-from-left-and-right",
  "topics": [
    "Hash Table",
    "String",
    "Sliding Window"
  ],
  "description": "You are given a string s consisting of the characters 'a', 'b', and 'c' and a non-negative integer k. Each minute, you may take either the leftmost character of s, or the rightmost character of s.\nReturn the minimum number of minutes needed for you to take at least k of each character, or return -1 if it is not possible to take k of each character.\nExample 1:\nExample 2:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: s = \"aabaaaacaabc\", k = 2\nOutput: 8\nExplanation: \nTake three characters from the left of s. You now have two 'a' characters, and one 'b' character.\nTake five characters from the right of s. You now have four 'a' characters, two 'b' characters, and two 'c' characters.\nA total of 3 + 5 = 8 minutes is needed.\nIt can be proven that 8 is the minimum number of minutes needed.",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input: s = \"a\", k = 1\nOutput: -1\nExplanation: It is not possible to take one 'b' or 'c' so return -1.",
      "images": []
    }
  ],
  "constraints": [
    "1 <= s.length <= 105",
    "s consists of only the letters 'a', 'b', and 'c'.",
    "0 <= k <= s.length"
  ],
  "follow_ups": [],
  "hints": [
    "Start by counting the frequency of each character and checking if it is possible.",
    "If you take x characters from the left side, what is the minimum number of characters you need to take from the right side? Find this for all values of x in the range 0 ≤ x ≤ s.length.",
    "Use a two-pointers approach to avoid computing the same information multiple times."
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    int takeCharacters(string s, int k) {\n        \n    }\n};",
    "java": "class Solution {\n    public int takeCharacters(String s, int k) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def takeCharacters(self, s, k):\n        \"\"\"\n        :type s: str\n        :type k: int\n        :rtype: int\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def takeCharacters(self, s: str, k: int) -> int:\n        ",
    "c": "int takeCharacters(char* s, int k) {\n    \n}",
    "csharp": "public class Solution {\n    public int TakeCharacters(string s, int k) {\n        \n    }\n}",
    "javascript": "/**\n * @param {string} s\n * @param {number} k\n * @return {number}\n */\nvar takeCharacters = function(s, k) {\n    \n};",
    "typescript": "function takeCharacters(s: string, k: number): number {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param String $s\n     * @param Integer $k\n     * @return Integer\n     */\n    function takeCharacters($s, $k) {\n        \n    }\n}",
    "swift": "class Solution {\n    func takeCharacters(_ s: String, _ k: Int) -> Int {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun takeCharacters(s: String, k: Int): Int {\n        \n    }\n}",
    "dart": "class Solution {\n  int takeCharacters(String s, int k) {\n    \n  }\n}",
    "golang": "func takeCharacters(s string, k int) int {\n    \n}",
    "ruby": "# @param {String} s\n# @param {Integer} k\n# @return {Integer}\ndef take_characters(s, k)\n    \nend",
    "scala": "object Solution {\n    def takeCharacters(s: String, k: Int): Int = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn take_characters(s: String, k: i32) -> i32 {\n        \n    }\n}",
    "racket": "(define/contract (take-characters s k)\n  (-> string? exact-integer? exact-integer?)\n  )",
    "erlang": "-spec take_characters(S :: unicode:unicode_binary(), K :: integer()) -> integer().\ntake_characters(S, K) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec take_characters(s :: String.t, k :: integer) :: integer\n  def take_characters(s, k) do\n    \n  end\nend"
  },
  "solution": "[TOC]\n\n## Solution\n\n--- \n\n### Overview\n\nWe are given a string `s` containing only the characters `'a'`, `'b'`, and `'c'`, along with a non-negative integer `k`. The goal is to calculate the minimum number of minutes needed to ensure at least `k` instances of each character remain in the string. The removal process allows us to eliminate one character per minute, and we can only remove characters from either the left or right ends of the string. If it is not possible to retain at least `k` occurrences of each character, the function should return `-1`.\n\n---\n\n### Approach 1: Recursion (Time Limit Exceeded)\n\n#### Intuition\n\nAt first glance, it seems feasible to solve this by checking all possible choices: on each step, we could either take a character from the left or from the right. By tracking the count of each character collected along the way, we could determine the minimum steps required to reach at least `k` occurrences for each character.\n\nThis naturally suggests a recursive approach. We can visualize the problem as a decision tree, where each branch corresponds to picking a character from one of the two ends. As we move through this tree, we update the count of each character collected. When the counts meet or exceed `k` for all characters, we log the steps taken.\n\nHowever, this approach leads to an exponential time complexity. Each decision doubles the number of possible paths, resulting in a time complexity of $O(2^n)$, where `n` is the length of the string. For longer strings, this rapidly becomes impractical, as the number of recursive calls grows exponentially. While this method might work for smaller cases, it is unsuitable for larger strings due to the excessive computation time required.\n\n#### Algorithm\n\n- `takeCharacters` function:\n  - If `k` is `0`, return `0` (no minutes needed to reach `k` of each character).\n  - Initialize a `count` array to keep track of occurrences of 'a', 'b', and 'c' in the string `s`.\n  - Call the `solve` function with the string `s`, target `k`, the initial `left` and `right` pointers, the `count` array, and the initial `minutes` set to `0`.\n  - After the `solve` function completes, return `minMinutes` if it was updated; otherwise, return `-1` (no valid solution).\n\n- `solve` function:\n  - Base case:\n    - If `count[0]`, `count[1]`, and `count[2]` (representing counts of 'a', 'b', and 'c') are each greater than or equal to `k`, update `minMinutes` with the current `minutes` and return.\n  - If the `left` pointer exceeds the `right` pointer, return (end condition).\n  \n  - Recursively take characters from the left:\n    - Create a copy of `count` named `leftCount`.\n    - Increment the frequency of the character at `s[left]` in `leftCount`.\n    - Recursively call `solve` with `s`, `k`, `left + 1` (move the left pointer forward), `right`, `leftCount`, and `minutes + 1`.\n\n  - Recursively take characters from the right:\n    - Create a copy of `count` named `rightCount`.\n    - Increment the frequency of the character at `s[right]` in `rightCount`.\n    - Recursively call `solve` with `s`, `k`, `left`, `right - 1` (move the right pointer backward), `rightCount`, and `minutes + 1`.\n\n#### Implementation#### Complexity Analysis\n\nLet $n$ be the length of the string.\n\n- Time complexity: $O(2^n)$\n  \n    The `solve` function uses a recursive backtracking where, at each step, it has two choices.\n    \n    This binary decision at each position leads to a total of $2^n$ possible combinations in the worst case. Even though there are base cases that can terminate some recursive paths early (e.g., when the required counts are met or when the left index exceeds the right), in the worst-case scenario where the solution requires exploring all possible subsets, the time complexity remains exponential.\n\n    Additionally, built-in functions like `min` operate in constant time $O(1)$, and copying the `count` array (which has a fixed size of 3) also takes constant time. Therefore, these do not affect the overall exponential time complexity.\n\n- Space complexity: $O(n)$\n  \n    The primary space consumption comes from the recursion stack. In the worst case, the depth of recursion can reach $n$ when characters are taken one by one from either end until the entire string is processed. Each recursive call uses a constant amount of additional space (for variables like `leftCount` and `rightCount`), so the overall space complexity is linear with respect to the length of the string.\n\n    The `count` array has a fixed size of 3, contributing only $O(1)$ space. Therefore, the dominant factor is the recursion depth, leading to a space complexity of $O(n)$.\n\n---\n\n### Approach 2: Sliding Window\n\n#### Intuition\n\nInstead of deciding whether to take or skip each individual character, we can use a sliding window approach to identify which characters we don't need to 'take' to get to at least `k` of each character.\n\nFirst things first, we'll rule out cases where this is impossible by counting the total occurrences of each character in `s`. If any character occurs fewer than `k` times, return -1.\n\nNow the core idea of this solution is to identify the largest removable window in the string such that removing it still leaves at least `k` occurrences of each character `'a'`, `'b'`, and `'c'`. The number of minutes required to perform this task corresponds to the length of the string minus the size of the largest such window.\n\nTo achieve this, we iterate through the string to locate the window using two pointers, `left` and `right`. The pointer `right` progressively expands the window by including characters, one at a time, into the current window. Simultaneously, the pointer `left` is used to shrink the window whenever the current configuration violates the condition that at least `k` occurrences of each character must remain outside the window. \n\nAs we increment `right`, we add the character at that position to the window and update the counts. If adding this character results in too few occurrences of any character outside the window, we increment `left` to remove characters from the start of the window, restoring the required character counts outside the window.\n\nWhenever a valid window is identified—where the counts of `'a'`, `'b'`, and `'c'` outside the window are all at least `k`—we calculate the size of the current window. If this size is larger than previously identified windows, we update `maxWindow`. The final result is derived by subtracting the size of the largest valid window (`maxWindow`) from the total string length, effectively calculating the smallest portion of the string that must be removed.\n\nAfter completing the iteration, the minimum number of minutes required is given by subtracting the size of the largest valid window from the total length of the string.\n\nMore mathematically, this can be expressed as:  $\\text{Minimum Minutes} = \\text{Length of String} - \\text{Size of the Largest Valid Window}$\n\nFor example, suppose the string is `\"aabbccabc\"`, and  `k = 2`:  \n\n![Example_Image](../Figures/2516/2516_slidning_window.png)\n\n#### Algorithm\n\n- Initialize a `count` array of size 3 to keep track of the frequency of characters 'a', 'b', and 'c' in the string.\n- Iterate through the string `s` to populate the `count` array with the total occurrences of each character ('a', 'b', 'c').\n- If any character in the string occurs fewer than `k` times, return `-1` (since it is impossible to satisfy the condition of having at least `k` of each character).\n\n- Initialize a `window` array of size 3 to track the counts of 'a', 'b', and 'c' within the current sliding window.\n- Set the `left` pointer to 0 and `maxWindow` to 0, which will store the length of the longest valid window.\n\n- Iterate over the string using a `right` pointer:\n  - Increment the count of the current character in the `window` array.\n\n  - If the window contains too many characters of any type (i.e., fewer than `k` characters are outside the window), shrink the window from the left:\n    - Decrease the count of the character at the `left` pointer.\n    - Move the `left` pointer to the right.\n\n  - Update `maxWindow` to be the maximum of its current value and the current window size (`right - left + 1`).\n\n- After the loop, return `n - maxWindow`, which represents the minimum number of characters to be removed from the string to satisfy the condition of having at least `k` of each character.\n\n#### Implementation#### Complexity Analysis\n\nLet $n$ be the length of the string.\n\n- Time complexity: $O(n)$\n\n    The first loop counts the total occurrences of characters in the string `s`, which takes $O(n)$ time.\n    \n    The second loop checks if the counts for all characters are greater than or equal to `k`. This is a constant time operation, $O(1)$, since there are only 3 characters (`'a'`, `'b'`, `'c'`).\n    \n    The sliding window approach in the third loop iterates through the string with a `right` pointer. For each character, the `left` pointer is adjusted. The inner `while` loop ensures that the window size remains valid, but each character is processed at most once by both `left` and `right` pointers. This results in $O(n)$ time for the sliding window section.\n\n    Therefore, the overall time complexity is dominated by the linear pass through the string, which is $O(n)$.\n\n- Space complexity: $O(3) = O(1)$\n\n    The space used for the `count` array and `window` array is fixed at 3 elements each (since there are only 3 possible characters to track). The rest of the variables, like `n`, `left`, `maxWindow`, and `right`, all use constant space as well. Thus, the overall space complexity is $O(3) = O(1)$.\n \n---"
}