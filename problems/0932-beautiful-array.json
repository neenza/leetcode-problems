{
  "title": "Beautiful Array",
  "problem_id": "968",
  "frontend_id": "932",
  "difficulty": "Medium",
  "problem_slug": "beautiful-array",
  "topics": [
    "Array",
    "Math",
    "Divide and Conquer"
  ],
  "description": "An array nums of length n is beautiful if:\nGiven the integer n, return any beautiful array nums of length n. There will be at least one valid answer for the given n.\nExample 1:\nExample 2:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: n = 4\nOutput: [2,1,4,3]",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input: n = 5\nOutput: [3,1,2,5,4]",
      "images": []
    }
  ],
  "constraints": [
    "1 <= n <= 1000"
  ],
  "follow_ups": [],
  "hints": [],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    vector<int> beautifulArray(int n) {\n        \n    }\n};",
    "java": "class Solution {\n    public int[] beautifulArray(int n) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def beautifulArray(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def beautifulArray(self, n: int) -> List[int]:\n        ",
    "c": "/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nint* beautifulArray(int n, int* returnSize) {\n    \n}",
    "csharp": "public class Solution {\n    public int[] BeautifulArray(int n) {\n        \n    }\n}",
    "javascript": "/**\n * @param {number} n\n * @return {number[]}\n */\nvar beautifulArray = function(n) {\n    \n};",
    "typescript": "function beautifulArray(n: number): number[] {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param Integer $n\n     * @return Integer[]\n     */\n    function beautifulArray($n) {\n        \n    }\n}",
    "swift": "class Solution {\n    func beautifulArray(_ n: Int) -> [Int] {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun beautifulArray(n: Int): IntArray {\n        \n    }\n}",
    "dart": "class Solution {\n  List<int> beautifulArray(int n) {\n    \n  }\n}",
    "golang": "func beautifulArray(n int) []int {\n    \n}",
    "ruby": "# @param {Integer} n\n# @return {Integer[]}\ndef beautiful_array(n)\n    \nend",
    "scala": "object Solution {\n    def beautifulArray(n: Int): Array[Int] = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn beautiful_array(n: i32) -> Vec<i32> {\n        \n    }\n}",
    "racket": "(define/contract (beautiful-array n)\n  (-> exact-integer? (listof exact-integer?))\n  )",
    "erlang": "-spec beautiful_array(N :: integer()) -> [integer()].\nbeautiful_array(N) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec beautiful_array(n :: integer) :: [integer]\n  def beautiful_array(n) do\n    \n  end\nend"
  },
  "solution": "[TOC]\n\n## Solution\n---\n\n### Approach 1: Divide and Conquer\n\n**Intuition**\n\nFirst, notice that the condition is equivalent to saying that `A` has no arithmetic subsequence.  We'll use the term \"*arithmetic-free*\" interchangeably with \"*beautiful*\".\n\nOne way is to guess that we should divide and conquer.  One reason for this is that the condition is linear, so if the condition is satisfied by variables taking on values `(1, 2, ..., n)`, it is satisfied by those variables taking on values `(a + b, a + 2*b, a + 3*b, ..., a + (n-1)*b)` instead.\n\nIf we perform a divide and conquer, then we have two parts `left` and `right`, such that each part is arithmetic-free, and we only want that a triple from both parts is not arithmetic.  Looking at the conditions:\n\n* `2*A[k] = A[i] + A[j]`\n* `(i < k < j)`, `i` from `left`, `j` from `right`\n\nwe can guess that because the left hand side `2*A[k]` is even, we can choose `left` to have all odd elements, and `right` to have all even elements.\n\nAnother way we could arrive at this is to try to place a number in the middle, like `5`.  We will have `4` and `6` say, to the left of `5`, and `7` to the right of `6`, etc.  We see that in general, odd numbers move towards one direction and even numbers towards another direction.\n\nOne final way we could arrive at this is to inspect possible answers arrived at by brute force.  On experimentation, we see that many answers have all the odd elements to one side, and all the even elements to the other side, with only minor variation.\n\n**Algorithm**\n\nLooking at the elements `1, 2, ..., N`, there are `(N+1) / 2` odd numbers and `N / 2` even numbers.\n\nWe solve for elements `1, 2, ..., (N+1) / 2` and map these numbers onto `1, 3, 5, ...`.  Similarly, we solve for elements `1, 2, ..., N/2` and map these numbers onto `2, 4, 6, ...`.\n\nWe can compose these solutions by concatenating them, since an arithmetic sequence never starts and ends with elements of different parity.\n\nWe memoize the result to arrive at the answer quicker.**Complexity Analysis**\n\n* Time Complexity:  $$O(N \\log N)$$.  The function `f` is called only $$O(\\log N)$$ times, and each time does $$O(N)$$ work.\n\n* Space Complexity:  $$O(N \\log N)$$."
}