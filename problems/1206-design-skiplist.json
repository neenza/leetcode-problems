{
  "title": "Design Skiplist",
  "problem_id": "1337",
  "frontend_id": "1206",
  "difficulty": "Hard",
  "problem_slug": "design-skiplist",
  "topics": [
    "Linked List",
    "Design"
  ],
  "description": "Design a Skiplist without using any built-in libraries.\nA skiplist is a data structure that takes O(log(n)) time to add, erase and search. Comparing with treap and red-black tree which has the same function and performance, the code length of Skiplist can be comparatively short and the idea behind Skiplists is just simple linked lists.\nFor example, we have a Skiplist containing [30,40,50,60,70,90] and we want to add 80 and 45 into it. The Skiplist works this way:\nArtyom Kalinin [CC BY-SA 3.0], via Wikimedia Commons\nYou can see there are many layers in the Skiplist. Each layer is a sorted linked list. With the help of the top layers, add, erase and search can be faster than O(n). It can be proven that the average time complexity for each operation is O(log(n)) and space complexity is O(n).\nSee more about Skiplist: https://en.wikipedia.org/wiki/Skip_list\nImplement the Skiplist class:\nNote that duplicates may exist in the Skiplist, your code needs to handle this situation.\nExample 1:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input\n[\"Skiplist\", \"add\", \"add\", \"add\", \"search\", \"add\", \"search\", \"erase\", \"erase\", \"search\"]\n[[], [1], [2], [3], [0], [4], [1], [0], [1], [1]]\nOutput\n[null, null, null, null, false, null, true, false, true, false]\n\nExplanation\nSkiplist skiplist = new Skiplist();\nskiplist.add(1);\nskiplist.add(2);\nskiplist.add(3);\nskiplist.search(0); // return False\nskiplist.add(4);\nskiplist.search(1); // return True\nskiplist.erase(0);  // return False, 0 is not in skiplist.\nskiplist.erase(1);  // return True\nskiplist.search(1); // return False, 1 has already been erased.",
      "images": [
        "https://assets.leetcode.com/uploads/2019/09/27/1506_skiplist.gif"
      ]
    }
  ],
  "constraints": [
    "0 <= num, target <= 2 * 104",
    "At most 5 * 104 calls will be made to search, add, and erase."
  ],
  "follow_ups": [],
  "hints": [],
  "code_snippets": {
    "cpp": "class Skiplist {\npublic:\n    Skiplist() {\n        \n    }\n    \n    bool search(int target) {\n        \n    }\n    \n    void add(int num) {\n        \n    }\n    \n    bool erase(int num) {\n        \n    }\n};\n\n/**\n * Your Skiplist object will be instantiated and called as such:\n * Skiplist* obj = new Skiplist();\n * bool param_1 = obj->search(target);\n * obj->add(num);\n * bool param_3 = obj->erase(num);\n */",
    "java": "class Skiplist {\n\n    public Skiplist() {\n        \n    }\n    \n    public boolean search(int target) {\n        \n    }\n    \n    public void add(int num) {\n        \n    }\n    \n    public boolean erase(int num) {\n        \n    }\n}\n\n/**\n * Your Skiplist object will be instantiated and called as such:\n * Skiplist obj = new Skiplist();\n * boolean param_1 = obj.search(target);\n * obj.add(num);\n * boolean param_3 = obj.erase(num);\n */",
    "python": "class Skiplist(object):\n\n    def __init__(self):\n        \n\n    def search(self, target):\n        \"\"\"\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        \n\n    def add(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: None\n        \"\"\"\n        \n\n    def erase(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        \n\n\n# Your Skiplist object will be instantiated and called as such:\n# obj = Skiplist()\n# param_1 = obj.search(target)\n# obj.add(num)\n# param_3 = obj.erase(num)",
    "python3": "class Skiplist:\n\n    def __init__(self):\n        \n\n    def search(self, target: int) -> bool:\n        \n\n    def add(self, num: int) -> None:\n        \n\n    def erase(self, num: int) -> bool:\n        \n\n\n# Your Skiplist object will be instantiated and called as such:\n# obj = Skiplist()\n# param_1 = obj.search(target)\n# obj.add(num)\n# param_3 = obj.erase(num)",
    "c": "\n\n\ntypedef struct {\n    \n} Skiplist;\n\n\nSkiplist* skiplistCreate() {\n    \n}\n\nbool skiplistSearch(Skiplist* obj, int target) {\n    \n}\n\nvoid skiplistAdd(Skiplist* obj, int num) {\n    \n}\n\nbool skiplistErase(Skiplist* obj, int num) {\n    \n}\n\nvoid skiplistFree(Skiplist* obj) {\n    \n}\n\n/**\n * Your Skiplist struct will be instantiated and called as such:\n * Skiplist* obj = skiplistCreate();\n * bool param_1 = skiplistSearch(obj, target);\n \n * skiplistAdd(obj, num);\n \n * bool param_3 = skiplistErase(obj, num);\n \n * skiplistFree(obj);\n*/",
    "csharp": "public class Skiplist {\n\n    public Skiplist() {\n        \n    }\n    \n    public bool Search(int target) {\n        \n    }\n    \n    public void Add(int num) {\n        \n    }\n    \n    public bool Erase(int num) {\n        \n    }\n}\n\n/**\n * Your Skiplist object will be instantiated and called as such:\n * Skiplist obj = new Skiplist();\n * bool param_1 = obj.Search(target);\n * obj.Add(num);\n * bool param_3 = obj.Erase(num);\n */",
    "javascript": "\nvar Skiplist = function() {\n    \n};\n\n/** \n * @param {number} target\n * @return {boolean}\n */\nSkiplist.prototype.search = function(target) {\n    \n};\n\n/** \n * @param {number} num\n * @return {void}\n */\nSkiplist.prototype.add = function(num) {\n    \n};\n\n/** \n * @param {number} num\n * @return {boolean}\n */\nSkiplist.prototype.erase = function(num) {\n    \n};\n\n/** \n * Your Skiplist object will be instantiated and called as such:\n * var obj = new Skiplist()\n * var param_1 = obj.search(target)\n * obj.add(num)\n * var param_3 = obj.erase(num)\n */",
    "typescript": "class Skiplist {\n    constructor() {\n        \n    }\n\n    search(target: number): boolean {\n        \n    }\n\n    add(num: number): void {\n        \n    }\n\n    erase(num: number): boolean {\n        \n    }\n}\n\n/**\n * Your Skiplist object will be instantiated and called as such:\n * var obj = new Skiplist()\n * var param_1 = obj.search(target)\n * obj.add(num)\n * var param_3 = obj.erase(num)\n */",
    "php": "class Skiplist {\n    /**\n     */\n    function __construct() {\n        \n    }\n  \n    /**\n     * @param Integer $target\n     * @return Boolean\n     */\n    function search($target) {\n        \n    }\n  \n    /**\n     * @param Integer $num\n     * @return NULL\n     */\n    function add($num) {\n        \n    }\n  \n    /**\n     * @param Integer $num\n     * @return Boolean\n     */\n    function erase($num) {\n        \n    }\n}\n\n/**\n * Your Skiplist object will be instantiated and called as such:\n * $obj = Skiplist();\n * $ret_1 = $obj->search($target);\n * $obj->add($num);\n * $ret_3 = $obj->erase($num);\n */",
    "swift": "\nclass Skiplist {\n\n    init() {\n        \n    }\n    \n    func search(_ target: Int) -> Bool {\n        \n    }\n    \n    func add(_ num: Int) {\n        \n    }\n    \n    func erase(_ num: Int) -> Bool {\n        \n    }\n}\n\n/**\n * Your Skiplist object will be instantiated and called as such:\n * let obj = Skiplist()\n * let ret_1: Bool = obj.search(target)\n * obj.add(num)\n * let ret_3: Bool = obj.erase(num)\n */",
    "kotlin": "class Skiplist() {\n\n    fun search(target: Int): Boolean {\n        \n    }\n\n    fun add(num: Int) {\n        \n    }\n\n    fun erase(num: Int): Boolean {\n        \n    }\n\n}\n\n/**\n * Your Skiplist object will be instantiated and called as such:\n * var obj = Skiplist()\n * var param_1 = obj.search(target)\n * obj.add(num)\n * var param_3 = obj.erase(num)\n */",
    "dart": "class Skiplist {\n\n  Skiplist() {\n    \n  }\n  \n  bool search(int target) {\n    \n  }\n  \n  void add(int num) {\n    \n  }\n  \n  bool erase(int num) {\n    \n  }\n}\n\n/**\n * Your Skiplist object will be instantiated and called as such:\n * Skiplist obj = Skiplist();\n * bool param1 = obj.search(target);\n * obj.add(num);\n * bool param3 = obj.erase(num);\n */",
    "golang": "type Skiplist struct {\n    \n}\n\n\nfunc Constructor() Skiplist {\n    \n}\n\n\nfunc (this *Skiplist) Search(target int) bool {\n    \n}\n\n\nfunc (this *Skiplist) Add(num int)  {\n    \n}\n\n\nfunc (this *Skiplist) Erase(num int) bool {\n    \n}\n\n\n/**\n * Your Skiplist object will be instantiated and called as such:\n * obj := Constructor();\n * param_1 := obj.Search(target);\n * obj.Add(num);\n * param_3 := obj.Erase(num);\n */",
    "ruby": "class Skiplist\n    def initialize()\n        \n    end\n\n\n=begin\n    :type target: Integer\n    :rtype: Boolean\n=end\n    def search(target)\n        \n    end\n\n\n=begin\n    :type num: Integer\n    :rtype: Void\n=end\n    def add(num)\n        \n    end\n\n\n=begin\n    :type num: Integer\n    :rtype: Boolean\n=end\n    def erase(num)\n        \n    end\n\n\nend\n\n# Your Skiplist object will be instantiated and called as such:\n# obj = Skiplist.new()\n# param_1 = obj.search(target)\n# obj.add(num)\n# param_3 = obj.erase(num)",
    "scala": "class Skiplist() {\n\n    def search(target: Int): Boolean = {\n        \n    }\n\n    def add(num: Int): Unit = {\n        \n    }\n\n    def erase(num: Int): Boolean = {\n        \n    }\n\n}\n\n/**\n * Your Skiplist object will be instantiated and called as such:\n * val obj = new Skiplist()\n * val param_1 = obj.search(target)\n * obj.add(num)\n * val param_3 = obj.erase(num)\n */",
    "rust": "struct Skiplist {\n\n}\n\n\n/** \n * `&self` means the method takes an immutable reference.\n * If you need a mutable reference, change it to `&mut self` instead.\n */\nimpl Skiplist {\n\n    fn new() -> Self {\n        \n    }\n    \n    fn search(&self, target: i32) -> bool {\n        \n    }\n    \n    fn add(&self, num: i32) {\n        \n    }\n    \n    fn erase(&self, num: i32) -> bool {\n        \n    }\n}\n\n/**\n * Your Skiplist object will be instantiated and called as such:\n * let obj = Skiplist::new();\n * let ret_1: bool = obj.search(target);\n * obj.add(num);\n * let ret_3: bool = obj.erase(num);\n */",
    "racket": "(define skiplist%\n  (class object%\n    (super-new)\n    \n    (init-field)\n    \n    ; search : exact-integer? -> boolean?\n    (define/public (search target)\n      )\n    ; add : exact-integer? -> void?\n    (define/public (add num)\n      )\n    ; erase : exact-integer? -> boolean?\n    (define/public (erase num)\n      )))\n\n;; Your skiplist% object will be instantiated and called as such:\n;; (define obj (new skiplist%))\n;; (define param_1 (send obj search target))\n;; (send obj add num)\n;; (define param_3 (send obj erase num))",
    "erlang": "-spec skiplist_init_() -> any().\nskiplist_init_() ->\n  .\n\n-spec skiplist_search(Target :: integer()) -> boolean().\nskiplist_search(Target) ->\n  .\n\n-spec skiplist_add(Num :: integer()) -> any().\nskiplist_add(Num) ->\n  .\n\n-spec skiplist_erase(Num :: integer()) -> boolean().\nskiplist_erase(Num) ->\n  .\n\n\n%% Your functions will be called as such:\n%% skiplist_init_(),\n%% Param_1 = skiplist_search(Target),\n%% skiplist_add(Num),\n%% Param_3 = skiplist_erase(Num),\n\n%% skiplist_init_ will be called before every test case, in which you can do some necessary initializations.",
    "elixir": "defmodule Skiplist do\n  @spec init_() :: any\n  def init_() do\n    \n  end\n\n  @spec search(target :: integer) :: boolean\n  def search(target) do\n    \n  end\n\n  @spec add(num :: integer) :: any\n  def add(num) do\n    \n  end\n\n  @spec erase(num :: integer) :: boolean\n  def erase(num) do\n    \n  end\nend\n\n# Your functions will be called as such:\n# Skiplist.init_()\n# param_1 = Skiplist.search(target)\n# Skiplist.add(num)\n# param_3 = Skiplist.erase(num)\n\n# Skiplist.init_ will be called before every test case, in which you can do some necessary initializations."
  }
}