{
  "title": "Closest Prime Numbers in Range",
  "problem_id": "2610",
  "frontend_id": "2523",
  "difficulty": "Medium",
  "problem_slug": "closest-prime-numbers-in-range",
  "topics": [
    "Math",
    "Number Theory"
  ],
  "description": "Given two positive integers left and right, find the two integers num1 and num2 such that:\nReturn the positive integer array ans = [num1, num2]. If there are multiple pairs satisfying these conditions, return the one with the smallest num1 value. If no such numbers exist, return [-1, -1].\nExample 1:\nExample 2:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: left = 10, right = 19\nOutput: [11,13]\nExplanation: The prime numbers between 10 and 19 are 11, 13, 17, and 19.\nThe closest gap between any pair is 2, which can be achieved by [11,13] or [17,19].\nSince 11 is smaller than 17, we return the first pair.",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input: left = 4, right = 6\nOutput: [-1,-1]\nExplanation: There exists only one prime number in the given range, so the conditions cannot be satisfied.",
      "images": []
    }
  ],
  "constraints": [
    "1 <= left <= right <= 106"
  ],
  "follow_ups": [],
  "hints": [
    "Use Sieve of Eratosthenes to mark numbers that are primes.",
    "Iterate from right to left and find pair with the minimum distance between marked numbers."
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    vector<int> closestPrimes(int left, int right) {\n        \n    }\n};",
    "java": "class Solution {\n    public int[] closestPrimes(int left, int right) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def closestPrimes(self, left, right):\n        \"\"\"\n        :type left: int\n        :type right: int\n        :rtype: List[int]\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def closestPrimes(self, left: int, right: int) -> List[int]:\n        ",
    "c": "/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nint* closestPrimes(int left, int right, int* returnSize) {\n    \n}",
    "csharp": "public class Solution {\n    public int[] ClosestPrimes(int left, int right) {\n        \n    }\n}",
    "javascript": "/**\n * @param {number} left\n * @param {number} right\n * @return {number[]}\n */\nvar closestPrimes = function(left, right) {\n    \n};",
    "typescript": "function closestPrimes(left: number, right: number): number[] {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param Integer $left\n     * @param Integer $right\n     * @return Integer[]\n     */\n    function closestPrimes($left, $right) {\n        \n    }\n}",
    "swift": "class Solution {\n    func closestPrimes(_ left: Int, _ right: Int) -> [Int] {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun closestPrimes(left: Int, right: Int): IntArray {\n        \n    }\n}",
    "dart": "class Solution {\n  List<int> closestPrimes(int left, int right) {\n    \n  }\n}",
    "golang": "func closestPrimes(left int, right int) []int {\n    \n}",
    "ruby": "# @param {Integer} left\n# @param {Integer} right\n# @return {Integer[]}\ndef closest_primes(left, right)\n    \nend",
    "scala": "object Solution {\n    def closestPrimes(left: Int, right: Int): Array[Int] = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn closest_primes(left: i32, right: i32) -> Vec<i32> {\n        \n    }\n}",
    "racket": "(define/contract (closest-primes left right)\n  (-> exact-integer? exact-integer? (listof exact-integer?))\n  )",
    "erlang": "-spec closest_primes(Left :: integer(), Right :: integer()) -> [integer()].\nclosest_primes(Left, Right) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec closest_primes(left :: integer, right :: integer) :: [integer]\n  def closest_primes(left, right) do\n    \n  end\nend"
  },
  "solution": "[TOC]\n\n## Solution\n\n---\n\n### Approach 1: Sieve of Eratosthenes\n\n#### Intuition\n\nWe are given two numbers, `left` and `right`, and we need to find a pair of prime numbers within this range such that their difference is minimized. If multiple pairs have the same minimum difference, we return the one with the smallest values. If no such pair exists, we return `[-1, -1]`.\n\nA simple approach would be to iterate through all numbers in this range, check whether each number is prime, store the primes, and then determine the pair with the smallest difference. However, checking if a number is prime requires verifying that it has no divisors other than `1` and itself. A naive way to do this is to test divisibility for all numbers up to `n`, but a more optimized approach would only check divisibility up to `sqrt(n)`. Even with this optimization, the approach remains too slow. Since `right` can be as large as $10^6$, iterating through all numbers and performing a divisibility check for each would still be inefficient, leading to a Time Limit Exceeded (TLE) error.\n\nA much faster way to find all prime numbers up to a given limit is the [Sieve of Eratosthenes](https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes). Instead of checking each number one by one, the sieve marks multiples of each prime in bulk, eliminating the need for repeated divisibility checks.  \n\nWe start with a list of numbers from 2 to 100. Notice we skip 1 since it’s not considered a prime. Starting with the smallest prime, 2, we know it’s prime because it hasn’t been marked yet. So, we keep it. Now, we cross out all multiples of 2 (like 4, 6, 8, etc.) because they’re definitely not prime. The next number that isn’t crossed out is 3, so we mark it as a prime. Then, we cross out all multiples of 3 (like 6, 9, 12, etc.). We keep going, finding the next unmarked number (which will be 5), and marking all of its multiples. We do this for 7 as well and continue until we’ve processed all numbers up to the limit.\n\nThe beauty of the Sieve of Eratosthenes is that it saves a lot of time by marking off composites in bulk, rather than testing each number individually to see if it’s prime. By the end, any number that’s still unmarked is a prime.\n\nAs we proceed, we collect all the numbers in an array `primeNumbers`, where `sieve[prime] = 1`. For any marked (non-prime) number, we could also keep track of the specific prime that marked it, though, for this problem, it’s sufficient to identify which numbers are prime.\n\nSince all values lie between 1 and 1000000, we can iterate through the array, check for the minimum difference between two consecutive primes, and return it as the answer.\n\n#### Algorithm\n\nMain Function: `closestPrimes(int left, int right)`\n\n1. Generate Prime Numbers using Sieve:\n   - Create an integer array `sieve` of size `(right + 1)`, initialized to `1` (indicating prime numbers).\n   - Set `sieve[0]` and `sieve[1]` to `0` (since `0` and `1` are not prime).\n   - Iterate through numbers from `2` to `sqrt(right)`:\n     - If the number is marked as prime (`sieve[number] == 1`), mark all its multiples as non-prime (`sieve[multiple] = 0`).\n\n2. Collect Prime Numbers in Range:\n   - Create a vector `primeNumbers` to store prime numbers within `[left, right]`.\n   - Iterate through numbers from `left` to `right`:\n     - If `sieve[num] == 1`, add `num` to `primeNumbers`.\n\n3. Find the Closest Prime Pair:\n   - If `primeNumbers.size() < 2`, return `{-1, -1}` (since there are not enough primes).\n   - Initialize `minDifference` to the maximum integer value and `closestPair` to `{-1, -1}`.\n   - Iterate through `primeNumbers` and check consecutive primes:\n     - Compute `difference = primeNumbers[index] - primeNumbers[index - 1]`.\n     - If `difference` is smaller than `minDifference`, update `closestPair = {primeNumbers[index - 1], primeNumbers[index]}`.\n\n4. Return `closestPair` as the result.\n\nHelper Function: `sieve(int upperLimit)`\n\n1. Create an integer vector `sieve` of size `(upperLimit + 1)`, initialized to `1` (indicating prime numbers).\n2. Set `sieve[0]` and `sieve[1]` to `0` (since `0` and `1` are not prime).\n3. Iterate through numbers from `2` to `sqrt(upperLimit)`:\n   - If `sieve[number] == 1`, mark all multiples of `number` as `0` (non-prime).\n4. Return the `sieve` array.\n\n#### Implementation#### Complexity Analysis\n\nLet $R$ be `right` and $L$ be `left`, representing the range within which we search for prime numbers.\n\n- Time Complexity: $O(R \\log(\\log(R)) + R - L)$\n\n    The **Sieve of Eratosthenes** runs in $O(R \\log(\\log(R)))$, where $R$ is the upper limit of the sieve. After generating the sieve, iterating through the range $[L, R]$ to collect prime numbers takes $O(R - L)$. Finally, finding the closest prime pair requires $O(R - L)$ operations.\n\n    Thus, the overall time complexity is $O(R \\log(\\log(R)) + R - L)$.\n\n- Space Complexity: $O(R)$\n\n    The algorithm uses a `sieve` array of size $O(R)$ to mark prime numbers. Additionally, the vector storing prime numbers within the range $[L, R]$ can have at most $O(R - L)$ elements. Thus, the overall space complexity is $O(R)$.\n\n---\n\n### Approach 2: Analyze Distance between twin primes\n\n#### Intuition\n\nTo avoid storing the prime numbers while iterating through the range, we can check if the current number is prime or not. If it is, we can store it and take it's difference with the next prime that we find in this range. Observe that the **Sieve of Eratosthenes** approach cannot be used here, since it uses extra storage to check whether the number is prime or not. The only method left is to iterate through the divisors upto `sqrt(number)` and check if the current number is prime or not.\n\nIn this approach, we take advantage of a special property of prime numbers known as **twin primes**, which are pairs of prime numbers that differ by exactly `2`, such as `(3,5)`, `(11,13)`, and `(17,19)`. Instead of searching through all prime numbers, we can optimize our search by focusing on this pattern.  \nA key mathematical observation under the given constraints (`1 ≤ L,R ≤ 10^6`) is that for any range `[L, R]` where `R - L ≥ 1452`, there is always at least one twin prime pair. This means that if the given range is wide enough (at least `1452` numbers long), we can be certain that a twin prime pair exists. Since no two prime numbers can be closer than a twin prime pair (which has a difference of exactly `2`), we can immediately return this result without further searching.You can use the following code snippet to verify this behavior by checking the maximum gap between consecutive prime numbers in the range [1, 10^6] (Click to expand):```cpp\nvectorsieve(int upper_limit) {\n    vectoris_prime(upper_limit + 1, true);\n    is_prime[0] = is_prime[1] = false;\n    for (int num = 2; num * num <= upper_limit; num++) {\n        if (is_prime[num]) {\n            for (int multiple = num * num; multiple <= upper_limit; multiple += num) {\n                is_prime[multiple] = false;\n            }\n        }\n    }\n    return is_prime;\n}\nint main() {\n    const int limit = 1000000;\n    vectorprimes = sieve(limit);\n\n    vectortwin_primes;\n    // Collect all twin primes\n    for (int num = 2; num <= limit - 2; num++) {\n        if (primes[num] && primes[num + 2]) {\n            twin_primes.push_back(num);\n        }\n    }\n    int max_distance = 0;\n    pairmax_twin_pair = {-1, -1};\n    // Find the largest gap between consecutive twin primes\n    for (int i = 1; i < twin_primes.size(); i++) {\n        int distance = twin_primes[i] - twin_primes[i - 1];\n        if (distance > max_distance) {\n            max_distance = distance;\n            max_twin_pair = {twin_primes[i - 1], twin_primes[i]};\n        }\n    }\n    cout << \"Twin primes with maximum distance: (\" << max_twin_pair.first \n         << \", \" << max_twin_pair.second << \")\" << endl;\n    cout << \"Maximum twin prime distance: \" << max_distance << endl;\n    return 0;\n}\n```However, if the range `[L, R]` is smaller than 1452 numbers, we cannot rely on this property and must manually find the closest prime pair. To do this, we iterate through the numbers in the range, check which ones are prime, and compute the smallest difference between consecutive primes.  \n\nTherefore, we leverage the concept of twin primes to optimize our search for the closest prime pair. Instead of storing all prime numbers and comparing them later, we track only the last encountered prime (`prevPrime`). As we iterate through the range `[left, right]`, if we find a new prime, we calculate the difference between it and `prevPrime`. If the difference is `2`, we instantly return the pair, since no closer pair can exist. This early exit significantly reduces unnecessary iterations, especially in large ranges where twin primes are guaranteed to exist. \n\nTo summarize, if no twin prime pair is found initially, we continue searching for the closest prime pair by tracking the smallest difference encountered. However, if the range is greater than `1452`, it is mathematically guaranteed that at least one twin prime pair will exist within it.\n\n#### Algorithm\n\nMain Function: `closestPrimes(int left, int right)`\n\n1. Initialize Variables:\n   - `prevPrime`: Stores the last encountered prime number.\n   - `closestA`, `closestB`: Stores the closest prime pair.\n   - `minDifference`: Stores the minimum difference found (initialized to a large value).\n\n2. Find the Closest Prime Pair in Range `[left, right]`:\n   - Iterate through all numbers from `left` to `right`:\n     - Use `isPrime(candidate)` to check if the number is prime.\n     - If the number is prime:\n       - If `prevPrime` is already set:\n         - Calculate the difference between `prevPrime` and `candidate`.\n         - If the difference is **2**, return `{prevPrime, candidate}` immediately (twin prime optimization).\n         - If the difference is smaller than `minDifference`, update `closestA`, `closestB`, and `minDifference`.\n       - Update `prevPrime` to `candidate`.\n\n3. Handle Cases with Fewer Than 2 Primes:\n   - If `closestA` is still `-1`, return `{-1, -1}`.\n\n4. Return Result:\n   - Return `{closestA, closestB}`.\n\nHelper Function: `isPrime(int number)`\n\n1. Handle Small Numbers:\n   - If `number < 2`, return `false`.\n   - If `number` is `2` or `3`, return `true` (both are prime).\n   - If `number` is even and greater than `2`, return `false`.\n\n2. Check for Divisibility:\n   - Iterate from `3` to `√number`, checking only odd numbers.\n   - If `number` is divisible by any of these, return `false`.\n\n3. Return `true` if No Divisors Found.\n\n#### Implementation#### Complexity Analysis\n\nLet $R$ be `right` and $L$ be `left`, representing the range within which we search for prime numbers.\n\n- Time Complexity: $O(\\min(1452, R - L) \\cdot sqrt(R))$  \n\n  The algorithm iterates through numbers in the range `[L, R]` to identify prime numbers. For each number, it performs a primality check, which takes $O(\\sqrt{R})$ time in the worst case.  \n\n  - If `R - L ≥ 1452`, we know that a twin prime pair must exist in the range, allowing us to stop early. In this case, the algorithm processes at most 1452 numbers, leading to a complexity of $O(1452 \\cdot \\sqrt{R})$.  \n  - If `R - L < 1452`, the algorithm checks up to `R - L` numbers, resulting in a worst-case complexity of $O((R - L) \\cdot \\sqrt{R})$.  \n\n  Therefore, the overall time complexity is bounded by $O(\\min(1452, R - L) \\cdot \\sqrt{R})$.\n\n- Space Complexity: $O(1)$  \n\n   We're only using a few variables that don't scale with the input size. Therefore, the overall space complexity remains $O(1)$.\n\n---"
}