{
  "title": "Cells with Odd Values in a Matrix",
  "problem_id": "1378",
  "frontend_id": "1252",
  "difficulty": "Easy",
  "problem_slug": "cells-with-odd-values-in-a-matrix",
  "topics": [
    "Array",
    "Math",
    "Simulation"
  ],
  "description": "There is an m x n matrix that is initialized to all 0's. There is also a 2D array indices where each indices[i] = [ri, ci] represents a 0-indexed location to perform some increment operations on the matrix.\nFor each location indices[i], do both of the following:\nGiven m, n, and indices, return the number of odd-valued cells in the matrix after applying the increment to all locations in indices.\nExample 1:\nExample 2:\nConstraints:\nFollow up: Could you solve this in O(n + m + indices.length) time with only O(n + m) extra space?",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: m = 2, n = 3, indices = [[0,1],[1,1]]\nOutput: 6\nExplanation: Initial matrix = [[0,0,0],[0,0,0]].\nAfter applying first increment it becomes [[1,2,1],[0,1,0]].\nThe final matrix is [[1,3,1],[1,3,1]], which contains 6 odd numbers.",
      "images": [
        "https://assets.leetcode.com/uploads/2019/10/30/e1.png"
      ]
    },
    {
      "example_num": 2,
      "example_text": "Input: m = 2, n = 2, indices = [[1,1],[0,0]]\nOutput: 0\nExplanation: Final matrix = [[2,2],[2,2]]. There are no odd numbers in the final matrix.",
      "images": [
        "https://assets.leetcode.com/uploads/2019/10/30/e2.png"
      ]
    }
  ],
  "constraints": [
    "1 <= m, n <= 50",
    "1 <= indices.length <= 100",
    "0 <= ri < m",
    "0 <= ci < n"
  ],
  "follow_ups": [
    "Could you solve this in O(n + m + indices.length) time with only O(n + m) extra space?"
  ],
  "hints": [
    "Simulation : With small constraints, it is possible to apply changes to each row and column and count odd cells after applying it.",
    "You can accumulate the number you should add to each row and column and then you can count the number of odd cells."
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    int oddCells(int m, int n, vector<vector<int>>& indices) {\n        \n    }\n};",
    "java": "class Solution {\n    public int oddCells(int m, int n, int[][] indices) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def oddCells(self, m, n, indices):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :type indices: List[List[int]]\n        :rtype: int\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def oddCells(self, m: int, n: int, indices: List[List[int]]) -> int:\n        ",
    "c": "int oddCells(int m, int n, int** indices, int indicesSize, int* indicesColSize) {\n    \n}",
    "csharp": "public class Solution {\n    public int OddCells(int m, int n, int[][] indices) {\n        \n    }\n}",
    "javascript": "/**\n * @param {number} m\n * @param {number} n\n * @param {number[][]} indices\n * @return {number}\n */\nvar oddCells = function(m, n, indices) {\n    \n};",
    "typescript": "function oddCells(m: number, n: number, indices: number[][]): number {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param Integer $m\n     * @param Integer $n\n     * @param Integer[][] $indices\n     * @return Integer\n     */\n    function oddCells($m, $n, $indices) {\n        \n    }\n}",
    "swift": "class Solution {\n    func oddCells(_ m: Int, _ n: Int, _ indices: [[Int]]) -> Int {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun oddCells(m: Int, n: Int, indices: Array<IntArray>): Int {\n        \n    }\n}",
    "dart": "class Solution {\n  int oddCells(int m, int n, List<List<int>> indices) {\n    \n  }\n}",
    "golang": "func oddCells(m int, n int, indices [][]int) int {\n    \n}",
    "ruby": "# @param {Integer} m\n# @param {Integer} n\n# @param {Integer[][]} indices\n# @return {Integer}\ndef odd_cells(m, n, indices)\n    \nend",
    "scala": "object Solution {\n    def oddCells(m: Int, n: Int, indices: Array[Array[Int]]): Int = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn odd_cells(m: i32, n: i32, indices: Vec<Vec<i32>>) -> i32 {\n        \n    }\n}",
    "racket": "(define/contract (odd-cells m n indices)\n  (-> exact-integer? exact-integer? (listof (listof exact-integer?)) exact-integer?)\n  )",
    "erlang": "-spec odd_cells(M :: integer(), N :: integer(), Indices :: [[integer()]]) -> integer().\nodd_cells(M, N, Indices) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec odd_cells(m :: integer, n :: integer, indices :: [[integer]]) :: integer\n  def odd_cells(m, n, indices) do\n    \n  end\nend"
  }
}