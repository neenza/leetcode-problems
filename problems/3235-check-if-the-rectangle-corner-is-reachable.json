{
  "title": "Check if the Rectangle Corner Is Reachable",
  "problem_id": "3478",
  "frontend_id": "3235",
  "difficulty": "Hard",
  "problem_slug": "check-if-the-rectangle-corner-is-reachable",
  "topics": [
    "Array",
    "Math",
    "Depth-First Search",
    "Breadth-First Search",
    "Union Find",
    "Geometry"
  ],
  "description": "You are given two positive integers xCorner and yCorner, and a 2D array circles, where circles[i] = [xi, yi, ri] denotes a circle with center at (xi, yi) and radius ri.\nThere is a rectangle in the coordinate plane with its bottom left corner at the origin and top right corner at the coordinate (xCorner, yCorner). You need to check whether there is a path from the bottom left corner to the top right corner such that the entire path lies inside the rectangle, does not touch or lie inside any circle, and touches the rectangle only at the two corners.\nReturn true if such a path exists, and false otherwise.\nExample 1:\nExample 2:\nExample 3:\nExample 4:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: xCorner = 3, yCorner = 4, circles = [[2,1,1]]\nOutput: true\nExplanation:\n\nThe black curve shows a possible path between (0, 0) and (3, 4) .",
      "images": [
        "https://assets.leetcode.com/uploads/2024/05/18/example2circle1.png"
      ]
    },
    {
      "example_num": 2,
      "example_text": "Input: xCorner = 3, yCorner = 3, circles = [[1,1,2]]\nOutput: false\nExplanation:\n\nNo path exists from (0, 0) to (3, 3) .",
      "images": [
        "https://assets.leetcode.com/uploads/2024/05/18/example1circle.png"
      ]
    },
    {
      "example_num": 3,
      "example_text": "Input: xCorner = 3, yCorner = 3, circles = [[2,1,1],[1,2,1]]\nOutput: false\nExplanation:\n\nNo path exists from (0, 0) to (3, 3) .",
      "images": [
        "https://assets.leetcode.com/uploads/2024/05/18/example0circle.png"
      ]
    },
    {
      "example_num": 4,
      "example_text": "Input: xCorner = 4, yCorner = 4, circles = [[5,5,1]]\nOutput: true\nExplanation:\n",
      "images": [
        "https://assets.leetcode.com/uploads/2024/08/04/rectangles.png"
      ]
    }
  ],
  "constraints": [
    "3 <= xCorner, yCorner <= 109",
    "1 <= circles.length <= 1000",
    "circles[i].length == 3",
    "1 <= xi, yi, ri <= 109"
  ],
  "follow_ups": [],
  "hints": [
    "Create a graph with <code>n + 4</code> vertices.",
    "Vertices 0 to <code>n - 1</code> represent the circles, vertex <code>n</code> represents upper edge, vertex <code>n + 1</code> represents right edge, vertex <code>n + 2</code> represents lower edge, and vertex <code>n + 3</code> represents left edge.",
    "Add an edge between these vertices if they intersect or touch.",
    "Answer will be <code>false</code> when any of two sides left-right, left-bottom, right-top or top-bottom are reachable using the edges."
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    bool canReachCorner(int xCorner, int yCorner, vector<vector<int>>& circles) {\n        \n    }\n};",
    "java": "class Solution {\n    public boolean canReachCorner(int xCorner, int yCorner, int[][] circles) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def canReachCorner(self, xCorner, yCorner, circles):\n        \"\"\"\n        :type xCorner: int\n        :type yCorner: int\n        :type circles: List[List[int]]\n        :rtype: bool\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def canReachCorner(self, xCorner: int, yCorner: int, circles: List[List[int]]) -> bool:\n        ",
    "c": "bool canReachCorner(int xCorner, int yCorner, int** circles, int circlesSize, int* circlesColSize) {\n    \n}",
    "csharp": "public class Solution {\n    public bool CanReachCorner(int xCorner, int yCorner, int[][] circles) {\n        \n    }\n}",
    "javascript": "/**\n * @param {number} xCorner\n * @param {number} yCorner\n * @param {number[][]} circles\n * @return {boolean}\n */\nvar canReachCorner = function(xCorner, yCorner, circles) {\n    \n};",
    "typescript": "function canReachCorner(xCorner: number, yCorner: number, circles: number[][]): boolean {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param Integer $xCorner\n     * @param Integer $yCorner\n     * @param Integer[][] $circles\n     * @return Boolean\n     */\n    function canReachCorner($xCorner, $yCorner, $circles) {\n        \n    }\n}",
    "swift": "class Solution {\n    func canReachCorner(_ xCorner: Int, _ yCorner: Int, _ circles: [[Int]]) -> Bool {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun canReachCorner(xCorner: Int, yCorner: Int, circles: Array<IntArray>): Boolean {\n        \n    }\n}",
    "dart": "class Solution {\n  bool canReachCorner(int xCorner, int yCorner, List<List<int>> circles) {\n    \n  }\n}",
    "golang": "func canReachCorner(xCorner int, yCorner int, circles [][]int) bool {\n    \n}",
    "ruby": "# @param {Integer} x_corner\n# @param {Integer} y_corner\n# @param {Integer[][]} circles\n# @return {Boolean}\ndef can_reach_corner(x_corner, y_corner, circles)\n    \nend",
    "scala": "object Solution {\n    def canReachCorner(xCorner: Int, yCorner: Int, circles: Array[Array[Int]]): Boolean = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn can_reach_corner(x_corner: i32, y_corner: i32, circles: Vec<Vec<i32>>) -> bool {\n        \n    }\n}",
    "racket": "(define/contract (can-reach-corner xCorner yCorner circles)\n  (-> exact-integer? exact-integer? (listof (listof exact-integer?)) boolean?)\n  )",
    "erlang": "-spec can_reach_corner(XCorner :: integer(), YCorner :: integer(), Circles :: [[integer()]]) -> boolean().\ncan_reach_corner(XCorner, YCorner, Circles) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec can_reach_corner(x_corner :: integer, y_corner :: integer, circles :: [[integer]]) :: boolean\n  def can_reach_corner(x_corner, y_corner, circles) do\n    \n  end\nend"
  }
}