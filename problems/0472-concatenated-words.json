{
  "title": "Concatenated Words",
  "problem_id": "472",
  "frontend_id": "472",
  "difficulty": "Hard",
  "problem_slug": "concatenated-words",
  "topics": [
    "Array",
    "String",
    "Dynamic Programming",
    "Depth-First Search",
    "Trie",
    "Sorting"
  ],
  "description": "Given an array of strings words (without duplicates), return all the concatenated words in the given list of words.\nA concatenated word is defined as a string that is comprised entirely of at least two shorter words (not necessarily distinct)Â in the given array.\nExample 1:\nExample 2:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: words = [\"cat\",\"cats\",\"catsdogcats\",\"dog\",\"dogcatsdog\",\"hippopotamuses\",\"rat\",\"ratcatdogcat\"]\nOutput: [\"catsdogcats\",\"dogcatsdog\",\"ratcatdogcat\"]\nExplanation: \"catsdogcats\" can be concatenated by \"cats\", \"dog\" and \"cats\"; \n\"dogcatsdog\" can be concatenated by \"dog\", \"cats\" and \"dog\"; \n\"ratcatdogcat\" can be concatenated by \"rat\", \"cat\", \"dog\" and \"cat\".",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input: words = [\"cat\",\"dog\",\"catdog\"]\nOutput: [\"catdog\"]",
      "images": []
    }
  ],
  "constraints": [
    "1 <= words.length <= 104",
    "1 <= words[i].length <= 30",
    "words[i] consists of only lowercase English letters.",
    "All the strings of words are unique.",
    "1 <= sum(words[i].length) <= 105"
  ],
  "follow_ups": [],
  "hints": [],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\n        \n    }\n};",
    "java": "class Solution {\n    public List<String> findAllConcatenatedWordsInADict(String[] words) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def findAllConcatenatedWordsInADict(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def findAllConcatenatedWordsInADict(self, words: List[str]) -> List[str]:\n        ",
    "c": "/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nchar** findAllConcatenatedWordsInADict(char** words, int wordsSize, int* returnSize) {\n    \n}",
    "csharp": "public class Solution {\n    public IList<string> FindAllConcatenatedWordsInADict(string[] words) {\n        \n    }\n}",
    "javascript": "/**\n * @param {string[]} words\n * @return {string[]}\n */\nvar findAllConcatenatedWordsInADict = function(words) {\n    \n};",
    "typescript": "function findAllConcatenatedWordsInADict(words: string[]): string[] {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param String[] $words\n     * @return String[]\n     */\n    function findAllConcatenatedWordsInADict($words) {\n        \n    }\n}",
    "swift": "class Solution {\n    func findAllConcatenatedWordsInADict(_ words: [String]) -> [String] {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun findAllConcatenatedWordsInADict(words: Array<String>): List<String> {\n        \n    }\n}",
    "dart": "class Solution {\n  List<String> findAllConcatenatedWordsInADict(List<String> words) {\n    \n  }\n}",
    "golang": "func findAllConcatenatedWordsInADict(words []string) []string {\n    \n}",
    "ruby": "# @param {String[]} words\n# @return {String[]}\ndef find_all_concatenated_words_in_a_dict(words)\n    \nend",
    "scala": "object Solution {\n    def findAllConcatenatedWordsInADict(words: Array[String]): List[String] = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn find_all_concatenated_words_in_a_dict(words: Vec<String>) -> Vec<String> {\n        \n    }\n}",
    "racket": "(define/contract (find-all-concatenated-words-in-a-dict words)\n  (-> (listof string?) (listof string?))\n  )",
    "erlang": "-spec find_all_concatenated_words_in_a_dict(Words :: [unicode:unicode_binary()]) -> [unicode:unicode_binary()].\nfind_all_concatenated_words_in_a_dict(Words) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec find_all_concatenated_words_in_a_dict(words :: [String.t]) :: [String.t]\n  def find_all_concatenated_words_in_a_dict(words) do\n    \n  end\nend"
  },
  "solution": "[TOC]\n\n## Solution\n\n--- \n\nThe main logic of the solutions is similar to the question [Word Break](https://leetcode.com/problems/word-break/).\n### Approach 1: Dynamic Programming\n\n#### Intuition\n\nConsider the word list as a dictionary, then the problem is: which words can be created by concatenating two or more words in the dictionary?\n\nThis is a famous \"reachability\" problem and it can be solved by DP(dynamic programming), BFS and/or DFS. Though they seem to be different, the core idea behind them is the same. Namely, if a given `word` can be created by concatenating the given words, we can split it into 2 parts, the prefix and the suffix, the prefix is a shorter word which can be got by concatenating the given words and the suffix is a given word. \n\nNamely, `word` = (another shorter word that can be created by concatenation) + (a given word in the dictionary). We can enumerate the suffix and look it up in the dictionary and the prefix part is just a sub-problem to solve.\n\n#### Algorithm\n\n##### State definition\nFormally, for each word, let's define the sub-problem as whether a (possibly empty) prefix can be created by concatenation. So the state of the dynamic programming algorithm can be defined as a boolean array:\nlet $dp[i]$ denote whether word's prefix of length i (index range [0, i - 1]) can be created by concatenation.\n\n##### Induction\nWe need to calculate $dp[i]$ for each i in range [0, word.length]. Let's do it by induction.\n\nThe base case is simple: $dp[0]$ = true, since it's the empty string that can always be created without using any words in the dictionary. \n\nNow, let's consider the value of $dp[i]$ for i > 0. \n\nIf $dp[i]$ is true, as mentioned before, we can split this prefix into 2 parts, a prefix of length j < i which can be created by the words in the dictionary, and the remaining suffix which is exactly a single word in the dictionary.\n\n$dp[i]$ is true if and only if there is an integer j, such that 0 <= j < i and the word's substring (index range [j, i - 1]) is in the dictionary.\n\n**Note: There is an corner case, when i == length, since we don't want to use the word in the dictionary directly, we should check 1 <= j < i instead.**\n\n#### The answer\n$dp[word.length]$ tells if the word can be created by concatenation.\n\nHere is how the algorithm works with \"catsdogcats\" if we have \"cats\" and \"dog\" in the dictionary.For instance, $dp[7]$ tells if we can create \"catsdogs\" (the first 7 letters). It's true because we can split it into a prefix \"cats\" which we know we can create because $dp[4]$ is true, and a suffix \"dogs\", which is in dictionary.\n\n#### Steps\n1. Put all the words into a HashSet as a `dictionary`. \n2. Create an empty list `answer`.\n3. For each `word` in the `words` create a boolean array `dp` of length = `word.length + 1`, and set dp[0] = true.\n4. For each index `i` from 1 to `word.length`, set `dp[i]` to true if we can find a value `j` from 0 (1 if i == `word.length`) such that dp[j] = true and `word.substring(j, i)` is in the `dictionary`.\n5. Put `word` into `answer` if dp[word.length] = true.\n6. After processing all the `words`, return `answer`.\n\n\n#### Implementation#### Complexity Analysis\n\nHere, $N$ is the total number of strings in the array `words`, namely `words.length`, and $M$ is the length of the longest string in the array `words`.\n\n* Time complexity: $O(M ^ 3 \\cdot N)$.\n\nAlthough we use HashSet, we need to consider the cost to calculate the hash value of a string internally which would be $O(M)$. So putting all words into the HashSet takes $O(N * M)$.\nFor each word, the i and j loops take $O(M ^ 2)$. The internal logic to take the substring and search in the HashSet needs to calculate the hash value for the substring too, and it should take another $O(M)$, so for each word, the time complexity is $O(M^3)$ and the total time complexity for $N$ words is $O(M ^ 3 \\cdot N)$\n\n\n\n* Space complexity: $O(N \\cdot M)$.\n\n  This is just the space to save all words in the `dictionary`, if we don't take $M$ as a constant.\n\n\n### Approach 2: DFS\n\n#### Intuition\n\nAs mentioned before, this problem can be transformed into a reachability problem and thus can be solved by a DFS (or BFS) algorithm. For each word, we construct a directed graph with all prefixes as nodes. For simplicity, we can represent each prefix by its length. \n\nSo the graph contains (word.length + 1) nodes. \nFor edges, consider 2 prefixes i and j with 0 <= i < j <= word.length, if prefix j can be created by concatenating prefix i and a word in the dictionary, we add a directed edge from node i to node j. \n> When i = 0, we require `j < word.length` as there should be an edge from node `0` to node `word.length`.\nDetermining whether a word can be created by concatenating 2 or more words in the dictionary is the same as determining whether there is a path from node `0` to node `word.length` in the graph.\n\n#### Algorithm\n\nFor each word, construct the implicit graph mentioned above, then add it to the answer if the node `word.length` can be reached from node `0` in the graph which can be checked using DFS.\n\n\n#### Implementation#### Complexity Analysis\n\nHere, $N$ is the total number of strings in the array `words`, namely `words.length`, and $M$ is the length of the longest string in the array `words`.\n\n* Time complexity: $O(M ^ 3 \\cdot N)$.\n\nFor each word, the constructed graph has $M$ nodes and $O(M ^ 2)$ edges, and the DFS algorithm for reachability is $O(M ^ 2)$ without considering the time complexities of substring and HashSet. If we consider everything, the time complexity to check one word is $O(M ^ 3)$ and the total time complexity to check all words is $O(M ^ 3 \\cdot N)$.\n\n\n\n* Space complexity: $O(N \\cdot M)$.\n\n  This is the space to save all words in the `dictionary`, if we don't take $M$ as a constant, there is also $O(M)$ for the call stack to execute DFS, which wouldn't affect the space complexity anyways.\n\n\n---"
}