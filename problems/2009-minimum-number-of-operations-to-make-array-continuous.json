{
  "title": "Minimum Number of Operations to Make Array Continuous",
  "problem_id": "2119",
  "frontend_id": "2009",
  "difficulty": "Hard",
  "problem_slug": "minimum-number-of-operations-to-make-array-continuous",
  "topics": [
    "Array",
    "Hash Table",
    "Binary Search",
    "Sliding Window"
  ],
  "description": "You are given an integer array nums. In one operation, you can replace any element in nums with any integer.\nnums is considered continuous if both of the following conditions are fulfilled:\nFor example, nums = [4, 2, 5, 3] is continuous, but nums = [1, 2, 3, 5, 6] is not continuous.\nReturn the minimum number of operations to make nums continuous.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: nums = [4,2,5,3]\nOutput: 0\nExplanation: nums is already continuous.",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input: nums = [1,2,3,5,6]\nOutput: 1\nExplanation: One possible solution is to change the last element to 4.\nThe resulting array is [1,2,3,5,4], which is continuous.",
      "images": []
    },
    {
      "example_num": 3,
      "example_text": "Input: nums = [1,10,100,1000]\nOutput: 3\nExplanation: One possible solution is to:\n- Change the second element to 2.\n- Change the third element to 3.\n- Change the fourth element to 4.\nThe resulting array is [1,2,3,4], which is continuous.",
      "images": []
    }
  ],
  "constraints": [
    "1 <= nums.length <= 105",
    "1 <= nums[i] <= 109"
  ],
  "follow_ups": [],
  "hints": [
    "Sort the array.",
    "For every index do a binary search to get the possible right end of the window and calculate the possible answer."
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    int minOperations(vector<int>& nums) {\n        \n    }\n};",
    "java": "class Solution {\n    public int minOperations(int[] nums) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def minOperations(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        ",
    "c": "int minOperations(int* nums, int numsSize) {\n    \n}",
    "csharp": "public class Solution {\n    public int MinOperations(int[] nums) {\n        \n    }\n}",
    "javascript": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar minOperations = function(nums) {\n    \n};",
    "typescript": "function minOperations(nums: number[]): number {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @return Integer\n     */\n    function minOperations($nums) {\n        \n    }\n}",
    "swift": "class Solution {\n    func minOperations(_ nums: [Int]) -> Int {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun minOperations(nums: IntArray): Int {\n        \n    }\n}",
    "dart": "class Solution {\n  int minOperations(List<int> nums) {\n    \n  }\n}",
    "golang": "func minOperations(nums []int) int {\n    \n}",
    "ruby": "# @param {Integer[]} nums\n# @return {Integer}\ndef min_operations(nums)\n    \nend",
    "scala": "object Solution {\n    def minOperations(nums: Array[Int]): Int = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn min_operations(nums: Vec<i32>) -> i32 {\n        \n    }\n}",
    "racket": "(define/contract (min-operations nums)\n  (-> (listof exact-integer?) exact-integer?)\n  )",
    "erlang": "-spec min_operations(Nums :: [integer()]) -> integer().\nmin_operations(Nums) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec min_operations(nums :: [integer]) :: integer\n  def min_operations(nums) do\n    \n  end\nend"
  },
  "solution": "[TOC]\n\n## Solution\n\n---\n\n### Approach 1: Binary Search\n\n**Intuition**\n\nThe problem description gives some rules for what a continuous array is, but we can simplify it to help us better understand the problem. A continuous array covers all the elements in a range of size `n`. Essentially, if we sort a continuous array, it will continuously count up by `1`.\n\nWe can define a continuous array by giving its bounds - `left` and `right`. For example, in the following continuous array:\n\n`[6, 3, 5, 4]`\n\nThe bounds are `left = 3` and `right = 6`. As you can see, the array fully covers all elements in the range `[3, 6]`. If we were to sort it, we would get `[3, 4, 5, 6]`, which starts at `left` and counts up by `1` until we reach `right`.\n\nTo solve this problem, we will iterate over the array and treat each element as `left`. We can then calculate `right = left + n - 1`. We now want to convert the array into a continuous array that covers all elements in the range `[left, right]`. How many operations do we need to accomplish this?\n\nWe need to find how many elements in the array are already in the range `[left, right]`. We can leave these elements unchanged and fill in the rest of the range using operations. Note that if there are duplicate elements in the input, this strategy will not work properly. For example, let's say we had the following input:\n\n`6, 3, 3, 5, 4`\n\nIf we had `left = 3`, we would have `right = 7`. Every element in the input is in the range `[3, 7]`, so it appears that we don't need any operations. However, the number `7` is missing because we have `3` twice. Thus, we should first convert `nums` into a set to get rid of duplicate numbers.\n\nNow that we have gotten rid of the duplicates, how can we quickly find how many elements in the array are in a given range `[left, right]`? If the array is sorted, then we can binary search to efficiently find how many elements are less than or equal to `right`. We already know how many elements are less than `left` because we treat `left = nums[i]` during iteration.\n\nLet's summarize the algorithm with an example.\n\n![example](../Figures/2009/1.png)First, we remove duplicates from the array, then sort it. Note the original length before removing duplicates as `n = 8`.\n\n![example](../Figures/2009/2.png)Now, we iterate over the array. For each index `i`, we treat `left = nums[i]`.\n\n![example](../Figures/2009/3.png)If we were to create a continuous array with `left = 2` as the minimum, we would need a maximum of `right = left + n - 1 = 9`.\n\n![example](../Figures/2009/4.png)How many operations do we need? We start by finding how many elements in the array are already in the desired range `[left, right]`. Binary search to find the insertion index of `right`. Note that the binary search here is finding the index **after** the greatest element less than or equal to `right`.\n\n![example](../Figures/2009/5.png)Let's call this index `j`. We have `j` as the index of the first element that falls outside our range due to it being too large. We also have `i` as the index of the first element in our range. Thus, we can calculate the number of elements already in our range as `j - i`.\n\n![example](../Figures/2009/6.png)As you can see, we have `4` elements already in the range `[left, right]`. Thus, these elements do not need to be changed. As we must construct an array of length `8`, we require `8 - 4 = 4` operations (one for each other element) to create a continuous array if we treat `2` as the minimum.\n\n![example](../Figures/2009/7.png)We can repeat this process for every index in the sorted, duplicate-free array. For example, if we treat `nums[3] = 7` as the minimum, then our range is `[7, 14]`. We can binary search to find `j` and then calculate `j - i = 2` as the number of elements already in our range. Thus, we need to perform `8 - 2 = 6` operations if we treat `7` as the minimum.\n\n![example](../Figures/2009/8.png)As we iterate over all indices and perform the above process, we keep track of the minimum operations needed.\n\n**Algorithm**\n\n1. Set `n = nums.length` and the answer `ans = n`.\n2. Remove duplicates from `nums` and then sort it. We will call this new array `newNums`.\n3. Iterate `i` over the indices of `newNums`:\n    - Set `left = newNums[i]`.\n    - Calculate `right = left + n - 1`.\n    - Calculate `j`, the insertion index of `right` in `newNums` using binary search.\n    - Calculate `count = j - i`, the number of elements already in our range.\n    - Update `ans` with `n - count` if it is smaller.\n4. Return `ans`.\n\n**Implementation****Complexity Analysis**\n\nGiven $$n$$ as the length of `nums`,\n\n* Time complexity: $$O(n \\cdot \\log{}n)$$\n\n    To remove duplicates and sort `nums`, we require $$O(n \\cdot \\log{}n)$$ time.\n\n    Then, we iterate over $$n$$ indices and perform a $$O(\\log{}n)$$ binary search at each index.\n\n* Space complexity: $$O(n)$$\n\n    We create a new array `newNums` of size $$O(n)$$. Note that even if you were to modify the input directly, we still use $$O(n)$$ space creating a hash set to remove duplicates. Also, it is considered a bad practice to modify the input, and many people will argue that modifying the input makes it part of the space complexity anyway.---\n\n### Approach 2: Sliding Window\n\n**Intuition**\n\nIn the previous approach, we locked in an element `newNums[i]` as `left`, calculated `right`, then found the insertion index of `right` as `j`. We used an $$O(\\log{}n)$$ binary search to find `j`, but we can do better using a sliding window.\n\nBecause `newNums` is sorted:\n- As `i` increases, so does `left = newNums[i]`. \n- An increase in the lower bound `left` means an increase in the upper bound `right` as well.\n- As `right` increases, `j` either remains the same or increases.\n\nThus, as `i` increases, `j` will stay the same or increase.\n\nWe initialize `j = 0` and follow the same process as in the last approach. Iterate `i` over the indices of `newNums` and treat each `left = newNums[i]` as the minimum element. This gives us `right = newNums[i] + n - 1` as our maximum element.\n\nHow do we update `j`? Similar to the last approach, we have `j` as the index of the first element out of our range. Thus, we increment `j` until it points to an element out of our range. The condition for this is:\n\n`while (newNums[j] < newNums[i] + n)`\n\nOnce this condition is broken, `newNums[j]` is out of our range `[left, right]` and correctly positioned. We can calculate the number of elements already in our range as `j - i` just like in the previous approach.\n\nBecause `j` starts at `0` and cannot exceed the length of `newNums`, it will only be incremented at most $$n$$ times across the entire algorithm. This means it costs $$O(1)$$ amortized to calculate `j`, an improvement from the $$O(\\log{}n)$$ binary search.\n\n**Algorithm**\n\n1. Set `n = nums.length` and the answer `ans = n`.\n2. Remove duplicates from `nums` and then sort it. We will call this new array `newNums`.\n3. Initialize `j = 0` and iterate `i` over the indices of `newNums`:\n    - While `newNums[j]` is within our range (less than `newNums[i] + n`), increment `j`.\n    - Calculate `count = j - i`, the number of elements already in our range.\n    - Update `ans` with `n - count` if it is smaller.\n4. Return `ans`.\n\n**Implementation****Complexity Analysis**\n\nGiven $$n$$ as the length of `nums`,\n\n* Time complexity: $$O(n \\cdot \\log{}n)$$\n\n    To remove duplicates and sort `nums`, we require $$O(n \\cdot \\log{}n)$$ time.\n\n    Then, we iterate over $$n$$ indices and perform $$O(1)$$ amortized work at each iteration. The while loop inside the for loop can only iterate at most $$n$$ times total across all iterations of the for loop. Each element in `newNums` can only be iterated over once by this while loop.\n\n    Despite this approach having the same time complexity as the previous approach (due to the sort), it is a slight practical improvement as the sliding window portion is $$O(n)$$.\n\n* Space complexity: $$O(n)$$\n\n    We create a new array `newNums` of size $$O(n)$$. Note that even if you were to modify the input directly, we still use $$O(n)$$ space creating a hash set to remove duplicates. Also, it is considered a bad practice to modify the input, and many people will argue that modifying the input makes it part of the space complexity anyway.---"
}