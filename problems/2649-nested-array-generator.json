{
  "title": "Nested Array Generator",
  "problem_id": "2783",
  "frontend_id": "2649",
  "difficulty": "Medium",
  "problem_slug": "nested-array-generator",
  "topics": [],
  "description": "Given a multi-dimensional array of integers, return a generator object which yields integers in the same order as inorder traversal.\nA multi-dimensional array is a recursive data structure that contains both integers and other multi-dimensional arrays.\ninorder traversal iterates over each array from left to right, yielding any integers it encounters or applying inorder traversal to any arrays it encounters.\nExample 1:\nExample 2:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: arr = [[[6]],[1,3],[]]\nOutput: [6,1,3]\nExplanation:\nconst generator = inorderTraversal(arr);\ngenerator.next().value; // 6\ngenerator.next().value; // 1\ngenerator.next().value; // 3\ngenerator.next().done; // true",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input: arr = []\nOutput: []\nExplanation: There are no integers so the generator doesn't yield anything.",
      "images": []
    }
  ],
  "constraints": [
    "0 <= arr.flat().length <= 105",
    "0 <= arr.flat()[i] <= 105",
    "maxNestingDepth <= 105"
  ],
  "follow_ups": [],
  "hints": [
    "Generator functions can pass control to another generator function with \"yield*\" syntax.",
    "Generator functions can recursively yield control to themselves.",
    "You don't need to worry about recursion depth for this problem."
  ],
  "code_snippets": {
    "javascript": "/**\n * @param {Array} arr\n * @return {Generator}\n */\nvar inorderTraversal = function*(arr) {\n    \n};\n\n/**\n * const gen = inorderTraversal([1, [2, 3]]);\n * gen.next().value; // 1\n * gen.next().value; // 2\n * gen.next().value; // 3\n */",
    "typescript": "type MultidimensionalArray = (MultidimensionalArray | number)[]\n\nfunction* inorderTraversal(arr: MultidimensionalArray): Generator<number, void, unknown> {\n    \n};\n\n/**\n * const gen = inorderTraversal([1, [2, 3]]);\n * gen.next().value; // 1\n * gen.next().value; // 2\n * gen.next().value; // 3\n */"
  }
}