{
  "title": "Find All Good Indices",
  "problem_id": "2504",
  "frontend_id": "2420",
  "difficulty": "Medium",
  "problem_slug": "find-all-good-indices",
  "topics": [
    "Array",
    "Dynamic Programming",
    "Prefix Sum"
  ],
  "description": "You are given a 0-indexed integer array nums of size n and a positive integer k.\nWe call an index i in the range k <= i < n - k good if the following conditions are satisfied:\nReturn an array of all good indices sorted in increasing order.\nExample 1:\nExample 2:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: nums = [2,1,1,1,3,4,1], k = 2\nOutput: [2,3]\nExplanation: There are two good indices in the array:\n- Index 2. The subarray [2,1] is in non-increasing order, and the subarray [1,3] is in non-decreasing order.\n- Index 3. The subarray [1,1] is in non-increasing order, and the subarray [3,4] is in non-decreasing order.\nNote that the index 4 is not good because [4,1] is not non-decreasing.",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input: nums = [2,1,1,2], k = 2\nOutput: []\nExplanation: There are no good indices in this array.",
      "images": []
    }
  ],
  "constraints": [
    "n == nums.length",
    "3 <= n <= 105",
    "1 <= nums[i] <= 106",
    "1 <= k <= n / 2"
  ],
  "follow_ups": [],
  "hints": [
    "Iterate over all indices i. How do you quickly check the two conditions?",
    "Precompute for each index whether the conditions are satisfied on the left and the right of the index. You can do that with two iterations, from left to right and right to left."
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    vector<int> goodIndices(vector<int>& nums, int k) {\n        \n    }\n};",
    "java": "class Solution {\n    public List<Integer> goodIndices(int[] nums, int k) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def goodIndices(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def goodIndices(self, nums: List[int], k: int) -> List[int]:\n        ",
    "c": "/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nint* goodIndices(int* nums, int numsSize, int k, int* returnSize) {\n    \n}",
    "csharp": "public class Solution {\n    public IList<int> GoodIndices(int[] nums, int k) {\n        \n    }\n}",
    "javascript": "/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number[]}\n */\nvar goodIndices = function(nums, k) {\n    \n};",
    "typescript": "function goodIndices(nums: number[], k: number): number[] {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @param Integer $k\n     * @return Integer[]\n     */\n    function goodIndices($nums, $k) {\n        \n    }\n}",
    "swift": "class Solution {\n    func goodIndices(_ nums: [Int], _ k: Int) -> [Int] {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun goodIndices(nums: IntArray, k: Int): List<Int> {\n        \n    }\n}",
    "dart": "class Solution {\n  List<int> goodIndices(List<int> nums, int k) {\n    \n  }\n}",
    "golang": "func goodIndices(nums []int, k int) []int {\n    \n}",
    "ruby": "# @param {Integer[]} nums\n# @param {Integer} k\n# @return {Integer[]}\ndef good_indices(nums, k)\n    \nend",
    "scala": "object Solution {\n    def goodIndices(nums: Array[Int], k: Int): List[Int] = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn good_indices(nums: Vec<i32>, k: i32) -> Vec<i32> {\n        \n    }\n}",
    "racket": "(define/contract (good-indices nums k)\n  (-> (listof exact-integer?) exact-integer? (listof exact-integer?))\n  )",
    "erlang": "-spec good_indices(Nums :: [integer()], K :: integer()) -> [integer()].\ngood_indices(Nums, K) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec good_indices(nums :: [integer], k :: integer) :: [integer]\n  def good_indices(nums, k) do\n    \n  end\nend"
  }
}