{
  "title": "Maximum Nesting Depth of the Parentheses",
  "problem_id": "1737",
  "frontend_id": "1614",
  "difficulty": "Easy",
  "problem_slug": "maximum-nesting-depth-of-the-parentheses",
  "topics": [
    "String",
    "Stack"
  ],
  "description": "Given a valid parentheses string s, return the nesting depth of s. The nesting depth is the maximum number of nested parentheses.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: s = \"(1+(2*3)+((8)/4))+1\"\nOutput: 3\nExplanation:\nDigit 8 is inside of 3 nested parentheses in the string.",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input: s = \"(1)+((2))+(((3)))\"\nOutput: 3\nExplanation:\nDigit 3 is inside of 3 nested parentheses in the string.",
      "images": []
    },
    {
      "example_num": 3,
      "example_text": "Input: s = \"()(())((()()))\"\nOutput: 3",
      "images": []
    }
  ],
  "constraints": [
    "1 <= s.length <= 100",
    "s consists of digits 0-9 and characters '+', '-', '*', '/', '(', and ')'.",
    "It is guaranteed that parentheses expression s is a VPS."
  ],
  "follow_ups": [],
  "hints": [
    "The depth of any character in the VPS is the ( number of left brackets before it ) - ( number of right brackets before it )"
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    int maxDepth(string s) {\n        \n    }\n};",
    "java": "class Solution {\n    public int maxDepth(String s) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def maxDepth(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def maxDepth(self, s: str) -> int:\n        ",
    "c": "int maxDepth(char* s) {\n    \n}",
    "csharp": "public class Solution {\n    public int MaxDepth(string s) {\n        \n    }\n}",
    "javascript": "/**\n * @param {string} s\n * @return {number}\n */\nvar maxDepth = function(s) {\n    \n};",
    "typescript": "function maxDepth(s: string): number {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param String $s\n     * @return Integer\n     */\n    function maxDepth($s) {\n        \n    }\n}",
    "swift": "class Solution {\n    func maxDepth(_ s: String) -> Int {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun maxDepth(s: String): Int {\n        \n    }\n}",
    "dart": "class Solution {\n  int maxDepth(String s) {\n    \n  }\n}",
    "golang": "func maxDepth(s string) int {\n    \n}",
    "ruby": "# @param {String} s\n# @return {Integer}\ndef max_depth(s)\n    \nend",
    "scala": "object Solution {\n    def maxDepth(s: String): Int = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn max_depth(s: String) -> i32 {\n        \n    }\n}",
    "racket": "(define/contract (max-depth s)\n  (-> string? exact-integer?)\n  )",
    "erlang": "-spec max_depth(S :: unicode:unicode_binary()) -> integer().\nmax_depth(S) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec max_depth(s :: String.t) :: integer\n  def max_depth(s) do\n    \n  end\nend"
  },
  "solution": "## Solution\n\n---\n\n### Approach 1: Stack\n\n#### Intuition\n\nThe most important point in the problem description is that the given string is a valid parentheses string (VPS). This means there will always be a matching closing bracket for every opening bracket. Hence, we don't need to check the validity of the given expression. Since the nesting depth depends only on the bracket counts, we can ignore the rest of the characters, such as integers and operators.\n\nThe maximum nesting depth is equal to the maximum number of open brackets at a time. The stack data structure is the first choice in solving brackets matching problems. In this approach, we will use a stack to store the opening brackets. Whenever we reach a closing bracket, we will pop one bracket from the stack. Since the string is always valid, we don't have to check if the stack is empty. After each iteration, we will check the size of the stack and update the variable `ans` if the size is more than the value of `ans`.\n\n#### Algorithm\n\n1. Initialize a variable `ans` to `0`. This will store the maximum nesting depth so far.\n2. Initialize an empty stack `st`.\n3. Iterate over the characters in the string `s`, for each character `c`:\n\n    - If `c` is equal to `(`, add it to the stack `st`.\n    - If `c` is equal to `)`, pop one element from the stack `st`.\n    - Update `ans` as the max of `ans` and `st.size()`.\n4. Return `ans`.\n\n#### Implementation#### Complexity Analysis\n\nHere, $N$ is the number of characters in the string `s`.\n\n* Time complexity: $O(N)$\n\n  We are iterating over each character in the string `s`, and hence the time complexity will be equal to $O(N)$.\n\n* Space complexity: $O(N)$\n\n  The size of the stack can grow up to $\\frac{N}{2}$ for strings like `(((())))`, and hence the space complexity of this approach will be $O(N)$.\n\n---\n\n### Approach 2: Counter variable\n\n#### Intuition\n\nThe above approach is easily extendable to cases where the input has brackets of multiple types like `[]`, `()`, and `{}`. It is also useful if the input is invalid because we can match the current closing bracket with the previous one, even if they are different types.\n\nHowever, the problem here is a very specific use case where the string will only have brackets of type `()` and will always be valid. Hence, using a stack is not necessary. Instead, we can use a variable to keep the count of open brackets and compare it with the variable `ans` to track the maximum nesting depth. For every open bracket `(`, we will increment the variable `openBrackets`, and for every closing bracket, we will decrement it (it will never be negative as the string is valid).\n\n![fig](../Figures/1614/1614A.png)\n\n#### Algorithm\n\n1. Initialize a variable `ans` to `0`. This will store the maximum nesting depth so far.\n2. Initialize a variable `openBrackets` to `0`. This will store the current open brackets count.\n3. Iterate over the characters in the string `s`, for each character `c`:\n\n    - If `c` is equal to `(`, increment the counter `openBrackets`.\n    - If `c` is equal to `)`, decrement the counter `openBrackets`.\n    - Update `ans` as the max of `ans` and `openBrackets`.\n4. Return `ans`.\n\n#### Implementation#### Complexity Analysis\n\nHere, $N$ is the number of characters in the string `s`.\n\n* Time complexity: $O(N)$\n\n  We are iterating over each character in the string `s`, and hence the time complexity will be equal to $O(N)$.\n\n* Space complexity: $O(1)$\n\n  The only variables we require are `openBrackets` and `ans`. Hence, the space complexity is constant.\n\n---"
}