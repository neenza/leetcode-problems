{
  "title": "Minimum Number of Operations to Make Array XOR Equal to K",
  "problem_id": "3249",
  "frontend_id": "2997",
  "difficulty": "Medium",
  "problem_slug": "minimum-number-of-operations-to-make-array-xor-equal-to-k",
  "topics": [
    "Array",
    "Bit Manipulation"
  ],
  "description": "You are given a 0-indexed integer array nums and a positive integer k.\nYou can apply the following operation on the array any number of times:\nReturn the minimum number of operations required to make the bitwise XOR of all elements of the final array equal to k.\nNote that you can flip leading zero bits in the binary representation of elements. For example, for the number (101)2 you can flip the fourth bit and obtain (1101)2.\nExample 1:\nExample 2:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: nums = [2,1,3,4], k = 1\nOutput: 2\nExplanation: We can do the following operations:\n- Choose element 2 which is 3 == (011)2, we flip the first bit and we obtain (010)2 == 2. nums becomes [2,1,2,4].\n- Choose element 0 which is 2 == (010)2, we flip the third bit and we obtain (110)2 = 6. nums becomes [6,1,2,4].\nThe XOR of elements of the final array is (6 XOR 1 XOR 2 XOR 4) == 1 == k.\nIt can be shown that we cannot make the XOR equal to k in less than 2 operations.",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input: nums = [2,0,2,0], k = 0\nOutput: 0\nExplanation: The XOR of elements of the array is (2 XOR 0 XOR 2 XOR 0) == 0 == k. So no operation is needed.",
      "images": []
    }
  ],
  "constraints": [
    "1 <= nums.length <= 105",
    "0 <= nums[i] <= 106",
    "0 <= k <= 106"
  ],
  "follow_ups": [],
  "hints": [
    "Calculate the bitwise <code>XOR</code> of all elements of the original array and compare it to <code>k</code> in their binary representation.",
    "For each different bit between the bitwise <code>XOR</code> of elements of the original array and <code>k</code> we have to flip <strong>exactly</strong> one bit of an element in <code>nums</code> to make that bit equal."
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    int minOperations(vector<int>& nums, int k) {\n        \n    }\n};",
    "java": "class Solution {\n    public int minOperations(int[] nums, int k) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def minOperations(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def minOperations(self, nums: List[int], k: int) -> int:\n        ",
    "c": "int minOperations(int* nums, int numsSize, int k) {\n    \n}",
    "csharp": "public class Solution {\n    public int MinOperations(int[] nums, int k) {\n        \n    }\n}",
    "javascript": "/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number}\n */\nvar minOperations = function(nums, k) {\n    \n};",
    "typescript": "function minOperations(nums: number[], k: number): number {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @param Integer $k\n     * @return Integer\n     */\n    function minOperations($nums, $k) {\n        \n    }\n}",
    "swift": "class Solution {\n    func minOperations(_ nums: [Int], _ k: Int) -> Int {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun minOperations(nums: IntArray, k: Int): Int {\n        \n    }\n}",
    "dart": "class Solution {\n  int minOperations(List<int> nums, int k) {\n    \n  }\n}",
    "golang": "func minOperations(nums []int, k int) int {\n    \n}",
    "ruby": "# @param {Integer[]} nums\n# @param {Integer} k\n# @return {Integer}\ndef min_operations(nums, k)\n    \nend",
    "scala": "object Solution {\n    def minOperations(nums: Array[Int], k: Int): Int = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn min_operations(nums: Vec<i32>, k: i32) -> i32 {\n        \n    }\n}",
    "racket": "(define/contract (min-operations nums k)\n  (-> (listof exact-integer?) exact-integer? exact-integer?)\n  )",
    "erlang": "-spec min_operations(Nums :: [integer()], K :: integer()) -> integer().\nmin_operations(Nums, K) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec min_operations(nums :: [integer], k :: integer) :: integer\n  def min_operations(nums, k) do\n    \n  end\nend"
  },
  "solution": "## Solution\n\n---\n\n### Approach: Bit Manipulation\n\n#### Intuition\n\nWe are given an array `nums` of $N$ integers and an integer `K`. We can apply any number of operations on the array, where each operation involves choosing an integer from the array and flipping one bit in its binary representation. We need to return the minimum number of operations required to make the bitwise `XOR` of the array equal to `K`. Note that we don't actually have to flip the bits, as we only need to return the number of operations.\n\nLet's first examine some fundamental facts about the `XOR` operation. The result of all possible combinations of two bits is shown below:\n\n![fig](../Figures/2997/2997A.png)\n\nThe `XOR` operation returns `1` when the bits are different and `0` when they are the same.\n\nThe `XOR` result of all combinations of three bits is shown below:\n\n![fig](../Figures/2997/2997B.png)\n\nTo calculate the `XOR` of three bits, we can `XOR` the first two bits, then `XOR` the result of that operation with the third bit. However, if we observe closely, we notice the result of `XOR` is `1` when the number of `1` bits is odd and `0` otherwise.\n\nThis implies that if the `XOR` of $N$ bits is `0`, then an even number of the $N$ bits are set to `1`. We can flip one bit to make the number of `1` bits odd, and then the result of the `XOR` will become `1`. Similarly, if the `XOR` of $N$ bits is `1`, then an odd number of the $N$ bits are set to `1`. We can again flip one bit to make the number of `1` bits even, which will change the result of the `XOR` to `0`. Hence, we always need to flip a single bit to change the `XOR` result of $N$ bits.\n\nWe will use the above observation to solve this problem. Let's say the `XOR` of all the $N$ integers in the array `nums` is `finalXor`. We want this `finalXor` to be `K`. We will compare the binary representation of `finalXor` and `K`. The number of bit mismatches is the minimum number of operations required because each bit difference between `finalXor` and `K` will require one operation to flip that bit in any of the $N$ integers in the array.\n\nOne way to implement this is to find the `finalXor` and then compare the binary representation of `K` and `finalXor` to find the mismatched bits. This implementation is shown below:However, we can simplify the implementation using the `XOR` operation. We need to find the number of bits that don't match between `finalXor` and `K`. If we find the `XOR` of `finalXor` and `K`, then the binary representation of the result would contain `1` for each bit position where the bits in `finalXor` and `K` don't match. We can take the `XOR` of `finalXor` and `K,` and each bit position that is set to `1` in the result is a position where the bits in the operands didn't match. Then, we can count the number of set bits (value `1`) in the result, which is the minimum number of operations. We will use the standard library function to count the number of set bits.\n\n#### Algorithm\n\n1. Initialize the variable `finalXor` to `0`.\n2. Iterate over the elements in the array `nums` and find the `XOR` of each element with the variable `finalXor`.\n3. Return the number of set bits in the variable `finalXor`.\n\n#### Implementation#### Complexity Analysis\n\nHere, $N$ is the number of integers in the array `nums`.\n\n* Time complexity: $O(N)$\n\n  The `XOR` operation takes $O(1)$, and we iterate over the $N$ elements in the array `nums`. The STL function to count the number of set bits takes $O(\\log V)$ where $V$ is the value of `finalXor`.  Since the values in the array are less than or equal to $10^6 < 2^{20}$, the value of $O(\\log V)$ will be `~20`. Hence, the total time complexity is equal to $O(N)$.\n\n* Space complexity: $O(1)$\n\n  The only space required is the variable `finalXor` so the space complexity is constant.\n  \n---"
}