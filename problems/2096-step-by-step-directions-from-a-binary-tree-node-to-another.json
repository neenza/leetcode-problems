{
  "title": "Step-By-Step Directions From a Binary Tree Node to Another",
  "problem_id": "2217",
  "frontend_id": "2096",
  "difficulty": "Medium",
  "problem_slug": "step-by-step-directions-from-a-binary-tree-node-to-another",
  "topics": [
    "String",
    "Tree",
    "Depth-First Search",
    "Binary Tree"
  ],
  "description": "You are given the root of a binary tree with n nodes. Each node is uniquely assigned a value from 1 to n. You are also given an integer startValue representing the value of the start node s, and a different integer destValue representing the value of the destination node t.\nFind the shortest path starting from node s and ending at node t. Generate step-by-step directions of such path as a string consisting of only the uppercase letters 'L', 'R', and 'U'. Each letter indicates a specific direction:\nReturn the step-by-step directions of the shortest path from node s to node t.\nExample 1:\nExample 2:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: root = [5,1,2,3,null,6,4], startValue = 3, destValue = 6\nOutput: \"UURL\"\nExplanation: The shortest path is: 3 → 1 → 5 → 2 → 6.",
      "images": [
        "https://assets.leetcode.com/uploads/2021/11/15/eg1.png"
      ]
    },
    {
      "example_num": 2,
      "example_text": "Input: root = [2,1], startValue = 2, destValue = 1\nOutput: \"L\"\nExplanation: The shortest path is: 2 → 1.",
      "images": [
        "https://assets.leetcode.com/uploads/2021/11/15/eg2.png"
      ]
    }
  ],
  "constraints": [
    "The number of nodes in the tree is n.",
    "2 <= n <= 105",
    "1 <= Node.val <= n",
    "All the values in the tree are unique.",
    "1 <= startValue, destValue <= n",
    "startValue != destValue"
  ],
  "follow_ups": [],
  "hints": [
    "The shortest path between any two nodes in a tree must pass through their Lowest Common Ancestor (LCA). The path will travel upwards from node s to the LCA and then downwards from the LCA to node t.",
    "Find the path strings from root → s, and root → t. Can you use these two strings to prepare the final answer?",
    "Remove the longest common prefix of the two path strings to get the path LCA → s, and LCA → t. Each step in the path of LCA → s should be reversed as 'U'."
  ],
  "code_snippets": {
    "cpp": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    string getDirections(TreeNode* root, int startValue, int destValue) {\n        \n    }\n};",
    "java": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public String getDirections(TreeNode root, int startValue, int destValue) {\n        \n    }\n}",
    "python": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def getDirections(self, root, startValue, destValue):\n        \"\"\"\n        :type root: Optional[TreeNode]\n        :type startValue: int\n        :type destValue: int\n        :rtype: str\n        \"\"\"\n        ",
    "python3": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def getDirections(self, root: Optional[TreeNode], startValue: int, destValue: int) -> str:\n        ",
    "c": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     struct TreeNode *left;\n *     struct TreeNode *right;\n * };\n */\nchar* getDirections(struct TreeNode* root, int startValue, int destValue) {\n    \n}",
    "csharp": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public int val;\n *     public TreeNode left;\n *     public TreeNode right;\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\npublic class Solution {\n    public string GetDirections(TreeNode root, int startValue, int destValue) {\n        \n    }\n}",
    "javascript": "/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @param {number} startValue\n * @param {number} destValue\n * @return {string}\n */\nvar getDirections = function(root, startValue, destValue) {\n    \n};",
    "typescript": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nfunction getDirections(root: TreeNode | null, startValue: number, destValue: number): string {\n    \n};",
    "php": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     public $val = null;\n *     public $left = null;\n *     public $right = null;\n *     function __construct($val = 0, $left = null, $right = null) {\n *         $this->val = $val;\n *         $this->left = $left;\n *         $this->right = $right;\n *     }\n * }\n */\nclass Solution {\n\n    /**\n     * @param TreeNode $root\n     * @param Integer $startValue\n     * @param Integer $destValue\n     * @return String\n     */\n    function getDirections($root, $startValue, $destValue) {\n        \n    }\n}",
    "swift": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public var val: Int\n *     public var left: TreeNode?\n *     public var right: TreeNode?\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\n *         self.val = val\n *         self.left = left\n *         self.right = right\n *     }\n * }\n */\nclass Solution {\n    func getDirections(_ root: TreeNode?, _ startValue: Int, _ destValue: Int) -> String {\n        \n    }\n}",
    "kotlin": "/**\n * Example:\n * var ti = TreeNode(5)\n * var v = ti.`val`\n * Definition for a binary tree node.\n * class TreeNode(var `val`: Int) {\n *     var left: TreeNode? = null\n *     var right: TreeNode? = null\n * }\n */\nclass Solution {\n    fun getDirections(root: TreeNode?, startValue: Int, destValue: Int): String {\n        \n    }\n}",
    "dart": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *   int val;\n *   TreeNode? left;\n *   TreeNode? right;\n *   TreeNode([this.val = 0, this.left, this.right]);\n * }\n */\nclass Solution {\n  String getDirections(TreeNode? root, int startValue, int destValue) {\n    \n  }\n}",
    "golang": "/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\nfunc getDirections(root *TreeNode, startValue int, destValue int) string {\n    \n}",
    "ruby": "# Definition for a binary tree node.\n# class TreeNode\n#     attr_accessor :val, :left, :right\n#     def initialize(val = 0, left = nil, right = nil)\n#         @val = val\n#         @left = left\n#         @right = right\n#     end\n# end\n# @param {TreeNode} root\n# @param {Integer} start_value\n# @param {Integer} dest_value\n# @return {String}\ndef get_directions(root, start_value, dest_value)\n    \nend",
    "scala": "/**\n * Definition for a binary tree node.\n * class TreeNode(_value: Int = 0, _left: TreeNode = null, _right: TreeNode = null) {\n *   var value: Int = _value\n *   var left: TreeNode = _left\n *   var right: TreeNode = _right\n * }\n */\nobject Solution {\n    def getDirections(root: TreeNode, startValue: Int, destValue: Int): String = {\n        \n    }\n}",
    "rust": "// Definition for a binary tree node.\n// #[derive(Debug, PartialEq, Eq)]\n// pub struct TreeNode {\n//   pub val: i32,\n//   pub left: Option<Rc<RefCell<TreeNode>>>,\n//   pub right: Option<Rc<RefCell<TreeNode>>>,\n// }\n// \n// impl TreeNode {\n//   #[inline]\n//   pub fn new(val: i32) -> Self {\n//     TreeNode {\n//       val,\n//       left: None,\n//       right: None\n//     }\n//   }\n// }\nuse std::rc::Rc;\nuse std::cell::RefCell;\nimpl Solution {\n    pub fn get_directions(root: Option<Rc<RefCell<TreeNode>>>, start_value: i32, dest_value: i32) -> String {\n        \n    }\n}",
    "racket": "; Definition for a binary tree node.\n#|\n\n; val : integer?\n; left : (or/c tree-node? #f)\n; right : (or/c tree-node? #f)\n(struct tree-node\n  (val left right) #:mutable #:transparent)\n\n; constructor\n(define (make-tree-node [val 0])\n  (tree-node val #f #f))\n\n|#\n\n(define/contract (get-directions root startValue destValue)\n  (-> (or/c tree-node? #f) exact-integer? exact-integer? string?)\n  )",
    "erlang": "%% Definition for a binary tree node.\n%%\n%% -record(tree_node, {val = 0 :: integer(),\n%%                     left = null  :: 'null' | #tree_node{},\n%%                     right = null :: 'null' | #tree_node{}}).\n\n-spec get_directions(Root :: #tree_node{} | null, StartValue :: integer(), DestValue :: integer()) -> unicode:unicode_binary().\nget_directions(Root, StartValue, DestValue) ->\n  .",
    "elixir": "# Definition for a binary tree node.\n#\n# defmodule TreeNode do\n#   @type t :: %__MODULE__{\n#           val: integer,\n#           left: TreeNode.t() | nil,\n#           right: TreeNode.t() | nil\n#         }\n#   defstruct val: 0, left: nil, right: nil\n# end\n\ndefmodule Solution do\n  @spec get_directions(root :: TreeNode.t | nil, start_value :: integer, dest_value :: integer) :: String.t\n  def get_directions(root, start_value, dest_value) do\n    \n  end\nend"
  },
  "solution": "[TOC]\n\n## Solution\n\n---\n\n### Approach 1: BFS + DFS\n\n#### Intuition\n\nThe problem requires finding the shortest path between two given nodes using step-by-step directions. Shortest path problems are common in graph theory, and several efficient algorithms can be learned to solve them. Let's explore solving the problem with one of these algorithms. \n\nTo apply one of these algorithms, we first must convert the tree to a bidirectional graph. In a binary tree, each node can connect to its children but not directly to its parent. To facilitate all the movement from a node to its parent, we commonly use a `parent` table. This table stores the parent of each node, built by traversing the tree and marking each node's children with their respective parent.\n\nWith the ability to traverse the tree in any direction, we first locate the starting node. Once we've identified it, we can then proceed to calculate the shortest path.\n\nTo efficiently determine the shortest path, we use a breadth-first search (BFS) to explore nodes at the current depth before moving deeper. For those unfamiliar with BFS, the LeetCode [Explore Card](https://leetcode.com/explore/learn/card/graph/620/breadth-first-search-in-graph/) provides a helpful introduction.\n\nDuring the BFS traversal, we use a map `pathTracker` to record the path taken to each node. In `pathTracker`, each key represents a node, while its corresponding value is a pair containing the parent node and the direction from that parent. Upon reaching the destination node, we backtrack using `pathTracker` to trace the path back to the start node. The path string is constructed by appending directions from `pathTracker` and moving to the parent node stored in the tuple.\n\nThis process continues until we reach the start node. Since directions are recorded in reverse order during backtracking, we reverse the path string to obtain the correct sequence of directions from the start node to the destination node. Finally, we return this reversed string as the result.\n\n#### Algorithm\n\nMain method `getDirections`:\n\n- Initialize a map `parentMap` to store parent nodes for each node in the tree.\n- Find the `startNode` using the `findStartNode` method, which recursively searches the tree for the node with `startValue`.\n- Populate `parentMap` using the `populateParentMap` method, which traverses the tree and maps each child node to its parent.\n- For the BFS, initialize \n  - A queue containing the `startNode`.\n  - A set `visitedNodes` to keep track of visited nodes to avoid cycles.\n  - A map `pathTracker` to record the path taken by the BFS.\n- While the queue is not empty:\n  - Dequeue a TreeNode from the queue.\n  - If the current node's value matches `destValue`, we have found our path. Call `backtrackPath` and return the path calculated by it.\n- If `parentMap` contains a parent for the current node and it hasn't been visited, enqueue the parent node and add an entry to `pathTracker` with the current node as the key and a pair containing the parent node and direction 'U' as the value.\n- If the left child exists and hasn't been visited, enqueue the left child and add an entry to `pathTracker` with the current node as the key and a pair containing the left child and direction 'L' as the value.\n- If the right child exists and hasn't been visited, enqueue the right child and add an entry to `pathTracker` with the current node as the key and a pair containing the right child and direction 'R' as the value.\n- If the destination node is never reached, an empty string is returned.\n\nHelper method `backtrackPath`:\n\n- Define `backtrackPath` with parameters: destination `node` (TreeNode) and `pathTracker` map.\n- Initialize an empty string `path`.\n- While `node` exists in `pathTracker`:\n  - Retrieve the parent node and direction from `pathTracker`.\n  - Append the direction to `path`.\n  - Set `node` to the parent node.\n- Reverse and return `path`.\n\nHelper method `populateParentMap`:\n\n- Define `populateParentMap` with parameters: current `node` (TreeNode) and `parentMap`.\n- If `node` is `null`, return.\n- If left or right children exist, add them to `parentMap` with `node` as their parent.\n- Recurse on left and right children.\n\nHelper method `findStartNode`:\n\n- Define `findStartNode` with parameters: current `node` (TreeNode) and `startValue`.\n- If `node` is `null`, return.\n- If `node`'s value matches `startValue`, return `node`.\n- Recursively search the left subtree. If a node is found, return it.\n- Otherwise, search the right subtree and return the result.\n\n#### Implementation#### Complexity Analysis\n\nLet $n$ be the number of nodes in the tree.\n\n- Time complexity: $O(n)$\n\n    The `findStartNode` method traverses the tree once to find the start node, which has a worst case time complexity of $O(n)$ (skewed tree). \n\n    The `populateParentMap` method visits each node once to populate the map. It has a time complexity of $O(n)$.\n\n    In the worst case, the BFS to find the path might visit all nodes of the tree. Inside the BFS loop, the operations on the set and map are $O(1)$ on average. Thus, the time complexity of the BFS remains $O(n)$.\n\n    The `backtrackPath` method can take at most $O(n)$ time to traverse over the entire length of the resultant path, which can be of length $n$ in the worst case.\n\n    The time complexity of the entire algorithm is sum of these individual complexities, which is $O(n)$.\n\n- Space complexity: $O(n)$\n\n    The `parentMap` stores the parent information for each node, taking $O(n)$ space.\n\n    The `backtrackPath` method stores the length of the final path, which can have a maximum length of $n$.\n\n    The recursive call stacks in the `findStartNode` and `populateParentMap` methods can have a worst case space complexity of $O(n)$ (e.g. a skewed tree).\n\n    The queue for the BFS can contain up to $n/2$ nodes in the worst case (for a complete binary tree). So, it has a space complexity of $O(n/2)$, which simplifies to $O(n)$. The `visitedNodes` set and `pathTracker` map used in the BFS uses another $O(n)$ space each.\n\n    Thus, the overall space complexity of the algorithm is $6 \\cdot O(n)$, which simplifies to $O(n)$.\n\n---\n\n### Approach 2: LCA + DFS\n\n#### Intuition\n\nA more optimal method exists to solve a tree problem that doesn't involve converting it to a bidirectional graph. Let's try to solve it as a tree this time.\n\nIf we trace paths from the root to the two nodes, we see that these paths share a common segment until a certain point, after which they diverge. This last intersection is the Lowest Common Ancestor (LCA). Since it is the last shared point, any path connecting the two nodes must pass through this LCA. We won't discuss the methods to find the LCA in a binary tree in this article, as it is a separate and popular problem. Here we will be focusing on the application of it. If you are unfamiliar with LCA, check out [Lowest Common Ancestor of a Binary Tree](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/description/).\n\nCheck out how the LCA is a part of the common paths for the start and destination nodes in this image:\n\n![LCA Image](../Figures/2096/image1.png)\n\nThe path between the start node and the destination node can be divided into two parts: the path from the start node to the LCA and the path from the LCA to the destination node. The path from the start node to the LCA consists only of the direction 'U' since all moves are from a child node to a parent node.\n\nTo find these paths, we use depth-first search starting from the LCA and moving towards the target nodes. Initially, we explore the left subtree appending 'L' to the path. Upon finding the target node, we return immediately. If not found, we backtrack by replacing 'L' with 'R' to explore the right subtree. If the target node isn't found in either subtree, we backtrack to the parent node. This recursive process continues until the target node is located.\n\nCheck out this slideshow to better understand how to find the path for a node:\n\n!?!../Documents/2096/slideshow.json:1244,1008!?!\n\nNow that we have the directions to both the start and destination nodes from the LCA, we can piece together the full path. We transform the path from the LCA to the start node by replacing all directions with \"U\" and prepend it to the path to the destination node. The resulting sequence gives the step-by-step directions from the start node to the end node in the binary tree\n\n#### Algorithm\n\nMain method `getDirections`:\n\n- Find the `lowestCommonAncestor` of `startValue` and `destValue` using the `findLowestCommonAncestor` method.\n- Initialize `pathToStart` and `pathToDest` to store paths from the LCA to the start and destination nodes, respectively.\n- Call `findPath` to determine these paths.\n- Initialize `directions` to store the final result.\n- Add \"U\" for each step in `pathToStart`.\n- Append `pathToDest` to `directions`.\n- Return `directions`, which contains the step-by-step directions from the start node to the destination node.\n\nHelper method `findLowestCommonAncestor`:\n\n- Define `findLowestCommonAncestor` with parameters: `node`, `value1`, and `value2`.\n- If `node` is null, return `null`.\n- If `node`'s value matches `value1` or `value2`, return `node`.\n- Recursively search for the LCA in the left and right subtrees, storing results in `leftLCA` and `rightLCA`.\n- If `leftLCA` is null, return `rightLCA`.\n- If `rightLCA` is null, return `leftLCA`.\n- If both `leftLCA` and `rightLCA` contain nodes, the current node is the lowest common ancestor. Return `node`.\n\nHelper method `findPath`:\n\n- Define `findPath` with parameters: `node`, `targetValue`, and `path`.\n- If `node` is null, return `false`.\n- If `node`'s value matches `targetValue`, return `true`.\n- Append \"L\" to `path` and search the left subtree. If the target node is found, return `true`.\n- If not found, remove the last character from `path`.\n- Append \"R\" to `path` and search the right subtree. If the target node is found, return `true`.\n- If not found, remove the last character from `path`.\n- Return `false` if the target node is not found in either subtree.\n\n#### Implementation#### Complexity Analysis\n\nLet $n$ be the total number of nodes in the tree.\n\n* Time complexity: $O(n)$\n\n    The `findLowestCommonAncestor` method is called once and traverses the tree to find the LCA, which takes $O(n)$ time in the worst case. \n    \n    The `findPath` method is called twice, once for the path from the LCA to `startValue` and once for the path to `destValue`. Each call can traverse up to the height of the tree, which is $n$ in the worst case (e.g., a skewed tree), making the total time complexity for both calls $O(n) + O(n) = O(n)$.\n\n    Adding \"U\" for all upward movements and constructing the final path also takes $O(n)$ time. Therefore, the total time complexity of the entire algorithm is $3 \\cdot O(n)$, which simplifies to $O(n)$.\n\n* Space complexity: $O(n)$\n\n    The recursive call stacks for `findLowestCommonAncestor` and `findPath` can each have a space complexity of $O(n)$ in the worst case. The variables `pathToStart`, `pathToDest`, and `directions` can store a path of length up to the height of the tree, which is $O(n)$ in the worst case.\n\n    Combining all elements, the algorithm has a space complexity of $O(n)$.\n\n---\n\n### Approach 3: LCA + DFS (Optimized)\n\n#### Intuition\n\nInstead of focusing on finding the LCA and identifying paths from the LCA to both nodes, we can directly find the full paths from the root to each node and then trim off their common part ourselves. This approach eliminates the need to explicitly find the LCA, resulting in significantly shorter and simpler code.\n\nWe'll use the `findPath` method from our previous approach to determine the paths from the root to both the start and end nodes. After obtaining these paths, we identify and remove their common initial segment. Then, we adjust the remaining portion of the start node's path by replacing each step with \"U\" to indicate upward movement. Finally, we concatenate this adjusted path with the unique part of the end node's path, giving us the step-by-step directions from the start node to the end node.\n\n#### Algorithm\n\nMain method `getDirections`:\n\n- Initialize `startPath` and `destPath` to store paths from the root to the start node and the destination node, respectively.\n- Determine `startPath` and `destPath` using `findPath`. \n- Initialize `directions` to store the resultant directions.\n- Compare `startPath` and `endPath` to find the length of common path. Store it in `commonPathLength`.\n- Iterate through the difference between the length of `startPath` and `commonPathLength`. For each step, add \"U\" to `directions`.\n- From `destPath`, add the directions from index `commonPathLength` to the end of the string to `directions`.\n- Return `directions`.\n\nHelper method `findPath`:\n\n- Define `findPath` with parameters: `node`, `targetValue`, and `path`.\n- If `node` is `null`, return `false`.\n- If `node.val == targetValue`, return `true`.\n- Add \"L\" to `path` and search the left subtree recursively. If the target node is found, return `true`.\n- If not found, remove the last character from `path`.\n- Add \"R\" to `path` and search the right subtree recursively. If the target node is found, return `true`.\n- If not found, remove the last character from `path`.\n- Return `false` if the target node was not found in either subtrees.\n\n#### Implementation#### Complexity Analysis\n\nLet $n$ be the number of nodes in the tree.\n\n* Time complexity: $O(n)$\n\n    The `findPath` method is called twice, once for the start node and once for the destination node. Each call may traverse the entire tree in the worst case (skewed tree), making the time complexity $2 \\cdot O(n)$, which simplifies to $O(n)$.\n\n    To construct the final result, we iterate over the entire lengths of `startPath` and `destPath`, each of which could have a complexity of $O(n)$ in the worst case. \n\n    Thus, the overall time complexity of the algorithm is $O(n) + O(n)$, simplifying to $O(n)$. \n\n* Space complexity: $O(n)$\n\n    The recursive call stack of the `findPath` method can have a space complexity of $O(n)$ in the worst case. The variables `startPath`, `destPath`, and `directions` can each have a length equal to the height of the tree, which is $n$ in the worst case (skewed tree). \n\n    Thus, the total space complexity of the algorithm is $4 \\cdot O(n)$, or $O(n)$.\n\n---"
}