{
  "title": "Maximum Value at a Given Index in a Bounded Array",
  "problem_id": "1929",
  "frontend_id": "1802",
  "difficulty": "Medium",
  "problem_slug": "maximum-value-at-a-given-index-in-a-bounded-array",
  "topics": [
    "Math",
    "Binary Search",
    "Greedy"
  ],
  "description": "You are given three positive integers:Â n, index, and maxSum. You want to construct an array nums (0-indexed) that satisfies the following conditions:\nReturn nums[index] of the constructed array.\nNote that abs(x) equals x if x >= 0, and -x otherwise.\nExample 1:\nExample 2:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: n = 4, index = 2,  maxSum = 6\nOutput: 2\nExplanation: nums = [1,2,2,1] is one array that satisfies all the conditions.\nThere are no arrays that satisfy all the conditions and have nums[2] == 3, so 2 is the maximum nums[2].",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input: n = 6, index = 1,  maxSum = 10\nOutput: 3",
      "images": []
    }
  ],
  "constraints": [
    "1 <= n <= maxSum <= 109",
    "0 <= index < n"
  ],
  "follow_ups": [],
  "hints": [
    "What if the problem was instead determining if you could generate a valid array with nums[index] == target?",
    "To generate the array, set nums[index] to target, nums[index-i] to target-i, and nums[index+i] to target-i. Then, this will give the minimum possible sum, so check if the sum is less than or equal to maxSum.",
    "n is too large to actually generate the array, so you can use the formula 1 + 2 + ... + n = n * (n+1) / 2 to quickly find the sum of nums[0...index] and nums[index...n-1].",
    "Binary search for the target. If it is possible, then move the lower bound up. Otherwise, move the upper bound down."
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    int maxValue(int n, int index, int maxSum) {\n        \n    }\n};",
    "java": "class Solution {\n    public int maxValue(int n, int index, int maxSum) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def maxValue(self, n, index, maxSum):\n        \"\"\"\n        :type n: int\n        :type index: int\n        :type maxSum: int\n        :rtype: int\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def maxValue(self, n: int, index: int, maxSum: int) -> int:\n        ",
    "c": "int maxValue(int n, int index, int maxSum) {\n    \n}",
    "csharp": "public class Solution {\n    public int MaxValue(int n, int index, int maxSum) {\n        \n    }\n}",
    "javascript": "/**\n * @param {number} n\n * @param {number} index\n * @param {number} maxSum\n * @return {number}\n */\nvar maxValue = function(n, index, maxSum) {\n    \n};",
    "typescript": "function maxValue(n: number, index: number, maxSum: number): number {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param Integer $n\n     * @param Integer $index\n     * @param Integer $maxSum\n     * @return Integer\n     */\n    function maxValue($n, $index, $maxSum) {\n        \n    }\n}",
    "swift": "class Solution {\n    func maxValue(_ n: Int, _ index: Int, _ maxSum: Int) -> Int {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun maxValue(n: Int, index: Int, maxSum: Int): Int {\n        \n    }\n}",
    "dart": "class Solution {\n  int maxValue(int n, int index, int maxSum) {\n    \n  }\n}",
    "golang": "func maxValue(n int, index int, maxSum int) int {\n    \n}",
    "ruby": "# @param {Integer} n\n# @param {Integer} index\n# @param {Integer} max_sum\n# @return {Integer}\ndef max_value(n, index, max_sum)\n    \nend",
    "scala": "object Solution {\n    def maxValue(n: Int, index: Int, maxSum: Int): Int = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn max_value(n: i32, index: i32, max_sum: i32) -> i32 {\n        \n    }\n}",
    "racket": "(define/contract (max-value n index maxSum)\n  (-> exact-integer? exact-integer? exact-integer? exact-integer?)\n  )",
    "erlang": "-spec max_value(N :: integer(), Index :: integer(), MaxSum :: integer()) -> integer().\nmax_value(N, Index, MaxSum) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec max_value(n :: integer, index :: integer, max_sum :: integer) :: integer\n  def max_value(n, index, max_sum) do\n    \n  end\nend"
  },
  "solution": "[TOC]\n\n## Solution\n\n--- \n\n### Overview\n\nAs usual, let's start with the example given in the problem statement. Referring to the figure below, there are several ways to make `nums[2]` the maximum, as shown in the first two examples. However, once we want a larger `nums[2]` as `3`, the sum of the array will certainly be greater than `maxSum`.\n\n![img](../Figures/1802/intro.png)\n\n\n\n---\n\n### Approach: Greedy + Binary Search\n\n\n#### Intuition   \n\nThe objective is to maximize `nums[index]` while ensuring the sum the array does not exceed `maxSum`, so we can try using a greedy algorithm. In order to maximize `nums[index]`, we need to ensure that all other values are **as small as possible**. \n\n\nHowever, we cannot take the other values to be arbitrarily small. Referring to the two rules given in the problem:\n> - The difference between adjacent numbers cannot be greater than `1`.\n> - `nums[i]` must be positive. \n\nTherefore, the last two examples in the figure below are not valid. In the example in the middle, the difference between adjacent numbers (`nums[3]` and `nums[4]`) is greater than `1`. In the example on the right, the first number is equal to `0`, which is not allowed. \n\nHence, we need to ensure that `nums[i]` satisfies these conditions as well.\n\n![img](../Figures/1802/1.png)\n\nTherefore, the straightforward approach is after setting a value for `nums[index]`, let the numbers to its left decrease one by one from right to left until they reach `1`. Similarly, the numbers to its right decrease one by one from left to right until they reach `1`. This way, we can ensure that the total sum of the array is minimized without violating the rules.\n\nNext, we need to calculate the sum of the array, which is a purely mathematical problem. Let's take the numbers to the left of `nums[index]` as an example. There will be an arithmetic sequence to its left, and (possibly) a consecutive sequence of `1`s if `nums[index]` is less than the number of elements to the left. We need to determine the length of the arithmetic sequence based on the relative sizes of `index` and `value`. \n\n \nOnce we have determined the length of the arithmetic sequence, we can calculate the sum of the sequence using the arithmetic sequence formula:\n\n\n$$\\text{sum} = (A[1] + A[n]) \\cdot n / 2$$\n\n \nwhere `A[1]` and `A[n]` are the first and last terms of the sequence respectively, and `n` is the length of the sequence. \n \nTake the following figure as an example:\n\n![img](../Figures/1802/2.png)\n\n- If `value <= index`, it means in addition to the arithmetic sequence from value to `1`, there will also be a continuous sequence of `1`s with length `index - value + 1`. The sum of all elements on `index`'s left (including `nums[index]`) is made up by two parts:\n    - The sum of arithmetic sequence `[1, 2, 3, ..., value - 1, value]`, which is `(value + 1) * value / 2`.\n    - The sum of sequence of length `index - value + 1` consisting of all `1`s, which is `index - value + 1`.\n\n- Otherwise, it means there is only one arithmetic sequence on the left side of index, with the first item being `value` and the last item being `value - index`, so the sum of all elements on `index`'s left (including `nums[index]`) is:\n    - The sum of arithmetic sequence `[value - index, ..., value - 1, value]`, which is `(value + value - index) * (index + 1) / 2`.Similarly, the right side of `nums[index]` is exactly the same. We need to determine the length of the arithmetic sequence and the length of the continuous subarray of `1` based on the relative sizes of `n - index` and `value`.\n\n\n![img](../Figures/1802/3.png)\n\n- If `value` is less than or equal to `n - index`, it means there is a subarray of length `n - index - value` consisting of all `1`s in addition to the arithmetic sequence from `value` to `1`. The sum of all elements on `index`'s right (including `nums[index]`) is made up by two parts:\n    - The sum of arithmetic sequence `[value, value - 1, ..., 2, 1]`, which is `(value + 1) * value / 2`.\n    - The sum of sequence of length `index - value + 1` consisting of all `1`s, which is `n - index - value`\n\n- Otherwise, there is only an arithmetic sequence on the right side of index with the first term being `value` and the last term being `value - n + 1 + index`, so the sum of all elements on `index`'s right (including `nums[index]`) is:\n    - The sum of arithmetic sequence `[value, value - 1, ..., value - n + 1 + index]`, which is `(value + value - n + 1 + index) * (n - index) / 2`.Don't forget that we have added the actual `value` at `index` twice, so we need to subtract the final sum by `value`.Now that we know how to calculate the array sum given a specific `nums[index] = value`, the question is how do we maximize `value`?\n\nWe can use binary search to find the maximum `value` that meets the criteria. First, we define a search range `[left, right]` that ensures the maximum `value` falls within this range. Next, we perform a binary search within this range. For each boundary value `mid` that divides the current search space in half, we try whether `nums[index] = mid` is a feasible value that ensures the sum of the array does not exceed `maxSum`. If it is valid, we continue searching for a larger `mid` in the right half of the interval. If it is not feasible, it means that `mid` is too large, and we need to search for a smaller value in the left half of the interval. In this way, we can halve the search interval at each step, and find the maximum `mid` that meets the criteria in logarithmic time.There are many other interesting problems that can be solved by performing a binary search to find the optimal value. You can practice using the binary search approach on the following problems! (click to show)- [410. Split Array Largest Sum](https://leetcode.com/problems/split-array-largest-sum/) \n- [774. Minimize Max Distance to Gas Station](https://leetcode.com/problems/minimize-max-distance-to-gas-station/) \n- [875. Koko Eating Bananas](https://leetcode.com/problems/koko-eating-bananas/) \n- [1011. Capacity To Ship Packages Within D Days](https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/) \n- [1231. Divide Chocolate](https://leetcode.com/problems/divide-chocolate/)#### Algorithm\n\n1) We first need to define a function `getSum(index, value)` to calculate the minimum sum of the array given `nums[index] = value`.\n2) Initialize the search space `[left, right]`, set `left = 1` as it is the minimum possible value, set `right = maxSum` for it is the maximum possible value.\n3) While `left < right`, get the middle index of the search space as `mid = (left + right + 1) / 2`, and check if `getSum(index, mid) <= maxSum`:\n    - If so, it means that `nums[index] = mid` is a valid value, we can go for the right half by setting `left = mid`.\n    - Otherwise, it means that `mid` is too large for `nums[index]`, we shall go for the left half of the searching space by setting `right = mid - 1`.\n4) Return `left` once the binary search ends.\n\n#### Implementation#### Complexity Analysis\n\n\n* Time complexity: $$O(\\log (\\text{maxSum}))$$\n\n\n    - We set the searching space as `[1, maxSum]`, thus it takes $$O(\\log (\\text{maxSum}))$$ steps to finish the binary search. \n\n    - At each step, we made some calculations that take $$O(1)$$ time.\n\n* Space complexity: $$O(1)$$\n\n    - Both the binary search and the `getSum` function take $$O(1)$$ space."
}