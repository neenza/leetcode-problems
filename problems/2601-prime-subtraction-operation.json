{
  "title": "Prime Subtraction Operation",
  "problem_id": "2716",
  "frontend_id": "2601",
  "difficulty": "Medium",
  "problem_slug": "prime-subtraction-operation",
  "topics": [
    "Array",
    "Math",
    "Binary Search",
    "Greedy",
    "Number Theory"
  ],
  "description": "You are given a 0-indexed integer array nums of length n.\nYou can perform the following operation as many times as you want:\nReturn true if you can make nums a strictly increasing array using the above operation and false otherwise.\nA strictly increasing array is an array whose each element is strictly greater than its preceding element.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: nums = [4,9,6,10]\nOutput: true\nExplanation: In the first operation: Pick i = 0 and p = 3, and then subtract 3 from nums[0], so that nums becomes [1,9,6,10].\nIn the second operation: i = 1, p = 7, subtract 7 from nums[1], so nums becomes equal to [1,2,6,10].\nAfter the second operation, nums is sorted in strictly increasing order, so the answer is true.",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input: nums = [6,8,11,12]\nOutput: true\nExplanation: Initially nums is sorted in strictly increasing order, so we don't need to make any operations.",
      "images": []
    },
    {
      "example_num": 3,
      "example_text": "Input: nums = [5,8,3]\nOutput: false\nExplanation: It can be proven that there is no way to perform operations to make nums sorted in strictly increasing order, so the answer is false.",
      "images": []
    }
  ],
  "constraints": [
    "1 <= nums.length <= 1000",
    "1 <= nums[i] <= 1000",
    "nums.length == n"
  ],
  "follow_ups": [],
  "hints": [
    "Think about if we have many primes to subtract from nums[i]. Which prime is more optimal?",
    "The most optimal prime to subtract from nums[i] is the one that makes nums[i] the smallest as possible and greater than nums[i-1]."
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    bool primeSubOperation(vector<int>& nums) {\n        \n    }\n};",
    "java": "class Solution {\n    public boolean primeSubOperation(int[] nums) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def primeSubOperation(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def primeSubOperation(self, nums: List[int]) -> bool:\n        ",
    "c": "bool primeSubOperation(int* nums, int numsSize) {\n    \n}",
    "csharp": "public class Solution {\n    public bool PrimeSubOperation(int[] nums) {\n        \n    }\n}",
    "javascript": "/**\n * @param {number[]} nums\n * @return {boolean}\n */\nvar primeSubOperation = function(nums) {\n    \n};",
    "typescript": "function primeSubOperation(nums: number[]): boolean {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @return Boolean\n     */\n    function primeSubOperation($nums) {\n        \n    }\n}",
    "swift": "class Solution {\n    func primeSubOperation(_ nums: [Int]) -> Bool {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun primeSubOperation(nums: IntArray): Boolean {\n        \n    }\n}",
    "dart": "class Solution {\n  bool primeSubOperation(List<int> nums) {\n    \n  }\n}",
    "golang": "func primeSubOperation(nums []int) bool {\n    \n}",
    "ruby": "# @param {Integer[]} nums\n# @return {Boolean}\ndef prime_sub_operation(nums)\n    \nend",
    "scala": "object Solution {\n    def primeSubOperation(nums: Array[Int]): Boolean = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn prime_sub_operation(nums: Vec<i32>) -> bool {\n        \n    }\n}",
    "racket": "(define/contract (prime-sub-operation nums)\n  (-> (listof exact-integer?) boolean?)\n  )",
    "erlang": "-spec prime_sub_operation(Nums :: [integer()]) -> boolean().\nprime_sub_operation(Nums) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec prime_sub_operation(nums :: [integer]) :: boolean\n  def prime_sub_operation(nums) do\n    \n  end\nend"
  },
  "solution": "[TOC]\n\n## Solution\n\n---\n\n### Overview\n\nWe are given an integer array `nums`. For each element in `nums`, we can subtract any prime number strictly less than the current element at most once, with the goal of making the array strictly increasing by performing operations on any number of elements.\n\nFor example, consider `nums = [5, 5, 4]`. For the first element, we have two options:\n\n1. **Make a minimal adjustment** by subtracting a small prime, like `2`, from `5`, resulting in `[3, 5, 4]`. While `3` is less than `5`, we still need to adjust the second `5` to make it smaller than `4`. Subtracting `2` from the second `5` gives `[3, 3, 4]`, which isn’t strictly increasing.\n\n2. **Make a maximal adjustment** by subtracting the largest possible prime under `5`, which is `3`. This results in `[2, 5, 4]`. Now, for the second element, we again subtract the largest prime that keeps it greater than the previous element, resulting in `[2, 3, 4]`—a strictly increasing sequence.\n\nFollowing this approach, we prioritize subtracting the largest possible prime from each element while ensuring each adjusted element is still greater than the one before it. This allows us to minimize each value as much as possible, providing the most flexibility for later adjustments.\n\nWe’ll explore three approaches based on this greedy strategy. The main difference between them is the method used to find the largest prime to subtract for each element. In the first approach, we use a brute-force method, while in the latter approach, we use the Sieve of Eratosthenes for efficiency. You can refer to these links to learn more about the [Greedy Algorithm](https://leetcode.com/explore/interview/card/leetcodes-interview-crash-course-data-structures-and-algorithms/709/greedy/) and [Sieve of Eratosthenes](https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes).\n\n---\n\n### Approach 1: Brute Force\n\n#### Intuition\n\nLet's think through a basic approach to solve the problem. We want to make sure that each number in the array stays just a bit larger than the one before it. To do this, we’ll be subtracting the largest possible prime number from each element, but we have to be careful: the prime we subtract should leave the current element just slightly above the previous one.\n\nIn other words, for each element `nums[i]`, we need to find the biggest prime `p` so that after subtracting `p`, the new value of `nums[i]` is still greater than `nums[i-1]`. Mathematically, that’s `nums[i] - p > nums[i-1]`. So, `p` has to be the largest prime that’s smaller than the difference `nums[i] - nums[i-1]`.\n\nTo make this work, we’ll loop through each element in `nums`. For each one, we’ll look at the difference between it and the previous number. If this difference is zero or negative, it’s impossible to make the sequence strictly increasing, so we can just return `false` right away. But if the difference is positive, we need to find the largest prime within this range.\n\nNow, remember a prime number only has two divisors: 1 and itself. To check if a number is prime, we don’t have to test all the way up to that number, we just need to check up to its square root. If we don’t find any divisors up to that point, then the number is prime.\n\nOnce we find this largest prime `p`, we subtract it from `nums[i]` and move on to the next element. If we manage to go through the whole array without any issues, we know the sequence is strictly increasing, so we return `true`.\n\n#### Algorithm\n\nMain Function - `primeSubOperation(nums)`\n\n1. Iterate over each element in `nums` by looping through indices `i` ranging from 0 to the size of `nums` minus 1.\n    - For the first element (`i` = 0), set bound to `nums[0]`. For subsequent elements, set `bound` to `nums[i] - nums[i - 1]`.\n    - If `bound` is less than or equal to 0, return false, as it is impossible to create a strictly increasing sequence.\n    - Initialize `largestPrime` as 0.\n    - Starting from `bound - 1`, iterate downwards until 2 to find the largest prime number less than `bound`.\n        - If a prime number is found (using `checkPrime`), store it in `largestPrime` and stop the search.\n    - Subtract `largestPrime` from `nums[i]`.\n2. If the loop completes, return `true`.\n\nHelper Function - `checkPrime(x)`\n\n1. Loop from 2 to the square root of `x`:\n    - If any number divides `x` evenly, return false (indicating `x` is not prime).\n2. If no divisors are found, return `true`, indicating `x`` is prime.\n\n#### Implementation#### Complexity Analysis\n\nLet `n` be the length of the `nums` array, and `m` denotes the maximum value in the `nums` array.\n\n- Time complexity: $O(n \\cdot m \\cdot \\sqrt(m))$\n\n    The algorithm iterates through the `nums` array, which takes $O(n)$ time for the outer loop. For each element in the array, the algorithm may check each number from `bound - 1` down to `2` to find the largest prime. \n    \n    The primality check is done using the `checkPrime` function, which has a time complexity of $O(sqrt(m))$, where `m` is the current number being checked. \n    \n    In the worst case, this results in an overall time complexity of $O(n \\cdot m \\cdot \\sqrt(m))$.\n\n- Space complexity: $O(1)$\n\n    The space complexity is determined by a few integer variables and does not depend on the size of the input. Hence, the overall space complexity is constant.\n\n---\n\n### Approach 2: Storing the primes\n\n#### Intuition\n\nIn our previous method, we checked if each number below a certain difference was prime, which could get repetitive and slow. To make this faster, we can create an array, `previousPrime`, to store the largest prime number less than each number up to our limit. This lets us quickly look up the nearest prime without recalculating it every time.\n\nSince all values in `nums` are between 1 and 1000, we only need to find primes within this range. First, we identify which numbers are prime. For each prime number `p`, we set `previousPrime[p] = p`. Then, for numbers in between (where no prime has been assigned), we just carry forward the most recent prime we found. For example, if we find `previousPrime[3] = 3` and `previousPrime[5] = 5`, but `previousPrime[4]` is empty, we fill in `3` for it.\n\nThis way, it lets us find the nearest prime for any number in constant time and avoids recalculating primes repeatedly.\n\n#### Algorithm\n\nMain Function - `primeSubOperation(nums)`\n- Calculate `maxElement` as the maximum value in the `nums` array.\n- Create an array `previousPrime` of size `maxElement + 1`, where each index will store the largest prime number less than or equal to that index.\n- Loop from 2 to `maxElement`:\n    - If the number is prime (using `checkPrime`), set `previousPrime[i]` to `i`.\n    - If it’s not prime, set `previousPrime[i]` to `previousPrime[i - 1]`.\n- Loop Through Each Element in `nums`:\n- For each element in `nums`, iterate the index `i` from 0 to `nums.size() - 1`:\n    - For the first element (i = 0), set `bound` to `nums[0]`.\n    - For subsequent elements, set `bound` to `nums[i] - nums[i - 1]`.\n    - If `bound` is less than or equal to 0, return `false`, as it’s impossible to create a strictly increasing sequence.\n    - Retrieve `largestPrime` as the value of `previousPrime[bound - 1]`, representing the largest prime number less than `bound`.\n    - Subtract `largestPrime` from `nums[i]`.\n- If the loop completes successfully, return `true`.\n\nHelper Function - `checkPrime(x)`\n- Loop from 2 to the square root of `x`:\n    - If any number divides `x` evenly, return false (indicating `x` is not prime).\n- If no divisors are found, return `true` (indicating `x` is prime).\n\n#### Implementation#### Complexity Analysis\n\nLet `n` be the length of the `nums` array, and `m` denotes the maximum value in the `nums` array.\n\n- Time complexity: $O(n + m \\cdot \\sqrt(m))$\n\n    We first populate the `previousPrime` array for all integers from 2 to the maximum element. This involves checking the primality of numbers up to `m`, which takes $O(m \\cdot \\sqrt(m))$ time due to the `checkPrime` function.\n\n    Finally, the algorithm iterates through the `nums` array to apply the prime subtraction operation, which takes $O(n)$ time.\n    \n    In the worst case, this results in an overall time complexity of $O(n + m \\cdot \\sqrt(m))$.\n\n- Space complexity: $O(m)$\n\n    The space complexity is determined by the `previousPrime` array, which is of size `m`. This requires $O(m)$ space, where `m` is the maximum value in the input array.\n\n---\n\n### Approach 3: Sieve of Eratosthenes + Two Pointers \n\n#### Intuition\n\nThe [Sieve of Eratosthenes](https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes) is a classic and efficient way to find all the prime numbers up to a certain limit, like 100. Essentially, we’re going to go through a list of numbers and cross off anything that’s not prime.\n\n1. Create a List: We start with a list of numbers from 2 to 100. Notice we skip 1 since it’s not considered a prime.\n\n2. Mark Multiples of Each Prime:\n   - Starting with the smallest prime, 2, we know it’s prime because it hasn’t been marked yet. So, we keep it.\n   - Now, we cross out all multiples of 2 (like 4, 6, 8, etc.) because they’re definitely not prime.\n\n3. Move to the Next Unmarked Number:\n   - The next number that isn’t crossed out is 3, so we mark it as a prime.\n   - Then, we cross out all multiples of 3 (like 6, 9, 12, etc.).\n\n4. Repeat the Process:\n   - We keep going, finding the next unmarked number (which will be 5), and marking all of its multiples. We do this for 7 as well and continue until we’ve processed all numbers up to the limit.\n\nThe beauty of the Sieve of Eratosthenes is that it saves a lot of time by marking off composites in bulk, rather than testing each number individually to see if it’s prime. By the end, any number that’s still unmarked is a prime.\n\nAs we proceed, we can store each prime in an array by setting `sieve[prime] = 1`. For any marked (non-prime) number, we could also keep track of the specific prime that marked it, though, for basic prime-finding, it’s sufficient to identify which numbers are prime.\n\nSince all values lie between 1 and 1000, we can iterate through the array and check the minimum value that can be assigned to the current index. The array should be strictly increasing, so the next value assigned would be greater than the current value. Therefore, we can iterate through the indices and the values simultaneously using two pointers. \n\nWe’ll have one pointer, `i`, which represents the current index in the array, and another variable, `currValue`, which keeps track of the current value we want to assign to that index. The key here is that `nums[i]` should equal `currValue` after we subtract a prime number from it, meaning we need to ensure that the difference between `nums[i]` and `currValue` is a prime number.\n\nAs we iterate through the array, for each element, we will check if the difference `nums[i] - currValue` is a prime number. We can use the sieve table for this check. If the difference is prime (i.e. `sieve[difference] = 1`), we assign `currValue` to `nums[i]` and move on by incrementing both `i` and `currValue`. However, if the difference isn't prime, we increment `currValue` and check again to see if we can assign it to the same index `i`.\n\nIf at any point the difference becomes negative, it means that `nums[i]` is already less than `currValue`, and in that case, we can conclude that it’s impossible to assign the values correctly and return `false`.\n\n#### Algorithm\n\n1. Calculate `maxElement` as the maximum value in the `nums` array.\n2. Create a `sieve` array of size `maxElement + 1` where each index initially has a value of 1 (indicating prime), except `sieve[1]`, which is set to 0 (indicating non-prime).\n3. Loop through each number from `2` to the square root of `maxElement + 1`:\n    - For each prime number `i`, mark all multiples of `i` as non-prime by setting `sieve[j]` to 0 for each multiple `j`.\n4. Initialize `currValue` to 1 and start with index `i` = 0 in `nums`:\n5. While `i` is less than the size of `nums`:\n        - Calculate difference as `nums[i] - currValue`.\n            - If difference is less than 0, return `false`, as `nums[i]` is already less than `currValue`.\n            - If difference is either prime (`sieve[difference]` equals 1) or `0`, move to the next element by incrementing `i` and `currValue`.\n            - Otherwise, increment `currValue` and try again.\n6. If the loop completes successfully, return `true`.\n\n!?!../Documents/2601/slideshow1.json:960,540!?!\n\n#### Implementation#### Complexity Analysis\n\nLet `n` be the length of the `nums` array, and `m` denotes the maximum value in the `nums` array.\n\n- Time complexity: $O(n + m \\log \\log (m))$\n\n    We first construct the sieve array to identify prime numbers up to `maxElement`. The Sieve of Eratosthenes runs in $O(m \\log \\log (m))$ time, where `m` is the maximum element.\n\n    Finally, the algorithm iterates through the `nums` array to apply the prime subtraction operation, which takes $O(n)$ time.\n    \n    In the worst case, this results in an overall time complexity of $O(n + m \\log \\log (m))$.\n\n- Space complexity: $O(m)$\n\n    The space complexity is determined by the `sieve` array, which is of size `m`. This requires $O(m)$ space, where `m` is the maximum value in the input array.\n\n---"
}