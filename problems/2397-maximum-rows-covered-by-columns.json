{
  "title": "Maximum Rows Covered by Columns",
  "problem_id": "2482",
  "frontend_id": "2397",
  "difficulty": "Medium",
  "problem_slug": "maximum-rows-covered-by-columns",
  "topics": [
    "Array",
    "Backtracking",
    "Bit Manipulation",
    "Matrix",
    "Enumeration"
  ],
  "description": "You are given an m x n binary matrix matrix and an integer numSelect.\nYour goal is to select exactly numSelect distinct columns from matrix such that you cover as many rows as possible.\nA row is considered covered if all the 1's in that row are also part of a column that you have selected. If a row does not have any 1s, it is also considered covered.\nMore formally, let us consider selected = {c1, c2, ...., cnumSelect} as the set of columns selected by you. A row i is covered by selected if:\nReturn the maximum number of rows that can be covered by a set of numSelect columns.\nExample 1:\nExample 2:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: matrix = [[0,0,0],[1,0,1],[0,1,1],[0,0,1]], numSelect = 2\nOutput: 3\nExplanation:\nOne possible way to cover 3 rows is shown in the diagram above. We choose s = {0, 2}. - Row 0 is covered because it has no occurrences of 1. - Row 1 is covered because the columns with value 1, i.e. 0 and 2 are present in s. - Row 2 is not covered because matrix[2][1] == 1 but 1 is not present in s. - Row 3 is covered because matrix[2][2] == 1 and 2 is present in s. Thus, we can cover three rows. Note that s = {1, 2} will also cover 3 rows, but it can be shown that no more than three rows can be covered.",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input: matrix = [[1],[0]], numSelect = 1\nOutput: 2\nExplanation:\nSelecting the only column will result in both rows being covered since the entire matrix is selected.",
      "images": []
    }
  ],
  "constraints": [
    "m == matrix.length",
    "n == matrix[i].length",
    "1 <= m, n <= 12",
    "matrix[i][j] is either 0 or 1.",
    "1 <= numSelectÂ <= n"
  ],
  "follow_ups": [],
  "hints": [
    "Try a brute-force approach.",
    "Iterate through all possible sets of exactly <code>cols</code> columns.",
    "For each valid set, check how many rows are covered, and return the maximum."
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    int maximumRows(vector<vector<int>>& matrix, int numSelect) {\n        \n    }\n};",
    "java": "class Solution {\n    public int maximumRows(int[][] matrix, int numSelect) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def maximumRows(self, matrix, numSelect):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type numSelect: int\n        :rtype: int\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def maximumRows(self, matrix: List[List[int]], numSelect: int) -> int:\n        ",
    "c": "int maximumRows(int** matrix, int matrixSize, int* matrixColSize, int numSelect) {\n    \n}",
    "csharp": "public class Solution {\n    public int MaximumRows(int[][] matrix, int numSelect) {\n        \n    }\n}",
    "javascript": "/**\n * @param {number[][]} matrix\n * @param {number} numSelect\n * @return {number}\n */\nvar maximumRows = function(matrix, numSelect) {\n    \n};",
    "typescript": "function maximumRows(matrix: number[][], numSelect: number): number {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param Integer[][] $matrix\n     * @param Integer $numSelect\n     * @return Integer\n     */\n    function maximumRows($matrix, $numSelect) {\n        \n    }\n}",
    "swift": "class Solution {\n    func maximumRows(_ matrix: [[Int]], _ numSelect: Int) -> Int {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun maximumRows(matrix: Array<IntArray>, numSelect: Int): Int {\n        \n    }\n}",
    "dart": "class Solution {\n  int maximumRows(List<List<int>> matrix, int numSelect) {\n    \n  }\n}",
    "golang": "func maximumRows(matrix [][]int, numSelect int) int {\n    \n}",
    "ruby": "# @param {Integer[][]} matrix\n# @param {Integer} num_select\n# @return {Integer}\ndef maximum_rows(matrix, num_select)\n    \nend",
    "scala": "object Solution {\n    def maximumRows(matrix: Array[Array[Int]], numSelect: Int): Int = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn maximum_rows(matrix: Vec<Vec<i32>>, num_select: i32) -> i32 {\n        \n    }\n}",
    "racket": "(define/contract (maximum-rows matrix numSelect)\n  (-> (listof (listof exact-integer?)) exact-integer? exact-integer?)\n  )",
    "erlang": "-spec maximum_rows(Matrix :: [[integer()]], NumSelect :: integer()) -> integer().\nmaximum_rows(Matrix, NumSelect) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec maximum_rows(matrix :: [[integer]], num_select :: integer) :: integer\n  def maximum_rows(matrix, num_select) do\n    \n  end\nend"
  }
}