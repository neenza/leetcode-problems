{
  "title": "Find Closest Node to Given Two Nodes",
  "problem_id": "2438",
  "frontend_id": "2359",
  "difficulty": "Medium",
  "problem_slug": "find-closest-node-to-given-two-nodes",
  "topics": [
    "Depth-First Search",
    "Graph"
  ],
  "description": "You are given a directed graph of n nodes numbered from 0 to n - 1, where each node has at most one outgoing edge.\nThe graph is represented with a given 0-indexed array edges of size n, indicating that there is a directed edge from node i to node edges[i]. If there is no outgoing edge from i, then edges[i] == -1.\nYou are also given two integers node1 and node2.\nReturn the index of the node that can be reached from both node1 and node2, such that the maximum between the distance from node1 to that node, and from node2 to that node is minimized. If there are multiple answers, return the node with the smallest index, and if no possible answer exists, return -1.\nNote that edges may contain cycles.\nExample 1:\nExample 2:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: edges = [2,2,3,-1], node1 = 0, node2 = 1\nOutput: 2\nExplanation: The distance from node 0 to node 2 is 1, and the distance from node 1 to node 2 is 1.\nThe maximum of those two distances is 1. It can be proven that we cannot get a node with a smaller maximum distance than 1, so we return node 2.",
      "images": [
        "https://assets.leetcode.com/uploads/2022/06/07/graph4drawio-2.png"
      ]
    },
    {
      "example_num": 2,
      "example_text": "Input: edges = [1,2,-1], node1 = 0, node2 = 2\nOutput: 2\nExplanation: The distance from node 0 to node 2 is 2, and the distance from node 2 to itself is 0.\nThe maximum of those two distances is 2. It can be proven that we cannot get a node with a smaller maximum distance than 2, so we return node 2.",
      "images": [
        "https://assets.leetcode.com/uploads/2022/06/07/graph4drawio-4.png"
      ]
    }
  ],
  "constraints": [
    "n == edges.length",
    "2 <= n <= 105",
    "-1 <= edges[i] < n",
    "edges[i] != i",
    "0 <= node1, node2 < n"
  ],
  "follow_ups": [],
  "hints": [
    "How can you find the shortest distance from one node to all nodes in the graph?",
    "Use BFS to find the shortest distance from both node1 and node2 to all nodes in the graph. Then iterate over all nodes, and find the node with the minimum max distance."
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    int closestMeetingNode(vector<int>& edges, int node1, int node2) {\n        \n    }\n};",
    "java": "class Solution {\n    public int closestMeetingNode(int[] edges, int node1, int node2) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def closestMeetingNode(self, edges, node1, node2):\n        \"\"\"\n        :type edges: List[int]\n        :type node1: int\n        :type node2: int\n        :rtype: int\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\n        ",
    "c": "int closestMeetingNode(int* edges, int edgesSize, int node1, int node2) {\n    \n}",
    "csharp": "public class Solution {\n    public int ClosestMeetingNode(int[] edges, int node1, int node2) {\n        \n    }\n}",
    "javascript": "/**\n * @param {number[]} edges\n * @param {number} node1\n * @param {number} node2\n * @return {number}\n */\nvar closestMeetingNode = function(edges, node1, node2) {\n    \n};",
    "typescript": "function closestMeetingNode(edges: number[], node1: number, node2: number): number {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param Integer[] $edges\n     * @param Integer $node1\n     * @param Integer $node2\n     * @return Integer\n     */\n    function closestMeetingNode($edges, $node1, $node2) {\n        \n    }\n}",
    "swift": "class Solution {\n    func closestMeetingNode(_ edges: [Int], _ node1: Int, _ node2: Int) -> Int {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun closestMeetingNode(edges: IntArray, node1: Int, node2: Int): Int {\n        \n    }\n}",
    "dart": "class Solution {\n  int closestMeetingNode(List<int> edges, int node1, int node2) {\n    \n  }\n}",
    "golang": "func closestMeetingNode(edges []int, node1 int, node2 int) int {\n    \n}",
    "ruby": "# @param {Integer[]} edges\n# @param {Integer} node1\n# @param {Integer} node2\n# @return {Integer}\ndef closest_meeting_node(edges, node1, node2)\n    \nend",
    "scala": "object Solution {\n    def closestMeetingNode(edges: Array[Int], node1: Int, node2: Int): Int = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn closest_meeting_node(edges: Vec<i32>, node1: i32, node2: i32) -> i32 {\n        \n    }\n}",
    "racket": "(define/contract (closest-meeting-node edges node1 node2)\n  (-> (listof exact-integer?) exact-integer? exact-integer? exact-integer?)\n  )",
    "erlang": "-spec closest_meeting_node(Edges :: [integer()], Node1 :: integer(), Node2 :: integer()) -> integer().\nclosest_meeting_node(Edges, Node1, Node2) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec closest_meeting_node(edges :: [integer], node1 :: integer, node2 :: integer) :: integer\n  def closest_meeting_node(edges, node1, node2) do\n    \n  end\nend"
  },
  "solution": "[TOC]\n\n## Solution\n\n---\n\n### Overview\n\nThe problem presents a directed unweighted graph with `n` nodes. Each node can have at most one outgoing edge. Our task is to find the closest node from two given nodes, `node1` and `node2` so that the maximum between the distances from `node1` and `node2` to that node is minimized over all the nodes. If there are multiple answers, we need to return the node with the smallest index, and if no possible answer exists, we need to return `-1`.\n\n---\n\n### Approach 1: Breadth First Search\n\n#### Intuition\n\nWe can see intuitively that if we have the distances from `node1` and `node2` to all the nodes, then we can iterate over all the nodes and choose a node that has the smallest maximum value between the distances from `node1` to that node and from  `node2` to that node.\n\nA breadth-first search (BFS) is a good algorithm to use if we want to find the shortest path in an unweighted graph. The path used in BFS traversal always has the least number of edges. The BFS algorithm does a level-wise iteration of the graph. As a result, it first finds all paths that are one edge away from the source node, followed by all paths that are two edges away from the source node, and so on. This allows BFS to find the shortest path in terms of steps from the source node to any other node. It is implemented with a queue.\n\nHere is an example with steps:\n\n![img](../Figures/2359/2359-bfs.png)\n\nIn this approach, we begin BFS traversals for both `node1` and `node2` to compute the shortest distances from `node1` and `node2` to all other nodes. We store the results in arrays labeled `dist1` and `dist2`, respectively. We also set two variables: `minDistNode = -1`, which is the answer to our problem, and `minDistTillNow`, which is the maximum between the distances from `node1` to `minDistNode` and from `node2` to `minDistNode`.\n\nNow, we iterate over all of the nodes from `0` to `n - 1`. For each node, say `currNode` we check if the maximum distance from `node1` and `node2` is smaller than the other nodes previously seen. If `minDistTillNow > max(dist1[currNode], dist2[currNode])`, we have a node `currNode` with a smaller maximum value between the distances from `node1` to `currNode` and from `node2` to `currNode`. In this case, we update the `minDistTillNow` to `minDistTillNow = max(dist1[currNode], dist2[currNode])` and update the `minDistNode` to `minDistNode = currNode`.\n\nOtherwise, if `minDistTillNow <= max(dist1[currNode], dist2[currNode])` we do not do anything. We return `minDistNode` at the end of all the iterations over every node. We would never update the variable `currNode` if we couldn't reach any node that is reachable from `node1` and `node2`. In that case, we'd return the `currNode` variable with its original value of `-1`.\n\n#### Algorithm\n\n1. Initialize two arrays, `dist1` and `dist2` storing the shortest distances from `node1` and `node2` to all the nodes. Initialize them with large values.\n2. Start a BFS traversal.\n    - We use a function `bfs` to perform the traversal. It requires `startNode, edges, dist` as the parameters, where `dist` is the array that stores the shortest distances from `startNode` to all the nodes.\n    - Start with `node1, edges, dist1`.\n    - Initialize a queue with `startNode` in the queue.\n3. Initialize an array `visit`, storing a boolean for each node to indicate if a node is visited. Initialize it with `false` for all the nodes.\n4. Then, while the queue is not empty:\n    - Dequeue the first `node` from the queue. If it has not been visited, mark it as visited. Otherwise, if it has been visited, repeat step 4.\n    - Check if `node` has an outgoing edge. If there is no outgoing edge, we don't do anything.\n    - If the `node` has an outgoing edge to another node called `neighbor`, and `neighbor` has not yet been visited, update the `dist[neighbor]` to `dist[neighbor] = 1 + dist[node]` and push the `neighbor` into the queue.\n5. Perform another BFS traversal with `node2, edges, dist2` to get the shortest distances from `node2` to every other node in `dist2`.\n6. Initialize two variables: `minDistNode = -1`, which is the answer to our problem, and `minDistTillNow`, which is the maximum between the distances from `node1` to `minDistNode` and from `node2` to `minDistNode`.\n7. Run a loop over all the nodes and check each node called `currNode`.\n    - If `minDistTillNow > max(dist1[currNode], dist2[currNode])`, update `minDistTillNow` to `minDistTillNow = max(dist1[currNode], dist2[currNode])` and update `minDistNode` to `minDistNode = currNode`.\n    - Otherwise, we do not update anything.\n8. Return `minDistNode`.\n\n#### Implementation#### Complexity Analysis\n\nHere, $n$ is the number of nodes.\n\n* Time complexity: $O(N)$\n\n    - The complexity would be similar to the standard BFS algorithm since we are performing the BFS traversal twice.\n    - For the BFS algorithm, each node is only queued once, which takes $O(1)$ time for each node. We also iterate over the edge of every node once (since we only visit each node once, we won't iterate over a node's edge multiple times), which adds $O(n)$ time since we have at most $n$ edges.\n    - We also require $O(n)$ time to initialize each `dist1`, the `dist2` and the `visit` arrays.\n    - We also require $O(n)$ time to run a loop over all the nodes in the end to compute the answer.\n\n* Space complexity: $O(n)$\n\n    - Because each node only has one outgoing edge, the queue size will never exceed `1`. As such, we don't actually need the queue, but we've used it here to show the template code implementation for BFS.\n    - However, we still require $O(n)$ space each for the `dist1`, the `dist2` and the `visit` arrays.\n\n---\n\n### Approach 2: Depth First Search\n\n#### Intuition\n\nAn interesting property of the graph mentioned in the problem is that each node can have at most one outgoing edge. We can see intuitively that if every node has at most one outgoing edge, there can only be one path from a node to any other node. This is because we only have one way to proceed from one node to another node by using the outgoing edge, if one exists. If there is no outgoing edge or the node has a self-loop (an edge that connects a node to itself), we cannot move ahead. So, if we are able to move, we can only move in one direction. Due to this property, we would be able to use the depth-first search (DFS) algorithm to find the shortest path from a node to all the other nodes in this scenario.\n\nIn DFS, we use a recursive function to explore nodes as far as possible along each branch. Upon reaching the end of a branch, we backtrack to the next branch and continue exploring. Once we encounter an unvisited node, we will take one of its neighbor nodes (if exists) as the next node on this branch. Recursively call the function to take the next node as the 'starting node' and solve the subproblem.\n\nHere is an example with steps:\n\n![img](../Figures/2359/2359-dfs.png)\n\nWe can only have one branch as per our problem. So, DFS works for our use case to find the shortest distance from a node to all other nodes.\n\nNote that, we cannot use DFS in a standard unweighted graph to find the shortest distance from a node to any other node. For example, let's take a graph with three edges: `1 -> 2`, `1 -> 3` and `2 -> 3`. Let's say we start with node `1` and mark its distance as `0`. We move forward, visit node `2` and mark its distance as `1`. As mentioned in DFS, we explore nodes as far as possible along the branch, so from node `2` we will go to node `3`. We will mark its distance as `2`, which is incorrect. We can visit node `3` via `1 -> 3` with a distance of `1`. \n\nIf you are new to Depth First Search, please see our [Leetcode Explore Card](https://leetcode.com/explore/featured/card/graph/619/depth-first-search-in-graph/3882/) for more information on it!\n\nIn this approach, we begin DFS traversals for both `node1` and `node2` to compute the shortest distances from `node1` and `node2` to all other nodes. We will store the results in arrays labelled `dist1` and `dist2`, respectively.\n\nThen, we will iterate over all the nodes and find a node `minDistNode` with the smallest maximum value between the distances from `node1` to `minDistNode` and `node2` to `minDistNode` similar to the BFS approach.\n\n#### Algorithm\n\n1. Initialize two arrays, `dist1` and `dist2` storing the shortest distances from `node1` and `node2` to all the nodes. Initialize them with large values. Set `dist1[node1] = 0` and `dist2[node2] = 0`.\n2. Initialize two boolean arrays, `visit1` and `visit2` to indicate if a node is visited or not in a DFS traversal, starting from `node1` and `node2` respectively. Initialize them with false.\n3. Start a DFS traversal.\n    - We use a function `dfs` to perform the traversal. For each call, pass the `node, edges, dist, visit` as the parameters.\n    - Start with `node1, edges, dist, visit1` to get the shortest distances from `node1` to every node in `dist1`.\n    - Mark `node` as visited.\n    - If the `node` has an outgoing edge to another node called `neighbor`, and `neighbor` has not yet been visited, update the `dist[neighbor]` to `dist[neighbor] = 1 + dist[node]`. We also recursively call the dfs with `neighbor, dges, dist, visit`.\n4. Perform another DFS traversal with `node2, edges, dist2, visit2` to get the shortest distances from `node2` to every node. The distances will be stored in `dist2`.\n6. Initialize two variables: `minDistNode = -1`, which is the answer to our problem, and `minDistTillNow`, which is the maximum between the distances from `node1` to `minDistNode` and from `node2` to `minDistNode`.\n7. Run a loop over all the nodes and check each node called `currNode`.\n    - If `minDistTillNow > max(dist1[currNode], dist2[currNode])`, update `minDistTillNow` to `minDistTillNow = max(dist1[currNode], dist2[currNode])` and update `minDistNode` to `minDistNode = currNode`.\n    - Otherwise, we do not update anything.\n8. Return `minDistNode`.\n\n#### Implementation#### Complexity Analysis\n\nHere, $n$ is the number of nodes.\n\n* Time complexity: $O(n)$\n\n    - The complexity would be similar to the standard DFS algorithm since we’re performing the DFS traversal twice.\n    - Each node is visited by the `dfs` function once, which takes $O(n)$ time in total. We also iterate over the edge of every node once (since we only visit each node once, we won't iterate over a node's edge multiple times), which adds $O(n)$ time since we have at most $n$ edges.\n    - We also require $O(n)$ time to initialize each `dist1`, the `dist2` and the `visit` arrays.\n    - We also require $O(n)$ time to run a loop over all the nodes in the end to compute the answer.\n\n* Space complexity: $O(n)$\n\n    - The recursion call stack used by `dfs` can have no more than $n$ elements in the worst-case scenario. It would take up $O(n)$ space in that case.\n    - We also require $O(n)$ space each for the `dist1`, the `dist2` and the `visit` arrays."
}