{
  "title": "Guess Number Higher or Lower II",
  "problem_id": "375",
  "frontend_id": "375",
  "difficulty": "Medium",
  "problem_slug": "guess-number-higher-or-lower-ii",
  "topics": [
    "Math",
    "Dynamic Programming",
    "Game Theory"
  ],
  "description": "We are playing the Guessing Game. The game will work as follows:\nGiven a particular n, return the minimum amount of money you need to guarantee a win regardless of what number I pick.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: n = 10\nOutput: 16\nExplanation: The winning strategy is as follows:\n- The range is [1,10]. Guess 7.\n    - If this is my number, your total is $0. Otherwise, you pay $7.\n    - If my number is higher, the range is [8,10]. Guess 9.\n        - If this is my number, your total is $7. Otherwise, you pay $9.\n        - If my number is higher, it must be 10. Guess 10. Your total is $7 + $9 = $16.\n        - If my number is lower, it must be 8. Guess 8. Your total is $7 + $9 = $16.\n    - If my number is lower, the range is [1,6]. Guess 3.\n        - If this is my number, your total is $7. Otherwise, you pay $3.\n        - If my number is higher, the range is [4,6]. Guess 5.\n            - If this is my number, your total is $7 + $3 = $10. Otherwise, you pay $5.\n            - If my number is higher, it must be 6. Guess 6. Your total is $7 + $3 + $5 = $15.\n            - If my number is lower, it must be 4. Guess 4. Your total is $7 + $3 + $5 = $15.\n        - If my number is lower, the range is [1,2]. Guess 1.\n            - If this is my number, your total is $7 + $3 = $10. Otherwise, you pay $1.\n            - If my number is higher, it must be 2. Guess 2. Your total is $7 + $3 + $1 = $11.\nThe worst case in all these scenarios is that you pay $16. Hence, you only need $16 to guarantee a win.",
      "images": [
        "https://assets.leetcode.com/uploads/2020/09/10/graph.png"
      ]
    },
    {
      "example_num": 2,
      "example_text": "Input: n = 1\nOutput: 0\nExplanation: There is only one possible number, so you can guess 1 and not have to pay anything.",
      "images": [
        "https://assets.leetcode.com/uploads/2020/09/10/graph.png"
      ]
    },
    {
      "example_num": 3,
      "example_text": "Input: n = 2\nOutput: 1\nExplanation: There are two possible numbers, 1 and 2.\n- Guess 1.\n    - If this is my number, your total is $0. Otherwise, you pay $1.\n    - If my number is higher, it must be 2. Guess 2. Your total is $1.\nThe worst case is that you pay $1.",
      "images": [
        "https://assets.leetcode.com/uploads/2020/09/10/graph.png"
      ]
    }
  ],
  "constraints": [
    "1 <= n <= 200"
  ],
  "follow_ups": [],
  "hints": [
    "The best strategy to play the game is to minimize the maximum loss you could possibly face. Another strategy is to minimize the expected loss. Here, we are interested in the <b>first</b> scenario.",
    "Take a small example (n = 3). What do you end up paying in the worst case?",
    "Check out <a href=\"https://en.wikipedia.org/wiki/Minimax\">this article</a> if you're still stuck.",
    "The purely recursive implementation of minimax would be worthless for even a small n. You MUST use dynamic programming.",
    "As a follow-up, how would you modify your code to solve the problem of minimizing the expected loss, instead of the worst-case loss?"
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    int getMoneyAmount(int n) {\n        \n    }\n};",
    "java": "class Solution {\n    public int getMoneyAmount(int n) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def getMoneyAmount(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def getMoneyAmount(self, n: int) -> int:\n        ",
    "c": "int getMoneyAmount(int n) {\n    \n}",
    "csharp": "public class Solution {\n    public int GetMoneyAmount(int n) {\n        \n    }\n}",
    "javascript": "/**\n * @param {number} n\n * @return {number}\n */\nvar getMoneyAmount = function(n) {\n    \n};",
    "typescript": "function getMoneyAmount(n: number): number {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param Integer $n\n     * @return Integer\n     */\n    function getMoneyAmount($n) {\n        \n    }\n}",
    "swift": "class Solution {\n    func getMoneyAmount(_ n: Int) -> Int {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun getMoneyAmount(n: Int): Int {\n        \n    }\n}",
    "dart": "class Solution {\n  int getMoneyAmount(int n) {\n    \n  }\n}",
    "golang": "func getMoneyAmount(n int) int {\n    \n}",
    "ruby": "# @param {Integer} n\n# @return {Integer}\ndef get_money_amount(n)\n    \nend",
    "scala": "object Solution {\n    def getMoneyAmount(n: Int): Int = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn get_money_amount(n: i32) -> i32 {\n        \n    }\n}",
    "racket": "(define/contract (get-money-amount n)\n  (-> exact-integer? exact-integer?)\n  )",
    "erlang": "-spec get_money_amount(N :: integer()) -> integer().\nget_money_amount(N) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec get_money_amount(n :: integer) :: integer\n  def get_money_amount(n) do\n    \n  end\nend"
  },
  "solution": "[TOC]\n\n## Summary\n\nGiven a number $$n$$, we have to find the worst-case cost of guessing a number chosen from the range $$(1, n)$$, assuming that the guesses are made intelligently(minimize the total cost). The cost is incremented by $$i$$ for every wrong guess $$i$$.\n\nFor example:\n```\nn=5\n1 2 3 4 5\n```\nIf we start with 3 as the initial guess, the next guess would certainly be 4 as in the worst case required number is 5. Total Cost $$= 4+3=7$$.\n\nBut if we start with 4 as the initial guess, our next guess would be 2 as in the worst case required number is 3 or 1. Total Cost $$=4+2=6$$ which is the minimum cost.\n\n```\nn=8\n1 2 3 4 5 6 7 8\n```\nIn this case, we have to guess 5 followed by 7. Total Cost $$=5+7=12$$.\nIf we choose 4 as our initial guess. Total Cost $$=4+5+7=16$$.\n\n## Solution\n\n---\n### Approach #1 Brute Force [Time Limit Exceeded]\n\nFirstly, we need to be aware of the fact that out of the range $$(1, n)$$, we have to guess the numbers intelligently in order to minimize the cost. But, along with that we have to take into account the worst-case scenario possible, that is we have to assume that the original number chosen is such that it will try to maximize the overall cost.\n\nIn Brute Force, we can pick up any number $$i$$ in the range $$(1, n)$$. Assuming it is a wrong guess(worst-case scenario), we have to minimize the cost of reaching the required number. Now, the required number could be lying either to the right or left of the number picked($$i$$). But to cover the possibility of the worst case number chosen, we need to take the maximum cost out of the cost of reaching the worst number out of the right and left segments of $$i$$. Thus, if we pick up $$i$$ as the pivot, the overall minimum cost for the worst required number will be:\n\n$$\n\\mathrm{cost}(1, n)=i + \\max\\big(\\mathrm{cost}(1,i-1), \\mathrm{cost}(i+1,n)\\big)\n$$\n\nFor every segment, we can further choose another pivot and repeat the same process for calculating the minimum cost.\n\nBy using the above procedure, we found out the cost of reaching the required number starting with $$i$$ as the pivot. In the same way, we iterate over all the numbers in the range $$(1, n)$$, choosing them as the pivot, calculating the cost of every pivot chosen, and thus, we can find the minimum cost out of those.**Complexity Analysis**\n\n* Time complexity : $$O(n!)$$. We choose a number as the pivot and repeat the pivoting process further $$n$$ times $$O(n!)$$. We repeat the same process for $$n$$ pivots.\n* Space complexity : $$O(n)$$. Recursion of depth $$n$$ is used.\n\n---\n### Approach #2 Modified Brute Force [Time Limit Exceeded]\n\n**Algorithm**\n\nIn Brute Force, for numbers in the range $$(i, j)$$, we picked up every number from $$i$$ to $$j$$ as the pivot and found the maximum cost out of its left and right segments. But an important point to observe is that if we choose any number from the range $$\\big( i,\\frac{i+j}{2} \\big)$$ as the pivot, the right segment(consisting of numbers larger than the picked up pivot) will be longer than the left segment(consisting of numbers smaller than it). Thus, we will always get the maximum cost from the right segment and it will be larger than the minimum cost achievable by choosing some other pivot. Therefore, our objective here is to reduce the larger cost that is coming from the right segment. Thus, it is wise to choose the pivot from the range $$\\big(\\frac{i+j}{2}, j\\big)$$. In this way the costs of the two segments will be nearer to each other and this will minimize the overall cost.\n\nThus, while choosing the pivot instead of iterating from $$i$$ to $$j$$, we iterate from $$\\frac{i+j}{2}$$ to $$j$$ and find the minimum achievable cost similar to brute force.**Complexity Analysis**\n\n* Time complexity : $$O(n!)$$. We choose a number as the pivot and repeat the pivoting process further $$n$$ times $$O(n!)$$. We repeat the same process for $$n$$ pivots.\n* Space complexity : $$O(n)$$. Recursion of depth $$n$$ is used.\n\n---\n### Approach #3 Using DP [Accepted]\n\n**Algorithm**\n\nThe problem of finding the minimum cost of reaching the destination number by choosing $$i$$ as a pivot can be divided into the subproblem of finding the maximum out of the minimum costs of its left and right segments as explained above. For each segment, we can continue the process leading to smaller and smaller subproblems. This leads us to the conclusion that we can use DP for this problem.\n\nWe need to use a $$dp$$ matrix, where $$dp(i, j)$$ refers to the minimum cost of finding the worst number given only the numbers in the range $$(i, j)$$. Now, we need to know how to fill in the entries of this $$dp$$. If we are given only a single number $$k$$, no matter what the number is the cost of finding that number is always 0 since we always hit the number directly without any wrong guess. Thus, firstly, we fill in all the entries of the $$dp$$ which correspond to segments of length 1 i.e. all entries $$dp(k, k)$$ are initialized to 0. Then, in order to find the entries for segments of length 2, we need all the entries for segments of length 1. Thus, in general, to fill in the entries corresponding to segments of length $$len$$, we need all the entries of length $$len-1$$ and below to be already filled. Thus, we need to fill the entries in the order of their segment lengths. Thus, we fill the entries of $$dp$$ diagonally.\n\nNow, what criteria do we need to fill up the $$dp$$ matrix? For any entry  $$dp(i, j)$$, given the current segment length of interest is $$len$$ i.e. if $$len=j-i+1$$, we assume as if we are available only with the numbers in the range $$(i, j)$$. To fill in its current entry, we follow the same process as Approach 1, choosing every number as the pivot and finding the minimum cost as:\n\n$$\n\\mathrm{cost}(i, j)=\\mathrm{pivot} + \\max\\big(\\mathrm{cost}(i,\\mathrm{pivot}-1), \\mathrm{cost}(\\mathrm{pivot}+1,j)\\big)\n$$\n\nBut, we have an advantage in terms of calculating the cost here, since we already know the costs for the segments of length smaller than $$len$$ from $$dp$$. Thus, the dp equation becomes:\n\n$$\n\\mathrm{dp}(i, j) = \\min_{\\mathrm{pivot} \\in (i, j)} \\big[ \\mathrm{pivot} + \\max \\big( \\mathrm{dp}(i,\\mathrm{pivot}-1) , \\mathrm{dp}(\\mathrm{pivot}+1,j) \\big) \\big]\n$$\n\n  where $$\\min_{\\mathrm{pivot} \\in (i, j)}$$ indicates the minimum obtained by considering every number in the range $$(i, j)$$ as the pivot.\n\nThe following animation will make the process more clear for n=5:!?!../Documents/375_Guess.json:791,552!?!**Complexity Analysis**\n\n* Time complexity : $$O(n^3)$$. We traverse the complete $$dp$$ matrix once $$(O(n^2))$$. For every entry, we take at most $$n$$ numbers as pivot.\n\n* Space complexity : $$O(n^2)$$. $$dp$$ matrix of size $$n^2$$ is used.\n\n---\n\n### Approach #4 Better Approach using DP [Accepted]\n\n**Algorithm**\n\nIn the last approach, we chose every possible pivot from the range $$(i, j)$$. But, as per the argument given in Approach 2, we can choose pivots only from the range $$\\big(i+(len-1)/2,j\\big)$$, where $$len$$ is the current segment length of interest.\nThus the governing equation is:\n\n$$\n\\mathrm{dp}(i, j)=\\min_{\\mathrm{pivot} \\in \\big(i+\\frac{len-1}{2}, j\\big)}\\big[\\mathrm{pivot} + \\max\\big(\\mathrm{dp}(i,\\mathrm{pivot}-1), \\mathrm{dp}(\\mathrm{pivot}+1,j)\\big)\\big]\n$$\n\n Thus, we can optimize the Approach 3 to some extent.**Complexity Analysis**\n\n* Time complexity : $$O(n^3)$$. We traverse the complete $$dp$$ matrix once $$(O(n^2))$$. For every entry, we take at most $$n$$ numbers as pivot.\n\n* Space complexity : $$O(n^2)$$. $$dp$$ matrix of size $$n^2$$ is used."
}