{
  "title": "Largest Substring Between Two Equal Characters",
  "problem_id": "1746",
  "frontend_id": "1624",
  "difficulty": "Easy",
  "problem_slug": "largest-substring-between-two-equal-characters",
  "topics": [
    "Hash Table",
    "String"
  ],
  "description": "Given a string s, return the length of the longest substring between two equal characters, excluding the two characters. If there is no such substring return -1.\nA substring is a contiguous sequence of characters within a string.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: s = \"aa\"\nOutput: 0\nExplanation: The optimal substring here is an empty substring between the two 'a's.",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input: s = \"abca\"\nOutput: 2\nExplanation: The optimal substring here is \"bc\".",
      "images": []
    },
    {
      "example_num": 3,
      "example_text": "Input: s = \"cbzxy\"\nOutput: -1\nExplanation: There are no characters that appear twice in s.",
      "images": []
    }
  ],
  "constraints": [
    "1 <= s.length <= 300",
    "s contains only lowercase English letters."
  ],
  "follow_ups": [],
  "hints": [
    "Try saving the first and last position of each character",
    "Try finding every pair of indexes with equal characters"
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    int maxLengthBetweenEqualCharacters(string s) {\n        \n    }\n};",
    "java": "class Solution {\n    public int maxLengthBetweenEqualCharacters(String s) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def maxLengthBetweenEqualCharacters(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def maxLengthBetweenEqualCharacters(self, s: str) -> int:\n        ",
    "c": "int maxLengthBetweenEqualCharacters(char* s) {\n    \n}",
    "csharp": "public class Solution {\n    public int MaxLengthBetweenEqualCharacters(string s) {\n        \n    }\n}",
    "javascript": "/**\n * @param {string} s\n * @return {number}\n */\nvar maxLengthBetweenEqualCharacters = function(s) {\n    \n};",
    "typescript": "function maxLengthBetweenEqualCharacters(s: string): number {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param String $s\n     * @return Integer\n     */\n    function maxLengthBetweenEqualCharacters($s) {\n        \n    }\n}",
    "swift": "class Solution {\n    func maxLengthBetweenEqualCharacters(_ s: String) -> Int {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun maxLengthBetweenEqualCharacters(s: String): Int {\n        \n    }\n}",
    "dart": "class Solution {\n  int maxLengthBetweenEqualCharacters(String s) {\n    \n  }\n}",
    "golang": "func maxLengthBetweenEqualCharacters(s string) int {\n    \n}",
    "ruby": "# @param {String} s\n# @return {Integer}\ndef max_length_between_equal_characters(s)\n    \nend",
    "scala": "object Solution {\n    def maxLengthBetweenEqualCharacters(s: String): Int = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn max_length_between_equal_characters(s: String) -> i32 {\n        \n    }\n}",
    "racket": "(define/contract (max-length-between-equal-characters s)\n  (-> string? exact-integer?)\n  )",
    "erlang": "-spec max_length_between_equal_characters(S :: unicode:unicode_binary()) -> integer().\nmax_length_between_equal_characters(S) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec max_length_between_equal_characters(s :: String.t) :: integer\n  def max_length_between_equal_characters(s) do\n    \n  end\nend"
  },
  "solution": "[TOC]\n\n## Solution\n\n---\n\n### Approach 1: Brute Force\n\n**Intuition**\n\nFor our first approach, we will check every substring of `s` to see if the first and last characters are equal. If they are, we will calculate the length of the substring between the first and last characters, and update the answer with it if it is larger.\n\nA substring can be defined by two integers: its `left` bound and its `right` bound. Here, `left` represents the index of the first character and `right` represents the index of the last character.\n\nWe can iterate `left` over each index of `s`. For each value of `left`, we consider all substrings that start at `left` by iterating `right` over the indices of `s`, starting from `left + 1`. For example, if the length of `s` is `8` and we are currently considering `left = 4`, then we iterate `right` over the indices `5, 6, 7`. Each iteration represents the substring of `s` that starts at index `left` and ends at index `5, 6, 7` respectively.\n\nIf we find that `s[left] = s[right]`, we can consider the substring between `left, right` for our answer. What is the length of the substring between `left, right`?\n\n![example](../Figures/1624/1.png)Normally, the length of a substring defined by `left, right` would be `right - left + 1`. However, we are not considering `s[left]` or `s[right]`. Thus, we need to subtract `2`. Therefore, we would update our answer with `right - left - 1` if it is larger.\n\n**Algorithm**\n\n1. Initialize the answer `ans = -1`.\n2. Iterate `left` over the indices of `s`:\n    - Iterate `right` over the indices of `s`, starting from `left + 1`:\n        - If `s[left] = s[right]`:\n            - Update `ans` with `right - left - 1` if it is larger.\n3. Return `ans`.\n\n**Implementation****Complexity Analysis**\n\nGiven $$n$$ as the length of `s`,\n\n* Time complexity: $$O(n^2)$$\n\n    We have a nested for loop over the indices of `s`.\n\n    For `left = 0`, we have $$n - 1$$ iterations of `right`. For `left = 1`, we have $$n - 2$$ iterations of `right`. For `left = 2`, we have $$n - 3$$ iterations of `right`, and so on.\n\n    Thus, in total we have $$1 + 2 + 3 + ... + n - 1$$ iterations of `right`. This is the partial sum of [this series](https://en.wikipedia.org/wiki/1_%2B_2_%2B_3_%2B_4_%2B_%E2%8B%AF#Partial_sums), for $$n - 1$$, which is equal to $$\\frac{n \\cdot (n - 1)}{2} = O(n^2)$$.\n\n* Space complexity: $$O(1)$$\n\n    We aren't using any extra space.---\n\n### Approach 2: Hash Map\n\n**Intuition**\n\nWe can solve the problem more efficiently. As we talked about in the previous approach, a substring can be described by its bounds `left, right`.\n\nIn this approach, we will consider each index `i` as the **right bound** for a substring. For a given `i`, we are interested in a `left` bound such that `s[left] = s[i]`. Note that there may be many indices that meet this criteria.\n\nFor example, let's say we had `s = \"abaacda\"` and we currently had `i = 6` at the final index. We are considering substrings that have a `right` bound of `6` and are interested in finding a `left` bound such that `s[left] = 'a'`, since `s[6] = 'a'`. There are three indices: `0, 2, 3` that all represent the character `'a'`. Which one should we choose?\n\nSince the problem is asking for the maximum length, we would choose the `left` bound with the lowest value, to maximize the distance between the bounds. Thus, we would choose `left = 0` here.\n\nIn general, for a given `i` as the right bound, we are interested in the first index where `s[i]` occurred. We can use a hash map `firstIndex` to record this.\n\n![example](../Figures/1624/2.png)We iterate `i` over the indices of `s`. For each `i`, we first check if `s[i]` is in `firstIndex`. If it is, it means that the first character equal to `s[i]` is at `firstIndex[s[i]]`, and the substring has a length of `i - firstIndex[s[i]] - 1`. Therefore, we update the answer with `i - firstIndex[s[i]] - 1` if it is larger. Otherwise, this is the first time we encounter character `s[i]`, thus we set `firstIndex[s[i]] = i`.\n\nYou may be thinking: won't we be skipping a lot of valid substrings? The answer is yes, but it's OK, because the only substrings that we skip are those that could not possibly be the answer. If we are treating `i` as the right boundary, we only consider the leftmost occurrence of `s[i]` as the left boundary because any other occurrence would result in a shorter substring.\n\n**Algorithm**\n\n1. Initialize a hash map `firstIndex` and the answer `ans = -1`.\n2. Iterate `i` over the indices of `s`:\n    - If `s[i]` is in `firstIndex`:\n        - Update `ans` with `i - firstIndex[s[i]] - 1` if it is larger.\n    - Otherwise, set `firstIndex[s[i]] = i`.\n3. Return `ans`.\n\n**Implementation****Complexity Analysis**\n\nGiven $$n$$ as the length of `s`,\n\n* Time complexity: $$O(n)$$\n\n    We iterate over each character of `s` once, performing $$O(1)$$ work at each iteration. With a hash map, checking if an element `s[i]` exists costs $$O(1)$$.\n\n* Space complexity: $$O(1)$$\n\n    Although we are using the hash map `firstIndex`, the input consists of only lowercase English letters. Thus, the size of `firstIndex` can never exceed `26`.---"
}