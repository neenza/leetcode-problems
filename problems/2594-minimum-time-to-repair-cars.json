{
  "title": "Minimum Time to Repair Cars",
  "problem_id": "2665",
  "frontend_id": "2594",
  "difficulty": "Medium",
  "problem_slug": "minimum-time-to-repair-cars",
  "topics": [
    "Array",
    "Binary Search"
  ],
  "description": "You are given an integer array ranks representing the ranks of some mechanics. ranksi is the rank of the ith mechanic. A mechanic with a rank r can repair n cars in r * n2 minutes.\nYou are also given an integer cars representing the total number of cars waiting in the garage to be repaired.\nReturn the minimum time taken to repair all the cars.\nNote: All the mechanics can repair the cars simultaneously.\nExample 1:\nExample 2:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: ranks = [4,2,3,1], cars = 10\nOutput: 16\nExplanation: \n- The first mechanic will repair two cars. The time required is 4 * 2 * 2 = 16 minutes.\n- The second mechanic will repair two cars. The time required is 2 * 2 * 2 = 8 minutes.\n- The third mechanic will repair two cars. The time required is 3 * 2 * 2 = 12 minutes.\n- The fourth mechanic will repair four cars. The time required is 1 * 4 * 4 = 16 minutes.\nIt can be proved that the cars cannot be repaired in less than 16 minutes.​​​​​",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input: ranks = [5,1,8], cars = 6\nOutput: 16\nExplanation: \n- The first mechanic will repair one car. The time required is 5 * 1 * 1 = 5 minutes.\n- The second mechanic will repair four cars. The time required is 1 * 4 * 4 = 16 minutes.\n- The third mechanic will repair one car. The time required is 8 * 1 * 1 = 8 minutes.\nIt can be proved that the cars cannot be repaired in less than 16 minutes.​​​​​",
      "images": []
    }
  ],
  "constraints": [
    "1 <= ranks.length <= 105",
    "1 <= ranks[i] <= 100",
    "1 <= cars <= 106"
  ],
  "follow_ups": [],
  "hints": [
    "For a predefined fixed time, can all the cars be repaired?",
    "Try using binary search on the answer."
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    long long repairCars(vector<int>& ranks, int cars) {\n        \n    }\n};",
    "java": "class Solution {\n    public long repairCars(int[] ranks, int cars) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def repairCars(self, ranks, cars):\n        \"\"\"\n        :type ranks: List[int]\n        :type cars: int\n        :rtype: int\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def repairCars(self, ranks: List[int], cars: int) -> int:\n        ",
    "c": "long long repairCars(int* ranks, int ranksSize, int cars) {\n    \n}",
    "csharp": "public class Solution {\n    public long RepairCars(int[] ranks, int cars) {\n        \n    }\n}",
    "javascript": "/**\n * @param {number[]} ranks\n * @param {number} cars\n * @return {number}\n */\nvar repairCars = function(ranks, cars) {\n    \n};",
    "typescript": "function repairCars(ranks: number[], cars: number): number {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param Integer[] $ranks\n     * @param Integer $cars\n     * @return Integer\n     */\n    function repairCars($ranks, $cars) {\n        \n    }\n}",
    "swift": "class Solution {\n    func repairCars(_ ranks: [Int], _ cars: Int) -> Int {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun repairCars(ranks: IntArray, cars: Int): Long {\n        \n    }\n}",
    "dart": "class Solution {\n  int repairCars(List<int> ranks, int cars) {\n    \n  }\n}",
    "golang": "func repairCars(ranks []int, cars int) int64 {\n    \n}",
    "ruby": "# @param {Integer[]} ranks\n# @param {Integer} cars\n# @return {Integer}\ndef repair_cars(ranks, cars)\n    \nend",
    "scala": "object Solution {\n    def repairCars(ranks: Array[Int], cars: Int): Long = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn repair_cars(ranks: Vec<i32>, cars: i32) -> i64 {\n        \n    }\n}",
    "racket": "(define/contract (repair-cars ranks cars)\n  (-> (listof exact-integer?) exact-integer? exact-integer?)\n  )",
    "erlang": "-spec repair_cars(Ranks :: [integer()], Cars :: integer()) -> integer().\nrepair_cars(Ranks, Cars) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec repair_cars(ranks :: [integer], cars :: integer) :: integer\n  def repair_cars(ranks, cars) do\n    \n  end\nend"
  },
  "solution": "## Solution\n\n---\n\n### Overview\n\nWe are given an array `ranks`, where `ranks[i]` represents the efficiency of the `i`-th mechanic. A mechanic with a rank `r` repairs `n` cars in `r * n^2` minutes, meaning the time required increases quadratically as more cars are assigned to a single mechanic. We also have an integer `cars`, representing the total number of cars that need to be repaired. The goal is to determine the minimum possible time required to repair all cars if all mechanics work simultaneously.  \n\nTo understand the problem, consider the example where `ranks = [4,2,3,1]` and `cars = 10`. The optimal allocation would be:  \n- The first mechanic (rank `4`) repairs `2` cars, taking $4 * 2^2 = 16$ minutes. \n- The second mechanic (rank `2`) repairs `2` cars, taking $2 * 2^2 = 8$ minutes. \n- The third mechanic (rank `3`) repairs `2` cars, taking $3 * 2^2 = 12$ minutes. \n- The fourth mechanic (rank `1`) repairs `4` cars, taking $1 * 4^2 = 16$ minutes. \n\nSince all mechanics work in parallel, the total time required is determined by the slowest mechanic in the optimal assignment, which is `16` minutes.\n\nThe problem essentially boils down to distributing the cars optimally among the mechanics so that the maximum repair time (the slowest mechanic) is minimized. Another way to say this is that a mechanic with a lower rank (higher skill) can repair cars faster than one with a higher rank. A brute force approach of checking every possible distribution would be highly inefficient, so we need a smarter strategy.\n\nA common mistake is misunderstanding how parallel execution works. Instead of focusing on the slowest mechanic, some mistakenly add up all the repair times, as if the tasks were done sequentially. This misinterpretation leads to incorrect conclusions about the total time required.  \n\nAnother mistake is assuming dynamic programming (DP) is always the right approach for optimization problems. When faced with minimization or maximization, our first instinct might be to reach for DP. However, before committing to it, we need to check the constraints. If the problem lacks overlapping subproblems or an optimal substructure, DP may not be a suitable choice.\n\nIn this problem, we are given:  \n- `ranks.length` can be up to $10^5$ \n- `cars` can be up to $10^6$\n\nA typical DP solution would require a state representation like `dp[mechanic][car]`. The time complexity would then be $O(n \\cdot cars)$, which in the worst case is $10^5 × 10^6 = 10^{11}$ operations. This is far too large to be computationally feasible.  \n\nA good approach here can be to use binary search, as it provides a more natural way to minimize the maximum time while still efficiently distributing cars. We will talk about it more in [approach one](#approach-1-binary-search-on-time).\n\n> Takeaway Tip: When deciding on an approach, always check the constraints first. If `n` and `cars` are large (in the range of $10^5$ to $10^6$), DP is usually not feasible. Instead, binary search, greedy, or two pointers are more likely to work in such cases.\n\n---\n\n### Approach 1: Binary Search on Time\n\n#### Intuition\n\nGiven the relationship that a mechanic with a lower rank (higher skill) can repair cars faster than one with a higher rank, the key observation is that if we fix a certain amount of time `t`, we can determine how many cars can be repaired within `t` by all available mechanics. Since we want the minimum possible time to repair all cars, we can apply binary search on the time.\n\nMore technically, given a fixed time `t`, we can determine how many cars can be repaired within that time using a simple formula. But how do we actually find the smallest `t` that allows all cars to be repaired?\n\nWe observe that if a given time `t` is sufficient to repair all cars, then any time greater than `t` will also be sufficient. Conversely, if `t` is not enough, then any time smaller than `t` will also fail. \n\nThis forms a monotonic relationship: \n- If `t` is too small, increasing `t` will eventually make it work.\n- If `t` is large enough, decreasing `t` will still work until we hit the minimum threshold.\n\nThis kind of \"yes/no\" behavior, where a function transitions from failure to success at a specific boundary, is exactly when binary search is useful. Instead of checking every possible value of `t` from `1` to `minRank * cars^2`, we can narrow down the search space logarithmically.\n\nWe define our search space based on the slowest possible case. The minimum possible time is `1`, and the maximum time is when the slowest mechanic (one with the lowest rank) repairs all cars alone. This worst-case scenario takes `minRank * cars^2` time.\n \nWe perform **binary search** over this time range. For each candidate time $\\text{mid}$, we check how many cars can be repaired within $\\text{mid}$.  \n\nSince the time required by a mechanic with rank `r` to repair `n` cars follows the formula:\n\n$T = r \\cdot n^2$\n\nWe need to determine the maximum number of cars a mechanic can repair within $\\text{mid}$, which means solving:\n\n$r \\cdot n^2 \\leq \\text{mid}$\n\nSolving for `n`:\n\n$n \\leq \\sqrt{\\frac{\\text{mid}}{r}}$\n\nThus, for each mechanic with rank `r`, the maximum number of cars they can repair within $\\text{mid}$ is:\n\n$\\lfloor \\sqrt{\\frac{\\text{mid}}{r}} \\rfloor$\n\nWe sum up the number of cars each mechanic can repair and compare it with the required number of cars. If the total is at least the required number, we adjust our binary search range accordingly.\n\nIf the total number of repaired cars is at least the required number of cars, it means we might be able to complete all repairs in a smaller time, so we move left in the binary search by setting `high = mid`. Otherwise, if the number of repaired cars is too low, we need more time, so we move right by setting `low = mid + 1`.\n \nTo implement, we first determine the smallest rank among all mechanics since it defines our upper bound (`minRank * cars^2`). Then, we maintain a frequency array `freq` to count how many mechanics have each rank, which allows us to efficiently compute the total number of repaired cars at any given time.\n\nWe initialize `low = 1` and `high = minRank * cars^2`, then apply binary search. For each `mid` value, we iterate over all possible ranks (from `1` to `maxRank`) and compute how many cars can be repaired by mechanics of that rank using `sqrt(mid / r)`. If the total repaired cars meet or exceed the requirement, we shrink the search space (`high = mid`). Otherwise, we expand it (`low = mid + 1`).\n\nOnce the binary search terminates, `low` contains the minimum time required to repair all cars.\n\nThe algorithm is visualized below:\n\n![Binary_approach1](../Figures/2594/Binary_approach1.png)\n\n> For a more comprehensive understanding of binary search, check out the [Binary Search Explore Card 🔗](https://leetcode.com/explore/learn/card/binary-search/). This resource provides an in-depth look at binary search, explaining its key concepts and applications with a variety of problems to solidify understanding of the pattern.\n\n#### Algorithm\n\n- Initialize `minRank` to track the minimum rank in `ranks`.\n- Initialize `freq` array of size `101` to count the number of mechanics with each rank.\n\n- Iterate through `ranks`:\n  - Update `minRank` with the smallest rank encountered.\n  - Increment `freq` at index `rank` to track the count of mechanics with that rank.\n\n- Set `low` to `1` (minimum possible repair time).\n- Set `high` to `minRank * cars * cars` (worst-case longest repair time).\n\n- Perform binary search while `low < high`:\n  - Compute `mid` as the middle value between `low` and `high`.\n  - Initialize `carsRepaired` to count total cars repaired in `mid` time.\n\n  - Iterate through possible ranks from `1` to `maxRank + 1`:\n    - Calculate the number of cars repaired by mechanics of each rank.\n    - Use `freq[rank] * sqrt(mid / rank)` to compute repairs.\n\n  - If `carsRepaired` is at least `cars`, update `high = mid` to find a smaller valid time.\n  - Else, update `low = mid + 1` since more time is needed.\n\n- Return `low`, the minimum time required to repair all cars.\n\n#### Implementation\n\n> **Fun Tip:** The maximum possible `maxRank` is 100, so we can also hardcode the frequency array size to 101 instead of dynamically allocating it as `maxRank + 1`.#### Complexity Analysis\n\nLet $n$ be the size of the `ranks` array, $m$ be the number of cars (`cars`).\n\n- Time Complexity: $O(n + \\text{max\\_rank} \\log (m \\cdot \\text{max\\_rank}))$\n\n    The algorithm starts by iterating through the `ranks` array to compute the minimum rank and build a frequency array. This step takes $O(n)$ time, as it involves a single pass over the array. Next, the algorithm performs a binary search over the possible time range, which spans from 1 to $1L \\cdot \\text{minRank} \\cdot m \\cdot m$. The binary search runs in $O(\\log (m \\cdot \\text{max\\_rank}))$ iterations, where $\\text{max\\_rank}$ is the maximum rank in the `ranks` array. \n\n    For each iteration of the binary search, the algorithm calculates the total number of cars that can be repaired in `mid` time. This involves iterating over the frequency array which has a fixed size of $\\text{max\\_rank}$ and computing the square root of the ratio of `mid` to the rank for each entry. This computation takes $O(\\text{max\\_rank})$ time per iteration. Combining these steps, the overall time complexity is $O(n + \\text{max\\_rank} \\log (m \\cdot \\text{max\\_rank}))$.\n\n- Space Complexity: $O(\\text{max\\_rank})$\n\n    The algorithm uses a frequency array of size $\\text{max\\_rank}$ to store the count of mechanics for each rank. This array occupies $O(\\text{max\\_rank})$ space. Additionally, a few variables are used for the binary search (`low`, `high`, `mid`, `carsRepaired`) and for storing the minimum rank, all of which require constant space, $O(1)$. Thus, the overall space complexity is $O(\\text{max\\_rank})$.\n\n---\n\n### Approach 2: Space Optimized Binary Search\n\n#### Intuition\n\nIn the previous approach, we precomputed the smallest rank and used a frequency array to count how many mechanics had each rank. The idea behind this was to speed up the calculation of how many cars could be repaired in a given time. However, this extra bookkeeping can be removed if we want to space optimize it because we can determine the number of cars repaired directly by iterating over the `ranks` array. \n\nMore specifically, instead of grouping mechanics by rank and iterating over a fixed range of possible ranks (from `1` to `100`), we can simply iterate over the given ranks and compute the number of cars each mechanic can repair on the fly. This removes the processing and makes the solution more straightforward while maintaining the same logic.  \n\nWith this optimization in mind, we keep the core idea of binary search on time. The search space remains the same: the lower bound is `1`, representing the smallest unit of time, while the upper bound is `ranks[0] * cars^2`, representing the worst-case scenario where the slowest mechanic repairs all cars alone.\n\nFor a given `mid` time, we compute how many cars can be repaired by summing up contributions from all mechanics. The number of cars a mechanic with rank `r` can repair within `mid` time is given by `n ≤ sqrt(mid / r)`, since repairing `n` cars requires `r * n^2` time. By iterating over the `ranks` array and applying this formula to each mechanic, we calculate the total number of repaired cars and compare it with the required amount.\n\nIf the total number of repaired cars is less than the required amount, it means `mid` is too small, so we increase `low` (`low = mid + 1`). Otherwise, if the total is at least the required amount, we try to minimize the repair time by decreasing `high` (`high = mid`).  \n \n#### Algorithm\n\n- Set `low` to `1`, the minimum possible repair time.\n- Set `high` to `ranks[0] * cars * cars`, the worst-case maximum repair time.\n\n- Perform binary search while `low < high`:\n  - Compute `mid` as the middle value between `low` and `high`.\n  - Initialize `carsRepaired` to count total cars repaired in `mid` time.\n\n  - Iterate through `ranks`:\n    - Calculate the number of cars repaired by each mechanic using `sqrt(mid / rank)`.\n    - Accumulate the total `carsRepaired`.\n\n  - If `carsRepaired` is less than `cars`, update `low = mid + 1` since more time is needed.\n  - Else, update `high = mid` to search for a smaller valid time.\n\n- Return `low`, the minimum time required to repair all cars.\n\n#### Implementation#### Complexity Analysis\n\nLet $n$ be the size of the `ranks` array, $m$ be the number of cars (`cars`), and $k$ be the maximum possible rank (`100` in this case).\n\n- Time Complexity: $O(n \\cdot \\log (m \\cdot \\text{max\\_rank}))$  \n\n    The algorithm performs a binary search over the possible time range, which takes $O(\\log (m \\cdot \\text{max\\_rank}))$ iterations. For each iteration, it calculates the number of cars that can be repaired in $O(n)$ time by iterating over the `ranks` array. The overall time complexity is $O(n \\cdot \\log (m \\cdot \\text{max\\_rank}))$.\n\n- Space Complexity: $O(1)$  \n\n    The algorithm uses only a constant amount of extra space for variables, resulting in $O(1)$ space complexity. No additional data structures are used.\n\n---\n\n### Approach 3: Using Heap\n\n#### Intuition\n\nInstead of using binary search, we can directly simulate the car repair process using a min-heap to always prioritize the mechanic who can complete the next repair in the shortest possible time. Since each mechanic follows the formula `time = rank * n^2` to determine how long it takes to repair their `k`-th car, we can predict the sequence of repair times for each mechanic. The first car takes `rank * 1^2 = rank` time, the second car takes `rank * 4` time, the third car takes `rank * 9` time, and so on.  \n\nGiven this pattern, at any moment, the mechanic who will finish the next repair the fastest should be chosen to repair the next car. The most efficient way to track the next available repair time for all mechanics is to use a min-heap, where each entry stores the next repair time for a mechanic, their rank (to calculate future repair times), the number of cars they have already repaired, and the count of mechanics with that rank (since multiple mechanics can have the same rank).  \n\nWe begin by initializing the heap with the first repair time for each unique rank. If multiple mechanics share the same rank, we keep track of how many exist. Then, we repeatedly extract the mechanic with the earliest repair time and assign them the next car to repair. Once a mechanic repairs a car, we compute their next available repair time using the formula `time = rank * (n + 1)^2`, then push this new time back into the heap. This process continues until all cars are repaired.  \n\nBy always selecting the fastest available repair, we ensure that the total time remains minimal while efficiently distributing the workload among mechanics. Since each mechanic’s repair time follows a monotonically increasing pattern, the heap naturally maintains the correct ordering.\n\n#### Algorithm\n\n- Count the frequency of each rank to determine how many mechanics have each rank.\n\n- Initialize a min-heap (`minHeap`) with elements `[time, rank, n, count[rank]]`:\n  - `time`: time needed for the next repair (initially `rank * 1^2 = rank`).\n  - `rank`: the mechanic's rank.\n  - `n`: the number of cars repaired so far by this mechanic (initially 1).\n  - `count`: the number of mechanics with this rank.\n\n- Convert `minHeap` into a valid heap to ensure the smallest repair time is at the root.\n\n- While there are cars left to repair:\n  - Pop the mechanic with the smallest current repair time from `minHeap`.\n  - Deduct the number of cars repaired by this mechanic group from `cars`.\n  - Increment the number of cars repaired by this mechanic (`n += 1`).\n  - Calculate the next repair time using the formula `rank * n^2`.\n  - Push the updated mechanic's info back into the heap to continue tracking their repair time.\n\n- Return the time of the last repair, which is the minimum time needed to repair all cars.\n\n#### Implementation#### Complexity Analysis\n\nLet $n$ be the size of the `ranks` array, $m$ be the number of cars (`cars`), and $k$ be the maximum possible rank (`100` in this case).\n\n- Time Complexity: $O(n + m \\log k)$\n\n    The algorithm begins by counting the frequency of each rank using a `Counter`. This step takes $O(n)$ time, as it involves iterating through the `rank` array once. Next, a min-heap is initialized with the unique ranks and their frequencies. The heap initially contains at most $k$ elements, and building the heap takes $O(k)$ time using `heapify`.\n\n    The main loop processes the cars one by one until all $m$ cars are repaired. In each iteration, the mechanic with the smallest current repair time is popped from the heap. This operation takes $O(\\log k)$ time. The number of cars repaired by this mechanic group is deducted, and the repair time for the next car is calculated as $\\text{rank} \\cdot n^2$, where $n$ is the number of cars already repaired by this mechanic. The updated repair time is then pushed back into the heap, which also takes $O(\\log k)$ time. Since this loop runs for $m$ iterations, the total time complexity for the loop is $O(m \\log k)$.\n\n    Combining these steps, the overall time complexity is $O(n + m \\log k)$.\n\n- Space Complexity: $O(k)$\n\n    The algorithm stores the frequency of each rank, which occupies $O(k)$ space. Additionally, the min-heap stores at most $k$ elements at any point, as it only keeps track of unique ranks and their repair times. This results in an overall space complexity of $O(k)$. The heap operations themselves use $O(\\log k)$ space per element, but the total space for the heap is $O(k)$.\n\n---\n\nHere are some problems that use concepts similar to the binary search technique we covered in this editorial. Practicing them will help you get more comfortable applying it to different situations.\n\n- [2560. House Robber IV](https://leetcode.com/problems/house-robber-iv/)\n- [875. Koko Eating Bananas](https://leetcode.com/problems/koko-eating-bananas/)\n- [1231. Divide Chocolate](https://leetcode.com/problems/divide-chocolate/)\n- [1011. Capacity To Ship Packages In N Days](https://leetcode.com/problems/capacity-to-ship-packages-in-n-days/)\n- [2587. Minimum Time to Repair Cars](https://leetcode.com/problems/minimum-time-to-repair-cars/)\n- [1539. Kth Missing Positive Number](https://leetcode.com/problems/kth-missing-positive-number/)\n- [2064. Minimized Maximum of Products Distributed to Any Store](https://leetcode.com/problems/minimized-maximum-of-products-distributed-to-any-store/)\n- [2226. Maximum Candies Allocated to K Children](https://leetcode.com/problems/maximum-candies-allocated-to-k-children/)\n- [1802. Maximum Value at a Given Index in a Bounded Array](https://leetcode.com/problems/maximum-value-at-a-given-index-in-a-bounded-array/)\n- [1482. Minimum Number of Days to Make m Bouquets](https://leetcode.com/problems/minimum-number-of-days-to-make-m-bouquets/)\n- [1283. Find the Smallest Divisor Given a Threshold](https://leetcode.com/problems/find-the-smallest-divisor-given-a-threshold/)\n- [774. Minimize Max Distance to Gas Station](https://leetcode.com/problems/minimize-max-distance-to-gas-station/)\n- [410. Split Array Largest Sum](https://leetcode.com/problems/split-array-largest-sum/)\n\n---"
}