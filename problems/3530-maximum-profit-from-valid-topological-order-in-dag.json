{
  "title": "Maximum Profit from Valid Topological Order in DAG",
  "problem_id": "3826",
  "frontend_id": "3530",
  "difficulty": "Hard",
  "problem_slug": "maximum-profit-from-valid-topological-order-in-dag",
  "topics": [
    "Array",
    "Dynamic Programming",
    "Bit Manipulation",
    "Graph",
    "Topological Sort",
    "Bitmask"
  ],
  "description": "You are given a Directed Acyclic Graph (DAG) with n nodes labeled from 0 to n - 1, represented by a 2D array edges, where edges[i] = [ui, vi] indicates a directed edge from node ui to vi. Each node has an associated score given in an array score, where score[i] represents the score of node i.\nYou must process the nodes in a valid topological order. Each node is assigned a 1-based position in the processing order.\nThe profit is calculated by summing up the product of each node's score and its position in the ordering.\nReturn the maximum possible profit achievable with an optimal topological order.\nA topological order of a DAG is a linear ordering of its nodes such that for every directed edge u â†’ v, node u comes before v in the ordering.\nExample 1:\nExample 2:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: n = 2, edges = [[0,1]], score = [2,3]\nOutput: 8\nExplanation:\n\nNode 1 depends on node 0, so a valid order is [0, 1] .\nThe maximum total profit achievable over all valid topological orders is 2 + 6 = 8 .",
      "images": [
        "https://assets.leetcode.com/uploads/2025/03/10/screenshot-2025-03-11-at-021131.png"
      ]
    },
    {
      "example_num": 2,
      "example_text": "Input: n = 3, edges = [[0,1],[0,2]], score = [1,6,3]\nOutput: 25\nExplanation:\n\nNodes 1 and 2 depend on node 0, so the most optimal valid order is [0, 2, 1] .\nThe maximum total profit achievable over all valid topological orders is 1 + 6 + 18 = 25 .",
      "images": [
        "https://assets.leetcode.com/uploads/2025/03/10/screenshot-2025-03-11-at-023558.png"
      ]
    }
  ],
  "constraints": [
    "1 <= n == score.length <= 22",
    "1 <= score[i] <= 105",
    "0 <= edges.length <= n * (n - 1) / 2",
    "edges[i] == [ui, vi] denotes a directed edge from ui to vi.",
    "0 <= ui, vi < n",
    "ui != vi",
    "The input graph is guaranteed to be a DAG.",
    "There are no duplicate edges."
  ],
  "follow_ups": [],
  "hints": [
    "Use bitmask dynamic programming.",
    "States are <code>mask</code> = (bits such that if a bit is set, it means the corresponding node is removed).",
    "Try maintaining the <code>degrees</code> across function calls."
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    int maxProfit(int n, vector<vector<int>>& edges, vector<int>& score) {\n        \n    }\n};",
    "java": "class Solution {\n    public int maxProfit(int n, int[][] edges, int[] score) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def maxProfit(self, n, edges, score):\n        \"\"\"\n        :type n: int\n        :type edges: List[List[int]]\n        :type score: List[int]\n        :rtype: int\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def maxProfit(self, n: int, edges: List[List[int]], score: List[int]) -> int:\n        ",
    "c": "int maxProfit(int n, int** edges, int edgesSize, int* edgesColSize, int* score, int scoreSize) {\n    \n}",
    "csharp": "public class Solution {\n    public int MaxProfit(int n, int[][] edges, int[] score) {\n        \n    }\n}",
    "javascript": "/**\n * @param {number} n\n * @param {number[][]} edges\n * @param {number[]} score\n * @return {number}\n */\nvar maxProfit = function(n, edges, score) {\n    \n};",
    "typescript": "function maxProfit(n: number, edges: number[][], score: number[]): number {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param Integer $n\n     * @param Integer[][] $edges\n     * @param Integer[] $score\n     * @return Integer\n     */\n    function maxProfit($n, $edges, $score) {\n        \n    }\n}",
    "swift": "class Solution {\n    func maxProfit(_ n: Int, _ edges: [[Int]], _ score: [Int]) -> Int {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun maxProfit(n: Int, edges: Array<IntArray>, score: IntArray): Int {\n        \n    }\n}",
    "dart": "class Solution {\n  int maxProfit(int n, List<List<int>> edges, List<int> score) {\n    \n  }\n}",
    "golang": "func maxProfit(n int, edges [][]int, score []int) int {\n    \n}",
    "ruby": "# @param {Integer} n\n# @param {Integer[][]} edges\n# @param {Integer[]} score\n# @return {Integer}\ndef max_profit(n, edges, score)\n    \nend",
    "scala": "object Solution {\n    def maxProfit(n: Int, edges: Array[Array[Int]], score: Array[Int]): Int = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn max_profit(n: i32, edges: Vec<Vec<i32>>, score: Vec<i32>) -> i32 {\n        \n    }\n}",
    "racket": "(define/contract (max-profit n edges score)\n  (-> exact-integer? (listof (listof exact-integer?)) (listof exact-integer?) exact-integer?)\n  )",
    "erlang": "-spec max_profit(N :: integer(), Edges :: [[integer()]], Score :: [integer()]) -> integer().\nmax_profit(N, Edges, Score) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec max_profit(n :: integer, edges :: [[integer]], score :: [integer]) :: integer\n  def max_profit(n, edges, score) do\n    \n  end\nend"
  }
}