{
  "title": "Trapping Rain Water II",
  "problem_id": "407",
  "frontend_id": "407",
  "difficulty": "Hard",
  "problem_slug": "trapping-rain-water-ii",
  "topics": [
    "Array",
    "Breadth-First Search",
    "Heap (Priority Queue)",
    "Matrix"
  ],
  "description": "Given an m x n integer matrix heightMap representing the height of each unit cell in a 2D elevation map, return the volume of water it can trap after raining.\nExample 1:\nExample 2:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: heightMap = [[1,4,3,1,3,2],[3,2,1,3,2,4],[2,3,3,2,3,1]]\nOutput: 4\nExplanation: After the rain, water is trapped between the blocks.\nWe have two small ponds 1 and 3 units trapped.\nThe total volume of water trapped is 4.",
      "images": [
        "https://assets.leetcode.com/uploads/2021/04/08/trap1-3d.jpg"
      ]
    },
    {
      "example_num": 2,
      "example_text": "Input: heightMap = [[3,3,3,3,3],[3,2,2,2,3],[3,2,1,2,3],[3,2,2,2,3],[3,3,3,3,3]]\nOutput: 10",
      "images": [
        "https://assets.leetcode.com/uploads/2021/04/08/trap2-3d.jpg"
      ]
    }
  ],
  "constraints": [
    "m == heightMap.length",
    "n == heightMap[i].length",
    "1 <= m, n <= 200",
    "0 <= heightMap[i][j] <= 2 * 104"
  ],
  "follow_ups": [],
  "hints": [],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    int trapRainWater(vector<vector<int>>& heightMap) {\n        \n    }\n};",
    "java": "class Solution {\n    public int trapRainWater(int[][] heightMap) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def trapRainWater(self, heightMap):\n        \"\"\"\n        :type heightMap: List[List[int]]\n        :rtype: int\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def trapRainWater(self, heightMap: List[List[int]]) -> int:\n        ",
    "c": "int trapRainWater(int** heightMap, int heightMapSize, int* heightMapColSize) {\n    \n}",
    "csharp": "public class Solution {\n    public int TrapRainWater(int[][] heightMap) {\n        \n    }\n}",
    "javascript": "/**\n * @param {number[][]} heightMap\n * @return {number}\n */\nvar trapRainWater = function(heightMap) {\n    \n};",
    "typescript": "function trapRainWater(heightMap: number[][]): number {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param Integer[][] $heightMap\n     * @return Integer\n     */\n    function trapRainWater($heightMap) {\n        \n    }\n}",
    "swift": "class Solution {\n    func trapRainWater(_ heightMap: [[Int]]) -> Int {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun trapRainWater(heightMap: Array<IntArray>): Int {\n        \n    }\n}",
    "dart": "class Solution {\n  int trapRainWater(List<List<int>> heightMap) {\n    \n  }\n}",
    "golang": "func trapRainWater(heightMap [][]int) int {\n    \n}",
    "ruby": "# @param {Integer[][]} height_map\n# @return {Integer}\ndef trap_rain_water(height_map)\n    \nend",
    "scala": "object Solution {\n    def trapRainWater(heightMap: Array[Array[Int]]): Int = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn trap_rain_water(height_map: Vec<Vec<i32>>) -> i32 {\n        \n    }\n}",
    "racket": "(define/contract (trap-rain-water heightMap)\n  (-> (listof (listof exact-integer?)) exact-integer?)\n  )",
    "erlang": "-spec trap_rain_water(HeightMap :: [[integer()]]) -> integer().\ntrap_rain_water(HeightMap) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec trap_rain_water(height_map :: [[integer]]) :: integer\n  def trap_rain_water(height_map) do\n    \n  end\nend"
  },
  "solution": "[TOC]\n\n## Solution\n\n---\n\n### Overview\n\nWe are given a grid, `heightMap`, where each element represents the height of the corresponding cell in the 3D representation of the map. Our task is to calculate the total amount of water trapped on the map after it rains.\n\nWe can assume that it rains an infinite amount of water, but the water stays inside any area of the map only if there is a boundary that traps it. Specifically, the water remains on top of a cell as long as its combined height (the height of the cell plus the water above it) is less than or equal to the height of all its neighbors. If any neighbor is lower, the water will flow out to that lower cell. \n\n---\n\n### Approach: BFS + Priority Queue \n\n#### Intuition\n\nBuilding on the earlier observation, the total height of any cell (its original height plus any trapped water) must not exceed the smallest total height of its neighbors. Specifically, it cannot exceed the smallest total height of its neighboring cells. This constraint propagates outward from the gridâ€™s edges, which act as the ultimate boundary since no water can be trapped beyond them.\n\nIn simpler terms, the cells around a region of the grid act as a boundary, and the smallest height of this boundary determines how much water can be stored in that region. To solve the problem, we begin by treating the edges of the grid as the initial boundary since water cannot spill beyond them. From there, we move inward, processing cells in a manner that respects the relationship between a cellâ€™s height and the boundary:\n\n1. **Trapping Water**: When we process a cell, if its height is lower than the current boundary height, water can be trapped above it. The amount of water trapped is equal to the difference between the boundary height and the cellâ€™s height. We then add this trapped water to our running total. To ensure the boundary remains valid, the cell is added to the boundary with its effective height adjusted to match the current boundary height. This adjustment prevents water from \"spilling\" through this cell and invalidating the boundary.\n\n2. **Updating the Boundary**: If the cell's height is greater than or equal to the boundary height, no water can be trapped above it. However, the cell still becomes part of the boundary because it might help trap water in adjacent, higher regions as we continue processing.\n\nTo efficiently manage the boundary and dynamically update the smallest height, we use a min-heap (priority queue). The heap lets us quickly find the lowest boundary height and ensure the traversal always processes the most constrained regions first.\n\n> For a more comprehensive understanding of heaps and priority queues, check out the [Heap Explore Card ðŸ”—](https://leetcode.com/explore/learn/card/heap/). This resource provides an in-depth look at heap-based algorithms, explaining their key concepts and applications with a variety of problems to solidify understanding of the pattern.\n\n!?!../Documents/407/407_approach1_fix.json:960,540!?!\n\n#### Algorithm\n\n-   Define a struct `Cell` that stores the height and the coordinates of a cell in the map.\n-   Define two direction arrays, that will help us explore the neighbors of each cell: `dRow = [0, 0, -1, 1], dCol = [-1, 1, 0, 0]`.\n-   Initialize `numOfRows` and `numOfCols` to the number of rows and columns of the original grid, respectively.\n-   Create a `numOfRows x numOfCols` boolean grid, called `visited`, with all its values initialized to `false`.\n-   Initialize a priority queue (min-heap) of `Cells`, called `boundary`.\n-   Push the cells of the first and last row and column of the grid into the `boundary` and mark them as visited.\n-   Initialize `totalWaterVolume` to `0`.\n-   While the `boundary` is not empty:\n    -   Pop the top cell out of the `boundary`, as `[minBoundaryHeight, [currentRow, currentCol]]` - this is the cell with the minimum height in the unexplored part of the boundary.\n    -   Update `minBoundaryHeight` to `height`.\n    -   Loop through all neighbors of the current cell, with `direction` from `0` to `3`:\n        -   Initialize `neighborRow` to `currentRow + dRow[direction]` and `neighborCol` to `currentCol + dCol[direction]`.\n        -   If the cell `(neighborRow, neighborCol)` is valid, i.e. it is not out of the bounds of the grid and not visited:\n            -   If the height of the cell, `neighborHeight` is lower than `minBoundaryHeight`, add the difference `minBoundaryHeight - neighborHeight` to the `totalWaterVolume`.\n            -   Push the neighboring cell into the `boundary` with its height set to the maximum of its value and `minBoundayHeight`, as the lowest height of the boundary cannot fall below its current value.\n            -   Mark the neighboring cell as visited.\n-   Return `totalWaterVolume`.\n\n#### Implementation#### Complexity Analysis\n\nLet $m$ be the number of rows and $n$ the number of columns of the input grid.\n\n-   Time complexity: $O(m \\cdot n \\times \\log{m \\cdot n})$\n\n    Each cell is pushed in the `boundary` exactly once, so the while loops runs $O(mn)$ times. On each iteration, an element is popped from the priority queue and four other elements (the neighboring cells) are potentially pushed into it. Since the push and pop operations of the priority queue have a time complexity of $O(k)$, where $k$ represents the size of the priority queue, the overall time complexity of the algorithm becomes $O(m \\cdot n \\times \\log{m \\cdot n})$.\n\n-   Space complexity: $O(m \\times n)$\n\n    We create a `visited` grid of size $m \\times n$ to keep track of the cells already explored. The priority queue, `boundary` can also grow up to $O(m \\times n)$ in size, so the algorithm requires $O(m \\times n)$ extra space.\n\n---"
}