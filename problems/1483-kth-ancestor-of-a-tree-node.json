{
  "title": "Kth Ancestor of a Tree Node",
  "problem_id": "1296",
  "frontend_id": "1483",
  "difficulty": "Hard",
  "problem_slug": "kth-ancestor-of-a-tree-node",
  "topics": [
    "Binary Search",
    "Dynamic Programming",
    "Tree",
    "Depth-First Search",
    "Breadth-First Search",
    "Design"
  ],
  "description": "You are given a tree with n nodes numbered from 0 to n - 1 in the form of a parent array parent where parent[i] is the parent of ith node. The root of the tree is node 0. Find the kth ancestor of a given node.\nThe kth ancestor of a tree node is the kth node in the path from that node to the root node.\nImplement the TreeAncestor class:\nExample 1:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input\n[\"TreeAncestor\", \"getKthAncestor\", \"getKthAncestor\", \"getKthAncestor\"]\n[[7, [-1, 0, 0, 1, 1, 2, 2]], [3, 1], [5, 2], [6, 3]]\nOutput\n[null, 1, 0, -1]\n\nExplanation\nTreeAncestor treeAncestor = new TreeAncestor(7, [-1, 0, 0, 1, 1, 2, 2]);\ntreeAncestor.getKthAncestor(3, 1); // returns 1 which is the parent of 3\ntreeAncestor.getKthAncestor(5, 2); // returns 0 which is the grandparent of 5\ntreeAncestor.getKthAncestor(6, 3); // returns -1 because there is no such ancestor",
      "images": [
        "https://assets.leetcode.com/uploads/2019/08/28/1528_ex1.png"
      ]
    }
  ],
  "constraints": [
    "1 <= k <= n <= 5 * 104",
    "parent.length == n",
    "parent[0] == -1",
    "0 <= parent[i] < n for all 0 < i < n",
    "0 <= node < n",
    "There will be at most 5 * 104 queries."
  ],
  "follow_ups": [],
  "hints": [
    "The queries must be answered efficiently to avoid time limit exceeded verdict.",
    "Use sparse table (dynamic programming application) to travel the tree upwards in a fast way."
  ],
  "code_snippets": {
    "cpp": "class TreeAncestor {\npublic:\n    TreeAncestor(int n, vector<int>& parent) {\n        \n    }\n    \n    int getKthAncestor(int node, int k) {\n        \n    }\n};\n\n/**\n * Your TreeAncestor object will be instantiated and called as such:\n * TreeAncestor* obj = new TreeAncestor(n, parent);\n * int param_1 = obj->getKthAncestor(node,k);\n */",
    "java": "class TreeAncestor {\n\n    public TreeAncestor(int n, int[] parent) {\n        \n    }\n    \n    public int getKthAncestor(int node, int k) {\n        \n    }\n}\n\n/**\n * Your TreeAncestor object will be instantiated and called as such:\n * TreeAncestor obj = new TreeAncestor(n, parent);\n * int param_1 = obj.getKthAncestor(node,k);\n */",
    "python": "class TreeAncestor(object):\n\n    def __init__(self, n, parent):\n        \"\"\"\n        :type n: int\n        :type parent: List[int]\n        \"\"\"\n        \n\n    def getKthAncestor(self, node, k):\n        \"\"\"\n        :type node: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n\n\n# Your TreeAncestor object will be instantiated and called as such:\n# obj = TreeAncestor(n, parent)\n# param_1 = obj.getKthAncestor(node,k)",
    "python3": "class TreeAncestor:\n\n    def __init__(self, n: int, parent: List[int]):\n        \n\n    def getKthAncestor(self, node: int, k: int) -> int:\n        \n\n\n# Your TreeAncestor object will be instantiated and called as such:\n# obj = TreeAncestor(n, parent)\n# param_1 = obj.getKthAncestor(node,k)",
    "c": "\n\n\ntypedef struct {\n    \n} TreeAncestor;\n\n\nTreeAncestor* treeAncestorCreate(int n, int* parent, int parentSize) {\n    \n}\n\nint treeAncestorGetKthAncestor(TreeAncestor* obj, int node, int k) {\n    \n}\n\nvoid treeAncestorFree(TreeAncestor* obj) {\n    \n}\n\n/**\n * Your TreeAncestor struct will be instantiated and called as such:\n * TreeAncestor* obj = treeAncestorCreate(n, parent, parentSize);\n * int param_1 = treeAncestorGetKthAncestor(obj, node, k);\n \n * treeAncestorFree(obj);\n*/",
    "csharp": "public class TreeAncestor {\n\n    public TreeAncestor(int n, int[] parent) {\n        \n    }\n    \n    public int GetKthAncestor(int node, int k) {\n        \n    }\n}\n\n/**\n * Your TreeAncestor object will be instantiated and called as such:\n * TreeAncestor obj = new TreeAncestor(n, parent);\n * int param_1 = obj.GetKthAncestor(node,k);\n */",
    "javascript": "/**\n * @param {number} n\n * @param {number[]} parent\n */\nvar TreeAncestor = function(n, parent) {\n    \n};\n\n/** \n * @param {number} node \n * @param {number} k\n * @return {number}\n */\nTreeAncestor.prototype.getKthAncestor = function(node, k) {\n    \n};\n\n/** \n * Your TreeAncestor object will be instantiated and called as such:\n * var obj = new TreeAncestor(n, parent)\n * var param_1 = obj.getKthAncestor(node,k)\n */",
    "typescript": "class TreeAncestor {\n    constructor(n: number, parent: number[]) {\n        \n    }\n\n    getKthAncestor(node: number, k: number): number {\n        \n    }\n}\n\n/**\n * Your TreeAncestor object will be instantiated and called as such:\n * var obj = new TreeAncestor(n, parent)\n * var param_1 = obj.getKthAncestor(node,k)\n */",
    "php": "class TreeAncestor {\n    /**\n     * @param Integer $n\n     * @param Integer[] $parent\n     */\n    function __construct($n, $parent) {\n        \n    }\n  \n    /**\n     * @param Integer $node\n     * @param Integer $k\n     * @return Integer\n     */\n    function getKthAncestor($node, $k) {\n        \n    }\n}\n\n/**\n * Your TreeAncestor object will be instantiated and called as such:\n * $obj = TreeAncestor($n, $parent);\n * $ret_1 = $obj->getKthAncestor($node, $k);\n */",
    "swift": "\nclass TreeAncestor {\n\n    init(_ n: Int, _ parent: [Int]) {\n        \n    }\n    \n    func getKthAncestor(_ node: Int, _ k: Int) -> Int {\n        \n    }\n}\n\n/**\n * Your TreeAncestor object will be instantiated and called as such:\n * let obj = TreeAncestor(n, parent)\n * let ret_1: Int = obj.getKthAncestor(node, k)\n */",
    "kotlin": "class TreeAncestor(n: Int, parent: IntArray) {\n\n    fun getKthAncestor(node: Int, k: Int): Int {\n        \n    }\n\n}\n\n/**\n * Your TreeAncestor object will be instantiated and called as such:\n * var obj = TreeAncestor(n, parent)\n * var param_1 = obj.getKthAncestor(node,k)\n */",
    "dart": "class TreeAncestor {\n\n  TreeAncestor(int n, List<int> parent) {\n    \n  }\n  \n  int getKthAncestor(int node, int k) {\n    \n  }\n}\n\n/**\n * Your TreeAncestor object will be instantiated and called as such:\n * TreeAncestor obj = TreeAncestor(n, parent);\n * int param1 = obj.getKthAncestor(node,k);\n */",
    "golang": "type TreeAncestor struct {\n    \n}\n\n\nfunc Constructor(n int, parent []int) TreeAncestor {\n    \n}\n\n\nfunc (this *TreeAncestor) GetKthAncestor(node int, k int) int {\n    \n}\n\n\n/**\n * Your TreeAncestor object will be instantiated and called as such:\n * obj := Constructor(n, parent);\n * param_1 := obj.GetKthAncestor(node,k);\n */",
    "ruby": "class TreeAncestor\n\n=begin\n    :type n: Integer\n    :type parent: Integer[]\n=end\n    def initialize(n, parent)\n        \n    end\n\n\n=begin\n    :type node: Integer\n    :type k: Integer\n    :rtype: Integer\n=end\n    def get_kth_ancestor(node, k)\n        \n    end\n\n\nend\n\n# Your TreeAncestor object will be instantiated and called as such:\n# obj = TreeAncestor.new(n, parent)\n# param_1 = obj.get_kth_ancestor(node, k)",
    "scala": "class TreeAncestor(_n: Int, _parent: Array[Int]) {\n\n    def getKthAncestor(node: Int, k: Int): Int = {\n        \n    }\n\n}\n\n/**\n * Your TreeAncestor object will be instantiated and called as such:\n * val obj = new TreeAncestor(n, parent)\n * val param_1 = obj.getKthAncestor(node,k)\n */",
    "rust": "struct TreeAncestor {\n\n}\n\n\n/** \n * `&self` means the method takes an immutable reference.\n * If you need a mutable reference, change it to `&mut self` instead.\n */\nimpl TreeAncestor {\n\n    fn new(n: i32, parent: Vec<i32>) -> Self {\n        \n    }\n    \n    fn get_kth_ancestor(&self, node: i32, k: i32) -> i32 {\n        \n    }\n}\n\n/**\n * Your TreeAncestor object will be instantiated and called as such:\n * let obj = TreeAncestor::new(n, parent);\n * let ret_1: i32 = obj.get_kth_ancestor(node, k);\n */",
    "racket": "(define tree-ancestor%\n  (class object%\n    (super-new)\n    \n    ; n : exact-integer?\n    ; parent : (listof exact-integer?)\n    (init-field\n      n\n      parent)\n    \n    ; get-kth-ancestor : exact-integer? exact-integer? -> exact-integer?\n    (define/public (get-kth-ancestor node k)\n      )))\n\n;; Your tree-ancestor% object will be instantiated and called as such:\n;; (define obj (new tree-ancestor% [n n] [parent parent]))\n;; (define param_1 (send obj get-kth-ancestor node k))",
    "erlang": "-spec tree_ancestor_init_(N :: integer(), Parent :: [integer()]) -> any().\ntree_ancestor_init_(N, Parent) ->\n  .\n\n-spec tree_ancestor_get_kth_ancestor(Node :: integer(), K :: integer()) -> integer().\ntree_ancestor_get_kth_ancestor(Node, K) ->\n  .\n\n\n%% Your functions will be called as such:\n%% tree_ancestor_init_(N, Parent),\n%% Param_1 = tree_ancestor_get_kth_ancestor(Node, K),\n\n%% tree_ancestor_init_ will be called before every test case, in which you can do some necessary initializations.",
    "elixir": "defmodule TreeAncestor do\n  @spec init_(n :: integer, parent :: [integer]) :: any\n  def init_(n, parent) do\n    \n  end\n\n  @spec get_kth_ancestor(node :: integer, k :: integer) :: integer\n  def get_kth_ancestor(node, k) do\n    \n  end\nend\n\n# Your functions will be called as such:\n# TreeAncestor.init_(n, parent)\n# param_1 = TreeAncestor.get_kth_ancestor(node, k)\n\n# TreeAncestor.init_ will be called before every test case, in which you can do some necessary initializations."
  }
}