{
  "title": "Maximum Running Time of N Computers",
  "problem_id": "2263",
  "frontend_id": "2141",
  "difficulty": "Hard",
  "problem_slug": "maximum-running-time-of-n-computers",
  "topics": [
    "Array",
    "Binary Search",
    "Greedy",
    "Sorting"
  ],
  "description": "You have n computers. You are given the integer n and a 0-indexed integer array batteries where the ith battery can run a computer for batteries[i] minutes. You are interested in running all n computers simultaneously using the given batteries.\nInitially, you can insert at most one battery into each computer. After that and at any integer time moment, you can remove a battery from a computer and insert another battery any number of times. The inserted battery can be a totally new battery or a battery from another computer. You may assume that the removing and inserting processes take no time.\nNote that the batteries cannot be recharged.\nReturn the maximum number of minutes you can run all the n computers simultaneously.\nExample 1:\nExample 2:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: n = 2, batteries = [3,3,3]\nOutput: 4\nExplanation: \nInitially, insert battery 0 into the first computer and battery 1 into the second computer.\nAfter two minutes, remove battery 1 from the second computer and insert battery 2 instead. Note that battery 1 can still run for one minute.\nAt the end of the third minute, battery 0 is drained, and you need to remove it from the first computer and insert battery 1 instead.\nBy the end of the fourth minute, battery 1 is also drained, and the first computer is no longer running.\nWe can run the two computers simultaneously for at most 4 minutes, so we return 4.",
      "images": [
        "https://assets.leetcode.com/uploads/2022/01/06/example1-fit.png"
      ]
    },
    {
      "example_num": 2,
      "example_text": "Input: n = 2, batteries = [1,1,1,1]\nOutput: 2\nExplanation: \nInitially, insert battery 0 into the first computer and battery 2 into the second computer. \nAfter one minute, battery 0 and battery 2 are drained so you need to remove them and insert battery 1 into the first computer and battery 3 into the second computer. \nAfter another minute, battery 1 and battery 3 are also drained so the first and second computers are no longer running.\nWe can run the two computers simultaneously for at most 2 minutes, so we return 2.",
      "images": [
        "https://assets.leetcode.com/uploads/2022/01/06/example2.png"
      ]
    }
  ],
  "constraints": [
    "1 <= n <= batteries.length <= 105",
    "1 <= batteries[i] <= 109"
  ],
  "follow_ups": [],
  "hints": [
    "For a given running time, can you determine if it is possible to run all n computers simultaneously?",
    "Try to use Binary Search to find the maximal running time"
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    long long maxRunTime(int n, vector<int>& batteries) {\n        \n    }\n};",
    "java": "class Solution {\n    public long maxRunTime(int n, int[] batteries) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def maxRunTime(self, n, batteries):\n        \"\"\"\n        :type n: int\n        :type batteries: List[int]\n        :rtype: int\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def maxRunTime(self, n: int, batteries: List[int]) -> int:\n        ",
    "c": "long long maxRunTime(int n, int* batteries, int batteriesSize) {\n    \n}",
    "csharp": "public class Solution {\n    public long MaxRunTime(int n, int[] batteries) {\n        \n    }\n}",
    "javascript": "/**\n * @param {number} n\n * @param {number[]} batteries\n * @return {number}\n */\nvar maxRunTime = function(n, batteries) {\n    \n};",
    "typescript": "function maxRunTime(n: number, batteries: number[]): number {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param Integer $n\n     * @param Integer[] $batteries\n     * @return Integer\n     */\n    function maxRunTime($n, $batteries) {\n        \n    }\n}",
    "swift": "class Solution {\n    func maxRunTime(_ n: Int, _ batteries: [Int]) -> Int {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun maxRunTime(n: Int, batteries: IntArray): Long {\n        \n    }\n}",
    "dart": "class Solution {\n  int maxRunTime(int n, List<int> batteries) {\n    \n  }\n}",
    "golang": "func maxRunTime(n int, batteries []int) int64 {\n    \n}",
    "ruby": "# @param {Integer} n\n# @param {Integer[]} batteries\n# @return {Integer}\ndef max_run_time(n, batteries)\n    \nend",
    "scala": "object Solution {\n    def maxRunTime(n: Int, batteries: Array[Int]): Long = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn max_run_time(n: i32, batteries: Vec<i32>) -> i64 {\n        \n    }\n}",
    "racket": "(define/contract (max-run-time n batteries)\n  (-> exact-integer? (listof exact-integer?) exact-integer?)\n  )",
    "erlang": "-spec max_run_time(N :: integer(), Batteries :: [integer()]) -> integer().\nmax_run_time(N, Batteries) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec max_run_time(n :: integer, batteries :: [integer]) :: integer\n  def max_run_time(n, batteries) do\n    \n  end\nend"
  },
  "solution": "[TOC]\n\n## Solution\n\n--- \n\n### Overview\n\nFrom the first example, let's try another distribution plan first. Suppose we let 2 batteries support 2 computers continuously, we will end up with 2 empty batteries and 1 full battery. Then the running time is fixed at `3` since we can't use the only battery left to support 2 computers simultaneously.\n\n\n![img](../Figures/2141/intro.png)\n\nIt implies that there is a strategy to distribute the batteries properly. Let's move on to finding the best patterns.\n\n\n---\n\n### Approach 1: Sorting and Prefix Sum\n\n\n#### Intuition   \n\nFirst, we simplify the original problem a little bit:\n\n**Suppose we have 4 computers (named A, B, C and D) and have to pick exactly 4 batteries. What is the maximum running time?**\n\nThis is quite straightforward. We just pick the largest 4 batteries and let them support these 4 computers separately (let's call the list that contains these 4 batteries `live`), and the running time is determined by the smallest battery picked.\n\n\n![img](../Figures/2141/n4.png)\n\n**What if we are allowed to pick a 5th battery?**\n\nLet's pick the largest battery that isn't in use. Clearly, the smallest of these 4 batteries will be the bottleneck, so we use the power in the 5th battery to increase the running time of computer A that has the smallest battery.\n\n![img](../Figures/2141/n5.png)\n\n\n\n**What if we are allowed to pick more batteries?**\n\nWe can freely use every battery except the largest 4 to increase the total running time. Because we can freely swap batteries in 0 time, all the extra power is interchangeable. We can take this extra power and \"transfer\" it to the batteries in `live`. Let `extra` be the sum of all the extra power.\n\n\nLet's say live is sorted. We try using some of our extra power to increase live[0] running time to live[1]. In the process, `extra -= live[1] - live[0]`.\n\n\n![img](../Figures/2141/n6.png)\n\nNow, `live[0] = live[1]`. Can we continue? We try increasing the running time to `live[2]`. However, not only would we need to increase `live[1]` to `live[2]`, we also need to increase `live[0]` to `live[2]` so it doesn't bottleneck the running time. We already spent some power to increase `live[0]` to `live[1]`, so we just need to spend twice as much power as the difference `live[2] - live[1]`.\n\n\n\n![img](../Figures/2141/n70.png)\n\nNow we have `live[0] = live[1] = live[2]`. If we want to increase the running time to `live[3]`, we need to spend three times as much power as the difference `(live[3] - live[2])`.![img](../Figures/2141/n71.png)\n\n\nOops, seems we are running out of `extra` power before reaching `live[3]`, so the bottleneck is decided by `live[2]`. We have some extra power remaining, so we do our best to increase the running time by evenly splitting the remaining power to the computers  (`extra / 3`).What if we have an example where `extra` is large enough to support all batteries in `live` becoming equal to `live[n - 1]`. Any remaining power in `extra` should similarly be evenly split across all the computers to increase the final running time. The final running time is determined by `live[n - 1]` plus the extra running time we can make using `extra` power, which is `extra / n`.\n\n\n![img](../Figures/2141/n8.png)\n\n\nTo generalize, at each battery `live[i]`, if we want to increase the running time to `live[i + 1]`, we need to spend `(i + 1)` times as much power as `(live[i + 1] - live[i])`. With this formula, we don't actually need to update the values of `live`. Since after each iteration, we already know that `live[0] = live[1] = ... = live[i]`.\n\nWe iterate through `live` until we either cannot afford to increase to `live[i + 1]` anymore, or we manage to iterate through the entire array. In both cases, we do our best to evenly allocate the remaining extra power.You may be thinking that in the case below, since there is some unused power in the larger batteries (like the largest battery on the right), can we further increase the total running time using this unused power? The answer is NO. \n\n![img](../Figures/2141/n7.png)\n\nAs shown in the following picture, suppose we do allocate the power \"equally\" by using the excess power of the largest battery (colored in red) on other computers. It means that there are times when the red battery is used on other computers, but the same battery also supports the computer D **all the time**. This contradicts the rule that *one battery can't support more than one computer at the same time*.\n\n![img](../Figures/2141/7.png)\n\nTherefore, we observe the pattern that:\n\n> If a battery `batteries[i]` has more power than the total running time, there is no way we can use its excess power to further increase the running time. Therefore, once we have picked the largest `n` batteries and assign them to `n` computers, these batteries are tied to their computer and swapping them does not bring any longer running time.#### Algorithm\n\n1) Sort `batteries`. \n\n2) Find the largest `n` batteries and assign them to `n` computers, these `n` batteries are exclusively used by each computer and cannot be shared with other computers. Create an array `live` that contains the largest `n` batteries in sorted order, which represents the `n` computers.\n\n3) Sum up the power of the remaining batteries as `extra`.\n\n4) Iterate over `live` from `0` to `n - 2`, for each index `i`:\n    - If `extra` power can increase the running time of the first `i` computers from `live[i]` to `live[i + 1]`, then we subtract the required power from `extra` and move on to the next index.\n    - Otherwise, we have to stop at this point and return `live[i] + extra / (i + 1)`.\n\n5) If there is still power left after the iteration, it means we can further increase the total running time of `n` computers from `live[n - 1]` by `extra / n`. Therefore, return `live[n - 1] + extra / n`.\n\n#### Implementation#### Complexity Analysis\n\nLet $$m$$ be the length of the input array `batteries`.\n\n* Time complexity: $$O(m \\cdot\\log m)$$\n\n    - We sort $$\\text{batteries}$$ in place, it takes $$O(m \\cdot\\log m)$$ time.\n    - Picking the largest n-th batteries from a sorted array takes $$O(n)$$ time. Note that since $n < m$, this term will be dominated.\n\n    - Then we iterate over the remaining part of the `batteries`, the computation at each step takes constant time. Thus it takes $$O(m)$$ time to finish the iteration.\n    - To sum up, the overall time complexity is $$O(m \\cdot\\log m)$$.\n    \n\n* Space complexity: $$O(m)$$\n\n    - Some extra space is used when we sort $$\\text{batteries}$$ in place. The space complexity of the sorting algorithm depends on the programming language.\n        - In python, the `sort` method sorts a list using the Timsort algorithm, which is a combination of Merge Sort and Insertion Sort and uses $$O(m)$$ additional space.\n        - In Java, Arrays.sort() is implemented using a variant of the Quick Sort algorithm which has a space complexity of $$O(\\log m)$$.\n    - We create an array of size $$O(n)$$ to record the power (running time) of each computer.\n    - To sum up, the overall space complexity is $$O(m)$$.---\n\n### Approach 2: Binary Search\n\n#### Intuition   \n\nIn the previous approach, we began by selecting the largest `n` batteries (one for each computer) and then assigning the remaining power `extra` to these computers using a greedy approach until we reach the longest running time.\n\nAlternatively, we can first set a target running time, `target`, then try to reach this running time using all batteries.\n\n\n![img](../Figures/2141/b1.png)\n\nHere we still take advantage of the conclusion we reached at the end of the previous approach (Please refer to the previous approach):\n- If the power of a battery is smaller than `target`, we can use all of its power. \n- If the power of a battery is larger than `target`, we can only use `target` power from it.\n\n\n![img](../Figures/2141/b2.png)\n\nTherefore, we can traverse through `batteries` and collect all the power that can be used. If the sum of collected power is larger than or equal to `target * n`, all computers can run for `target` time. \n\n\nAs shown in the picture above, suppose we set a running time `target`, then we collect power from all batteries (colored in green). Finally, we check if the sum of the collected power is larger than or equals to `target * 2`.\n\n**How to find the largest running time?**\n\nInstead of trying every `target` from `1` until finding the largest possible running time, we can take advantage of binary search to locate the largest `target` faster than linear search.\n\n![img](../Figures/2141/b3.png)\n\nInitially, we set the left boundary as `1` as the minimum possible running time. Assuming we can use all the power perfectly, the maximum running time is `sum(batteries) / n`, so we set the right boundary as `sum(batteries) / n`. As a result, the largest `target` is limited to the inclusive range `[left, right]`, and we can apply binary search in this range to find it.#### Algorithm\n\n1) Initialize the boundaries of the search space as `left = 1`, and `right = sum(batteries) / n`.\n\n\n2) While `left < right`:\n    - Find the middle value `target = right - (right - left) / 2`.\n    - Check if batteries can support `n` computers run `target` time. Iterate over `batteries` and record `extra`, the accumulative sum of `min(batteries[i], target)`.\n\n3) Check if `extra >= n * target`:\n    - If so, set `left = target` and repeat step 2.\n    - Otherwise, set `right = target - 1` and repeat step 2.\n\n4) Once the binary search ends, return `left`.\n\n\n#### Implementation#### Complexity Analysis\n\nLet $$m$$ be the length of the input array `batteries` and $$k$$ be the maximum power of one battery.\n\n* Time complexity: $$O(m \\cdot\\log k)$$\n\n    - Initially, we set `1` as the left boundary and `sum(batteries) / n` as the right boundary. Thus it takes $$O(\\log (\\frac{m\\cdot k}{n}))$$ steps to locate the maximum running time in the worst-case scenario.\n    - At each step, we need to iterate over `batteries` to add up the power that can be used, which takes $$O(m)$$ time.\n    - Therefore, the overall time complexity is $$O(m \\cdot\\log (\\frac{m\\cdot k}{n})) = O(m\\cdot \\log k)$$\n    $$, k \\gg m, n$$\n\n\n    \n\n* Space complexity: $$O(1)$$\n\n    - During the binary search, we only need to record the boundaries of the searching space and the power `extra`, and the accumulative sum of `extra`, which only takes constant space."
}