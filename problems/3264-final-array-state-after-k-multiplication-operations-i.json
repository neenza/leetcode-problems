{
  "title": "Final Array State After K Multiplication Operations I",
  "problem_id": "3555",
  "frontend_id": "3264",
  "difficulty": "Easy",
  "problem_slug": "final-array-state-after-k-multiplication-operations-i",
  "topics": [
    "Array",
    "Math",
    "Heap (Priority Queue)",
    "Simulation"
  ],
  "description": "You are given an integer array nums, an integer k, and an integer multiplier.\nYou need to perform k operations on nums. In each operation:\nReturn an integer array denoting the final state of nums after performing all k operations.\nExample 1:\nExample 2:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: nums = [2,1,3,5,6], k = 5, multiplier = 2\nOutput: [8,4,6,5,6]\nExplanation:",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input: nums = [1,2], k = 3, multiplier = 4\nOutput: [16,8]\nExplanation:",
      "images": []
    }
  ],
  "constraints": [
    "1 <= nums.length <= 100",
    "1 <= nums[i] <= 100",
    "1 <= k <= 10",
    "1 <= multiplier <= 5"
  ],
  "follow_ups": [],
  "hints": [
    "Maintain sorted pairs <code>(nums[index], index)</code> in a priority queue.",
    "Simulate the operation <code>k</code> times."
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    vector<int> getFinalState(vector<int>& nums, int k, int multiplier) {\n        \n    }\n};",
    "java": "class Solution {\n    public int[] getFinalState(int[] nums, int k, int multiplier) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def getFinalState(self, nums, k, multiplier):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :type multiplier: int\n        :rtype: List[int]\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def getFinalState(self, nums: List[int], k: int, multiplier: int) -> List[int]:\n        ",
    "c": "/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nint* getFinalState(int* nums, int numsSize, int k, int multiplier, int* returnSize) {\n    \n}",
    "csharp": "public class Solution {\n    public int[] GetFinalState(int[] nums, int k, int multiplier) {\n        \n    }\n}",
    "javascript": "/**\n * @param {number[]} nums\n * @param {number} k\n * @param {number} multiplier\n * @return {number[]}\n */\nvar getFinalState = function(nums, k, multiplier) {\n    \n};",
    "typescript": "function getFinalState(nums: number[], k: number, multiplier: number): number[] {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @param Integer $k\n     * @param Integer $multiplier\n     * @return Integer[]\n     */\n    function getFinalState($nums, $k, $multiplier) {\n        \n    }\n}",
    "swift": "class Solution {\n    func getFinalState(_ nums: [Int], _ k: Int, _ multiplier: Int) -> [Int] {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun getFinalState(nums: IntArray, k: Int, multiplier: Int): IntArray {\n        \n    }\n}",
    "dart": "class Solution {\n  List<int> getFinalState(List<int> nums, int k, int multiplier) {\n    \n  }\n}",
    "golang": "func getFinalState(nums []int, k int, multiplier int) []int {\n    \n}",
    "ruby": "# @param {Integer[]} nums\n# @param {Integer} k\n# @param {Integer} multiplier\n# @return {Integer[]}\ndef get_final_state(nums, k, multiplier)\n    \nend",
    "scala": "object Solution {\n    def getFinalState(nums: Array[Int], k: Int, multiplier: Int): Array[Int] = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn get_final_state(nums: Vec<i32>, k: i32, multiplier: i32) -> Vec<i32> {\n        \n    }\n}",
    "racket": "(define/contract (get-final-state nums k multiplier)\n  (-> (listof exact-integer?) exact-integer? exact-integer? (listof exact-integer?))\n  )",
    "erlang": "-spec get_final_state(Nums :: [integer()], K :: integer(), Multiplier :: integer()) -> [integer()].\nget_final_state(Nums, K, Multiplier) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec get_final_state(nums :: [integer], k :: integer, multiplier :: integer) :: [integer]\n  def get_final_state(nums, k, multiplier) do\n    \n  end\nend"
  },
  "solution": "[TOC]\n\n## Solution\n\n---\n\n### Overview\n\nWe need to perform `k` operations on an integer array. In each operation, we identify the smallest value, multiply it by a given multiplier, and then replace the original value with the new one. The main challenge is to efficiently track and update the smallest element in the array. \n\nThis kind of problem often arises in resource management scenarios, where tasks or items need to be prioritized or adjusted based on criteria such as price or urgency. \n\n---\n\n### Approach 1: K Full Array Scans for Minimum Element Multiplication\n\n#### Intuition\n\nFirst, let's consider the task: repeatedly finding the smallest value in an array and updating it. We know that every time we modify the smallest value, it might no longer be the smallest element in the array. This means we need to evaluate the entire array again to find the next smallest value. This tells us that finding the minimum at each step is a key part of the process.\n\nNow, think about how we find the smallest value. To ensure we always pick the first occurrence of the minimum when there are duplicates, we need to check each element in the array in order. As we go through the array, we compare the values we encounter with the smallest value we've seen so far. If we find a smaller value, we update our record of what the smallest value is and where itâ€™s located.\n\nOnce we know where the smallest value is, the next step is to modify it. We multiply the value by the `multiplier` and replace it in its original position. With this updated array, we repeat the same process to find and modify the smallest value a total of `k` times.\n\n#### Algorithm\n\n1. The length of the array `nums` is stored in `n`.\n2. The outer loop runs `k` times. Each iteration represents one operation where the smallest element in the array is identified and modified. \n3. Inside the outer loop, we initialize `min_index` to `0`. Then, we start iterating over the array with the inner loop.\n4. The inner loop runs from `i = 0` to `i = n - 1`. For each element in the array, we check if the current element `nums[i]` is smaller than the element at the current `min_index`. If it is, we update `min_index` to `i`.\n5. After the inner loop finishes the smallest element is multiplied by the `multiplier`, and the result is stored back at the `min_index` position in the array.\n6. Once all `k` iterations are complete, the final state of the array is returned.\n\n#### ImplementationLet $N$ be the length of `nums`.\n\n* Time Complexity: $O(N \\cdot k)$\n\n    The approach iterates through the `nums` list `k` times, where each iteration involves locating the index of the smallest element. This requires a full scan of the array, which incurs an $O(N)$ time complexity. Given that each operation within the inner loop is performed in constant time, the overall time complexity amounts to $O(N \\cdot k)$.\n\n* Space Complexity: $O(1)$\n    \n    The approach uses a fixed amount of extra space, independent of the input array `nums` size. It uses only a few variables - such as `n`, `min_index`, and loop counters to track intermediate values. Thus, the space complexity remains constant.\n\n---\n\n### Approach 2: Heap-Optimized K Minimum Value Multiplication\n\n#### Intuition\n\nIn the previous approach, we were doing full array scans to find the minimum element. To optimize this, we can use a data structure that is designed for quickly retrieving and modifying the smallest element: a heap. A heap allows us to access the smallest element in constant time and efficiently supports removing and inserting elements with logarithmic time complexity.\n\nTo implement this, we can start by creating a list where each element is paired with its index in the original array. The index is crucial because after modifying an element, we need to know where to place the updated value in the array. This way, we can keep track of the original position of each element while sorting them based on their values.\n\nOnce the list is created, we convert it into a heap. In a heap, the smallest element can be accessed and removed efficiently. For each of the `k` operations, we need to perform 3 steps:\n\n1. Pop the smallest element from the heap: This gives us both the value of the smallest element and its index in the original array.\n2. Multiply the value by the `multiplier`: Update the array at the corresponding index with this new value.\n3. Push the modified value back into the heap: Include its index so that it can be considered for future operations.\n\nAfter completing all `k` operations, we return the modified array.\n\n!?!../Documents/3264/3264_approach_2.json:3000,1687!?!\n\n> For a more comprehensive understanding of heaps and priority queues, check out the [Heap Explore Card ðŸ”—](https://leetcode.com/explore/learn/card/heap/). This resource provides an in-depth look at heap-based algorithms, explaining their key concepts and applications with a variety of problems to solidify understanding of the pattern.\n\n#### Algorithm\n\n1. Create a list where each element is paired with its index from the input `nums`.\n2. Convert the list into a heap.\n3. Loop through the process `k` times, where each iteration represents one operation of finding and updating the smallest value.\n4. In each iteration, remove the smallest element from the heap, which gives us both the value and its index in the original array.\n5. Multiply the value at the identified index by the `multiplier` and update the value in `nums`.\n6. Insert the updated value and its index back into the heap.\n7. After completing all `k` operations, return the updated array.\n\n#### Implementation \n\n> Note: Heap sort is an unstable sorting algorithm, meaning the relative order of equal-valued elements may not be preserved. While the implementation in the language below preserves order, special care must be taken when implementing in other languages to ensure the first occurrence of the minimum value is selected correctly.Let $N$ be the length of `nums`.\n\n* Time Complexity: $O(N + k \\cdot \\log N)$\n\n    The approach uses a heap (priority queue) to efficiently find and update the smallest element in the `nums` list. Initially, building the heap takes $O(N)$ time. \n    \n    Each of the `k` iterations involves removing the smallest element from the heap and then reinserting the updated element. Both the removal and insertion operations take $O(\\log N)$ time. \n    \n    Therefore, the total time complexity for `k` iterations is $O(k \\cdot \\log N)$, resulting in a total time complexity of $O(N + k \\cdot \\log N)$.\n    \n    > Note: The time complexity of the Java solution is $O(N \\cdot \\log N + k \\cdot \\log N)$ because we aren't using an inbuilt heapify method in Java.\n\n* Space Complexity: $O(N)$\n\n    The approach uses a heap to store the elements of the `nums` list along with their indices. The heap requires additional space proportional to the number of elements in the `nums` list. \n    \n    Therefore, the space complexity is $O(N)$.\n\n---"
}