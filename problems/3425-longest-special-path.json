{
  "title": "Longest Special Path",
  "problem_id": "3687",
  "frontend_id": "3425",
  "difficulty": "Hard",
  "problem_slug": "longest-special-path",
  "topics": [
    "Array",
    "Hash Table",
    "Tree",
    "Depth-First Search",
    "Prefix Sum"
  ],
  "description": "You are given an undirected tree rooted at node 0 with n nodes numbered from 0 to n - 1, represented by a 2D array edges of length n - 1, where edges[i] = [ui, vi, lengthi] indicates an edge between nodes ui and vi with length lengthi. You are also given an integer array nums, where nums[i] represents the value at node i.\nA special path is defined as a downward path from an ancestor node to a descendant node such that all the values of the nodes in that path are unique.\nNote that a path may start and end at the same node.\nReturn an array result of size 2, where result[0] is the length of the longest special path, and result[1] is the minimum number of nodes in all possible longest special paths.\nExample 1:\nExample 2:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: edges = [[0,1,2],[1,2,3],[1,3,5],[1,4,4],[2,5,6]], nums = [2,1,2,1,3,1]\nOutput: [6,2]\nExplanation:\n\nThe longest special paths are 2 -> 5 and 0 -> 1 -> 4 , both having a length of 6. The minimum number of nodes across all longest special paths is 2.",
      "images": [
        "https://assets.leetcode.com/uploads/2024/11/02/tree3.jpeg"
      ]
    },
    {
      "example_num": 2,
      "example_text": "Input: edges = [[1,0,8]], nums = [2,2]\nOutput: [0,1]\nExplanation:\n\nThe longest special paths are 0 and 1 , both having a length of 0. The minimum number of nodes across all longest special paths is 1.",
      "images": [
        "https://assets.leetcode.com/uploads/2024/11/02/tree4.jpeg"
      ]
    }
  ],
  "constraints": [
    "2 <= n <= 5 * 104",
    "edges.length == n - 1",
    "edges[i].length == 3",
    "0 <= ui, vi < n",
    "1 <= lengthi <= 103",
    "nums.length == n",
    "0 <= nums[i] <= 5 * 104",
    "The input is generated such that edges represents a valid tree."
  ],
  "follow_ups": [],
  "hints": [
    "Use DFS to traverse the tree and maintain the current path length from the root (starting at 0) to the current node.",
    "Use prefix sums to calculate the longest path ending at the current node with all unique values."
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    vector<int> longestSpecialPath(vector<vector<int>>& edges, vector<int>& nums) {\n        \n    }\n};",
    "java": "class Solution {\n    public int[] longestSpecialPath(int[][] edges, int[] nums) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def longestSpecialPath(self, edges, nums):\n        \"\"\"\n        :type edges: List[List[int]]\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def longestSpecialPath(self, edges: List[List[int]], nums: List[int]) -> List[int]:\n        ",
    "c": "/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nint* longestSpecialPath(int** edges, int edgesSize, int* edgesColSize, int* nums, int numsSize, int* returnSize) {\n    \n}",
    "csharp": "public class Solution {\n    public int[] LongestSpecialPath(int[][] edges, int[] nums) {\n        \n    }\n}",
    "javascript": "/**\n * @param {number[][]} edges\n * @param {number[]} nums\n * @return {number[]}\n */\nvar longestSpecialPath = function(edges, nums) {\n    \n};",
    "typescript": "function longestSpecialPath(edges: number[][], nums: number[]): number[] {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param Integer[][] $edges\n     * @param Integer[] $nums\n     * @return Integer[]\n     */\n    function longestSpecialPath($edges, $nums) {\n        \n    }\n}",
    "swift": "class Solution {\n    func longestSpecialPath(_ edges: [[Int]], _ nums: [Int]) -> [Int] {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun longestSpecialPath(edges: Array<IntArray>, nums: IntArray): IntArray {\n        \n    }\n}",
    "dart": "class Solution {\n  List<int> longestSpecialPath(List<List<int>> edges, List<int> nums) {\n    \n  }\n}",
    "golang": "func longestSpecialPath(edges [][]int, nums []int) []int {\n    \n}",
    "ruby": "# @param {Integer[][]} edges\n# @param {Integer[]} nums\n# @return {Integer[]}\ndef longest_special_path(edges, nums)\n    \nend",
    "scala": "object Solution {\n    def longestSpecialPath(edges: Array[Array[Int]], nums: Array[Int]): Array[Int] = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn longest_special_path(edges: Vec<Vec<i32>>, nums: Vec<i32>) -> Vec<i32> {\n        \n    }\n}",
    "racket": "(define/contract (longest-special-path edges nums)\n  (-> (listof (listof exact-integer?)) (listof exact-integer?) (listof exact-integer?))\n  )",
    "erlang": "-spec longest_special_path(Edges :: [[integer()]], Nums :: [integer()]) -> [integer()].\nlongest_special_path(Edges, Nums) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec longest_special_path(edges :: [[integer]], nums :: [integer]) :: [integer]\n  def longest_special_path(edges, nums) do\n    \n  end\nend"
  }
}