{
  "title": "Delete Nodes From Linked List Present in Array",
  "problem_id": "3501",
  "frontend_id": "3217",
  "difficulty": "Medium",
  "problem_slug": "delete-nodes-from-linked-list-present-in-array",
  "topics": [
    "Array",
    "Hash Table",
    "Linked List"
  ],
  "description": "You are given an array of integers nums and the head of a linked list. Return the head of the modified linked list after removing all nodes from the linked list that have a value that exists in nums.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: nums = [1,2,3], head = [1,2,3,4,5]\nOutput: [4,5]\nExplanation:\n\nRemove the nodes with values 1, 2, and 3.",
      "images": [
        "https://assets.leetcode.com/uploads/2024/06/11/linkedlistexample0.png"
      ]
    },
    {
      "example_num": 2,
      "example_text": "Input: nums = [1], head = [1,2,1,2,1,2]\nOutput: [2,2,2]\nExplanation:\n\nRemove the nodes with value 1.",
      "images": [
        "https://assets.leetcode.com/uploads/2024/06/11/linkedlistexample1.png"
      ]
    },
    {
      "example_num": 3,
      "example_text": "Input: nums = [5], head = [1,2,3,4]\nOutput: [1,2,3,4]\nExplanation:\n\nNo node has value 5.",
      "images": [
        "https://assets.leetcode.com/uploads/2024/06/11/linkedlistexample2.png"
      ]
    }
  ],
  "constraints": [
    "1 <= nums.length <= 105",
    "1 <= nums[i] <= 105",
    "All elements in nums are unique.",
    "The number of nodes in the given list is in the range [1, 105].",
    "1 <= Node.val <= 105",
    "The input is generated such that there is at least one node in the linked list that has a value not present in nums."
  ],
  "follow_ups": [],
  "hints": [
    "Add all elements of <code>nums</code> into a Set.",
    "Scan the list to check if the current element should be deleted by checking the Set."
  ],
  "code_snippets": {
    "cpp": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* modifiedList(vector<int>& nums, ListNode* head) {\n        \n    }\n};",
    "java": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode modifiedList(int[] nums, ListNode head) {\n        \n    }\n}",
    "python": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def modifiedList(self, nums, head):\n        \"\"\"\n        :type nums: List[int]\n        :type head: Optional[ListNode]\n        :rtype: Optional[ListNode]\n        \"\"\"\n        ",
    "python3": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def modifiedList(self, nums: List[int], head: Optional[ListNode]) -> Optional[ListNode]:\n        ",
    "c": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     struct ListNode *next;\n * };\n */\nstruct ListNode* modifiedList(int* nums, int numsSize, struct ListNode* head) {\n    \n}",
    "csharp": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     public int val;\n *     public ListNode next;\n *     public ListNode(int val=0, ListNode next=null) {\n *         this.val = val;\n *         this.next = next;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode ModifiedList(int[] nums, ListNode head) {\n        \n    }\n}",
    "javascript": "/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {number[]} nums\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar modifiedList = function(nums, head) {\n    \n};",
    "typescript": "/**\n * Definition for singly-linked list.\n * class ListNode {\n *     val: number\n *     next: ListNode | null\n *     constructor(val?: number, next?: ListNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.next = (next===undefined ? null : next)\n *     }\n * }\n */\n\nfunction modifiedList(nums: number[], head: ListNode | null): ListNode | null {\n    \n};",
    "php": "/**\n * Definition for a singly-linked list.\n * class ListNode {\n *     public $val = 0;\n *     public $next = null;\n *     function __construct($val = 0, $next = null) {\n *         $this->val = $val;\n *         $this->next = $next;\n *     }\n * }\n */\nclass Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @param ListNode $head\n     * @return ListNode\n     */\n    function modifiedList($nums, $head) {\n        \n    }\n}",
    "swift": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     public var val: Int\n *     public var next: ListNode?\n *     public init() { self.val = 0; self.next = nil; }\n *     public init(_ val: Int) { self.val = val; self.next = nil; }\n *     public init(_ val: Int, _ next: ListNode?) { self.val = val; self.next = next; }\n * }\n */\nclass Solution {\n    func modifiedList(_ nums: [Int], _ head: ListNode?) -> ListNode? {\n        \n    }\n}",
    "kotlin": "/**\n * Example:\n * var li = ListNode(5)\n * var v = li.`val`\n * Definition for singly-linked list.\n * class ListNode(var `val`: Int) {\n *     var next: ListNode? = null\n * }\n */\nclass Solution {\n    fun modifiedList(nums: IntArray, head: ListNode?): ListNode? {\n        \n    }\n}",
    "dart": "/**\n * Definition for singly-linked list.\n * class ListNode {\n *   int val;\n *   ListNode? next;\n *   ListNode([this.val = 0, this.next]);\n * }\n */\nclass Solution {\n  ListNode? modifiedList(List<int> nums, ListNode? head) {\n    \n  }\n}",
    "golang": "/**\n * Definition for singly-linked list.\n * type ListNode struct {\n *     Val int\n *     Next *ListNode\n * }\n */\nfunc modifiedList(nums []int, head *ListNode) *ListNode {\n    \n}",
    "ruby": "# Definition for singly-linked list.\n# class ListNode\n#     attr_accessor :val, :next\n#     def initialize(val = 0, _next = nil)\n#         @val = val\n#         @next = _next\n#     end\n# end\n# @param {Integer[]} nums\n# @param {ListNode} head\n# @return {ListNode}\ndef modified_list(nums, head)\n    \nend",
    "scala": "/**\n * Definition for singly-linked list.\n * class ListNode(_x: Int = 0, _next: ListNode = null) {\n *   var next: ListNode = _next\n *   var x: Int = _x\n * }\n */\nobject Solution {\n    def modifiedList(nums: Array[Int], head: ListNode): ListNode = {\n        \n    }\n}",
    "rust": "// Definition for singly-linked list.\n// #[derive(PartialEq, Eq, Clone, Debug)]\n// pub struct ListNode {\n//   pub val: i32,\n//   pub next: Option<Box<ListNode>>\n// }\n// \n// impl ListNode {\n//   #[inline]\n//   fn new(val: i32) -> Self {\n//     ListNode {\n//       next: None,\n//       val\n//     }\n//   }\n// }\nimpl Solution {\n    pub fn modified_list(nums: Vec<i32>, head: Option<Box<ListNode>>) -> Option<Box<ListNode>> {\n        \n    }\n}",
    "racket": "; Definition for singly-linked list:\n#|\n\n; val : integer?\n; next : (or/c list-node? #f)\n(struct list-node\n  (val next) #:mutable #:transparent)\n\n; constructor\n(define (make-list-node [val 0])\n  (list-node val #f))\n\n|#\n\n(define/contract (modified-list nums head)\n  (-> (listof exact-integer?) (or/c list-node? #f) (or/c list-node? #f))\n  )",
    "erlang": "%% Definition for singly-linked list.\n%%\n%% -record(list_node, {val = 0 :: integer(),\n%%                     next = null :: 'null' | #list_node{}}).\n\n-spec modified_list(Nums :: [integer()], Head :: #list_node{} | null) -> #list_node{} | null.\nmodified_list(Nums, Head) ->\n  .",
    "elixir": "# Definition for singly-linked list.\n#\n# defmodule ListNode do\n#   @type t :: %__MODULE__{\n#           val: integer,\n#           next: ListNode.t() | nil\n#         }\n#   defstruct val: 0, next: nil\n# end\n\ndefmodule Solution do\n  @spec modified_list(nums :: [integer], head :: ListNode.t | nil) :: ListNode.t | nil\n  def modified_list(nums, head) do\n    \n  end\nend"
  },
  "solution": "[TOC]\n\n## Solution\n\n---\n\n### Approach: Hash Set\n\n#### Intuition\n\nThe first challenge is efficiently determining whether a linked list value exists in the `nums` array. A naive approach would involve searching through `nums` for each node, but this is inefficient for large arrays. Instead, we can use a Hash Set, which allows constant-time lookups. By adding all elements of `nums` to the set, we can check if a node should be removed by verifying if its value exists in constant time.\n\n> If you're unfamiliar with hash sets, you can refer to this LeetCode [Explore Card](https://leetcode.com/explore/learn/card/hash-table/183/combination-with-other-algorithms/) for an in-depth tutorial.\n\nWith the lookup mechanism in place, we handle the linked list. The head requires special attention, as removing it alters the starting point of the list. We loop through the list to remove nodes from the beginning if their values are found in the hash set, then store the updated head. After this loop, the modified `head` is stored as the new starting point of the linked list.\n\nNext, we traverse the rest of the list using a `current` node. As we iterate, we check if `current.next`'s value is in the hash set. If it is, we adjust `current.next` to skip over that node, removing it from the list.\n\nOnce the traversal is complete, we return the modified head of the list.\n\nThe algorithm is visualized below:\n\n!?!../Documents/3217/slideshow.json:1082,602!?!\n\n#### Algorithm\n\n- Initialize a set `valuesToRemove` and populate it with the values of the `nums` array.\n- While the `head` of the linked list is not null and the `head`'s value is present in `valuesToRemove`:\n  - Move `head` to `head.next`.\n- If the `head` is `null`, return `null` since all nodes have been removed.\n- Start iterating from the `head` of the modified list:\n  - For each node `current`, check if the value of the next node (`current.next`) is in the `valuesToRemove` set.\n    - If it is, skip the next node by updating `current.next` to `current.next.next`\n  - If it is not, move the `current` pointer to the next node in the list.\n- Return the updated `head` of the list.\n\n#### Implementation\n\n> Note: In C++, memory management is manual, unlike languages with automatic garbage collection (like Java or Python). When you remove a node from a linked list, its memory remains allocated unless you explicitly free it. In the solution provided below, the memory of each removed node is properly deallocated using `delete`. However, if you're working in a production environment or during an interview, ensure that you discuss how the list nodes were allocated (e.g., via `new`) and ensure they are deallocated appropriately to avoid memory leaks. If possible, consider using smart pointers (`std::shared_ptr` or `std::unique_ptr`) for automatic memory management, which can help simplify the code and avoid manual memory management issues.#### Complexity Analysis\n\nLet $m$ and $n$ be the lengths of the `nums` array and the linked list, respectively.\n\n- Time complexity: $O(m + n)$\n\n    Iterating through the `nums` array and inserting each element into the hash set takes $O(m)$ time, as each insertion into the set is $O(1)$ on average.\n\n    The algorithm traverses the entire linked list exactly once, checking if each node's value is in the hash set. This operation takes $O(n)$ time.\n\n    Thus, the overall time complexity of the algorithm is $O(m) + O(n) = O(m + n)$.  \n\n- Space complexity: $O(m)$\n\n    The hash set can store up to $m$ elements, one for each unique value in the `nums` array, leading to a space complexity of $O(m)$. All additional variables used take constant space.\n\n---"
}