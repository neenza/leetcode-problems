{
  "title": "Odd Even Jump",
  "problem_id": "1017",
  "frontend_id": "975",
  "difficulty": "Hard",
  "problem_slug": "odd-even-jump",
  "topics": [
    "Array",
    "Dynamic Programming",
    "Stack",
    "Sorting",
    "Monotonic Stack",
    "Ordered Set"
  ],
  "description": "You are given an integer array arr. From some starting index, you can make a series of jumps. The (1st, 3rd, 5th, ...) jumps in the series are called odd-numbered jumps, and the (2nd, 4th, 6th, ...) jumps in the series are called even-numbered jumps. Note that the jumps are numbered, not the indices.\nYou may jump forward from index i to index j (with i < j) in the following way:\nA starting index is good if, starting from that index, you can reach the end of the array (index arr.length - 1) by jumping some number of times (possibly 0 or more than once).\nReturn the number of good starting indices.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: arr = [10,13,12,14,15]\nOutput: 2\nExplanation: \nFrom starting index i = 0, we can make our 1st jump to i = 2 (since arr[2] is the smallest among arr[1], arr[2], arr[3], arr[4] that is greater or equal to arr[0]), then we cannot jump any more.\nFrom starting index i = 1 and i = 2, we can make our 1st jump to i = 3, then we cannot jump any more.\nFrom starting index i = 3, we can make our 1st jump to i = 4, so we have reached the end.\nFrom starting index i = 4, we have reached the end already.\nIn total, there are 2 different starting indices i = 3 and i = 4, where we can reach the end with some number of\njumps.",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input: arr = [2,3,1,1,4]\nOutput: 3\nExplanation: \nFrom starting index i = 0, we make jumps to i = 1, i = 2, i = 3:\nDuring our 1st jump (odd-numbered), we first jump to i = 1 because arr[1] is the smallest value in [arr[1], arr[2], arr[3], arr[4]] that is greater than or equal to arr[0].\nDuring our 2nd jump (even-numbered), we jump from i = 1 to i = 2 because arr[2] is the largest value in [arr[2], arr[3], arr[4]] that is less than or equal to arr[1]. arr[3] is also the largest value, but 2 is a smaller index, so we can only jump to i = 2 and not i = 3\nDuring our 3rd jump (odd-numbered), we jump from i = 2 to i = 3 because arr[3] is the smallest value in [arr[3], arr[4]] that is greater than or equal to arr[2].\nWe can't jump from i = 3 to i = 4, so the starting index i = 0 is not good.\nIn a similar manner, we can deduce that:\nFrom starting index i = 1, we jump to i = 4, so we reach the end.\nFrom starting index i = 2, we jump to i = 3, and then we can't jump anymore.\nFrom starting index i = 3, we jump to i = 4, so we reach the end.\nFrom starting index i = 4, we are already at the end.\nIn total, there are 3 different starting indices i = 1, i = 3, and i = 4, where we can reach the end with some\nnumber of jumps.",
      "images": []
    },
    {
      "example_num": 3,
      "example_text": "Input: arr = [5,1,3,4,2]\nOutput: 3\nExplanation: We can reach the end from starting indices 1, 2, and 4.",
      "images": []
    }
  ],
  "constraints": [
    "1 <= arr.length <= 2 * 104",
    "0 <= arr[i] < 105"
  ],
  "follow_ups": [],
  "hints": [],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    int oddEvenJumps(vector<int>& arr) {\n        \n    }\n};",
    "java": "class Solution {\n    public int oddEvenJumps(int[] arr) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def oddEvenJumps(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: int\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def oddEvenJumps(self, arr: List[int]) -> int:\n        ",
    "c": "int oddEvenJumps(int* arr, int arrSize) {\n    \n}",
    "csharp": "public class Solution {\n    public int OddEvenJumps(int[] arr) {\n        \n    }\n}",
    "javascript": "/**\n * @param {number[]} arr\n * @return {number}\n */\nvar oddEvenJumps = function(arr) {\n    \n};",
    "typescript": "function oddEvenJumps(arr: number[]): number {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param Integer[] $arr\n     * @return Integer\n     */\n    function oddEvenJumps($arr) {\n        \n    }\n}",
    "swift": "class Solution {\n    func oddEvenJumps(_ arr: [Int]) -> Int {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun oddEvenJumps(arr: IntArray): Int {\n        \n    }\n}",
    "dart": "class Solution {\n  int oddEvenJumps(List<int> arr) {\n    \n  }\n}",
    "golang": "func oddEvenJumps(arr []int) int {\n    \n}",
    "ruby": "# @param {Integer[]} arr\n# @return {Integer}\ndef odd_even_jumps(arr)\n    \nend",
    "scala": "object Solution {\n    def oddEvenJumps(arr: Array[Int]): Int = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn odd_even_jumps(arr: Vec<i32>) -> i32 {\n        \n    }\n}",
    "racket": "(define/contract (odd-even-jumps arr)\n  (-> (listof exact-integer?) exact-integer?)\n  )",
    "erlang": "-spec odd_even_jumps(Arr :: [integer()]) -> integer().\nodd_even_jumps(Arr) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec odd_even_jumps(arr :: [integer]) :: integer\n  def odd_even_jumps(arr) do\n    \n  end\nend"
  }
}