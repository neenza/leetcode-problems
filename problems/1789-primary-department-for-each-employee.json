{
  "title": "Primary Department for Each Employee",
  "problem_id": "1942",
  "frontend_id": "1789",
  "difficulty": "Easy",
  "problem_slug": "primary-department-for-each-employee",
  "topics": [
    "Database"
  ],
  "description": "Table: Employee\nEmployees can belong to multiple departments. When the employee joins other departments, they need to decide which department is their primary department. Note that when an employee belongs to only one department, their primary column is 'N'.\nWrite a solution to report all the employees with their primary department. For employees who belong to one department, report their only department.\nReturn the result table in any order.\nTheÂ result format is in the following example.\nExample 1:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "+---------------+---------+\n| Column Name   |  Type   |\n+---------------+---------+\n| employee_id   | int     |\n| department_id | int     |\n| primary_flag  | varchar |\n+---------------+---------+\n(employee_id, department_id) is the primary key (combination of columns with unique values) for this table.\nemployee_id is the id of the employee.\ndepartment_id is the id of the department to which the employee belongs.\nprimary_flag is an ENUM (category) of type ('Y', 'N'). If the flag is 'Y', the department is the primary department for the employee. If the flag is 'N', the department is not the primary.",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input: \nEmployee table:\n+-------------+---------------+--------------+\n| employee_id | department_id | primary_flag |\n+-------------+---------------+--------------+\n| 1           | 1             | N            |\n| 2           | 1             | Y            |\n| 2           | 2             | N            |\n| 3           | 3             | N            |\n| 4           | 2             | N            |\n| 4           | 3             | Y            |\n| 4           | 4             | N            |\n+-------------+---------------+--------------+\nOutput: \n+-------------+---------------+\n| employee_id | department_id |\n+-------------+---------------+\n| 1           | 1             |\n| 2           | 1             |\n| 3           | 3             |\n| 4           | 3             |\n+-------------+---------------+\nExplanation: \n- The Primary department for employee 1 is 1.\n- The Primary department for employee 2 is 1.\n- The Primary department for employee 3 is 3.\n- The Primary department for employee 4 is 3.",
      "images": []
    }
  ],
  "constraints": [],
  "follow_ups": [],
  "hints": [],
  "code_snippets": {
    "mysql": "# Write your MySQL query statement below\n",
    "mssql": "/* Write your T-SQL query statement below */\n",
    "oraclesql": "/* Write your PL/SQL query statement below */\n",
    "pythondata": "import pandas as pd\n\ndef find_primary_department(employee: pd.DataFrame) -> pd.DataFrame:\n    ",
    "postgresql": "-- Write your PostgreSQL query statement below\n"
  },
  "solution": "[TOC]\n\n# Solution\n\n---\n\n### Overview\n\nEmployees can be associated with one or multiple departments. The task is to determine and report each employee's primary department, noting that if they're part of only one department, that's automatically their primary.\n\n---\n\n## pandas\n### Approach 1: Conditional Filtering and Aggregation-based Union\n\n![fig](../Figures/1789/1789-1.png)\n\n#### Intuition\n\nSample `employee` DataFrame:employee_iddepartment_idprimary_flag11N21Y22N33N42N43Y44N**Step 1 - Filter by Flag**:\n```python\n filtered_by_flag = employee[employee['primary_flag'] == 'Y'][['employee_id', 'department_id']]\n```\n - This part deals with employees that belong to multiple departments.\n  - The code filters rows from the `employee` DataFrame where the `primary_flag` is set to `'Y'`. This means we are interested in the primary department of employees who belong to multiple departments.\n  - After filtering, we only select two columns: `'employee_id'` and `'department_id'`. This will give us the primary department of each employee.\n  - The result is stored in `filtered_by_flag`.employee_iddepartment_id2143**Step 2 - Unique Employees**:\n```python\nunique_employees = employee.groupby('employee_id').filter(lambda x: len(x) == 1)[['employee_id', 'department_id']]\n```\n  - This part deals with employees that belong to only one department.\n  - Using `groupby`, we group the `employee` DataFrame by `employee_id`. This will group the rows based on the unique employee IDs.\n  - Using the `filter` function, we filter out groups whose size (number of rows in the group) is exactly 1. This means that these employees belong to only one department.\n  - After filtering, we select the same two columns: `'employee_id'` and `'department_id'`. Since these employees belong to only one department, that single department is their primary department.\n  - The result is stored in `unique_employees`.employee_iddepartment_id1133**Step 3 - Combining and Cleaning**:\n```python\nresult = pd.concat([filtered_by_flag, unique_employees]).drop_duplicates().reset_index(drop=True)\n```\n  - We now have two DataFrames: `filtered_by_flag`, which contains the primary departments of employees with multiple departments, and `unique_employees`, which contains the primary (and only) department of employees with a single department.\n  - Using `pd.concat`, we concatenate (or combine) these two DataFrames vertically. The resulting DataFrame will have all the primary departments for all employees.\n  - We then call `drop_duplicates()` to remove any duplicate rows. This is a safety measure; in the given context, it's unlikely that duplicates exist after the previous steps. However, it's good to be cautious.\n  - Finally, `reset_index(drop=True)` is used to reset the index of the DataFrame and make it more orderly. The `drop=True` argument ensures the old index doesn't become a column in the DataFrame.employee_iddepartment_id21431133**4. Return Result**:\n```python\nreturn result\n```\n  - The final DataFrame, `result`, containing the primary department for each employee, is returned.\n\nIn summary, the function provides an efficient way to determine the primary department of each employee, regardless of whether they belong to one or multiple departments.\n\n#### Implementation\n\nBased on the understanding above, the solution can be implemented as:\n\n\n```python\nimport pandas as pd\n\ndef find_primary_department(employee: pd.DataFrame) -> pd.DataFrame:\n    # 1. Employees with primary_flag set to 'Y'\n    filtered_by_flag = employee[employee['primary_flag'] == 'Y'][['employee_id', 'department_id']]\n\n    # 2. Employees that appear exactly once in the Employee table\n    unique_employees = employee.groupby('employee_id').filter(lambda x: len(x) == 1)[['employee_id', 'department_id']]\n\n    # 3. Combine both DataFrames using concat and drop duplicates\n    result = pd.concat([filtered_by_flag, unique_employees]).drop_duplicates().reset_index(drop=True)\n    \n    #4. Return result\n    return result\n\n```\n\n### Approach 2: Group-based Transform and Conditional Filtering\n\n![fig](../Figures/1789/1789-2.png)\n\n#### Intuition\n\nSample `employee` dataframe:employee_iddepartment_idprimary_flag11N21Y22N33N42N43Y44N**Step 1 - Calculate EmployeeCount**:\n```python\n employee[\"EmployeeCount\"] = employee.groupby(\"employee_id\")[\"employee_id\"].transform(\"size\")\n```\n  - For each employee (`employee_id`), the code calculates how many departments they are associated with.\n  - The `groupby` method groups the DataFrame by unique employee IDs.\n  - The `transform(\"size\")` method calculates the size (or count) of each group. It will return a Series with an identical size to `employee` where each entry corresponds to the count of rows for that `employee_id`.\n  - The result is a new column named `EmployeeCount` in the `employee` DataFrame which contains the number of rows (i.e., departments) for each `employee_id`.employee_iddepartment_idprimary_flagEmployeeCount11N121Y222N233N142N343Y344N3**Step 2 - Filtering the DataFrame**:\n```python\nresult = employee[(employee[\"EmployeeCount\"] == 1) | (employee[\"primary_flag\"] == \"Y\")][\n    [\"employee_id\", \"department_id\"]\n]\n```\n  - The goal is to filter out rows that represent the primary department for each employee.\n  - Two conditions are applied for filtering:\n      1. If `EmployeeCount` is `1`, it means the employee belongs to only one department, so that department is automatically the primary one.\n      2. If `primary_flag` is `\"Y\"`, it indicates that for employees who are part of multiple departments, this particular department is their primary one.\n  - The logical \"or\" (`|`) operator is used to combine the two conditions, so any row meeting either condition is retained.\n  - The resulting filtered DataFrame will contain only the primary department for each employee.\n  - The final filtered DataFrame will only retain two columns: `\"employee_id\"` and `\"department_id\"`.employee_iddepartment_id11213343**Step 3 - Return Result**:\n```python\n return result\n```\n  - Return the filtered DataFrame as the result.\n\nIn essence, the function works efficiently by leveraging the power of pandas to group and transform the data. It ensures that the output DataFrame contains only the primary department for each employee, whether they belong to one or multiple departments.\n#### Implementation\n\nBased on the understanding above, the solution can be implemented as:---\n\n## Database\n### Approach 1: `UNION`\n\n#### Intuition\n\nThe `UNION` approach combines two distinct sets of logic using the `UNION` operator. Here's the intuition behind each part:\n\n**Step 1 - Retrieving employees with primary_flag set to 'Y'**:\n```sql\nSELECT \n  employee_id, \n  department_id \nFROM \n  Employee \nWHERE \n  primary_flag = 'Y'\n```\n  - This part selects those employees that have been explicitly marked as having a particular department as their primary. \n  - For employees who belong to multiple departments, one of those departments will have the `primary_flag` set to 'Y', which denotes it as the primary department.\n  - The SQL code fetches `employee_id` and `department_id` where `primary_flag` is 'Y'.\n  \n**Step 2 - Retrieving employees that appear exactly once in the Employee table**:\n```sql\nSELECT \n  employee_id, \n  department_id \nFROM \n  Employee \nGROUP BY \n  employee_id \nHAVING \n  COUNT(employee_id) = 1\n```\n  - The objective here is to capture employees who are associated with only one department. In such cases, that single department is automatically their primary department.\n  - The code groups the records in the `Employee` table by `employee_id` using `GROUP BY`. For each employee ID, it then checks the count of associated rows (or departments).\n  - The `HAVING` clause filters out groups where the count of rows (i.e., departments) for that employee is not equal to 1.\n  - This way, only those employees who are associated with a single department are selected.\n\n**Step 3 - Combining both results with UNION**:\n```sql\nSELECT \n  employee_id, \n  department_id \nFROM \n  Employee \nWHERE \n  primary_flag = 'Y' \nUNION \nSELECT \n  employee_id, \n  department_id \nFROM \n  Employee \nGROUP BY \n  employee_id \nHAVING \n  COUNT(employee_id) = 1;\n```\n  - `UNION` is an SQL operator that combines the results of two SELECT statements into a single set of rows. It automatically removes duplicates.\n  - Here, it's used to merge the results from the two aforementioned logics: those with `primary_flag = 'Y'` and those appearing only once in the table.\n  - The final output is a unified list containing the primary department for each employee.\n\nIn essence, the SQL code ensures that for every employee, either their explicitly marked primary department is selected, or if they belong to only one department, that department is picked as the primary.\n\n#### Implementation\n\nBased on the understanding above, the solution can be implemented as:\n\n```sql\n-- Retrieving employees with primary_flag set to 'Y'\nSELECT \n  employee_id, \n  department_id \nFROM \n  Employee \nWHERE \n  primary_flag = 'Y' \nUNION \n-- Retrieving employees that appear exactly once in the Employee table\nSELECT \n  employee_id, \n  department_id \nFROM \n  Employee \nGROUP BY \n  employee_id \nHAVING \n  COUNT(employee_id) = 1;\n\n```\n\n### Approach 2: Window Function (`COUNT`)\n\n#### Intuition\n\nThis approach uses an *advanced* SQL feature called window functions, specifically `COUNT() OVER()`. Here's the intuition for each step:\n\n**Step 1 - Inner Query with Window Function**:\n```sql\nSELECT \n  *, \n  COUNT(employee_id) OVER(PARTITION BY employee_id) AS EmployeeCount \nFROM \n  Employee\n```\n  - This query fetches all columns from the `Employee` table and adds a new computed column, `EmployeeCount`.\n  - `COUNT(employee_id) OVER(PARTITION BY employee_id)` is a window function. Let's break down what it does:\n      - `PARTITION BY employee_id`: This breaks down the data into 'windows' or 'partitions' of rows that have the same `employee_id`. Each window is essentially a subset of the data for a specific employee.\n      - `COUNT(employee_id) OVER(...)`: This counts the number of rows (i.e., the number of departments) for each employee within their respective partition/window. The result is a new column, `EmployeeCount`, which tells us how many departments each employee is associated with. This count is repeated for every row of the same employee.\n\n**Step 2 - Alias & Outer Query**:\n```sql\nSELECT \n  employee_id, \n  department_id \nFROM \n  EmployeePartition \n```\n  - The inner query result is treated as a temporary table named `EmployeePartition`.\n  - From this table, we select the desired columns: `employee_id` and `department_id`.\n\n**Step 3 - Filtering with WHERE Clause**:\n```sql\nWHERE \n  EmployeeCount = 1 \n  OR primary_flag = 'Y'\n```\n  - We have two conditions to filter out the primary department for each employee:\n      1. `EmployeeCount = 1`: This captures those employees who belong to only one department. For them, that single department is automatically their primary department.\n      2. `primary_flag = 'Y'`: This captures employees who belong to multiple departments but have one department explicitly marked as primary with a flag 'Y'.\n  - The `OR` operator is used, so any row satisfying either of the above conditions is included in the result.\n\n**Summary**:\nThe code first assigns an employee department count to each row using a window function. It then filters out the desired rows based on whether an employee is associated with just one department or has a department explicitly flagged as primary. The end result is a list of primary departments for each employee.\n\n#### Implementation\n\nBased on the understanding above, the solution can be implemented as:\n\n```sql\nSELECT \n  employee_id, \n  department_id \nFROM \n  (\n    SELECT \n      *, \n      COUNT(employee_id) OVER(PARTITION BY employee_id) AS EmployeeCount\n    FROM \n      Employee\n  ) EmployeePartition \nWHERE \n  EmployeeCount = 1 \n  OR primary_flag = 'Y';\n\n```"
}