{
  "title": "Find the Lexicographically Largest String From the Box I",
  "problem_id": "3683",
  "frontend_id": "3403",
  "difficulty": "Medium",
  "problem_slug": "find-the-lexicographically-largest-string-from-the-box-i",
  "topics": [
    "Two Pointers",
    "String",
    "Enumeration"
  ],
  "description": "You are given a string word, and an integer numFriends.\nAlice is organizing a game for her numFriends friends. There are multiple rounds in the game, where in each round:\nFind the lexicographically largest string from the box after all the rounds are finished.\nExample 1:\nExample 2:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: word = \"dbca\", numFriends = 2\nOutput: \"dbc\"\nExplanation:\nAll possible splits are:",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input: word = \"gggg\", numFriends = 4\nOutput: \"g\"\nExplanation:\nThe only possible split is: \"g\" , \"g\" , \"g\" , and \"g\" .",
      "images": []
    }
  ],
  "constraints": [
    "1 <= word.length <= 5 * 103",
    "word consists only of lowercase English letters.",
    "1 <= numFriends <= word.length"
  ],
  "follow_ups": [],
  "hints": [
    "Find lexicographically largest substring of size <code>n - numFriends + 1</code> or less starting at every index."
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    string answerString(string word, int numFriends) {\n        \n    }\n};",
    "java": "class Solution {\n    public String answerString(String word, int numFriends) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def answerString(self, word, numFriends):\n        \"\"\"\n        :type word: str\n        :type numFriends: int\n        :rtype: str\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def answerString(self, word: str, numFriends: int) -> str:\n        ",
    "c": "char* answerString(char* word, int numFriends) {\n    \n}",
    "csharp": "public class Solution {\n    public string AnswerString(string word, int numFriends) {\n        \n    }\n}",
    "javascript": "/**\n * @param {string} word\n * @param {number} numFriends\n * @return {string}\n */\nvar answerString = function(word, numFriends) {\n    \n};",
    "typescript": "function answerString(word: string, numFriends: number): string {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param String $word\n     * @param Integer $numFriends\n     * @return String\n     */\n    function answerString($word, $numFriends) {\n        \n    }\n}",
    "swift": "class Solution {\n    func answerString(_ word: String, _ numFriends: Int) -> String {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun answerString(word: String, numFriends: Int): String {\n        \n    }\n}",
    "dart": "class Solution {\n  String answerString(String word, int numFriends) {\n    \n  }\n}",
    "golang": "func answerString(word string, numFriends int) string {\n    \n}",
    "ruby": "# @param {String} word\n# @param {Integer} num_friends\n# @return {String}\ndef answer_string(word, num_friends)\n    \nend",
    "scala": "object Solution {\n    def answerString(word: String, numFriends: Int): String = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn answer_string(word: String, num_friends: i32) -> String {\n        \n    }\n}",
    "racket": "(define/contract (answer-string word numFriends)\n  (-> string? exact-integer? string?)\n  )",
    "erlang": "-spec answer_string(Word :: unicode:unicode_binary(), NumFriends :: integer()) -> unicode:unicode_binary().\nanswer_string(Word, NumFriends) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec answer_string(word :: String.t, num_friends :: integer) :: String.t\n  def answer_string(word, num_friends) do\n    \n  end\nend"
  },
  "solution": "[TOC]\n\n## Solution\n\n--- \n\n### Approach 1: Enumeration\n\n#### Intuition\n\nWhen $\\textit{numFriends} = 1$, we simply return the entire $\\textit{word}$.\n\nWhen $\\textit{numFriends} > 1$, we consider all substrings starting at index $i$. Under the constraints of the problem, the maximum length of such a substring is $\\min(n - \\textit{numFriends} + 1, n - i)$. Among substrings of a fixed starting index, longer substrings have higher lexicographical order. Therefore, we can iterate over all starting indices $i$ from $0$ to $n - 1$, extract the substring of length $\\min(n - \\textit{numFriends} + 1, n - i)$ starting at $i$, and return the lexicographically largest substring among them.\n\n#### Implementation#### Complexity Analysis\n\nLet $n$ be the length of the string $\\textit{word}$.\n\n- Time Complexity: $O(n^2)$\n\n    We need to enumerate all substrings that meet the problem’s conditions. Since there are up to $n$ possible starting indices and for each we may extract a substring of up to $O(n)$ length, the overall time complexity is $O(n^2)$.\n\n- Space Complexity: $O(n)$ or $O(1)$\n\n    The space complexity depends on how the language handles string slicing:\n\n    - In languages where slicing creates a new copy of the substring (e.g., C++, Java), the space complexity is $O(n)$ due to the storage of temporary substrings.\n\n    - In languages where slicing creates a view or reference without copying (e.g., Python), the space complexity can be considered $O(1)$.\n\n### Approach 2: Two Pointers\n\n#### Intuition\n\n> **Note:** To fully understand the two-pointer method used here, it's essential to first solve [1163. Last Substring in Lexicographical Order](https://leetcode.com/problems/last-substring-in-lexicographical-order/), which introduces the core idea behind this technique.\n\nAs in Approach 1, when $\\textit{numFriends} > 1$, if the left endpoint of the lexicographically largest suffix of the string is $i$, then the substring $s_i$ which starts at index $i$ and has length $\\min(n - \\textit{numFriends} + 1, n - i)$ will be the lexicographically largest substring that satisfies the problem's constraints.\n\nWe use a proof by contradiction to verify this. Suppose there exists another valid substring $s_j$, starting at index $j$, such that $s_j > s_i$ lexicographically. We consider two cases:\n\n- Case 1: $s_i$ is a suffix substring\nThat is, $n - \\textit{numFriends} + 1 \\geq n - i$. Then $s_i$ spans to the end of the string, and $s_j > s_i$ contradicts the assumption that $s_i$ is the lexicographically largest suffix.\n\n- Case 2: $s_i$ is not a suffix substring\nThat is, $n - \\textit{numFriends} + 1 < n - i$, meaning $s_i$ is shorter than the entire suffix. Since $s_j$ must also be of length at most $n - \\textit{numFriends} + 1$, it is no longer than $s_i$. If $s_j > s_i$, it must differ at some position where the character in $s_j$ is greater than that in $s_i$. This implies that the suffix starting at $j$ is greater than the suffix starting at $i$, which again contradicts the assumption that the suffix starting at $i$ is the lexicographically largest.\n\nTherefore, $s_i$ must indeed produce the answer.\n\n#### Implementation#### Complexity Analysis\n\nLet $n$ be the length of the string $\\textit{word}$.\n\n- Time Complexity: $O(n)$\n\n    The two pointers together traverse at most $n$ characters. Each character is compared only a constant number of times, so the overall time complexity is linear.\n\n- Space Complexity: $O(n)$ or $O(1)$\n\n    The space complexity depends on the language's string handling behavior.\n\n    - In languages where string slicing creates a new copy (e.g., C++, Java), the space complexity is $O(n)$ in the worst case due to substring creation.\n\n    - In languages where string slices are views or references (e.g., Python), the space overhead can be considered $O(1)$ since no new characters are copied."
}