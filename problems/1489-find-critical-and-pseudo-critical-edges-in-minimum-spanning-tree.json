{
  "title": "Find Critical and Pseudo-Critical Edges in Minimum Spanning Tree",
  "problem_id": "1613",
  "frontend_id": "1489",
  "difficulty": "Hard",
  "problem_slug": "find-critical-and-pseudo-critical-edges-in-minimum-spanning-tree",
  "topics": [
    "Union Find",
    "Graph",
    "Sorting",
    "Minimum Spanning Tree",
    "Strongly Connected Component"
  ],
  "description": "Given a weighted undirected connected graph with n vertices numbered from 0 to n - 1, and an array edges where edges[i] = [ai, bi, weighti] represents a bidirectional and weighted edge between nodes ai and bi. A minimum spanning tree (MST) is a subset of the graph's edges that connects all vertices without cycles and with the minimum possible total edge weight.\nFind all the critical and pseudo-critical edges in the given graph's minimum spanning tree (MST). An MST edge whose deletion from the graph would cause the MST weight to increase is called a critical edge. On the other hand, a pseudo-critical edge is that which can appear in some MSTs but not all.\nNote that you can return the indices of the edges in any order.\nExample 1:\nExample 2:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: n = 5, edges = [[0,1,1],[1,2,1],[2,3,2],[0,3,2],[0,4,3],[3,4,3],[1,4,6]]\nOutput: [[0,1],[2,3,4,5]]\nExplanation: The figure above describes the graph.\nThe following figure shows all the possible MSTs:\n\nNotice that the two edges 0 and 1 appear in all MSTs, therefore they are critical edges, so we return them in the first list of the output.\nThe edges 2, 3, 4, and 5 are only part of some MSTs, therefore they are considered pseudo-critical edges. We add them to the second list of the output.",
      "images": [
        "https://assets.leetcode.com/uploads/2020/06/04/ex1.png"
      ]
    },
    {
      "example_num": 2,
      "example_text": "Input: n = 4, edges = [[0,1,1],[1,2,1],[2,3,1],[0,3,1]]\nOutput: [[],[0,1,2,3]]\nExplanation: We can observe that since all 4 edges have equal weight, choosing any 3 edges from the given 4 will yield an MST. Therefore all 4 edges are pseudo-critical.",
      "images": [
        "https://assets.leetcode.com/uploads/2020/06/04/ex2.png"
      ]
    }
  ],
  "constraints": [
    "2 <= n <= 100",
    "1 <= edges.length <= min(200, n * (n - 1) / 2)",
    "edges[i].length == 3",
    "0 <= ai < bi < n",
    "1 <= weighti <= 1000",
    "All pairs (ai, bi) are distinct."
  ],
  "follow_ups": [],
  "hints": [
    "Use the Kruskal algorithm to find the minimum spanning tree by sorting the edges and picking edges from ones with smaller weights.",
    "Use a disjoint set to avoid adding redundant edges that result in a cycle.",
    "To find if one edge is critical, delete that edge and re-run the MST algorithm and see if the weight of the new MST increases.",
    "To find if one edge is non-critical (in any MST), include that edge to the accepted edge list and continue the MST algorithm, then see if the resulting MST has the same weight of the initial MST of the entire graph."
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n, vector<vector<int>>& edges) {\n        \n    }\n};",
    "java": "class Solution {\n    public List<List<Integer>> findCriticalAndPseudoCriticalEdges(int n, int[][] edges) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def findCriticalAndPseudoCriticalEdges(self, n, edges):\n        \"\"\"\n        :type n: int\n        :type edges: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def findCriticalAndPseudoCriticalEdges(self, n: int, edges: List[List[int]]) -> List[List[int]]:\n        ",
    "c": "/**\n * Return an array of arrays of size *returnSize.\n * The sizes of the arrays are returned as *returnColumnSizes array.\n * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().\n */\nint** findCriticalAndPseudoCriticalEdges(int n, int** edges, int edgesSize, int* edgesColSize, int* returnSize, int** returnColumnSizes) {\n    \n}",
    "csharp": "public class Solution {\n    public IList<IList<int>> FindCriticalAndPseudoCriticalEdges(int n, int[][] edges) {\n        \n    }\n}",
    "javascript": "/**\n * @param {number} n\n * @param {number[][]} edges\n * @return {number[][]}\n */\nvar findCriticalAndPseudoCriticalEdges = function(n, edges) {\n    \n};",
    "typescript": "function findCriticalAndPseudoCriticalEdges(n: number, edges: number[][]): number[][] {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param Integer $n\n     * @param Integer[][] $edges\n     * @return Integer[][]\n     */\n    function findCriticalAndPseudoCriticalEdges($n, $edges) {\n        \n    }\n}",
    "swift": "class Solution {\n    func findCriticalAndPseudoCriticalEdges(_ n: Int, _ edges: [[Int]]) -> [[Int]] {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun findCriticalAndPseudoCriticalEdges(n: Int, edges: Array<IntArray>): List<List<Int>> {\n        \n    }\n}",
    "dart": "class Solution {\n  List<List<int>> findCriticalAndPseudoCriticalEdges(int n, List<List<int>> edges) {\n    \n  }\n}",
    "golang": "func findCriticalAndPseudoCriticalEdges(n int, edges [][]int) [][]int {\n    \n}",
    "ruby": "# @param {Integer} n\n# @param {Integer[][]} edges\n# @return {Integer[][]}\ndef find_critical_and_pseudo_critical_edges(n, edges)\n    \nend",
    "scala": "object Solution {\n    def findCriticalAndPseudoCriticalEdges(n: Int, edges: Array[Array[Int]]): List[List[Int]] = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn find_critical_and_pseudo_critical_edges(n: i32, edges: Vec<Vec<i32>>) -> Vec<Vec<i32>> {\n        \n    }\n}",
    "racket": "(define/contract (find-critical-and-pseudo-critical-edges n edges)\n  (-> exact-integer? (listof (listof exact-integer?)) (listof (listof exact-integer?)))\n  )",
    "erlang": "-spec find_critical_and_pseudo_critical_edges(N :: integer(), Edges :: [[integer()]]) -> [[integer()]].\nfind_critical_and_pseudo_critical_edges(N, Edges) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec find_critical_and_pseudo_critical_edges(n :: integer, edges :: [[integer]]) :: [[integer]]\n  def find_critical_and_pseudo_critical_edges(n, edges) do\n    \n  end\nend"
  }
}