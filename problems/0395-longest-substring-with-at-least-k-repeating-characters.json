{
  "title": "Longest Substring with At Least K Repeating Characters",
  "problem_id": "395",
  "frontend_id": "395",
  "difficulty": "Medium",
  "problem_slug": "longest-substring-with-at-least-k-repeating-characters",
  "topics": [
    "Hash Table",
    "String",
    "Divide and Conquer",
    "Sliding Window"
  ],
  "description": "Given a string s and an integer k, return the length of the longest substring of s such that the frequency of each character in this substring is greater than or equal to k.\nif no such substring exists, return 0.\nExample 1:\nExample 2:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: s = \"aaabb\", k = 3\nOutput: 3\nExplanation: The longest substring is \"aaa\", as 'a' is repeated 3 times.",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input: s = \"ababbc\", k = 2\nOutput: 5\nExplanation: The longest substring is \"ababb\", as 'a' is repeated 2 times and 'b' is repeated 3 times.",
      "images": []
    }
  ],
  "constraints": [
    "1 <= s.length <= 104",
    "s consists of only lowercase English letters.",
    "1 <= k <= 105"
  ],
  "follow_ups": [],
  "hints": [],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    int longestSubstring(string s, int k) {\n        \n    }\n};",
    "java": "class Solution {\n    public int longestSubstring(String s, int k) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def longestSubstring(self, s, k):\n        \"\"\"\n        :type s: str\n        :type k: int\n        :rtype: int\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def longestSubstring(self, s: str, k: int) -> int:\n        ",
    "c": "int longestSubstring(char* s, int k) {\n    \n}",
    "csharp": "public class Solution {\n    public int LongestSubstring(string s, int k) {\n        \n    }\n}",
    "javascript": "/**\n * @param {string} s\n * @param {number} k\n * @return {number}\n */\nvar longestSubstring = function(s, k) {\n    \n};",
    "typescript": "function longestSubstring(s: string, k: number): number {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param String $s\n     * @param Integer $k\n     * @return Integer\n     */\n    function longestSubstring($s, $k) {\n        \n    }\n}",
    "swift": "class Solution {\n    func longestSubstring(_ s: String, _ k: Int) -> Int {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun longestSubstring(s: String, k: Int): Int {\n        \n    }\n}",
    "dart": "class Solution {\n  int longestSubstring(String s, int k) {\n    \n  }\n}",
    "golang": "func longestSubstring(s string, k int) int {\n    \n}",
    "ruby": "# @param {String} s\n# @param {Integer} k\n# @return {Integer}\ndef longest_substring(s, k)\n    \nend",
    "scala": "object Solution {\n    def longestSubstring(s: String, k: Int): Int = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn longest_substring(s: String, k: i32) -> i32 {\n        \n    }\n}",
    "racket": "(define/contract (longest-substring s k)\n  (-> string? exact-integer? exact-integer?)\n  )",
    "erlang": "-spec longest_substring(S :: unicode:unicode_binary(), K :: integer()) -> integer().\nlongest_substring(S, K) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec longest_substring(s :: String.t, k :: integer) :: integer\n  def longest_substring(s, k) do\n    \n  end\nend"
  },
  "solution": "[TOC]\n\n## Solution\n---\n\n### Overview ####\n\n\nWe want to find the longest substring in a given string `s` where each character is repeated at least `k` times. This is an interesting problem that can be solved using different algorithm paradigms like Divide and Conquer and the Sliding Window Approach. We will start by discussing the brute force approach, moving towards more efficient implementations.\n\nLet's discuss each approach in detail.\n\n---\n\n### Approach 1: Brute Force\n\n**Intuition**\n\nThe naive approach would be to generate all possible substrings for a given string `s`. For each substring, we must check if all the characters are repeated at least `k` times. Among all the substrings that satisfy the given condition, return the length of the longest substring.\n\n**Algorithm**\n\n- Generate substrings from string `s` starting at index `start` and ending at index `end`.\n- Use the `countMap` array to store the frequency of each character in the substring.\n- The `isValid` method uses `countMap` to check whether every character in substring has at least `k` frequency.\n- Track the maximum substring length and return the result.\n\n**Implementation****Complexity Analysis**\n\n- Time Complexity : $$\\mathcal{O}(n^{2})$$, where $$n$$ is equal to length of string $$s$$. The nested for loop that generates all substrings from string $$s$$ takes $$\\mathcal{O}(n^{2})$$ time, and for each substring, we iterate over $$\\text{countMap}$$ array of size $$26$$.\nThis gives us time complexity as  $$\\mathcal{O}(26 \\cdot n^{2})$$ = $$\\mathcal{O}(n^{2})$$.\n\n This approach is exhaustive and results in _Time Limit Exceeded (TLE)_.\n\n- Space Complexity: $$\\mathcal{O}(1)$$ We use constant extra space of size 26 for `countMap` array.\n\n---\n\n### Approach 2: Divide And Conquer\n\n**Intuition**\n\n[Divide and Conquer](https://en.wikipedia.org/wiki/Divide-and-conquer_algorithm) is one of the popular strategies that work in 2 phases.\n - Divide the problem into subproblems. (Divide Phase).\n-  Repeatedly solve each subproblem independently and combine the result to solve the original problem. (Conquer Phase).\n\nWe could apply this strategy by recursively splitting the string into substrings and combine the result to find the longest substring that satisfies the given condition. The longest substring for a string starting at index `start` and ending at index `end` can be given by,\n\n```java\nlongestSustring(start, end) = max(longestSubstring(start, mid), longestSubstring(mid+1, end))\n```\n\n_Finding the split position `(mid)`_\n\nThe string would be split only when we find an invalid character. An invalid character is the one with a frequency of less than `k`. As we know, the invalid character cannot be part of the result, we split the string at the index where we find the invalid character, recursively check for each split, and combine the result.\n\n**Algorithm**\n\n- Build the `countMap` with the frequency of each character in the string `s`.\n- Find the position for `mid` index by iterating over the string. The `mid` index would be the first invalid character in the string.\n- Split the string into 2 substrings at the `mid` index and recursively find the result.\n\n> To make it more efficient, we ignore all the invalid characters after the mid index as well, thereby reducing the number of recursive calls.\n\n![img](../Figures/395/divide_and_conquer.png)\n\n**Implementation****Complexity Analysis**\n\n- Time Complexity : $$\\mathcal{O}(N ^ {2})$$, where $$N$$ is the length of string $$s$$. Though the algorithm performs better in most cases, the worst case time complexity is still $$\\mathcal{O}(N ^ {2})$$.\n\nIn cases where we perform split at every index, the maximum depth of recursive call could be $$\\mathcal{O}(N)$$. For each recursive call it takes $$\\mathcal{O}(N)$$ time to build the `countMap` resulting in $$\\mathcal{O}(n ^ {2})$$ time complexity.\n\n- Space Complexity: $$\\mathcal{O}(N)$$ This is the space used to store the recursive call stack. The maximum depth of recursive call stack would be $$\\mathcal{O}(N)$$.\n\n---\n\n### Approach 3: Sliding Window\n\n**Intuition**\n\nThere is another intuitive method to solve the problem by using the Sliding Window Approach. The sliding window slides over the string `s` and validates each character. Based on certain conditions, the sliding window either expands or shrinks.\n\nA substring is valid if each character has at least `k` frequency. The main idea is to find all the valid substrings with a different number of unique characters and track the maximum length. Let's look at the algorithm in detail.\n\n**Algorithm**\n\n1) Find the number of unique characters in the string `s` and store the count in variable `maxUnique`. For `s` = `aabcbacad`, the unique characters are `a,b,c,d` and `maxUnique = 4`.\n\n2)  Iterate over the string `s` with the value of `currUnique` ranging from `1` to `maxUnique`. In each iteration, `currUnique`  is the maximum number of unique characters that must be present in the sliding window.\n\n3) The sliding window starts at index `windowStart` and ends at index `windowEnd` and slides over string `s` until `windowEnd` reaches the end of string `s`. At any given point, we shrink or expand the window to ensure that the number of unique characters is not greater than `currUnique`.\n\n - If the number of unique character in the sliding window is less than or equal to `currUnique`, expand the window from the right by adding a character to the end of the window given by `windowEnd`\n\n- Otherwise, shrink the window from the left by removing a character from the start of the window given by `windowStart`.\n\n4) Keep track of the number of unique characters in the current sliding window having at least `k` frequency given by `countAtLeastK`. Update the result if all the characters in the window have at least `k` frequency.\n\n\n![img](../Figures/395/sliding_window.png)\n\n**Implementation****Complexity Analysis**\n\n- Time Complexity : $$\\mathcal{O}(\\text{maxUnique} \\cdot N)$$. We iterate over the string of length $$N$$, $$\\text{maxUnqiue}$$ times. Ideally, the number of unique characters in the string would not be more than $$26$$ `(a to z)`. Hence, the time complexity is approximately $$\\mathcal{O}( 26 \\cdot N)$$ = $$\\mathcal{O}(N)$$\n\n- Space Complexity: $$\\mathcal{O}(1)$$ We use constant extra space of size 26 to store the `countMap`."
}