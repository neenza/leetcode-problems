{
  "title": "Design Bitset",
  "problem_id": "2285",
  "frontend_id": "2166",
  "difficulty": "Medium",
  "problem_slug": "design-bitset",
  "topics": [
    "Array",
    "Hash Table",
    "String",
    "Design"
  ],
  "description": "A Bitset is a data structure that compactly stores bits.\nImplement the Bitset class:\nExample 1:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input\n[\"Bitset\", \"fix\", \"fix\", \"flip\", \"all\", \"unfix\", \"flip\", \"one\", \"unfix\", \"count\", \"toString\"]\n[[5], [3], [1], [], [], [0], [], [], [0], [], []]\nOutput\n[null, null, null, null, false, null, null, true, null, 2, \"01010\"]\n\nExplanation\nBitset bs = new Bitset(5); // bitset = \"00000\".\nbs.fix(3);     // the value at idx = 3 is updated to 1, so bitset = \"00010\".\nbs.fix(1);     // the value at idx = 1 is updated to 1, so bitset = \"01010\". \nbs.flip();     // the value of each bit is flipped, so bitset = \"10101\". \nbs.all();      // return False, as not all values of the bitset are 1.\nbs.unfix(0);   // the value at idx = 0 is updated to 0, so bitset = \"00101\".\nbs.flip();     // the value of each bit is flipped, so bitset = \"11010\". \nbs.one();      // return True, as there is at least 1 index with value 1.\nbs.unfix(0);   // the value at idx = 0 is updated to 0, so bitset = \"01010\".\nbs.count();    // return 2, as there are 2 bits with value 1.\nbs.toString(); // return \"01010\", which is the composition of bitset.",
      "images": []
    }
  ],
  "constraints": [
    "1 <= size <= 105",
    "0 <= idx <= size - 1",
    "At most 105 calls will be made in total to fix, unfix, flip, all, one, count, and toString.",
    "At least one call will be made to all, one, count, or toString.",
    "At most 5 calls will be made to toString."
  ],
  "follow_ups": [],
  "hints": [
    "Note that flipping a bit twice does nothing.",
    "In order to determine the value of a bit, consider how you can efficiently count the number of flips made on the bit since its latest update."
  ],
  "code_snippets": {
    "cpp": "class Bitset {\npublic:\n    Bitset(int size) {\n        \n    }\n    \n    void fix(int idx) {\n        \n    }\n    \n    void unfix(int idx) {\n        \n    }\n    \n    void flip() {\n        \n    }\n    \n    bool all() {\n        \n    }\n    \n    bool one() {\n        \n    }\n    \n    int count() {\n        \n    }\n    \n    string toString() {\n        \n    }\n};\n\n/**\n * Your Bitset object will be instantiated and called as such:\n * Bitset* obj = new Bitset(size);\n * obj->fix(idx);\n * obj->unfix(idx);\n * obj->flip();\n * bool param_4 = obj->all();\n * bool param_5 = obj->one();\n * int param_6 = obj->count();\n * string param_7 = obj->toString();\n */",
    "java": "class Bitset {\n\n    public Bitset(int size) {\n        \n    }\n    \n    public void fix(int idx) {\n        \n    }\n    \n    public void unfix(int idx) {\n        \n    }\n    \n    public void flip() {\n        \n    }\n    \n    public boolean all() {\n        \n    }\n    \n    public boolean one() {\n        \n    }\n    \n    public int count() {\n        \n    }\n    \n    public String toString() {\n        \n    }\n}\n\n/**\n * Your Bitset object will be instantiated and called as such:\n * Bitset obj = new Bitset(size);\n * obj.fix(idx);\n * obj.unfix(idx);\n * obj.flip();\n * boolean param_4 = obj.all();\n * boolean param_5 = obj.one();\n * int param_6 = obj.count();\n * String param_7 = obj.toString();\n */",
    "python": "class Bitset(object):\n\n    def __init__(self, size):\n        \"\"\"\n        :type size: int\n        \"\"\"\n        \n\n    def fix(self, idx):\n        \"\"\"\n        :type idx: int\n        :rtype: None\n        \"\"\"\n        \n\n    def unfix(self, idx):\n        \"\"\"\n        :type idx: int\n        :rtype: None\n        \"\"\"\n        \n\n    def flip(self):\n        \"\"\"\n        :rtype: None\n        \"\"\"\n        \n\n    def all(self):\n        \"\"\"\n        :rtype: bool\n        \"\"\"\n        \n\n    def one(self):\n        \"\"\"\n        :rtype: bool\n        \"\"\"\n        \n\n    def count(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        \n\n    def toString(self):\n        \"\"\"\n        :rtype: str\n        \"\"\"\n        \n\n\n# Your Bitset object will be instantiated and called as such:\n# obj = Bitset(size)\n# obj.fix(idx)\n# obj.unfix(idx)\n# obj.flip()\n# param_4 = obj.all()\n# param_5 = obj.one()\n# param_6 = obj.count()\n# param_7 = obj.toString()",
    "python3": "class Bitset:\n\n    def __init__(self, size: int):\n        \n\n    def fix(self, idx: int) -> None:\n        \n\n    def unfix(self, idx: int) -> None:\n        \n\n    def flip(self) -> None:\n        \n\n    def all(self) -> bool:\n        \n\n    def one(self) -> bool:\n        \n\n    def count(self) -> int:\n        \n\n    def toString(self) -> str:\n        \n\n\n# Your Bitset object will be instantiated and called as such:\n# obj = Bitset(size)\n# obj.fix(idx)\n# obj.unfix(idx)\n# obj.flip()\n# param_4 = obj.all()\n# param_5 = obj.one()\n# param_6 = obj.count()\n# param_7 = obj.toString()",
    "c": "\n\n\ntypedef struct {\n    \n} Bitset;\n\n\nBitset* bitsetCreate(int size) {\n    \n}\n\nvoid bitsetFix(Bitset* obj, int idx) {\n    \n}\n\nvoid bitsetUnfix(Bitset* obj, int idx) {\n    \n}\n\nvoid bitsetFlip(Bitset* obj) {\n    \n}\n\nbool bitsetAll(Bitset* obj) {\n    \n}\n\nbool bitsetOne(Bitset* obj) {\n    \n}\n\nint bitsetCount(Bitset* obj) {\n    \n}\n\nchar* bitsetToString(Bitset* obj) {\n    \n}\n\nvoid bitsetFree(Bitset* obj) {\n    \n}\n\n/**\n * Your Bitset struct will be instantiated and called as such:\n * Bitset* obj = bitsetCreate(size);\n * bitsetFix(obj, idx);\n \n * bitsetUnfix(obj, idx);\n \n * bitsetFlip(obj);\n \n * bool param_4 = bitsetAll(obj);\n \n * bool param_5 = bitsetOne(obj);\n \n * int param_6 = bitsetCount(obj);\n \n * char* param_7 = bitsetToString(obj);\n \n * bitsetFree(obj);\n*/",
    "csharp": "public class Bitset {\n\n    public Bitset(int size) {\n        \n    }\n    \n    public void Fix(int idx) {\n        \n    }\n    \n    public void Unfix(int idx) {\n        \n    }\n    \n    public void Flip() {\n        \n    }\n    \n    public bool All() {\n        \n    }\n    \n    public bool One() {\n        \n    }\n    \n    public int Count() {\n        \n    }\n    \n    public string ToString() {\n        \n    }\n}\n\n/**\n * Your Bitset object will be instantiated and called as such:\n * Bitset obj = new Bitset(size);\n * obj.Fix(idx);\n * obj.Unfix(idx);\n * obj.Flip();\n * bool param_4 = obj.All();\n * bool param_5 = obj.One();\n * int param_6 = obj.Count();\n * string param_7 = obj.ToString();\n */",
    "javascript": "/**\n * @param {number} size\n */\nvar Bitset = function(size) {\n    \n};\n\n/** \n * @param {number} idx\n * @return {void}\n */\nBitset.prototype.fix = function(idx) {\n    \n};\n\n/** \n * @param {number} idx\n * @return {void}\n */\nBitset.prototype.unfix = function(idx) {\n    \n};\n\n/**\n * @return {void}\n */\nBitset.prototype.flip = function() {\n    \n};\n\n/**\n * @return {boolean}\n */\nBitset.prototype.all = function() {\n    \n};\n\n/**\n * @return {boolean}\n */\nBitset.prototype.one = function() {\n    \n};\n\n/**\n * @return {number}\n */\nBitset.prototype.count = function() {\n    \n};\n\n/**\n * @return {string}\n */\nBitset.prototype.toString = function() {\n    \n};\n\n/** \n * Your Bitset object will be instantiated and called as such:\n * var obj = new Bitset(size)\n * obj.fix(idx)\n * obj.unfix(idx)\n * obj.flip()\n * var param_4 = obj.all()\n * var param_5 = obj.one()\n * var param_6 = obj.count()\n * var param_7 = obj.toString()\n */",
    "typescript": "class Bitset {\n    constructor(size: number) {\n        \n    }\n\n    fix(idx: number): void {\n        \n    }\n\n    unfix(idx: number): void {\n        \n    }\n\n    flip(): void {\n        \n    }\n\n    all(): boolean {\n        \n    }\n\n    one(): boolean {\n        \n    }\n\n    count(): number {\n        \n    }\n\n    toString(): string {\n        \n    }\n}\n\n/**\n * Your Bitset object will be instantiated and called as such:\n * var obj = new Bitset(size)\n * obj.fix(idx)\n * obj.unfix(idx)\n * obj.flip()\n * var param_4 = obj.all()\n * var param_5 = obj.one()\n * var param_6 = obj.count()\n * var param_7 = obj.toString()\n */",
    "php": "class Bitset {\n    /**\n     * @param Integer $size\n     */\n    function __construct($size) {\n        \n    }\n  \n    /**\n     * @param Integer $idx\n     * @return NULL\n     */\n    function fix($idx) {\n        \n    }\n  \n    /**\n     * @param Integer $idx\n     * @return NULL\n     */\n    function unfix($idx) {\n        \n    }\n  \n    /**\n     * @return NULL\n     */\n    function flip() {\n        \n    }\n  \n    /**\n     * @return Boolean\n     */\n    function all() {\n        \n    }\n  \n    /**\n     * @return Boolean\n     */\n    function one() {\n        \n    }\n  \n    /**\n     * @return Integer\n     */\n    function count() {\n        \n    }\n  \n    /**\n     * @return String\n     */\n    function toString() {\n        \n    }\n}\n\n/**\n * Your Bitset object will be instantiated and called as such:\n * $obj = Bitset($size);\n * $obj->fix($idx);\n * $obj->unfix($idx);\n * $obj->flip();\n * $ret_4 = $obj->all();\n * $ret_5 = $obj->one();\n * $ret_6 = $obj->count();\n * $ret_7 = $obj->toString();\n */",
    "swift": "\nclass Bitset {\n\n    init(_ size: Int) {\n        \n    }\n    \n    func fix(_ idx: Int) {\n        \n    }\n    \n    func unfix(_ idx: Int) {\n        \n    }\n    \n    func flip() {\n        \n    }\n    \n    func all() -> Bool {\n        \n    }\n    \n    func one() -> Bool {\n        \n    }\n    \n    func count() -> Int {\n        \n    }\n    \n    func toString() -> String {\n        \n    }\n}\n\n/**\n * Your Bitset object will be instantiated and called as such:\n * let obj = Bitset(size)\n * obj.fix(idx)\n * obj.unfix(idx)\n * obj.flip()\n * let ret_4: Bool = obj.all()\n * let ret_5: Bool = obj.one()\n * let ret_6: Int = obj.count()\n * let ret_7: String = obj.toString()\n */",
    "kotlin": "class Bitset(size: Int) {\n\n    fun fix(idx: Int) {\n        \n    }\n\n    fun unfix(idx: Int) {\n        \n    }\n\n    fun flip() {\n        \n    }\n\n    fun all(): Boolean {\n        \n    }\n\n    fun one(): Boolean {\n        \n    }\n\n    fun count(): Int {\n        \n    }\n\n    fun toString(): String {\n        \n    }\n\n}\n\n/**\n * Your Bitset object will be instantiated and called as such:\n * var obj = Bitset(size)\n * obj.fix(idx)\n * obj.unfix(idx)\n * obj.flip()\n * var param_4 = obj.all()\n * var param_5 = obj.one()\n * var param_6 = obj.count()\n * var param_7 = obj.toString()\n */",
    "dart": "class Bitset {\n\n  Bitset(int size) {\n    \n  }\n  \n  void fix(int idx) {\n    \n  }\n  \n  void unfix(int idx) {\n    \n  }\n  \n  void flip() {\n    \n  }\n  \n  bool all() {\n    \n  }\n  \n  bool one() {\n    \n  }\n  \n  int count() {\n    \n  }\n  \n  String toString() {\n    \n  }\n}\n\n/**\n * Your Bitset object will be instantiated and called as such:\n * Bitset obj = Bitset(size);\n * obj.fix(idx);\n * obj.unfix(idx);\n * obj.flip();\n * bool param4 = obj.all();\n * bool param5 = obj.one();\n * int param6 = obj.count();\n * String param7 = obj.toString();\n */",
    "golang": "type Bitset struct {\n    \n}\n\n\nfunc Constructor(size int) Bitset {\n    \n}\n\n\nfunc (this *Bitset) Fix(idx int)  {\n    \n}\n\n\nfunc (this *Bitset) Unfix(idx int)  {\n    \n}\n\n\nfunc (this *Bitset) Flip()  {\n    \n}\n\n\nfunc (this *Bitset) All() bool {\n    \n}\n\n\nfunc (this *Bitset) One() bool {\n    \n}\n\n\nfunc (this *Bitset) Count() int {\n    \n}\n\n\nfunc (this *Bitset) ToString() string {\n    \n}\n\n\n/**\n * Your Bitset object will be instantiated and called as such:\n * obj := Constructor(size);\n * obj.Fix(idx);\n * obj.Unfix(idx);\n * obj.Flip();\n * param_4 := obj.All();\n * param_5 := obj.One();\n * param_6 := obj.Count();\n * param_7 := obj.ToString();\n */",
    "ruby": "class Bitset\n\n=begin\n    :type size: Integer\n=end\n    def initialize(size)\n        \n    end\n\n\n=begin\n    :type idx: Integer\n    :rtype: Void\n=end\n    def fix(idx)\n        \n    end\n\n\n=begin\n    :type idx: Integer\n    :rtype: Void\n=end\n    def unfix(idx)\n        \n    end\n\n\n=begin\n    :rtype: Void\n=end\n    def flip()\n        \n    end\n\n\n=begin\n    :rtype: Boolean\n=end\n    def all()\n        \n    end\n\n\n=begin\n    :rtype: Boolean\n=end\n    def one()\n        \n    end\n\n\n=begin\n    :rtype: Integer\n=end\n    def count()\n        \n    end\n\n\n=begin\n    :rtype: String\n=end\n    def to_string()\n        \n    end\n\n\nend\n\n# Your Bitset object will be instantiated and called as such:\n# obj = Bitset.new(size)\n# obj.fix(idx)\n# obj.unfix(idx)\n# obj.flip()\n# param_4 = obj.all()\n# param_5 = obj.one()\n# param_6 = obj.count()\n# param_7 = obj.to_string()",
    "scala": "class Bitset(_size: Int) {\n\n    def fix(idx: Int): Unit = {\n        \n    }\n\n    def unfix(idx: Int): Unit = {\n        \n    }\n\n    def flip(): Unit = {\n        \n    }\n\n    def all(): Boolean = {\n        \n    }\n\n    def one(): Boolean = {\n        \n    }\n\n    def count(): Int = {\n        \n    }\n\n    def toString(): String = {\n        \n    }\n\n}\n\n/**\n * Your Bitset object will be instantiated and called as such:\n * val obj = new Bitset(size)\n * obj.fix(idx)\n * obj.unfix(idx)\n * obj.flip()\n * val param_4 = obj.all()\n * val param_5 = obj.one()\n * val param_6 = obj.count()\n * val param_7 = obj.toString()\n */",
    "rust": "struct Bitset {\n\n}\n\n\n/** \n * `&self` means the method takes an immutable reference.\n * If you need a mutable reference, change it to `&mut self` instead.\n */\nimpl Bitset {\n\n    fn new(size: i32) -> Self {\n        \n    }\n    \n    fn fix(&self, idx: i32) {\n        \n    }\n    \n    fn unfix(&self, idx: i32) {\n        \n    }\n    \n    fn flip(&self) {\n        \n    }\n    \n    fn all(&self) -> bool {\n        \n    }\n    \n    fn one(&self) -> bool {\n        \n    }\n    \n    fn count(&self) -> i32 {\n        \n    }\n    \n    fn to_string(&self) -> String {\n        \n    }\n}\n\n/**\n * Your Bitset object will be instantiated and called as such:\n * let obj = Bitset::new(size);\n * obj.fix(idx);\n * obj.unfix(idx);\n * obj.flip();\n * let ret_4: bool = obj.all();\n * let ret_5: bool = obj.one();\n * let ret_6: i32 = obj.count();\n * let ret_7: String = obj.to_string();\n */",
    "racket": "(define bitset%\n  (class object%\n    (super-new)\n    \n    ; size : exact-integer?\n    (init-field\n      size)\n    \n    ; fix : exact-integer? -> void?\n    (define/public (fix idx)\n      )\n    ; unfix : exact-integer? -> void?\n    (define/public (unfix idx)\n      )\n    ; flip : -> void?\n    (define/public (flip)\n      )\n    ; all : -> boolean?\n    (define/public (all)\n      )\n    ; one : -> boolean?\n    (define/public (one)\n      )\n    ; count : -> exact-integer?\n    (define/public (count)\n      )\n    ; to-string : -> string?\n    (define/public (to-string)\n      )))\n\n;; Your bitset% object will be instantiated and called as such:\n;; (define obj (new bitset% [size size]))\n;; (send obj fix idx)\n;; (send obj unfix idx)\n;; (send obj flip)\n;; (define param_4 (send obj all))\n;; (define param_5 (send obj one))\n;; (define param_6 (send obj count))\n;; (define param_7 (send obj to-string))",
    "erlang": "-spec bitset_init_(Size :: integer()) -> any().\nbitset_init_(Size) ->\n  .\n\n-spec bitset_fix(Idx :: integer()) -> any().\nbitset_fix(Idx) ->\n  .\n\n-spec bitset_unfix(Idx :: integer()) -> any().\nbitset_unfix(Idx) ->\n  .\n\n-spec bitset_flip() -> any().\nbitset_flip() ->\n  .\n\n-spec bitset_all() -> boolean().\nbitset_all() ->\n  .\n\n-spec bitset_one() -> boolean().\nbitset_one() ->\n  .\n\n-spec bitset_count() -> integer().\nbitset_count() ->\n  .\n\n-spec bitset_to_string() -> unicode:unicode_binary().\nbitset_to_string() ->\n  .\n\n\n%% Your functions will be called as such:\n%% bitset_init_(Size),\n%% bitset_fix(Idx),\n%% bitset_unfix(Idx),\n%% bitset_flip(),\n%% Param_4 = bitset_all(),\n%% Param_5 = bitset_one(),\n%% Param_6 = bitset_count(),\n%% Param_7 = bitset_to_string(),\n\n%% bitset_init_ will be called before every test case, in which you can do some necessary initializations.",
    "elixir": "defmodule Bitset do\n  @spec init_(size :: integer) :: any\n  def init_(size) do\n    \n  end\n\n  @spec fix(idx :: integer) :: any\n  def fix(idx) do\n    \n  end\n\n  @spec unfix(idx :: integer) :: any\n  def unfix(idx) do\n    \n  end\n\n  @spec flip() :: any\n  def flip() do\n    \n  end\n\n  @spec all() :: boolean\n  def all() do\n    \n  end\n\n  @spec one() :: boolean\n  def one() do\n    \n  end\n\n  @spec count() :: integer\n  def count() do\n    \n  end\n\n  @spec to_string() :: String.t\n  def to_string() do\n    \n  end\nend\n\n# Your functions will be called as such:\n# Bitset.init_(size)\n# Bitset.fix(idx)\n# Bitset.unfix(idx)\n# Bitset.flip()\n# param_4 = Bitset.all()\n# param_5 = Bitset.one()\n# param_6 = Bitset.count()\n# param_7 = Bitset.to_string()\n\n# Bitset.init_ will be called before every test case, in which you can do some necessary initializations."
  }
}