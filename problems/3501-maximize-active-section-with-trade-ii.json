{
  "title": "Maximize Active Section with Trade II",
  "problem_id": "3804",
  "frontend_id": "3501",
  "difficulty": "Hard",
  "problem_slug": "maximize-active-section-with-trade-ii",
  "topics": [
    "Array",
    "String",
    "Binary Search",
    "Segment Tree"
  ],
  "description": "You are given a binary string s of length n, where:\nYou can perform at most one trade to maximize the number of active sections in s. In a trade, you:\nAdditionally, you are given a 2D array queries, where queries[i] = [li, ri] represents a substring s[li...ri].\nFor each query, determine the maximum possible number of active sections in s after making the optimal trade on the substring s[li...ri].\nReturn an array answer, where answer[i] is the result for queries[i].\nNote\nExample 1:\nExample 2:\nExample 3:\nExample 4:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: s = \"01\", queries = [[0,1]]\nOutput: [1]\nExplanation:\nBecause there is no block of '1' s surrounded by '0' s, no valid trade is possible. The maximum number of active sections is 1.",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input: s = \"0100\", queries = [[0,3],[0,2],[1,3],[2,3]]\nOutput: [4,3,1,1]\nExplanation:\nQuery [0, 3] → Substring \"0100\" → Augmented to \"101001\" Choose \"0100\" , convert \"0100\" → \"0000\" → \"1111\" . The final string without augmentation is \"1111\" . The maximum number of active sections is 4.\nQuery [0, 2] → Substring \"010\" → Augmented to \"10101\" Choose \"010\" , convert \"010\" → \"000\" → \"111\" . The final string without augmentation is \"1110\" . The maximum number of active sections is 3.\nQuery [1, 3] → Substring \"100\" → Augmented to \"11001\" Because there is no block of '1' s surrounded by '0' s, no valid trade is possible. The maximum number of active sections is 1.\nQuery [2, 3] → Substring \"00\" → Augmented to \"1001\" Because there is no block of '1' s surrounded by '0' s, no valid trade is possible. The maximum number of active sections is 1.",
      "images": []
    },
    {
      "example_num": 3,
      "example_text": "Input: s = \"1000100\", queries = [[1,5],[0,6],[0,4]]\nOutput: [6,7,2]\nExplanation:\nQuery [1, 5] → Substring \"00010\" → Augmented to \"1000101\" Choose \"00010\" , convert \"00010\" → \"00000\" → \"11111\" . The final string without augmentation is \"1111110\" . The maximum number of active sections is 6.\nQuery [0, 6] → Substring \"1000100\" → Augmented to \"110001001\" Choose \"000100\" , convert \"000100\" → \"000000\" → \"111111\" . The final string without augmentation is \"1111111\" . The maximum number of active sections is 7.\nQuery [0, 4] → Substring \"10001\" → Augmented to \"1100011\" Because there is no block of '1' s surrounded by '0' s, no valid trade is possible. The maximum number of active sections is 2.",
      "images": []
    },
    {
      "example_num": 4,
      "example_text": "Input: s = \"01010\", queries = [[0,3],[1,4],[1,3]]\nOutput: [4,4,2]\nExplanation:\nQuery [0, 3] → Substring \"0101\" → Augmented to \"101011\" Choose \"010\" , convert \"010\" → \"000\" → \"111\" . The final string without augmentation is \"11110\" . The maximum number of active sections is 4.\nQuery [1, 4] → Substring \"1010\" → Augmented to \"110101\" Choose \"010\" , convert \"010\" → \"000\" → \"111\" . The final string without augmentation is \"01111\" . The maximum number of active sections is 4.\nQuery [1, 3] → Substring \"101\" → Augmented to \"11011\" Because there is no block of '1' s surrounded by '0' s, no valid trade is possible. The maximum number of active sections is 2.",
      "images": []
    }
  ],
  "constraints": [
    "1 <= n == s.length <= 105",
    "1 <= queries.length <= 105",
    "s[i] is either '0' or '1'.",
    "queries[i] = [li, ri]",
    "0 <= li <= ri < n"
  ],
  "follow_ups": [],
  "hints": [
    "Split consecutive zeros and ones into segments and give each segment an ID.",
    "The answer should be the maximum of <code>ans[i] = len[i - 1] + len[i + 1]</code>, where <code>i</code> is a one-segment.",
    "For a zero-segment, define <code>ans[i] = 0</code>.",
    "Note that all three segments (<code>i - 1</code>, <code>i</code>, and <code>i + 1</code>) should be fully covered by the substring.",
    "Use a segment tree to perform range maximum queries on the answer. The query to the segment tree is not straightforward since we need to ensure the zero-segments are fully covered. Handle the first and last segments separately."
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    vector<int> maxActiveSectionsAfterTrade(string s, vector<vector<int>>& queries) {\n        \n    }\n};",
    "java": "class Solution {\n    public List<Integer> maxActiveSectionsAfterTrade(String s, int[][] queries) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def maxActiveSectionsAfterTrade(self, s, queries):\n        \"\"\"\n        :type s: str\n        :type queries: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def maxActiveSectionsAfterTrade(self, s: str, queries: List[List[int]]) -> List[int]:\n        ",
    "c": "/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nint* maxActiveSectionsAfterTrade(char* s, int** queries, int queriesSize, int* queriesColSize, int* returnSize) {\n    \n}",
    "csharp": "public class Solution {\n    public IList<int> MaxActiveSectionsAfterTrade(string s, int[][] queries) {\n        \n    }\n}",
    "javascript": "/**\n * @param {string} s\n * @param {number[][]} queries\n * @return {number[]}\n */\nvar maxActiveSectionsAfterTrade = function(s, queries) {\n    \n};",
    "typescript": "function maxActiveSectionsAfterTrade(s: string, queries: number[][]): number[] {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param String $s\n     * @param Integer[][] $queries\n     * @return Integer[]\n     */\n    function maxActiveSectionsAfterTrade($s, $queries) {\n        \n    }\n}",
    "swift": "class Solution {\n    func maxActiveSectionsAfterTrade(_ s: String, _ queries: [[Int]]) -> [Int] {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun maxActiveSectionsAfterTrade(s: String, queries: Array<IntArray>): List<Int> {\n        \n    }\n}",
    "dart": "class Solution {\n  List<int> maxActiveSectionsAfterTrade(String s, List<List<int>> queries) {\n    \n  }\n}",
    "golang": "func maxActiveSectionsAfterTrade(s string, queries [][]int) []int {\n    \n}",
    "ruby": "# @param {String} s\n# @param {Integer[][]} queries\n# @return {Integer[]}\ndef max_active_sections_after_trade(s, queries)\n    \nend",
    "scala": "object Solution {\n    def maxActiveSectionsAfterTrade(s: String, queries: Array[Array[Int]]): List[Int] = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn max_active_sections_after_trade(s: String, queries: Vec<Vec<i32>>) -> Vec<i32> {\n        \n    }\n}",
    "racket": "(define/contract (max-active-sections-after-trade s queries)\n  (-> string? (listof (listof exact-integer?)) (listof exact-integer?))\n  )",
    "erlang": "-spec max_active_sections_after_trade(S :: unicode:unicode_binary(), Queries :: [[integer()]]) -> [integer()].\nmax_active_sections_after_trade(S, Queries) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec max_active_sections_after_trade(s :: String.t, queries :: [[integer]]) :: [integer]\n  def max_active_sections_after_trade(s, queries) do\n    \n  end\nend"
  }
}