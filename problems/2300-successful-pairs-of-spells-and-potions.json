{
  "title": "Successful Pairs of Spells and Potions",
  "problem_id": "2392",
  "frontend_id": "2300",
  "difficulty": "Medium",
  "problem_slug": "successful-pairs-of-spells-and-potions",
  "topics": [
    "Array",
    "Two Pointers",
    "Binary Search",
    "Sorting"
  ],
  "description": "You are given two positive integer arrays spells and potions, of length n and m respectively, where spells[i] represents the strength of the ith spell and potions[j] represents the strength of the jth potion.\nYou are also given an integer success. A spell and potion pair is considered successful if the product of their strengths is at least success.\nReturn an integer array pairs of length n where pairs[i] is the number of potions that will form a successful pair with the ith spell.\nExample 1:\nExample 2:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: spells = [5,1,3], potions = [1,2,3,4,5], success = 7\nOutput: [4,0,3]\nExplanation:\n- 0th spell: 5 * [1,2,3,4,5] = [5,10,15,20,25]. 4 pairs are successful.\n- 1st spell: 1 * [1,2,3,4,5] = [1,2,3,4,5]. 0 pairs are successful.\n- 2nd spell: 3 * [1,2,3,4,5] = [3,6,9,12,15]. 3 pairs are successful.\nThus, [4,0,3] is returned.",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input: spells = [3,1,2], potions = [8,5,8], success = 16\nOutput: [2,0,2]\nExplanation:\n- 0th spell: 3 * [8,5,8] = [24,15,24]. 2 pairs are successful.\n- 1st spell: 1 * [8,5,8] = [8,5,8]. 0 pairs are successful. \n- 2nd spell: 2 * [8,5,8] = [16,10,16]. 2 pairs are successful. \nThus, [2,0,2] is returned.",
      "images": []
    }
  ],
  "constraints": [
    "n == spells.length",
    "m == potions.length",
    "1 <= n, m <= 105",
    "1 <= spells[i], potions[i] <= 105",
    "1 <= success <= 1010"
  ],
  "follow_ups": [],
  "hints": [
    "Notice that if a spell and potion pair is successful, then the spell and all stronger potions will be successful too.",
    "Thus, for each spell, we need to find the potion with the least strength that will form a successful pair.",
    "We can efficiently do this by sorting the potions based on strength and using binary search."
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\n        \n    }\n};",
    "java": "class Solution {\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def successfulPairs(self, spells, potions, success):\n        \"\"\"\n        :type spells: List[int]\n        :type potions: List[int]\n        :type success: int\n        :rtype: List[int]\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\n        ",
    "c": "/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nint* successfulPairs(int* spells, int spellsSize, int* potions, int potionsSize, long long success, int* returnSize) {\n    \n}",
    "csharp": "public class Solution {\n    public int[] SuccessfulPairs(int[] spells, int[] potions, long success) {\n        \n    }\n}",
    "javascript": "/**\n * @param {number[]} spells\n * @param {number[]} potions\n * @param {number} success\n * @return {number[]}\n */\nvar successfulPairs = function(spells, potions, success) {\n    \n};",
    "typescript": "function successfulPairs(spells: number[], potions: number[], success: number): number[] {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param Integer[] $spells\n     * @param Integer[] $potions\n     * @param Integer $success\n     * @return Integer[]\n     */\n    function successfulPairs($spells, $potions, $success) {\n        \n    }\n}",
    "swift": "class Solution {\n    func successfulPairs(_ spells: [Int], _ potions: [Int], _ success: Int) -> [Int] {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun successfulPairs(spells: IntArray, potions: IntArray, success: Long): IntArray {\n        \n    }\n}",
    "dart": "class Solution {\n  List<int> successfulPairs(List<int> spells, List<int> potions, int success) {\n    \n  }\n}",
    "golang": "func successfulPairs(spells []int, potions []int, success int64) []int {\n    \n}",
    "ruby": "# @param {Integer[]} spells\n# @param {Integer[]} potions\n# @param {Integer} success\n# @return {Integer[]}\ndef successful_pairs(spells, potions, success)\n    \nend",
    "scala": "object Solution {\n    def successfulPairs(spells: Array[Int], potions: Array[Int], success: Long): Array[Int] = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn successful_pairs(spells: Vec<i32>, potions: Vec<i32>, success: i64) -> Vec<i32> {\n        \n    }\n}",
    "racket": "(define/contract (successful-pairs spells potions success)\n  (-> (listof exact-integer?) (listof exact-integer?) exact-integer? (listof exact-integer?))\n  )",
    "erlang": "-spec successful_pairs(Spells :: [integer()], Potions :: [integer()], Success :: integer()) -> [integer()].\nsuccessful_pairs(Spells, Potions, Success) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec successful_pairs(spells :: [integer], potions :: [integer], success :: integer) :: [integer]\n  def successful_pairs(spells, potions, success) do\n    \n  end\nend"
  }
}