{
  "title": "Number of Ways to Divide a Long Corridor",
  "problem_id": "2251",
  "frontend_id": "2147",
  "difficulty": "Hard",
  "problem_slug": "number-of-ways-to-divide-a-long-corridor",
  "topics": [
    "Math",
    "String",
    "Dynamic Programming"
  ],
  "description": "Along a long library corridor, there is a line of seats and decorative plants. You are given a 0-indexed string corridor of length n consisting of letters 'S' and 'P' where each 'S' represents a seat and each 'P' represents a plant.\nOne room divider has already been installed to the left of index 0, and another to the right of index n - 1. Additional room dividers can be installed. For each position between indices i - 1 and i (1 <= i <= n - 1), at most one divider can be installed.\nDivide the corridor into non-overlapping sections, where each section has exactly two seats with any number of plants. There may be multiple ways to perform the division. Two ways are different if there is a position with a room divider installed in the first way but not in the second way.\nReturn the number of ways to divide the corridor. Since the answer may be very large, return it modulo 109 + 7. If there is no way, return 0.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: corridor = \"SSPPSPS\"\nOutput: 3\nExplanation: There are 3 different ways to divide the corridor.\nThe black bars in the above image indicate the two room dividers already installed.\nNote that in each of the ways, each section has exactly two seats.",
      "images": [
        "https://assets.leetcode.com/uploads/2021/12/04/1.png"
      ]
    },
    {
      "example_num": 2,
      "example_text": "Input: corridor = \"PPSPSP\"\nOutput: 1\nExplanation: There is only 1 way to divide the corridor, by not installing any additional dividers.\nInstalling any would create some section that does not have exactly two seats.",
      "images": [
        "https://assets.leetcode.com/uploads/2021/12/04/2.png"
      ]
    },
    {
      "example_num": 3,
      "example_text": "Input: corridor = \"S\"\nOutput: 0\nExplanation: There is no way to divide the corridor because there will always be a section that does not have exactly two seats.",
      "images": [
        "https://assets.leetcode.com/uploads/2021/12/12/3.png"
      ]
    }
  ],
  "constraints": [
    "n == corridor.length",
    "1 <= n <= 105",
    "corridor[i] is either 'S' or 'P'."
  ],
  "follow_ups": [],
  "hints": [
    "Divide the corridor into segments. Each segment has two seats, starts precisely with one seat, and ends precisely with the other seat.",
    "How many dividers can you install between two adjacent segments? You must install precisely one. Otherwise, you would have created a section with not exactly two seats.",
    "If there are k plants between two adjacent segments, there are k + 1 positions (ways) you could install the divider you must install.",
    "The problem now becomes: Find the product of all possible positions between every two adjacent segments."
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    int numberOfWays(string corridor) {\n        \n    }\n};",
    "java": "class Solution {\n    public int numberOfWays(String corridor) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def numberOfWays(self, corridor):\n        \"\"\"\n        :type corridor: str\n        :rtype: int\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def numberOfWays(self, corridor: str) -> int:\n        ",
    "c": "int numberOfWays(char* corridor) {\n    \n}",
    "csharp": "public class Solution {\n    public int NumberOfWays(string corridor) {\n        \n    }\n}",
    "javascript": "/**\n * @param {string} corridor\n * @return {number}\n */\nvar numberOfWays = function(corridor) {\n    \n};",
    "typescript": "function numberOfWays(corridor: string): number {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param String $corridor\n     * @return Integer\n     */\n    function numberOfWays($corridor) {\n        \n    }\n}",
    "swift": "class Solution {\n    func numberOfWays(_ corridor: String) -> Int {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun numberOfWays(corridor: String): Int {\n        \n    }\n}",
    "dart": "class Solution {\n  int numberOfWays(String corridor) {\n    \n  }\n}",
    "golang": "func numberOfWays(corridor string) int {\n    \n}",
    "ruby": "# @param {String} corridor\n# @return {Integer}\ndef number_of_ways(corridor)\n    \nend",
    "scala": "object Solution {\n    def numberOfWays(corridor: String): Int = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn number_of_ways(corridor: String) -> i32 {\n        \n    }\n}",
    "racket": "(define/contract (number-of-ways corridor)\n  (-> string? exact-integer?)\n  )",
    "erlang": "-spec number_of_ways(Corridor :: unicode:unicode_binary()) -> integer().\nnumber_of_ways(Corridor) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec number_of_ways(corridor :: String.t) :: integer\n  def number_of_ways(corridor) do\n    \n  end\nend"
  },
  "solution": "[TOC]\n\n## Solution\n\n--- \n\n### Overview\n\nIn this problem, we are supposed to divide the `corridor`  which contains seats (encoded by `S`) and plants (encoded by `P`).\n\nThe division should produce non-overlapping sections such that each section contains **exactly** two `S`. There is no restriction on the number of `P` in each section, which offers flexibility to shift the divider.\n\n> Flexibility provided by `P` produces different ways to perform the division.\n\nWe are supposed to count the number of ways to divide the corridor, and then return the count modulo `1000000007`. Moreover, if there is no way to divide the corridor, we should return `0`.\n\nLet's try to filter out cases when the task is not possible, based on the number of `S` and `P` in the corridor.\n\n- if we have `0` seat, then we can't divide the corridor, because no section can contain **exactly** two `S`.\n\n- if we have only `1` seat, then we can't divide the corridor, because no section can contain **exactly** two `S`. \n\n- if we have only `2` seats, then we can divide the corridor, but in only one way, because there is only one way to divide the corridor into two sections, each containing **exactly** two `S`.\n\n    ![twoS](../Figures/2147/2147_used/Slide1_1.PNG){:height=\"75px\"}\n\n    The `...` in the illustration above represents any number of `P` (including `0`) in the `corridor`.\n\n    The only way is to use the existing installed end-divider so that each section contains **exactly** two `S`. If we shift any of these dividers or install a new divider, then we will end up with a section containing less than two `S`.\n\n- if we have only `3` seats, then again, we can't divide the corridor, because no division is such that each section contains **exactly** two `S`. There will be at least one section containing less than two `S`.\n\n- Let's examine one more case before generalizing the above observations. If we have `4` seats, then we can divide the corridor. Let's focus on the illustration to understand the division.\n\n    ![fourS](../Figures/2147/2147_used/Slide1_2.PNG){:height=\"75px\"}\n\n    The `...` in the illustration above represents any number of `P` (including `0`) in the `corridor`. \n    \n    We can have only one divider between the second and third `S`. Now, the number of ways we can have this divider certainly depends on the number of `P` between the second and third `S`. \n    \n    ![fourS](../Figures/2147/2147_used/Slide2.PNG){:height=\"80px\"}\n\n    - If there is `0` `P` between the second and third `S`, then we can have only one way of installing the divider.\n\n        ![fourSzeroP](../Figures/2147/2147_used/Slide3_1.PNG){:height=\"75px\"} \n\n    - If there is `1` `P` between the second and third `S`, then we can have two ways of installing the divider. Note that out of these two blue bars, we will select only one in one division. Thus, there are two **different** ways in this example, with one divider!\n\n        ![fourSoneP](../Figures/2147/2147_used/Slide3_2.PNG){:height=\"75px\"}\n\n    - If there are `2` `P` between the second and third `S`, then we can have three ways of installing the divider. Again, more precisely, there are three **different** ways in this example, with one divider!\n\n        ![fourStwoP](../Figures/2147/2147_used/Slide3_3.PNG){:height=\"75px\"}\n\n    In general, \n    \n    \"If there are `k` `P` between second and third `S`, then we can have `k+1` ways of installing the divider\"\n\n    In other words, we can say that\n\n    **\"If the index of second `S` is `i` and the index of third `S` is `j`, then we can have `j-i` ways of installing the divider\"**\n\nBased on the above observations, we can generalize the following facts.\n\n1. *\"No seats, or odd number of seats in the `corridor` implies that there is no way to divide the `corridor`\"*\n   \n    - The contrapositive of every implication is also true. Thus, we can say that\n    \n      *\"If there is a way to divide the `corridor`, then there will be seats in the corridor, and the number of seats will be even\"*\n\n    - Readers can appreciate that the converse of the fact is also true. \n    \n      *\"If there is no way to divide the `corridor`, then there will be no seats, or odd number of seats in the `corridor`.\"*\n\n    - Moreover, the contrapositive of this converse, like every other contrapositive, is also true. Thus, we can say that\n\n      *\"If there are seats in the corridor, and the number of seats is even, then there will be a way to divide the `corridor`\"*\n\n2. The number of plants does not determine the presence of a dividing way. However, the number of plants, if there is a dividing way, will determine the number of **different** methods of installing the divider. \n\n3. We can also emphasize that the pair of a given seat `S` is fixed (provided there is a way to divide the `corridor`). This can be illustrated as\n    \n    - the first `S` will always be paired with the second `S`\n\n    - the second `S` will always be paired with the first `S`. If it has another neighbor, the third `S`, then also it will be paired with the first `S` only. We can't leave the first `S` unpaired because each section should contain **exactly** two `S`.\n    \n    - the third `S` will always be paired with the fourth `S`\n    \n    - the fifth `S` will always be paired with the sixth `S`\n    \n    - and so on...\n\n4. **We can only install a divider between two `S` that are \"neighbors, but not paired\", and plants in between them offer flexibility to install the divider in different ways**.\n\n    The number of plants between paired seats doesn't offer any facility to install the divider.\n\n    > - The first `S` and the second `S` are paired neighbors. The plants in between them offer any facility to install the divider.\n    > - The second `S` and the third `S` are \"neighbors, but not paired\". The plants in between them offer flexibility to install the divider in different ways.\n    > - The first `S` and the third `S` are not neighbors. \n\n    Similarly, the number of plants between the pre-installed divider and the first seat (or the last seat and the pre-installed divider) doesn't offer any facility to install the divider.\n\nNow, let's focus on the phrase\n\n> Since the answer may be very large, return it modulo `1000000007`.Since we need to deal with modular arithmetic, the section lists important properties of modular arithmetic. If readers are not familiar with these properties, they are encouraged to expand the section by clicking here.1. $(a + b) \\mod m = ((a \\mod m) + (b \\mod m)) \\mod m$\n\n    In programming, `(a + b) % m = ((a % m) + (b % m)) % m`\n\n2. $(a - b) \\mod m = ((a \\mod m) - (b \\mod m) + m) \\mod m$\n\n    In programming, `(a - b) % m = ((a % m) - (b % m) + m) % m`\n\n    The $m$ is added to avoid downflowing to a negative value. \n\n    > Let's write $(a - b)\\mod m = (a\\mod m - b\\mod m)\\mod m$ and assume $a > b$.\n    > It might happen that after taking $\\text{mod}$, the value $a\\mod m$ is smaller than $b\\mod m$. In that case, we need to add $m$. Thus $(a - b)\\mod m = (a\\mod m - b\\mod m + m)\\mod m$.\n\n    **Example:** Let $a = 6$, $b = 4$, $m = 5$. Thus, $(a - b)\\mod m$ will be $2$. Now, if we do  \n    = $(a\\mod m - b\\mod m) \\mod 5$, then it will be  \n    = $(6\\mod 5 - 4\\mod 5) \\mod 5$  \n    = $(1 - 4) \\mod 5$  \n    = $(-3) \\mod 5$  \n\n    The value `(-3) % 5` will be evaluated to `-3` in Programming Languages like Java.\n\n    > However, in Python3, it will come out to be `2`. Programming Languages deal with negative integer division differently.\n\n    Thus, to avoid this, we need to add $m$. Hence, the final answer will be   \n    $= (a\\mod m - b\\mod m + m)\\mod m$   \n    $= (6\\mod 5 - 4\\mod 5 + 5)\\mod 5$  \n    $= (1 - 4 + 5)\\mod 5$   \n    $= 2\\mod 5$  \n    $= 2$\n\n3. $(a \\cdot b) \\mod m = ((a \\mod m) \\cdot (b \\mod m)) \\mod m$\n\n    In programming, `(a * b) % m = ((a % m) * (b % m)) % m`\n\n4. $(a^b) \\mod m = ((a \\mod m)^b) \\mod m$$\\downarrow_{\\text{Section after propeties of modular arithmetic}}$\n\nWith a few important facts being established, let's move on to the solution.\n\n---\n\n### Approach 1: Top-Down Dynamic Programming\n\n#### Intuition\n\nLet's try to count the number of ways to divide the `corridor`, by analyzing the arrangement of `S` and `P` from left to right. We will put weight on the fact that \n\n> \"Plants `P` offer flexibility to install the divider in **different** ways\".\n>\n> Let's analyze this with three different ways to install the divider when there were 4 `S` in the `corridor`, and two `P` in between the second and third `S`.\n>\n> In this case, the yellow plant took the responsibility of installing the divider after confirming that two `S` are there in the section.\n> ![fourS_2P1](../Figures/2147/2147_used/Slide4_1.PNG){:height=\"75px\"}\n>\n> In this case, the yellow plant passes the baton to the next index. The pink plant took the responsibility of installing the divider after confirming that two `S` were there in the section.\n> ![fourS_2P2](../Figures/2147/2147_used/Slide4_2.PNG){:height=\"75px\"}\n>\n> In this case, the pink plant passed after receiving the baton from the yellow plant again passed the baton to the next index. The next index is a seat, and in fact, the third `S`, thus it cannot be part of the received baton's section. Thus, it installed the divider after realizing that there were already two `S` in the section.\n> ![fourS_2P3](../Figures/2147/2147_used/Slide4_3.PNG){:height=\"75px\"}\n>\n> Thus, every plant, in general, has two options after realizing that there are two `S` in the growing section. These options produce **different** ways to divide the `corridor`.\n\nInitially, we have a pre-installed divider before index `0`, and we are in the first section, which we can close only when we find a pair of `S` while scanning from left to right. \n\nThus, for formulating, let's use \n\n- `index` to denote the index of the current element in the `corridor`, and\n\n- `seats` to denote the number of `S` in the current section. The `seats` can take only a limited number of values.\n\n  - `0` if there is no `S` in the current section\n  - `1` if there is only one `S` in the current section\n  - `2` if there are two `S` in the current section.\n      - if we close the section here, it means that for the next section, we will have `0` `S` remaining.\n      \n      - if we don't close, then we can keep growing the section until we find another `S`, then the moment we find more than two `S` in the current section, we have to start a new section, and the `S` in the new section will be `1`.\n\n    Thus, because of formulation, we can say that the `seats` can take only three values, `0`, `1`, and `2`.\n\nThus, with these notations, let's try to compute the number of ways to divide the `corridor` as a function of `index` and `seats`. \n\nMore precisely, we will define a function `count(index, seats)` to denote the number of ways to divide the `corridor` starting from index `index` to the last index, with `seats` number of `S` in the current section.\n\n- if `index` reaches `n` (the `corridor.length()`), then the current section is valid only if `seats == 2`. \n\n    Thus, if `index == n`, we can return `1` if `seats == 2`, otherwise we can return `0`. This additional `1` implies that we have found a valid way to divide the `corridor`. We will ensure not to count the same way again, by ensuring that the `(i1, s1)` pair calls `count(i2, s2)` not more than once.\n\n- now if we are on a valid index, and the number of seats in the current sections is **exactly** `2`, then we either can close the section, or we can keep growing the section. It depends on whether `corridor[index]` is `S` or `P`.\n\n    - if `corridor[index]` is `S`, then we have to close the section and start a new section from this index. Thus, we need to call `count` for the next index, with `seats = 1`. Hence, return `count(index + 1, 1)`\n    \n    - if `corridor[index]` is `P`, then we have two options, and both of these options will generate **different** ways to divide the `corridor`. \n\n        - *close the section:* then at the next index, we will have `seats = 0`.\n          \n        - *keep growing the section:* then at the next index, we will have `seats = 2` only.\n\n        Hence, return `count(index + 1, 0) + count(index + 1, 2)`\n\n- lastly, if we are on a valid index, but number of seats in the current section is less than `2`, then we don't have any option but to keep growing the section.\n    \n    - if `corridor[index]` is `S`, the number of seats in the section will be incremented. Hence, return `count(index + 1, seats + 1)`\n     \n    - if `corridor[index]` is `P`, then return `count(index + 1, seats)`\n\n\nWe would call `count(0, 0)` to compute the number of ways to divide the `corridor` starting from index `0` to the last index, with `0` number of `S` in the current section.\n\nNow, we can see that the function `count` is a recursive function. There might be a case when one sub-problem is called multiple times. The following tree illustrates one such case for `corridor` as `\"SSPPSPS\"`\n\n> ![recursionTree](../Figures/2147/2147_used/Slide5.PNG)\n> \n> The same color-coded rectangles denote the same sub-problems. In general, we call two sub-problems when `corridors[index] == P` and `seats == 2`\n>\n> At `(2, 2)` we call `(3, 0)` to close the section, and `(3, 2)` to keep growing the section.  \n> \n> - At `(3, 0)` we call `(4, 0)` to grow the section. We can't close the section because we have `0` `S` in the current section.\n> - At `(3, 2)` we call `(4, 0)` to close the section, and `(4, 2)` to keep growing the section.\n>\n> Thus, we can see that `(4, 0)` is called twice.\n\nAlthough we might call the same sub-problem multiple times, we aren't double counting the same way to divide the `corridor`. The count is incremented at the leaf nodes, and the leaf nodes with `seats == 2` represent a unique way to divide the `corridor`.\n\nStill, computing these overlapping sub-problems again and again is not efficient. \n\n**What if we store the result of each sub-problem and use it when required?** This is what we do in dynamic programming. We store the result of each sub-problem and use it when required. Thus, instead of solving the same sub-problem again and again, we can store the result of each sub-problem and use it whenever required. \n\n> Dynamic programming is a programming paradigm in which we break a problem into sub-problems store the result of each sub-problem and use it when required. To dive deep into dynamic programming, readers can visit [**Dynamic Programming Explore Card**](https://leetcode.com/explore/featured/card/dynamic-programming/).\n\nSince there are two state variables `index` and `seats`, we can use a two-dimensional array (or a hash map) to store the result of each sub-problem.\n\n> If there are $T$ state variables, then we need an array of at most $T$ dimensions to store the result of each sub-problem.\n\n**What will be the size of the array?** The size of the array will be the range of each state variable.\n- `index` can take values from `0` to `n - 1`, where `n` is the length of the `corridor`. Thus, there can be `n` rows in the memoization array. `index == n` is the base case, and need not be stored in the memoization array.\n- `seats` can take values from `0` to `2`. Thus, there can be `3` columns in the memoization array. \n\nThere is no hard-and-fast rule to use a two-dimensional array. We may use a hash map to cache the result of each sub-problem. The key of the hash map would be the pair `(index, seats)`, and the value would be the result of the sub-problem.\n\nReaders are encouraged to implement the solution on their own. Make sure to take modulo `1000000007` while storing the result in the `cache` array. We will exploit properties of modular arithmetic as discussed in the [overview](#overview) section.\n\n#### Algorithm\n\n1. Store `1000000007` in the variable `MOD` for convenience. It is a good practice to store constants.\n\n2. Initialize a two-dimensional array `cache` of size `n` rows and `3` columns. Initialize each element of the array to `-1`. We will use this array to cache the result of each sub-problem. Alternatively, we can use a hash map to cache the result of each sub-problem.\n\n3. Define a function `count` which takes two arguments `index` and `seats`. It can have other arguments as well to access the required variables.\n\n    - If `index` is equal to `n`, then the current section is valid only if `seats` is equal to `2`. Thus, return `1` if `seats == 2`, otherwise return `0`.\n\n    - If `cache[index][seats]` is not equal to `-1`, then return `cache[index][seats]`. This implies that we have already computed the result of this sub-problem, and we can return the cached result.\n\n    - If the current section has `seats == 2`\n\n        - If `corridor[index]` is `S`, then we have to close the section and start a new section from this index. Thus, return `count(index + 1, 1)`\n        - If `corridor[index]` is `P`, then we have the option to close or to keep growing the section. Thus, return `(count(index + 1, 0) + count(index + 1, 2)) % MOD`\n\n    - If the current section has `seats < 2`, then we have to keep growing the section.  \n\n        - If `corridor[index]` is `S`, then return `count(index + 1, seats + 1)`\n        - If `corridor[index]` is `P`, then return `count(index + 1, seats)`\n\n4. Call the function `count` with `index = 0` and `seats = 0`. Return the result of the function call. \n\n#### Implementation**Implementation Notes**\n\n1. The Python, C, and C++ implementation uses a two-dimensional array. The Java and JavaScript implementation uses a hash map.\n\n2. In the `cache`, we will store the result, which is less than `1000000007`. Now, when we are adding two such results *(in the case when `corridors[index] == P` and `seats == 2`)*, then we need to take modulo `1000000007` again because the sum of two numbers less than `1000000007` can be greater than `1000000007`.\n\n    It's worth noting that the sum of two numbers less than `1000000007` can be at most `2000000012` which is less than `INT_MAX`. Hence, we need not to worry about overflow when only two numbers are added.\n\n#### Complexity Analysis\n\nLet $N$ be the length of the `corridor`.\n\n* Time complexity: $O(N)$\n\n    We are calling the function `count` for each `index` with constant three possible values of `seats`. Thus, there will be at most $3N$ function calls. Each function call computes the result in constant time. Thus, the time complexity will be $O(3N) \\cdot O(1)$, which is $O(N)$.\n\n* Space complexity: $O(N)$\n\n    We are using a two-dimensional array of size $N \\times 3$ to cache the result of each sub-problem. Thus, the space complexity will be $O(N \\cdot 3)$, which is $O(N)$. \n        \n---\n\n### Approach 2: Bottom-up Dynamic Programming\n\n#### Intuition\n\nLet's transform the recursive solution into an iterative solution.\n\nFor this let's write the mathematical recurrence for the problem. \n\n$\\text{count}(index, seats)$ represents the number of ways to divide the `corridor` starting from index `index` to the last index, with `seats` number of `S` in the current section. The equation for the recurrence (which is often called the Bellman equation) is\n\n$\\text{count}(index, seats) = \\begin{cases} 1 & \\text{if } index = corridor.length \\text{ and } seats = 2 \\\\\n0 & \\text{if } index = corridor.length \\text{ and } seats < 2 \\\\\n\\\\\n\\text{count}(index + 1, 1) & \\text{if } seats = 2 \\text{ and } corridor[index] = S \\\\\n\\text{count}(index + 1, 0) + \\text{count}(index + 1, 2) & \\text{if } seats = 2 \\text{ and } corridor[index] = P \\\\\n\\text{count}(index + 1, seats + 1) & \\text{if } seats < 2 \\text{ and } corridor[index] = S \\\\\n\\text{count}(index + 1, seats) & \\text{if } seats < 2 \\text{ and } corridor[index] = P \\end{cases}$\n\nLet's break this recurrence for every possible value of $seats$ separately. Thus, we can have the following three recurrences.\n\n$\\text{count}(index, 0) = \\begin{cases} 0 & \\text{if } index = corridor.length \\\\\n\\\\\n\\text{count}(index + 1, 1) & \\text{if } corridor[index] = S \\\\\n\\text{count}(index + 1, 0) & \\text{if } corridor[index] = P \\end{cases}$\n\n$\\text{count}(index, 1) = \\begin{cases} 0 & \\text{if } index = corridor.length \\\\\n\\\\\n\\text{count}(index + 1, 2) & \\text{if } corridor[index] = S \\\\\n\\text{count}(index + 1, 1) & \\text{if } corridor[index] = P \\end{cases}$\n\n$\\text{count}(index, 2) = \\begin{cases} 1 & \\text{if } index = corridor.length \\\\\n\\\\\n\\text{count}(index + 1, 1) & \\text{if } corridor[index] = S \\\\\n\\text{count}(index + 1, 0) + \\text{count}(index + 1, 2) & \\text{if } corridor[index] = P \\end{cases}$\n\nSince there are two state variables `index` and `seats`, we can use a two-dimensional array to store the result of each sub-problem.\n\nOur agenda is to fill the array in a bottom-up fashion. We will start from the base case and then fill the array for the remaining sub-problems.\n\nWe will traverse from the last index, and fill the array for each possible value of `seats` at each `index`.\n\n- If `index = corridor.length`, then as per three recurrences,\n  - `count[index][0] = 0`\n\n  - `count[index][1] = 0`\n  - `count[index][2] = 1`\n\n- otherwise, \n  \n    - if `corridor[index]` is `S`, then as per three recurrences,\n      - `count[index][0] = count[index + 1][1]`\n\n      - `count[index][1] = count[index + 1][2]`\n      - `count[index][2] = count[index + 1][1]`\n\n    - if `corridor[index]` is `P`, then as per three recurrences,\n      - `count[index][0] = count[index + 1][0]`\n\n      - `count[index][1] = count[index + 1][1]`\n      - `count[index][2] = count[index + 1][0] + count[index + 1][2]`\n\n        As discussed in [implementation note of Approach-1](#implementation), we need to take modulo `1000000007` while saving `count[index][2]` in the actual implementation.\n\nThis completes the filling of the array. The result will be stored in `count[0][0]`, number of ways to divide the `corridor` starting from index `0` to the last index, with `0` number of `S` in the current section.\n\nMoreover, we also get hints about the dimension of the `count` array. `index` can take values from `0` to `N` (where `N = corridor.length`), and `seats` can take values from `0` to `2`. Thus, the dimensions of the array will be $(N + 1) \\times 3$.\n\n> In the [top-down approach](#approach-1-top-down-dynamic-programming), the `cache` was of size $N \\times 3$. This is because we were not storing the case when `index =  N`. In that case, we were returning without storing. In the bottom-up approach, we are storing the result for the case when `index = N`. Thus, we need to increase the size of the array by one row.\n>\n> It's worth noting that it is bottom-up because we are **moving from the solved base case to the unsolved sub-problems**. \n>\n> The order of traversal from bottom-row to up has **nothing to do** with the term bottom-up dynamic programming. Many problems require traversal in a diagonal manner. Thus, critically analyze the Bellman Equation to conclude the order of filling the array.\n\n> In this particular problem, readers can appreciate that because of symmetry in defining `count`, we can move from top-row to bottom as well. \n> \n> - our definition of `count` is that it denotes the number of ways to divide the `corridor` starting from index `index` to last index, with `seats` number of `S` in the current section.   \n> - we can define `count` as the number of ways to divide the `corridor` starting from index `index` to first index, with `seats` number of `S` in the current section. The `index < 0` will be the base case in this definition.\n>\n> Hence, we can see that\n> - Filling from the bottom row to the top can be interpreted as scanning the `corridor` from left to right\n> - Filling from top-row to bottom can be interpreted as scanning the `corridor` from right to left.\n> \n> Both are symmetric, and we can use either of them.\n\nReaders are encouraged to implement the solution on their own.\n\n#### Algorithm\n\n1. Store `1000000007` in the variable `MOD` for convenience. It is a good practice to store constants.\n\n2. Declare a two-dimensional array `count` of size `n + 1` rows and `3` columns, where `n` is the length of the `corridor`. \n\n3. Fill the base-cases\n   - `count[n][0] = 0`\n   - `count[n][1] = 0`\n   - `count[n][2] = 1`\n\n4. Fill the array in a bottom-up fashion, for `index` from `n - 1` to `0`\n     - if `corridor[index]` is `S`, then\n       - `count[index][0] = count[index + 1][1]`\n       - `count[index][1] = count[index + 1][2]`\n       - `count[index][2] = count[index + 1][1]`\n     - if `corridor[index]` is `P`, then\n       - `count[index][0] = count[index + 1][0]`\n       - `count[index][1] = count[index + 1][1]`\n       - `count[index][2] = (count[index + 1][0] + count[index + 1][2]) % MOD`\n\n5. Return `count[0][0]`\n\n#### Implementation#### Complexity Analysis\n\nLet $N$ be the length of the `corridor`.\n\n* Time complexity: $O(N)$\n\n    We are linearly traversing the `corridor` from the last index to the first index. In each iteration, we are filling three entries of the `count` array, which will take constant time. Thus, the time complexity will be $O(N) \\cdot O(1)$, which is $O(N)$.\n\n* Space complexity: $O(N)$\n\n    We are using a two-dimensional array of size $(N + 1) \\times 3$ to cache the result of each sub-problem. Thus, the space complexity will be $O((N + 1) \\cdot 3)$, which is $O(N)$. \n    \n---\n\n### Approach 3: Space-Optimized Bottom-up Dynamic Programming\n\n#### Intuition\n\nThe rule of thumb is\n\n> If there are $T$ state variables, then we need an array of **at most** $T$ dimensions to store the result of each sub-problem.\n\nThe term **at most** is a good signal. We might be able to reduce the number of dimensions of the array by carefully analyzing the recurrence relation. \n\n$\\text{count}(index, 0) = \\begin{cases} 0 & \\text{if } index = corridor.length \\\\\n\\\\\n\\text{count}(index + 1, 1) & \\text{if } corridor[index] = S \\\\\n\\text{count}(index + 1, 0) & \\text{if } corridor[index] = P \\end{cases}$\n\n$\\text{count}(index, 1) = \\begin{cases} 0 & \\text{if } index = corridor.length \\\\\n\\\\\n\\text{count}(index + 1, 2) & \\text{if } corridor[index] = S \\\\\n\\text{count}(index + 1, 1) & \\text{if } corridor[index] = P \\end{cases}$\n\n$\\text{count}(index, 2) = \\begin{cases} 1 & \\text{if } index = corridor.length \\\\\n\\\\\n\\text{count}(index + 1, 1) & \\text{if } corridor[index] = S \\\\\n\\text{count}(index + 1, 0) + \\text{count}(index + 1, 2) & \\text{if } corridor[index] = P \\end{cases}$\n\nWe can appreciate that whatever may be the case\n- $\\text{count}(index, 0)$ depends only on $\\text{count}(index + 1, 0)$ and $\\text{count}(index + 1, 1)$\n- $\\text{count}(index, 1)$ depends only on $\\text{count}(index + 1, 1)$ and $\\text{count}(index + 1, 2)$\n- $\\text{count}(index, 2)$ depends only on $\\text{count}(index + 1, 0)$, $\\text{count}(index + 1, 1)$ and $\\text{count}(index + 1, 2)$\n\nIn other words, we can say that to compute three values at index $index$, we need only three values at index $index + 1$. Hence, we can save only three variables, namely `zero`, `one`, and `two` that represent the values at the most recent computed index $index + 1$. \n\n- Initially\n    - `zero = 0`\n    - `one = 0`\n    - `two = 1`\n\n- If `corridor[index]` is `S`, then\n    \n    - `new_zero = one`\n    - `new_one = two`\n    - `new_two = one`\n\n    Then we can update the values of `zero`, `one`, and `two` as `zero = new_zero`, `one = new_one`, and `two = new_two`.\n\n    However, it is worth noting that `zero` is not used in the computation of any new variables. Thus, `zero = one` will work, and we are not overwriting the value of `zero` before using it.  \n    Adding to it, next we just need to swap the values of `one` and `two`. Hence, the final update is as\n\n    - `zero = one`\n    - `swap(one, two)`. For this, we can do an XOR swap or can use a temporary variable. \n\n- If `corridor[index]` is `P`, then\n\n    - `new_zero = zero`\n    - `new_one = one`\n    - `new_two = (zero + two) % MOD`\n\n    Then we can update the values of `zero`, `one`, and `two` as `zero = new_zero`, `one = new_one`, and `two = new_two`.\n\n    However, it is worth noting that `zero` and `one` remain unchanged in all of these assignments. Thus, updating `zero` and `one` is redundant.   \n    Regarding `two`, we just need to add `zero` in it, and then take modulo `MOD`. Hence, the final update is as\n\n    - `two = (two + zero) % MOD`\n  \nDue to the symmetry of `count`, the `corridor` traversal is possible from left to right as well as from right to left. We will traverse the `corridor` from left to right this time.\n\nAt last, our answer will be stored in variable `zero`, as initially, we have zero number of `S`.\n\n#### Algorithm\n\n1. Store `1000000007` in the variable `MOD` for convenience. It is a good practice to store constants.\n\n2. Initialize three variables `zero`, `one`, and `two` to `0`, `0`, and `1` respectively.\n\n3. Traverse `corridor` from left to right, for `index` from `0` to `n - 1`\n     - if `corridor[index]` is `S`, then\n       - `zero = one`\n       - `swap(one, two)`\n     - if `corridor[index]` is `P`, then\n       - `two = (two + zero) % MOD`\n\n4. Return `zero` as we have a zero number of `S` initially. \n\n#### Implementation#### Complexity Analysis\n\nLet $N$ be the length of the `corridor`.\n\n* Time complexity: $O(N)$\n\n    We are linearly traversing the `corridor`. In each iteration, we are updating three variables, which will take constant time. Thus, the time complexity will be $O(N) \\cdot O(1)$, which is $O(N)$.\n\n* Space complexity: $O(1)$\n\n    We are using a handful of variables, which will take constant extra space. Thus, the space complexity will be $O(1)$.\n    \n---\n\n### Approach 4: Combinatorics \n\n#### Intuition\n\nLet's derive intuition for this approach using a simple puzzle.\n\n> **Puzzle:** If we have 2 paths from A to B and 3 paths from B to C, then how many paths are there from A to C?\n> ![puzzle_abc](../Figures/2147/2147_used/Slide6_1.PNG){:height=\"75px\"}\n>\n> The answer is 6. We can enumerate all the paths as\n> - A to B using yellow edge, and B to C using red edge\n> - A to B using yellow edge, and B to C using purple edge\n> - A to B using yellow edge, and B to C using blue edge\n> - A to B using green edge, and B to C using red edge\n> - A to B using green edge, and B to C using purple edge\n> - A to B using green edge, and B to C using blue edge\n>\n> Because from every path from A to B, we can reach C using any one of the three paths from B to C. Hence, the answer is $2 \\cdot 3 = 6$.\n>\n> What if we add another city from C to D, and there are 2 paths from C to D? Then how many paths are there from A to D?\n> ![puzzle_abcd](../Figures/2147/2147_used/Slide6_2.PNG){:height=\"75px\"}\n>\n> For every 6 A to C paths enumerated above,\n> - we can append a pink edge to reach D from C. This will give us 6 A to D paths.\n> - we can append an orange edge to reach D from C. This will give us 6 A to D paths.  \n> \n> This gives us a total of 12 A to D paths.\n\nThe answers obtained above implicitly multiply the number of paths between the cities. This is a well-established fact in [combinatorics](https://en.wikipedia.org/wiki/Combinatorial_principles), known as [Fundamental Principle of Counting](https://en.wikipedia.org/wiki/Rule_of_product), particularly the **principle of multiplication**. The **principle of multiplication** or the product rule deals with the ‘AND’ statement. \n\n*\"If a task can be performed in a sequence of tasks, where one task is being completed one after the other, then the total number of ways of performing the task is the product of the number of ways they can be performed individually\"*\n\n> Although not mentioned explicitly, in [dynamic programming approaches](#approach-1-top-down-dynamic-programming), we were using the [**principle of addition**](https://en.wikipedia.org/wiki/Addition_principle) or the sum rule. \n> \n> The **principle of addition** or the sum rule deals with the ‘OR’ statement. It states that \"If we consider two tasks that have to be done, and task *cannot be done simultaneously*, then the total number of ways of performing the task is the sum of the number of ways they can be performed individually\".\n\nLet's try to find out how this will be useful in our problem. Let the arrangement in the corridor be represented by the following illustration. The `...` represents any number of `P` (including `0`).\n\n![fpm_1](../Figures/2147/2147_used/Slide7_1.PNG){:height=\"75px\"}\n\nAs discussed in [overview](#overview), the pair of a seat `S` is fixed.   \n\n![fpm_2](../Figures/2147/2147_used/Slide7_2.PNG){:height=\"75px\"}\n\nAgain, from the fact discussed in [overview](#overview), we can say that `...` plants don't offer any facility to install dividers.\n\nWe can only install a divider between two `S` which are neighbors, but not paired.\n\nThus, between yellow-blue `S`, we have *two* choices of installing a divider, and between blue-orange `S`, we have *three* choices of installing a divider. This is computed as the difference between indices of non-paired neighbors.\n\n![fpm_3](../Figures/2147/2147_used/Slide7_3.PNG){:height=\"75px\"}\n\nHence, using the multiplication principle, we can say that the total number of ways to divide the corridor is $2 \\cdot 3 = 6$.  \n*Every pink divider has three choices of purple divider, and exactly one will be chosen*\n\n![fpm_4](../Figures/2147/2147_used/Slide8_and_9.PNG){:height=\"400px\"}\n\nHence, what eventually matters is the difference between indices of non-paired `S` neighbors. Hence, we can store indices of `S` in an array, and then compute the difference between indices of non-paired `S` neighbors. The differences need to be multiplied to get the final answer. We also need to take care of modulo, thus, we will use properties of modulo arithmetic.\n\n#### Algorithm\n\n1. Store `1000000007` in the variable `MOD` for convenience. It is a good practice to store constants.\n\n2. Declare array/list `indices` to store indices of `S` in the `corridor`. Traverse linearly in the `corridor`, and store indices of `S` in the `indices` array.\n\n3. If `indices` is empty, or if the length of `indices` is odd, then return `0`. This is the case when no divider can be installed such that each section contains **exactly** two `S`.\n\n4. Initialize a variable `count` to `1`. This will store the final answer.\n   \n    > If we want to take the product of integers, then we should initialize the variable to `1`. If we want to take the sum of integers, then we should initialize the variable to `0`.\n    >\n    > **Caution:** We will always restrict `count` to be less than `MOD`.   \n    > Now, we may want to multiply `count` with \"differences between seat indices\"\n    > \n    > - The maximum value of `count` can be `1000000006` (one less than `MOD`). which is roughly $10^9$.\n    > - The maximum value of \"differences between seat indices\" can be analyzed by looking at constraints. It can be as large as `(100000 - 1) - 0`, which is roughly $10^5$.\n    > \n    > Now, their product can be as large as $10^{14}$, which is greater than `INT_MAX` ($2^{31} - 1$) in many programming languages. \n    > Thus, we need to make sure that `count` has enough capacity to store this product.\n    >\n    > Readers might be prompted to think that $(a \\cdot b) \\bmod c = \\textbf{((a mod c) ⸱ (b mod c))} \\bmod c$ might be useful to avoid overflow. Overall computation will clip the value of `count` to be less than `MOD`. However, the $\\textbf{bold}$ part can still overflow. Thus, we must take care of it.\n\n5. Initialize two variables\n    - `previous_pair_last` to `1`\n    - `current_pair_first` to `2`\n\n6. While `current_pair_first` is less than the length of `indices`, do the following\n    - update `count` as `count = (count * (indices[current_pair_first] - indices[previous_pair_last])) % MOD`\n    - increment `previous_pair_last` by `2`\n    - increment `current_pair_first` by `2`\n\n    > The loop invariant ensures that `current_pair_first` is equal to `previous_pair_last + 1`. Thus, instead of two variables, we can use a single variable as well.\n\n7. Return `count`. Make sure to return `count` as `int` as required by the function signature.\n\n#### Implementation**Implementation Note:** As mentioned in [algorithm](#algorithm-3), we need to declare `count` such that it can store value as large as $10^{14}$, which is approximately $2^{46}$. Thus, we need a data type of size of at least $46$ bits.\n\nIn C++, we have used `long` to avoid overflow. The [standard](https://en.cppreference.com/w/cpp/language/types) ensures `long` is $64$ bits in LP64 data model, which can store $2^{64}-1$, and it is much larger than $10^{14}$. Similar constraint is fulfilled by `long` in [Java](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html)\n\n#### Complexity Analysis\n\nLet $N$ be the length of the `corridor`.\n\n* Time complexity: $O(N)$\n\n    We are linearly traversing the `corridor` to store indices of `S` in an array. This will take $O(N)$ time.\n\n    We are also linearly traversing the `indices` array to compute the product of differences between indices of non-paired `S` neighbor. These computations take constant time, and there can be at most $N/2$ such computations. Thus, this will take $O(N/2) \\cdot O(1)$ time, which is $O(N)$.\n\n    Hence, the overall time complexity will be $O(N) + O(N)$, which is $O(N)$.\n\n* Space complexity: $O(N)$\n\n    We are using an array to store indices of `S` in the `corridor`. This, in worst case, may take $O(N)$ space.\n    \n---\n\n### Approach 5: Combinatorics, Space Optimized\n\n#### Intuition\n\nIn the [previous approach](#approach-4-combinatorics), we were storing indices of `S` in an array. Let's try to come up with a way to avoid using this array.\n\nThe reason we were storing indices was to compute the index difference between non-paired `S` neighbors.\n\nNow, instead of storing all of the indices in the array, we can store only the index of the last `S` in the previous section. This will help us to compute the index difference when we see the first `S` in the current section. The next `S` in the current section then will become the last `S` in the previous section. \n\nHence, we can calculate the index difference on the fly by keeping track of `previous_pair_last`. To identify if `S` corresponds to `current_pair_first` or `previous_pair_last`, we can use a counter variable `seats`. \n\nReaders are encouraged to implement this approach. Make sure to handle corner cases, particularly cases when no divider can be installed such that each section contains **exactly** two `S`. Moreover, make sure to avoid overflow.\n\n#### Algorithm\n\n1. Store `1000000007` in the variable `MOD` for convenience. It is a good practice to store constants.\n\n2. Initialize a variable `count` to `1`. This will store the final answer.\n   \n    > If we want to take the product of integers, then we should initialize the variable to `1`. If we want to take the sum of integers, then we should initialize the variable to `0`.\n    >\n    > **Caution:** We will always restrict `count` to be less than `MOD`.   \n    > Now, we may want to multiply `count` with \"differences between seat indices\"\n    > \n    > - The maximum value of `count ` can be `1000000006` (one less than `MOD`). which is roughly $10^9$.\n    > - The maximum value of \"differences between seat indices\" can be analyzed by looking at constraints. It can be as large as `(100000 - 1) - 0`, which is roughly $10^5$.\n    > \n    > Now, their product can be as large as $10^{14}$, which is greater than `INT_MAX` ($2^{31} - 1$) in many programming languages. \n    > Thus, we need to make sure that `count` has enough capacity to store this product.\n    >\n    > Readers might be prompted to think that $(a \\cdot b) \\bmod c = \\textbf{((a mod c) ⸱ (b mod c))} \\bmod c$ might be useful to avoid overflow. Overall computation will clip the value of `count` to be less than `MOD`. However, the $\\textbf{bold}$ part can still overflow. Thus, we must take care of it.\n\n3. Initialize two variables\n    - `previous_pair_last` to `null`. It will store the index of the last `S` in the previous section.\n    - `seats` to `0`. It will store the number of `S` in the current section.\n\n4. Iterate over `corridor` from left to right, for `index` from `0` to `n - 1`\n    - if `corridor[index]` is `S`, then\n        - increment `seats` by `1`\n        - if `seats == 2`, then\n            - update `previous_pair_last` as `index`\n            - reset `seats` to `0`\n        - else if `seats == 1` and there exists a previous section, then update `count` as `count = (count * (index - previous_pair_last)) % MOD` \n\n5. If `seats == 1`, it means there are an odd number of `S` in the `corridor`. Thus, return `0`.\n\n6. If `seats` is not equal to `1`, then it must be equal to `0`, because as soon as it reaches `2`, we reset it to `0`. Now `seats` can be `0` when\n    - there are non-zero even number of `S` in the `corridor`\n    - there is no `S` in the `corridor`\n\n    In the latter case, we should return `0`. Both cases are differentiated from the fact that in the former case `previous_pair_last` will be some integer representing index, while in the latter case `previous_pair_last` will be `null`.\n\n    Thus, if `previous_pair_last` is `null`, then return `0`.\n\n7. Return `count`. Make sure to return `count` as `int` as required by the function signature.\n\n#### Implementation**Implementation Note:** As mentioned in [algorithm](#algorithm-4), we need to declare `count` such that it can store value as large as $10^{14}$, which is approximately $2^{46}$. Thus, we need a data type of size of at least $46$ bits.\n\nIn C++, we have used `long` to avoid overflow. The [standard](https://en.cppreference.com/w/cpp/language/types) ensures `long` is $64$ bits in LP64 data model, which can store $2^{64}-1$, and it is much larger than $10^{14}$. A similar constraint is fulfilled by `long` in [Java](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html)\n\n#### Complexity Analysis\n\nLet $N$ be the length of the `corridor`.\n\n* Time complexity: $O(N)$\n\n    We are linearly traversing the `corridor`. In each iteration, we are doing constant time computations. Thus, the time complexity will be $O(N) \\cdot O(1)$, which is $O(N)$.\n\n* Space complexity: $O(1)$\n\n    We are using a handful of variables, which will take constant extra space. Thus, the space complexity will be $O(1)$.\n    \n---"
}