{
  "title": "Minimum Index of a Valid Split",
  "problem_id": "2888",
  "frontend_id": "2780",
  "difficulty": "Medium",
  "problem_slug": "minimum-index-of-a-valid-split",
  "topics": [
    "Array",
    "Hash Table",
    "Sorting"
  ],
  "description": "An element x of an integer array arr of length m is dominant if more than half the elements of arr have a value of x.\nYou are given a 0-indexed integer array nums of length n with one dominant element.\nYou can split nums at an index i into two arrays nums[0, ..., i] and nums[i + 1, ..., n - 1], but the split is only valid if:\nHere, nums[i, ..., j] denotes the subarray of nums starting at index i and ending at index j, both ends being inclusive. Particularly, if j < i then nums[i, ..., j] denotes an empty subarray.\nReturn the minimum index of a valid split. If no valid split exists, return -1.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: nums = [1,2,2,2]\nOutput: 2\nExplanation: We can split the array at index 2 to obtain arrays [1,2,2] and [2]. \nIn array [1,2,2], element 2 is dominant since it occurs twice in the array and 2 * 2 > 3. \nIn array [2], element 2 is dominant since it occurs once in the array and 1 * 2 > 1.\nBoth [1,2,2] and [2] have the same dominant element as nums, so this is a valid split. \nIt can be shown that index 2 is the minimum index of a valid split.",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input: nums = [2,1,3,1,1,1,7,1,2,1]\nOutput: 4\nExplanation: We can split the array at index 4 to obtain arrays [2,1,3,1,1] and [1,7,1,2,1].\nIn array [2,1,3,1,1], element 1 is dominant since it occurs thrice in the array and 3 * 2 > 5.\nIn array [1,7,1,2,1], element 1 is dominant since it occurs thrice in the array and 3 * 2 > 5.\nBoth [2,1,3,1,1] and [1,7,1,2,1] have the same dominant element as nums, so this is a valid split.\nIt can be shown that index 4 is the minimum index of a valid split.",
      "images": []
    },
    {
      "example_num": 3,
      "example_text": "Input: nums = [3,3,3,3,7,2,2]\nOutput: -1\nExplanation: It can be shown that there is no valid split.",
      "images": []
    }
  ],
  "constraints": [
    "1 <= nums.length <= 105",
    "1 <= nums[i] <= 109",
    "nums has exactly one dominant element."
  ],
  "follow_ups": [],
  "hints": [
    "Find the dominant element of nums by using a hashmap to maintain element frequency, we denote the dominant element as x and its frequency as f.",
    "For each index in [0, n - 2], calculate f1, x’s frequency in the subarray [0, i] when looping the index. And f2, x’s frequency in the subarray [i + 1, n - 1] which is equal to f - f1. Then we can check whether x is dominant in both subarrays."
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    int minimumIndex(vector<int>& nums) {\n        \n    }\n};",
    "java": "class Solution {\n    public int minimumIndex(List<Integer> nums) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def minimumIndex(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def minimumIndex(self, nums: List[int]) -> int:\n        ",
    "c": "int minimumIndex(int* nums, int numsSize) {\n    \n}",
    "csharp": "public class Solution {\n    public int MinimumIndex(IList<int> nums) {\n        \n    }\n}",
    "javascript": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar minimumIndex = function(nums) {\n    \n};",
    "typescript": "function minimumIndex(nums: number[]): number {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @return Integer\n     */\n    function minimumIndex($nums) {\n        \n    }\n}",
    "swift": "class Solution {\n    func minimumIndex(_ nums: [Int]) -> Int {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun minimumIndex(nums: List<Int>): Int {\n        \n    }\n}",
    "dart": "class Solution {\n  int minimumIndex(List<int> nums) {\n    \n  }\n}",
    "golang": "func minimumIndex(nums []int) int {\n    \n}",
    "ruby": "# @param {Integer[]} nums\n# @return {Integer}\ndef minimum_index(nums)\n    \nend",
    "scala": "object Solution {\n    def minimumIndex(nums: List[Int]): Int = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn minimum_index(nums: Vec<i32>) -> i32 {\n        \n    }\n}",
    "racket": "(define/contract (minimum-index nums)\n  (-> (listof exact-integer?) exact-integer?)\n  )",
    "erlang": "-spec minimum_index(Nums :: [integer()]) -> integer().\nminimum_index(Nums) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec minimum_index(nums :: [integer]) :: integer\n  def minimum_index(nums) do\n    \n  end\nend"
  },
  "solution": "[TOC]\n\n## Solution\n\n---\n\n### Overview\n\nWe’re given an array `nums` of length `n` that has a **dominant element** `x`, meaning `x` appears more than half the time in the array. Our task is to find the earliest index where we can split the array into two parts such that both parts have the same dominant element. If no such split exists, we return `-1`.\n\nWe can look at an example of splits being evaluated:\n\n!?!../Documents/2780/slideshow.json:960,540!?!\n\nFrom this example, we can see that there are specific characteristics we can evaluate in each split. To begin, we start forming splits at the beginning of `nums` to find the earliest occurrence of a valid split. Furthermore, in each split, we have to track the most frequent element, the number of occurrences of that element, and the current size of each split array. Our approaches will be focused on determining these values to find the minimum index of a valid split.\n\n---\n\n### Approach 1: Hash Map\n\n#### Intuition\n\nThe main challenge in this problem is keeping track of how often each element appears in both split arrays, so we can determine whether a split is valid based on the dominant element in each half. To achieve this, we need a way to store and update element frequencies dynamically as we iterate through the array. A **hashmap** is a natural choice because it allows us to efficiently associate counts with specific elements and update them in constant time.\n\nTo implement this, we use two hashmaps: `firstMap` for tracking the frequency of elements in the first split array and `secondMap` for the second split array. Initially, we treat the entire `nums` array as belonging to the second split, so we populate `secondMap` with all elements of `nums`. This represents the scenario before any splits are made.\n\nNow, we iterate through `nums`, progressively moving elements from `secondMap` to `firstMap` as we consider different split points. At each `index`, we move the current element `num` from `secondMap` to `firstMap` by decrementing its count in `secondMap` and incrementing its count in `firstMap`. This simulates shifting the boundary between the two split arrays.\n\nAt each step, we check whether `num` is the dominant element in both halves. The first split array spans indices `[0, index]` and has size `index + 1`, while the second split array spans `[index + 1, n - 1]` and has size `n - index - 1`. For `num` to be dominant in both parts, it must appear more than half the size of each array, meaning:\n\n$\\text{firstMap}[num] \\times 2 > \\text{size of first array} \\quad \\text{and} \\quad \\text{secondMap}[num] \\times 2 > \\text{size of second array}$\n\nIf both conditions are met, we have found a valid split and return `index`. If we finish iterating without finding a valid split, we return `-1`.\n\n#### Algorithm\n\n- Initialize:\n    - `n` to the size of `nums`.\n    - `firstMap` and `secondMap` as hashmaps to track the numbers in the first and second half of the split, respectively.\n- Iterate through `nums`, adding each element to `secondMap`.\n- Iterate through `nums` again. For each number, `num`, at `index`:\n    - Decrement `secondMap[num]` by `1`.\n    - Increment `firstMap[num]` by `1`.\n    - If `firstMap[num] * 2 > index + 1` and `secondMap[num] * 2 > n - index - 1`, return `index`, since `num` is the dominant element in both halves of the current split.\n- Return `-1`, indicating that no valid split was found.\n\n#### Implementation#### Complexity Analysis\n\nLet $N$ be the size of `nums`.\n\n* Time Complexity: $O(N)$\n\n    The algorithm involves two main steps: populating the `secondMap` with the frequency of each element in the list and iterating through the list to check for a valid split. Both steps involve a single pass through the list, resulting in a total of $2n$ operations. Since constants are ignored in Big-O notation, the overall time complexity is $O(n)$.\n\n    Note: The operations on `firstMap` and `secondMap` (such as `get`, `put`, and `remove`) are considered $O(1)$ on average due to the nature of hash maps.\n\n* Space Complexity: $O(N)$\n\n    The `firstMap` and `secondMap` grow as the algorithm processes the list, and their size depends on the number of unique elements in `nums`. Since the number of unique elements can be up to $n$, the space complexity is $O(n)$. No additional data structures are used, so the space complexity is dominated by the hash maps.\n\n---\n\n### Approach 2: Boyer-Moore Majority Voting Algorithm\n\n#### Intuition\n\nIn the previous approach, we used hashmaps to keep track of element frequencies in each split, but this required extra space proportional to the size of `nums`. Since maintaining these frequency maps can be costly in terms of memory, we need a way to determine the dominant element without storing counts for every possible number.  \n\nTo optimize space usage, we first focus on identifying **which element** can be the dominant one in both split arrays of `nums`.\n\nHere, we can deduce our options based on the information we are given. Let's say `a` and `b` are the sizes of the first and second split array, respectively. If we find a valid split where `x` is the dominant element in each split array, then its frequency, `freq(x)` is greater than `a/2` in the first array and `b/2` in the second. Combining these totals together, the total frequency of the array, `totalFreq(x)`, is greater than `(a+b)/2`, where `a+b` represents the total size of the array. In other words, the element `x` is guaranteed to comprise more than half the elements of the entire array. This leaves only one option for the value of `x`: **the dominant element of the entire array**.\n\nAs such, if a valid split exists, the dominant element in both halves must also be the dominant element of `nums`. This means that the first step is to determine the element `x` that appears the most in `nums`.  \n\nThis is where the **Boyer-Moore Majority Voting Algorithm** comes in. This algorithm efficiently finds a majority element (if it exists) in linear time without using extra space. The key observation behind it is that if an element appears more than `n/2` times, then it must remain after canceling out other elements. By iterating through `nums` while maintaining a candidate element and a counter, we can determine the element `x` that appears the most.  \n\nOnce we have `x`, we need to check if it can be the dominant element in a valid split. We count how often `x` appears in `nums` (`xCount`). Then, we iterate through `nums` again to check each possible split at `index`. We track how many times `x` appears in the first split (`count`) and deduce how many times it remains in the second split (`xCount - count`). Since the two split arrays have sizes `index + 1` and `n - index - 1`, we check if:  \n\n$\\text{count} \\times 2 > \\text{size of first array} \\quad \\text{and} \\quad (\\text{xCount} - \\text{count}) \\times 2 > \\text{size of second array}$\n\nIf both conditions hold, we return `index` as the earliest valid split. Otherwise, we continue checking until we either find a valid split or determine that no such split exists (returning `-1`).  \n\n#### Algorithm\n\n- Initialize:\n    - `x` to the first element of `nums` to represent the dominant element of `nums`.\n    - `count` to `0` to track the count of a given element.\n    - `xCount` to `0` to track the count of the dominant element.\n    - `n` to the size of `nums`.\n- Iterate through `nums` to find the dominant element. For each element, `num`:\n    - If `num` equals `x`, increment `count` by `1`.\n    - Else, decrement `count` by `1`.\n    - If `count` equals `0`, meaning there are more occurrences of `num` than `x`:\n        - Set `x` to `num`.\n        - Set `count` to `1`.\n- Iterate through `nums` to find the frequency of the majority element:\n    - If the current element equals `x`, increment `xCount` by `1`.\n- Set `count` back to `0`.\n- Iterate through `nums` to find a valid split. For each `index`:\n    - If the current number equals `x`, increment `count` by `1`.\n    - Initialize `remainingCount` to `majorityCount - count`, the number of occurrences of the dominant element in the second split array.\n    - If `count * 2 > index + 1` and `remainingCount > n - index - 1`, return `index`, since the `x` is the dominant element in both halves of the split.\n- Return `-1`, indicating that no valid split was found.\n\n#### Implementation#### Complexity Analysis\n\nLet $N$ be the size of `nums`.\n\n* Time Complexity: $O(N)$\n\n    The algorithm consists of three main steps: finding the majority element, counting its frequency, and checking for a valid split. Each step involves a single pass through the array, resulting in a total of $3n$ operations. Since constants are ignored in Big-O notation, the overall time complexity is $O(n)$.\n\n* Space Complexity: $O(1)$\n\n    The space required does not depend on the size of the input value or any data structures that require additional space, so only constant $O(1)$ space is used.\n\n---"
}