{
  "title": "The Earliest and Latest Rounds Where Players Compete",
  "problem_id": "2028",
  "frontend_id": "1900",
  "difficulty": "Hard",
  "problem_slug": "the-earliest-and-latest-rounds-where-players-compete",
  "topics": [
    "Dynamic Programming",
    "Memoization"
  ],
  "description": "There is a tournament where n players are participating. The players are standing in a single row and are numbered from 1 to n based on their initial standing position (player 1 is the first player in the row, player 2 is the second player in the row, etc.).\nThe tournament consists of multiple rounds (starting from round number 1). In each round, the ith player from the front of the row competes against the ith player from the end of the row, and the winner advances to the next round. When the number of players is odd for the current round, the player in the middle automatically advances to the next round.\nAfter each round is over, the winners are lined back up in the row based on the original ordering assigned to them initially (ascending order).\nThe players numbered firstPlayer and secondPlayer are the best in the tournament. They can win against any other player before they compete against each other. If any two other players compete against each other, either of them might win, and thus you may choose the outcome of this round.\nGiven the integers n, firstPlayer, and secondPlayer, return an integer array containing two values, the earliest possible round number and the latest possible round number in which these two players will compete against each other, respectively.\nExample 1:\nExample 2:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: n = 11, firstPlayer = 2, secondPlayer = 4\nOutput: [3,4]\nExplanation:\nOne possible scenario which leads to the earliest round number:\nFirst round: 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11\nSecond round: 2, 3, 4, 5, 6, 11\nThird round: 2, 3, 4\nOne possible scenario which leads to the latest round number:\nFirst round: 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11\nSecond round: 1, 2, 3, 4, 5, 6\nThird round: 1, 2, 4\nFourth round: 2, 4",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input: n = 5, firstPlayer = 1, secondPlayer = 5\nOutput: [1,1]\nExplanation: The players numbered 1 and 5 compete in the first round.\nThere is no way to make them compete in any other round.",
      "images": []
    }
  ],
  "constraints": [
    "2 <= n <= 28",
    "1 <= firstPlayer < secondPlayer <= n"
  ],
  "follow_ups": [],
  "hints": [
    "Brute force using bitmasks and simulate the rounds.",
    "Calculate each state one time and save its solution."
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    vector<int> earliestAndLatest(int n, int firstPlayer, int secondPlayer) {\n        \n    }\n};",
    "java": "class Solution {\n    public int[] earliestAndLatest(int n, int firstPlayer, int secondPlayer) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def earliestAndLatest(self, n, firstPlayer, secondPlayer):\n        \"\"\"\n        :type n: int\n        :type firstPlayer: int\n        :type secondPlayer: int\n        :rtype: List[int]\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def earliestAndLatest(self, n: int, firstPlayer: int, secondPlayer: int) -> List[int]:\n        ",
    "c": "/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nint* earliestAndLatest(int n, int firstPlayer, int secondPlayer, int* returnSize) {\n    \n}",
    "csharp": "public class Solution {\n    public int[] EarliestAndLatest(int n, int firstPlayer, int secondPlayer) {\n        \n    }\n}",
    "javascript": "/**\n * @param {number} n\n * @param {number} firstPlayer\n * @param {number} secondPlayer\n * @return {number[]}\n */\nvar earliestAndLatest = function(n, firstPlayer, secondPlayer) {\n    \n};",
    "typescript": "function earliestAndLatest(n: number, firstPlayer: number, secondPlayer: number): number[] {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param Integer $n\n     * @param Integer $firstPlayer\n     * @param Integer $secondPlayer\n     * @return Integer[]\n     */\n    function earliestAndLatest($n, $firstPlayer, $secondPlayer) {\n        \n    }\n}",
    "swift": "class Solution {\n    func earliestAndLatest(_ n: Int, _ firstPlayer: Int, _ secondPlayer: Int) -> [Int] {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun earliestAndLatest(n: Int, firstPlayer: Int, secondPlayer: Int): IntArray {\n        \n    }\n}",
    "dart": "class Solution {\n  List<int> earliestAndLatest(int n, int firstPlayer, int secondPlayer) {\n    \n  }\n}",
    "golang": "func earliestAndLatest(n int, firstPlayer int, secondPlayer int) []int {\n    \n}",
    "ruby": "# @param {Integer} n\n# @param {Integer} first_player\n# @param {Integer} second_player\n# @return {Integer[]}\ndef earliest_and_latest(n, first_player, second_player)\n    \nend",
    "scala": "object Solution {\n    def earliestAndLatest(n: Int, firstPlayer: Int, secondPlayer: Int): Array[Int] = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn earliest_and_latest(n: i32, first_player: i32, second_player: i32) -> Vec<i32> {\n        \n    }\n}",
    "racket": "(define/contract (earliest-and-latest n firstPlayer secondPlayer)\n  (-> exact-integer? exact-integer? exact-integer? (listof exact-integer?))\n  )",
    "erlang": "-spec earliest_and_latest(N :: integer(), FirstPlayer :: integer(), SecondPlayer :: integer()) -> [integer()].\nearliest_and_latest(N, FirstPlayer, SecondPlayer) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec earliest_and_latest(n :: integer, first_player :: integer, second_player :: integer) :: [integer]\n  def earliest_and_latest(n, first_player, second_player) do\n    \n  end\nend"
  },
  "solution": "### Approach: Analyze Fundamentally Different Standing Situations + Memoized Search\n\n#### Intuition\n\nWe can represent the earliest round number of the competition between the two best athletes, who are the $f$th and $s$th athletes from the left in a row, with $n$ people remaining as $F(n, f, s)$.\n\nSimilarly, we use $G(n, f, s)$ to represent the latest round in which they compete.\n\nHow is state transition carried out?\n\n**We only consider situations with fundamentally different relative positions.**\n\nIf we simply use $F(n, f, s)$ for state transitions, the resulting algorithm and code would become quite complex. For example, we need to consider whether $f$ is on the left (i.e., counting from the front), in the middle (i.e., skipping a turn), or on the right (i.e., counting from the back). We must also consider several possibilities for $s$, which makes the state transition equations rather cumbersome.\n\nWe can consider analyzing the **essentially different positioning situations** and obtain the following table:\n\n| | $s$ on the left | $s$ in the middle | $s$ on the right |\n| :-: | :-: | :-: | :-: |\n| $f$ on the left | maintain unchanged | maintain unchanged | maintain unchanged |\n| $f$ in the middle | equivalent to \"$f$ on the left, $s$ in the middle\"| There is no such situation | equivalent to \"$f$ on the left, $s$ in the middle\"|\n| $f$ on the right | equivalent to \"$f$ on the left，$s$ on the right\"| equivalent to \"$f$ on the left, $s$ in the middle\" | equivalent to \"$f$ on the left, $s$ on the left\"|\n\nThe correctness is based on the following invariants:\n\n- $F(n, f, s) = F(n, s, f)$ holds true. That is, swapping the positions of the two best athletes does not change the result.\n\n- $F(n, f, s) = F(n, n+1-s, n+1-f)$ holds true. Since each $i$-th athlete from the front competes with the $i$-th athlete from the back, flipping the entire arrangement does not affect the outcome.\n\nWe use these two transformation rules to ensure that in $F(n, f, s)$, $f$ is always less than $s$. Therefore, $f$ must be on the left, while $s$ can be on the left, in the middle, or on the right. In this way, we reduce the original $8$ cases to $3$ cases.\n\nFor $G(n, f, s)$, the approach is completely the same.\n\n**Design of state transition equations**\n\nSince we know that $f$ is definitely on the left, we can then design the state transition equations separately according to whether $s$ is on the left, in the middle, or on the right.\n\n![fig1](https://assets.leetcode.com/users/images/9d5dad1d-f8de-42ab-b09c-9dfc4acf03e9_1751855251.8339484.png)\n\nIf $s$ is on the left, as shown in the figure above:\n\n- $f$ has $f-1$ athletes on the left, who will compete with the corresponding athletes on the right, leaving $[0, f-1]$ athletes.\n\n- $f$ and $s$ have $s-f-1$ athletes in between, who will compete with the corresponding athletes on the right, leaving $[0, s-f-1]$ athletes remaining.\n\nIf there are $f-1$ athletes remaining and $i$ of them, and $s-f-1$ athletes remaining and $j$ of them, then in the next round, the two best athletes are located at positions $i+1$ and $i+j+2$, respectively, and the total number of remaining athletes is $\\lfloor \\dfrac{n+1}{2} \\rfloor$, where $\\lfloor x \\rfloor$ denotes the floor function of $x$. Therefore, we can obtain the state transition equation:\n\n$$\nF(n, f, s) = \\left( \\min_{i\\in [0,f-1], j \\in [0, s-f-1]} F(\\lfloor \\frac{n+1}{2} \\rfloor, i + 1, i + j + 2) \\right) + 1\n$$\n\n![fig2](https://assets.leetcode.com/users/images/a12e8679-7c89-4fee-94c4-f5d6634a11da_1751855272.3308604.png)\n\nIf $s$ is in the middle, as shown in the figure above, the state transition equation is the same as in the case where $s$ is on the left.\n\n\nIf $s$ is on the right, the situation will be more complicated, and there will be three cases:\n\n- In the simplest case, $f$ and $s$ just match each other, that is, $f+s=n+1$, then $F(n, f, s)=1$.\n\n- In addition, if the one-on-one competition in this round is between $s$ and $s'=n+1-s$, then $f < s'$ is one case, and $f > s'$ is another case.\n\n![fig3](https://assets.leetcode.com/users/images/0a0b1d94-1be0-4f45-b118-f05bb85413bb_1751855288.4432793.png)\n\nHowever, we can know that according to the analysis similar to the previous section \"Essentially Different Positioning Situations,\" we change $f$ to $n+1-s$, and $s$ to $n+1-f$. In this way, $f$ is still less than $s$, and $f$ is also less than $s'$ now. Therefore, we only need to consider the case where $f < s'$, as shown in the figure above:\n\n- $f$ has $f-1$ athletes on the left, who will compete with the corresponding athletes on the right, leaving $[0, f-1]$ athletes.\n\n- $f$ and $s'$ have $s'-f-1$ athletes in between, who will compete with the corresponding athletes on the right, leaving $[0, s'-f-1]$ athletes remaining.\n\n- $s'$ will definitely lose to $s$.\n\n- There are $n - 2s'$ athletes between $s'$ and $s$. If $n - 2s'$ is even, they compete in pairs, leaving $\\dfrac{n - 2s'}{2}$ athletes; if $n - 2s'$ is odd, one person is eliminated by default, and the remaining athletes compete in pairs, leaving $\\dfrac{n - 2s' + 1}{2}$ athletes. Therefore, regardless of whether $n - 2s'$ is odd or even, there will always be $\\lfloor \\dfrac{n - 2s' + 1}{2} \\rfloor$ athletes between $s'$ and $s$.\n\nIf there are $f-1$ athletes and we keep $i$ of them, and $s'-f-1$ athletes and we keep $j$ of them, then in the next round, the two best athletes are respectively located at positions $i+1$ and $i+j+\\lfloor \\dfrac{n-2s'+1}{2} \\rfloor+2$. Therefore, we can obtain the state transition equation:\n\n$$\nF(n, f, s) = \\left( \\min_{i\\in [0,f-1], j \\in [0, s'-f-1]} F(\\lfloor \\frac{n+1}{2} \\rfloor, i + 1, i+j+\\lfloor \\dfrac{n-2s'+1}{2} \\rfloor+2) \\right) + 1\n$$\n\nSo we have obtained all the state transition equations for $F$. For $G$, we just need to change all the $\\min$ to $\\max$.\n\n**Details**\n\nIn the section on \"Essentially Different Positioning Situations,\" we mentioned two transformation rules. So, when exactly should we apply each transformation rule, based on the actual values of $n$, $f$, and $s$ (rather than the abstract labels \"left,\" \"middle,\" or \"right\")?\n\nThere are many design methods here, and we introduce a relatively simple one, the method used in the solution code:\n\n- Firstly, we use top-down memoization search instead of dynamic programming for state transition, which makes the code more concise and intuitive, and does not require consideration of the order of state evaluation.\n\n- The entry of the memoized search is $F(n, \\textit{firstPlayer}, \\textit{secondPlayer})$. Before starting the memoized search, we first transform it using the transformation rule $F(n, f, s) = F(n, s, f)$ to ensure that $\\textit{firstPlayer}$ is always less than $\\textit{secondPlayer}$. In this way, since the other transformation rule $F(n, f, s) = F(n, n+1-s, n+1-f)$ does not change the size relationship between $f$ and $s$, in the subsequent memoized search, $f < s$ is always true, and we do not need to use the transformation rule $F(n, f, s) = F(n, s, f)$ anymore.\n\n- In the previous table, there are $5$ cases that we need to transform, which are: \"f is in the middle, s is on the left\", \"f is in the middle, s is on the right\", \"f is on the right, s is on the left\", \"f is on the right, s is in the middle\", and \"f is on the right, s is on the right\". Since we have already ensured that $f < s$ always holds, there are only $2$ cases left to handle, namely: \"f is in the middle, s is on the right\" and \"f is on the right, s is on the right\". In addition, in the section \"Design of State Transition Equations\", we also found another case that needs to be handled, that is, \"f is on the left, s is on the right, and $f > s' = n + 1 - s$\".\n\nSo, can these three cases be unified? For the last case, we have $f+s > n+1$, and both \"f in the middle, s on the right\" and \"f on the right, s on the right\" also satisfy $f+s > n+1$, and all cases that do not require transformation do not satisfy $f+s > n+1$. Therefore, we only need to use the transformation rule $F(n, f, s) = F(n, n+1-s, n+1-f)$ once when $f+s > n+1$.\n\n#### Implementation#### Complexity analysis\n\n- Time complexity: $O(n^4 \\log n)$.\n  \n  In the state $F(n, f, s)$ (the same for $G(n, f, s)$), the range of each dimension is $O(n)$, and each state requires $O(n^2)$ time to enumerate all possible states that can be transferred to, thus the overall time complexity of the algorithm is $O(n^5)$.\n  \n  However, we can find that the number of values taken by $n$ in $F(n, f, s)$ is finite. During the process of memoization search, $n$ will become $\\lfloor \\dfrac{n+1}{2} \\rfloor$ and continue to recurse downward, so the number of values taken by $n$ is only $O(\\log n)$, that is, the total time complexity is $O(n^4 \\log n)$.\n\n- Space complexity: $O(n^2 \\log n)$ or $O(n^3)$.\n  \n  The space required for storing all states. In C++ code, we use an array to store all states, even though the number of possible values for $n$ is only $O(\\log n)$, we still need to allocate $O(n)$ space for the first dimension. In the Python code, the @cache uses a tuple as the key of a dictionary to store the values of all states, and the number of states is $O(n^2 \\log n)$, so the space used is also $O(n^2 \\log n)$.\n  \n  In addition, since the LeetCode platform calculates the running time by summing the running times of all test data, all test data will be tested in one run. **In this problem, the memoized storage results can be shared between different test cases**. Therefore, the command to clear the memoized results in the code (such as $\\texttt{memset}$ in $\\texttt{C++}$ or $\\texttt{cache\\_clear}$ in $\\texttt{Python}$) can be omitted."
}