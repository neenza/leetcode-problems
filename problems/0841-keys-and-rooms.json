{
  "title": "Keys and Rooms",
  "problem_id": "871",
  "frontend_id": "841",
  "difficulty": "Medium",
  "problem_slug": "keys-and-rooms",
  "topics": [
    "Depth-First Search",
    "Breadth-First Search",
    "Graph"
  ],
  "description": "There are n rooms labeled from 0 to n - 1Â and all the rooms are locked except for room 0. Your goal is to visit all the rooms. However, you cannot enter a locked room without having its key.\nWhen you visit a room, you may find a set of distinct keys in it. Each key has a number on it, denoting which room it unlocks, and you can take all of them with you to unlock the other rooms.\nGiven an array rooms where rooms[i] is the set of keys that you can obtain if you visited room i, return true if you can visit all the rooms, or false otherwise.\nExample 1:\nExample 2:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: rooms = [[1],[2],[3],[]]\nOutput: true\nExplanation: \nWe visit room 0 and pick up key 1.\nWe then visit room 1 and pick up key 2.\nWe then visit room 2 and pick up key 3.\nWe then visit room 3.\nSince we were able to visit every room, we return true.",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input: rooms = [[1,3],[3,0,1],[2],[0]]\nOutput: false\nExplanation: We can not enter room number 2 since the only key that unlocks it is in that room.",
      "images": []
    }
  ],
  "constraints": [
    "n == rooms.length",
    "2 <= n <= 1000",
    "0 <= rooms[i].length <= 1000",
    "1 <= sum(rooms[i].length) <= 3000",
    "0 <= rooms[i][j] < n",
    "All the values of rooms[i] are unique."
  ],
  "follow_ups": [],
  "hints": [],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    bool canVisitAllRooms(vector<vector<int>>& rooms) {\n        \n    }\n};",
    "java": "class Solution {\n    public boolean canVisitAllRooms(List<List<Integer>> rooms) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def canVisitAllRooms(self, rooms):\n        \"\"\"\n        :type rooms: List[List[int]]\n        :rtype: bool\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:\n        ",
    "c": "bool canVisitAllRooms(int** rooms, int roomsSize, int* roomsColSize) {\n    \n}",
    "csharp": "public class Solution {\n    public bool CanVisitAllRooms(IList<IList<int>> rooms) {\n        \n    }\n}",
    "javascript": "/**\n * @param {number[][]} rooms\n * @return {boolean}\n */\nvar canVisitAllRooms = function(rooms) {\n    \n};",
    "typescript": "function canVisitAllRooms(rooms: number[][]): boolean {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param Integer[][] $rooms\n     * @return Boolean\n     */\n    function canVisitAllRooms($rooms) {\n        \n    }\n}",
    "swift": "class Solution {\n    func canVisitAllRooms(_ rooms: [[Int]]) -> Bool {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun canVisitAllRooms(rooms: List<List<Int>>): Boolean {\n        \n    }\n}",
    "dart": "class Solution {\n  bool canVisitAllRooms(List<List<int>> rooms) {\n    \n  }\n}",
    "golang": "func canVisitAllRooms(rooms [][]int) bool {\n    \n}",
    "ruby": "# @param {Integer[][]} rooms\n# @return {Boolean}\ndef can_visit_all_rooms(rooms)\n    \nend",
    "scala": "object Solution {\n    def canVisitAllRooms(rooms: List[List[Int]]): Boolean = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn can_visit_all_rooms(rooms: Vec<Vec<i32>>) -> bool {\n        \n    }\n}",
    "racket": "(define/contract (can-visit-all-rooms rooms)\n  (-> (listof (listof exact-integer?)) boolean?)\n  )",
    "erlang": "-spec can_visit_all_rooms(Rooms :: [[integer()]]) -> boolean().\ncan_visit_all_rooms(Rooms) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec can_visit_all_rooms(rooms :: [[integer]]) :: boolean\n  def can_visit_all_rooms(rooms) do\n    \n  end\nend"
  },
  "solution": "[TOC]\n\n---\n### Approach #1: Depth-First Search [Accepted]\n\n**Intuition and Algorithm**\n\nWhen visiting a room for the first time, look at all the keys in that room.  For any key that hasn't been used yet, add it to the todo list (`stack`) for it to be used.\n\nSee the comments of the code for more details.**Complexity Analysis**\n\n* Time Complexity:  $$O(N + E)$$, where $$N$$ is the number of rooms, and $$E$$ is the total number of keys.\n\n* Space Complexity:  $$O(N)$$ in additional space complexity, to store `stack` and `seen`."
}