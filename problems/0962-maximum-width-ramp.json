{
  "title": "Maximum Width Ramp",
  "problem_id": "1002",
  "frontend_id": "962",
  "difficulty": "Medium",
  "problem_slug": "maximum-width-ramp",
  "topics": [
    "Array",
    "Two Pointers",
    "Stack",
    "Monotonic Stack"
  ],
  "description": "A ramp in an integer array nums is a pair (i, j) for which i < j and nums[i] <= nums[j]. The width of such a ramp is j - i.\nGiven an integer array nums, return the maximum width of a ramp in nums. If there is no ramp in nums, return 0.\nExample 1:\nExample 2:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: nums = [6,0,8,2,1,5]\nOutput: 4\nExplanation: The maximum width ramp is achieved at (i, j) = (1, 5): nums[1] = 0 and nums[5] = 5.",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input: nums = [9,8,1,0,1,9,4,0,4,1]\nOutput: 7\nExplanation: The maximum width ramp is achieved at (i, j) = (2, 9): nums[2] = 1 and nums[9] = 1.",
      "images": []
    }
  ],
  "constraints": [
    "2 <= nums.length <= 5 * 104",
    "0 <= nums[i] <= 5 * 104"
  ],
  "follow_ups": [],
  "hints": [],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    int maxWidthRamp(vector<int>& nums) {\n        \n    }\n};",
    "java": "class Solution {\n    public int maxWidthRamp(int[] nums) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def maxWidthRamp(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def maxWidthRamp(self, nums: List[int]) -> int:\n        ",
    "c": "int maxWidthRamp(int* nums, int numsSize) {\n    \n}",
    "csharp": "public class Solution {\n    public int MaxWidthRamp(int[] nums) {\n        \n    }\n}",
    "javascript": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar maxWidthRamp = function(nums) {\n    \n};",
    "typescript": "function maxWidthRamp(nums: number[]): number {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @return Integer\n     */\n    function maxWidthRamp($nums) {\n        \n    }\n}",
    "swift": "class Solution {\n    func maxWidthRamp(_ nums: [Int]) -> Int {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun maxWidthRamp(nums: IntArray): Int {\n        \n    }\n}",
    "dart": "class Solution {\n  int maxWidthRamp(List<int> nums) {\n    \n  }\n}",
    "golang": "func maxWidthRamp(nums []int) int {\n    \n}",
    "ruby": "# @param {Integer[]} nums\n# @return {Integer}\ndef max_width_ramp(nums)\n    \nend",
    "scala": "object Solution {\n    def maxWidthRamp(nums: Array[Int]): Int = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn max_width_ramp(nums: Vec<i32>) -> i32 {\n        \n    }\n}",
    "racket": "(define/contract (max-width-ramp nums)\n  (-> (listof exact-integer?) exact-integer?)\n  )",
    "erlang": "-spec max_width_ramp(Nums :: [integer()]) -> integer().\nmax_width_ramp(Nums) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec max_width_ramp(nums :: [integer]) :: integer\n  def max_width_ramp(nums) do\n    \n  end\nend"
  },
  "solution": "[TOC]\n\n## Solution\n\n---\n\n### Approach 1: Brute Force (Time Limit Exceeded)\n\n#### Intuition\n\nFor this problem, we need to efficiently find two indices `i` and `j` such that `i < j` and $\\text{nums}[i] \\leq \\text{nums}[j]$. \n\nThe brute force approach is to check every possible pair `(i, j)` where `i < j` and $\\text{nums}[i] \\leq \\text{nums}[j]$, and compute the maximum ramp width.\n\nFor each valid pair, compute the width `j - i` and update the maximum width if necessary.\n\nHowever, this brute force approach will not work due to the constraints below:\n\n- $2 \\leq \\text{nums.length} \\leq 5 \\times 10^4$\n- $0 \\leq \\text{nums}[i] \\leq 5 \\times 10^4$\n\n#### Algorithm\n\n- Initialize `n` to the size of the `nums` array and `maxWidth` to 0.\n- Use a nested loop to iterate through all pairs `(i, j)` where:\n  - The outer loop variable `i` goes from `0` to `n - 1`.\n  - The inner loop variable `j` goes from `i + 1` to `n - 1`.\n- For each pair `(i, j)`:\n  - Check if `nums[i]` is less than or equal to `nums[j]`.\n    - If true, calculate the width as `j - i`.\n    - Update `maxWidth` with the maximum value between the current `maxWidth` and the calculated width.\n- After checking all pairs, return `maxWidth` as the result.\n\n#### Implementation#### Complexity Analysis\n\nLet $n$ be the size of the `nums` array.\n\n- Time complexity: $O(n^2)$\n\n    The algorithm uses a nested loop where the outer loop iterates $n$ times and the inner loop can iterate up to $n - 1$ times for each iteration of the outer loop. This results in a total of $\\frac{n(n-1)}{2}$ iterations, leading to a quadratic time complexity of $O(n^2)$.\n\n- Space complexity: $O(1)$\n\n    The algorithm uses a constant amount of extra space, as it only requires a few integer variables (`n` and `maxWidth`) regardless of the size of the input array `nums`. There are no data structures used that would grow with the size of the input. Hence, the space complexity is $O(1)$.\n\n---\n\n### Approach 2: Sorting\n\n#### Intuition\n\nIn Approach 1, comparing `nums[i]` with `nums[j]` needed to be done for all pairs since `nums` is not sorted in order. This leads to an inefficient solution. \n\nTo make our solution more efficient, we can sort the indices of the array based on the values of `nums`. This way, when processing indices in the sorted order, each value is guaranteed to be greater than or equal to the values of previously processed indices.\n\nOnce the indices are sorted, we track the smallest index we've seen so far as we move through the sorted list. For each index we encounter, we calculate the difference between the current index and the smallest one. This difference represents a potential ramp width, and we update our maximum width as we go.\n\n#### Algorithm\n\n- Find the size of the input array `nums` and initialize a array `indices` of the same size to hold the indices.\n- Initialize the `indices` array and fill it with values from `0` to `n-1` (each index corresponding to its position in `nums`).\n- Sort the `indices` based on the values in `nums`:\n  - Use a custom comparator to ensure stability while sorting:\n    - Compare values in `nums` for the corresponding indices.\n    - If the values are equal, maintain the original order of the indices.\n- Initialize `minIndex` to `n` (a value larger than any possible index) to track the minimum index encountered so far.\n- Initialize `maxWidth` to `0` to store the maximum width ramp found.\n- Iterate over the sorted `indices`:\n  - Update `maxWidth` to be the maximum of its current value and the difference between the current index (`indices[i]`) and `minIndex`.\n  - Update `minIndex` to be the minimum of its current value and the current index (`indices[i]`).\n- Return `maxWidth` as the result (the maximum width found).\n\n#### Implementation#### Complexity Analysis\n\nLet $n$ be the size of the `nums` array.\n\n- Time complexity: $O(n \\log n)$\n\n    The most significant factor in the time complexity comes from the sorting operation on the `indices` array. Sorting takes $O(n \\log n)$ time. The subsequent loop that calculates the maximum width ramp runs in $O(n)$ time. Thus, the overall time complexity is dominated by the sorting step, resulting in $O(n \\log n)$.\n\n- Space complexity: $O(n + S) = O(n)$\n\n    The space complexity is primarily determined by the additional `indices` array that stores the indices of the `nums` array, which requires $O(n)$ space. Other variables used in the algorithm are of constant space, leading to an overall space complexity of $O(n)$.\n\n    The other additional space used is for the sorting algorithm. The space taken by the sorting algorithm ($S$) depends on the language of implementation:\n    - In Java, `Arrays.sort()` is implemented using a variant of the Quick Sort algorithm which has a space complexity of $O( \\log n)$.\n    - In C++, the `sort()` function is implemented as a hybrid of Quick Sort, Heap Sort, and Insertion Sort, with a worst-case space complexity of $O(\\log n)$.\n    - In Python, the `sort()` method sorts a list using the Timsort algorithm which is a combination of Merge Sort and Insertion Sort and has a space complexity of $O(n)$.\n\n---\n\n### Approach 3: Two Pointers\n\n#### Intuition\n\nAnother way to approach the problem is to recognize that if we could process the indices in such a way that we can easily compare their relative positions, it might help us avoid unnecessary comparisons. \n\nWe can notice that it would be helpful to know the maximum value from each index to the end of the array.  Given this information, we can easily check if the ramp condition is satisfied for any left index while iterating from the start of the array. Thus, we initialize `rightMax` where each element at index `i` stores the maximum value from index `i` to the last index. We populate this array in reverse order. Starting from the end of the `nums` array, we set the last element of `rightMax` to be equal to the last element of `nums`. For all previous indices, we store the maximum of the current value in `nums[i]` and the value at `rightMax[i + 1]`. This ensures that each index in `rightMax` contains the highest value from that index to the end of the original array.\n\nWith `rightMax` constructed, we can proceed with our two-pointer approach. We initialize one pointer (`left`) at the start of the array and another pointer (`right`) that we will move through the array. As we iterate:\n- We check if the condition $nums[left] \\leq rightMax[right]$ holds. If true, we calculate the ramp width as `right - left` and update our maximum width if this is the largest weâ€™ve seen.\n- If the condition is not satisfied, it means the value at `nums[left]` is too large to form a ramp with `rightMax[right]`, so we increment the `left` pointer to try and find a smaller value.\n\n#### Algorithm\n\n- Initialize `n` as the size of the input vector `nums`.\n- Create a `rightMax` array of the same size to store the maximum values from the right side of `nums`.\n- Fill the `rightMax` array:\n  - Set `rightMax[n - 1]` to `nums[n - 1]` (the last element).\n  - Iterate backward from the second-to-last element to the first:\n    - For each index `i`, set `rightMax[i]` to the maximum of `rightMax[i + 1]` and `nums[i]`.\n- Initialize two pointers, `left` and `right`, both starting at 0, and a variable `maxWidth` initialized to 0.\n- Traverse the array using `left` and `right` pointers:\n  - While `right` is less than `n`:\n    - Move the `left` pointer forward while the current value at `nums[left]` exceeds the corresponding value in `rightMax[right]`.\n    - Calculate the current width as `right - left` and update `maxWidth` to the maximum of `maxWidth` and the current width.\n    - Increment the `right` pointer.\n- Return `maxWidth` as the result (the maximum width found).\n\n#### Implementation#### Complexity Analysis\n\nLet $n$ be the size of the `nums` array.\n\n- Time complexity: $O(n)$\n\n    The algorithm consists of two main parts. The first loop fills the `rightMax` array, which takes $O(n)$ time since it iterates through the `nums` array once. The second part uses a two-pointer technique to traverse the `nums` array and the `rightMax` array, where both pointers traverse the array at most $n$ times. Thus, the total time taken is linear in terms of the size of the input array, leading to an overall time complexity of $O(n)$.\n\n- Space complexity: $O(n)$\n\n    The space complexity is determined by the additional storage used, which in this case is the `rightMax` array. This array also has a size of $n$, resulting in a space complexity of $O(n)$. Other variables used (like `left`, `right`, and `maxWidth`) take constant space, $O(1)$, but they do not contribute to the overall space complexity.\n\n---\n\n### Approach 4: Monotonic Stack\n\n#### Intuition\n\nWe notice that for any element $nums[i]$, we'd like to consider the indices of all elements $nums[j]$ preceding $nums[i]$ such that $nums[j] < nums[i]$. We can efficiently find all these indices by maintaining a monotonic stack. The key observation is that this problem involves finding valid pairs where an earlier index has a smaller or equal value than a later index, making it a perfect candidate for a monotonic stack. This way, whenever we encounter a value in $nums$ that is greater than the element at the index in top of our stack, we can pop all the indices from the stack to find left indices that can form valid pairs.\n\nAs we iterate over the array, we push indices onto a stack only if the value at the current index is smaller than or equal to the value at the index on top of the stack. This ensures that the stack contains a list of potential starting points for ramps, in decreasing order of value. The key insight is that when we encounter a larger value, we begin popping indices from the stack. For each index popped, we calculate the ramp width formed with the current index and check if it exceeds the maximum width we have tracked. Since the values on the stack are always decreasing, popping an index means that we have found a ramp where the condition $nums[i] \\leq nums[j]$ is satisfied. \n\nThe algorithm is visualized below: \n\n!?!../Documents/962/monotonic.json:1025,535!?!\n\n#### Algorithm\n\n- Initialize `n` to the size of the `nums` array and create an empty stack `indicesStack`.\n- Iterate through the array from index 0 to `n-1`.\n    - If `indicesStack` is empty or the value at the top index of the stack is greater than the current value `nums[i]`, push `i` onto the stack.\n    - This ensures the stack contains indices in increasing order of their corresponding values in `nums`.\n- Initialize `maxWidth` to 0.\n- Iterate through the array from index `n-1` down to 0.\n    - While the stack is not empty and the value at the index on the top of the stack is less than or equal to `nums[j]`:\n    - Update `maxWidth` to the maximum of its current value and the width calculated as `j - indicesStack.top()`.\n    - Pop the index from the stack, as it has already been processed.\n- Return `maxWidth` as the result (the maximum width found).\n\n#### Implementation#### Complexity Analysis\n\nLet $n$ be the size of the `nums` array.\n\n- Time complexity: $O(n)$\n\n    The first loop iterates through the `nums` array once, pushing indices onto the stack. This operation takes $O(n)$ time in the worst case since each index is pushed at most once. The second loop also iterates through the `nums` array, but each index is popped from the stack at most once. Hence, both loops combined result in a total of $O(n)$ time complexity.\n\n- Space complexity: $O(n)$\n\n    The space complexity arises primarily from the stack that holds indices. In the worst case, where all elements are in strictly increasing order, all $n$ indices could be pushed onto the stack. Therefore, the space complexity is $O(n)$ in this scenario. \n\n---"
}