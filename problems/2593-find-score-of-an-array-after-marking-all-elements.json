{
  "title": "Find Score of an Array After Marking All Elements",
  "problem_id": "2695",
  "frontend_id": "2593",
  "difficulty": "Medium",
  "problem_slug": "find-score-of-an-array-after-marking-all-elements",
  "topics": [
    "Array",
    "Hash Table",
    "Sorting",
    "Heap (Priority Queue)",
    "Simulation"
  ],
  "description": "You are given an array nums consisting of positive integers.\nStarting with score = 0, apply the following algorithm:\nReturn the score you get after applying the above algorithm.\nExample 1:\nExample 2:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: nums = [2,1,3,4,5,2]\nOutput: 7\nExplanation: We mark the elements as follows:\n- 1 is the smallest unmarked element, so we mark it and its two adjacent elements: [2,1,3,4,5,2].\n- 2 is the smallest unmarked element, so we mark it and its left adjacent element: [2,1,3,4,5,2].\n- 4 is the only remaining unmarked element, so we mark it: [2,1,3,4,5,2].\nOur score is 1 + 2 + 4 = 7.",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input: nums = [2,3,5,1,3,2]\nOutput: 5\nExplanation: We mark the elements as follows:\n- 1 is the smallest unmarked element, so we mark it and its two adjacent elements: [2,3,5,1,3,2].\n- 2 is the smallest unmarked element, since there are two of them, we choose the left-most one, so we mark the one at index 0 and its right adjacent element: [2,3,5,1,3,2].\n- 2 is the only remaining unmarked element, so we mark it: [2,3,5,1,3,2].\nOur score is 1 + 2 + 2 = 5.",
      "images": []
    }
  ],
  "constraints": [
    "1 <= nums.length <= 105",
    "1 <= nums[i] <= 106"
  ],
  "follow_ups": [],
  "hints": [
    "Try simulating the process of marking the elements and their adjacent.",
    "If there is an element that was already marked, then you skip it."
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    long long findScore(vector<int>& nums) {\n        \n    }\n};",
    "java": "class Solution {\n    public long findScore(int[] nums) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def findScore(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def findScore(self, nums: List[int]) -> int:\n        ",
    "c": "long long findScore(int* nums, int numsSize) {\n    \n}",
    "csharp": "public class Solution {\n    public long FindScore(int[] nums) {\n        \n    }\n}",
    "javascript": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar findScore = function(nums) {\n    \n};",
    "typescript": "function findScore(nums: number[]): number {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @return Integer\n     */\n    function findScore($nums) {\n        \n    }\n}",
    "swift": "class Solution {\n    func findScore(_ nums: [Int]) -> Int {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun findScore(nums: IntArray): Long {\n        \n    }\n}",
    "dart": "class Solution {\n  int findScore(List<int> nums) {\n    \n  }\n}",
    "golang": "func findScore(nums []int) int64 {\n    \n}",
    "ruby": "# @param {Integer[]} nums\n# @return {Integer}\ndef find_score(nums)\n    \nend",
    "scala": "object Solution {\n    def findScore(nums: Array[Int]): Long = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn find_score(nums: Vec<i32>) -> i64 {\n        \n    }\n}",
    "racket": "(define/contract (find-score nums)\n  (-> (listof exact-integer?) exact-integer?)\n  )",
    "erlang": "-spec find_score(Nums :: [integer()]) -> integer().\nfind_score(Nums) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec find_score(nums :: [integer]) :: integer\n  def find_score(nums) do\n    \n  end\nend"
  },
  "solution": "[TOC]\n\n## Solution\n\n---\n\n### Overview\n\nWe need to find and return the `score` by following rules that outline which elements from `nums` we can add to the `score` and which we should \"mark\" (remove from consideration). \n\nWe'll repeat the following until all elements of `nums` are marked:\n1. Identify the smallest unmarked integer and add it's value to `score`.\n2. Mark off this element (if there's a tie, mark the element with the lowest index) and it's adjacent elements.\n\nWe will outline two solutions that will simulate this algorithm by efficiently going through a sorted order of `nums`, and keeping track of which elements of `nums` have been marked.\n\n### Approach 1: Sorting\n\n#### Intuition\n\nAt the beginning of each iteration of the algorithm, we need to select the next smallest unmarked integer. While this approach adds some complexity by focusing only on unmarked elements, it ensures that the selected elements will still be in ascending order. To simplify this process, we can start by sorting the list `nums` in ascending order. This initial sorting will help us achieve the correct order specified by the algorithm.\n\nNow, as we iterate through this sorted version of `nums` from left to right, each integer can fall into one of two categories:\n\n1. **Unmarked Number:** If the number hasn't been marked before, we add it to our running `score` and mark its adjacent elements.\n2. **Marked Number:** If the number has already been marked, we simply skip it and move on to the next element.\n\nTo keep track of which elements have been marked, we can use a boolean array called `marked`. Here, `marked[i]` will be `true` if `nums[i]` has been marked. If `marked[i]` is `true`, we know to skip that number. If `marked[i]` is `false`, we add `nums[i]` to our `score` and update `marked` for the adjacent elements.\n\nTo mark the adjacent elements, we set `marked[i - 1]` (the element to its left) and `marked[i + 1]` (the element to its right) to `true`, as long as those indices are within the bounds of the array.\n\nIt's important to note that we need to maintain the original indices of `nums` to correctly identify the adjacent elements. If we sort `nums` directly, we lose the original indexing, which prevents us from finding the adjacent elements for each number in the original list. To solve this, we can create a new 2D array called `customSorted`, where `customSorted[i][0]` contains the element `nums[i]` and `customSorted[i][1]` holds the original index `i` for that element. After sorting `customSorted`, we have a customSorted version of `nums` while still keeping track of each element's original index.\n\n#### Algorithm\n\n1. Initialize our `ans` variable to `0`.\n2. Initialize our boolean array `marked` to maintain which elements have been marked.\n3. Initialize our sorted array `customSorted` to hold the sorted elements of `nums` as well as their original indices.\n4. Traverse the elements of `nums` and populate `customSorted`.\n5. Sort `customSorted` in ascending order.\n6. Traverse through `customSorted` from left to right. For each element `customSorted[i]`:\n    * Extract the number `number = customSorted[i][0]`.\n    * Extract the original index `index = customSorted[i][1]`\n    * If `!marked[index]`, then our number has not been marked yet:\n        * Add `number` to our running score: `ans += number`.\n        * Mark the current number: `marked[index] = true`.\n        * Mark the left element if it exists: `marked[index - 1] = true`.\n        * Mark the right element if it exists: `marked[index + 1] = true`.\n\n#### Implementation#### Complexity Analysis\n\nLet $N$ be the size of `nums`.\n\n* Time Complexity: $O(N \\cdot \\log N)$\n\n    Sorting our `customSorted` array takes $O(N \\cdot \\log N)$ time. Traversing through `customSorted` and processing each element takes a total of $O(N)$ time. Thus, the total time complexity is $O(N \\cdot \\log N)$.\n\n* Space Complexity: $O(N + S_N) \\approx (N)$\n\n    Our `customSorted` and `marked` arrays both have a size of $N$. Furthermore, additional space is needed to sort `nums`. This space complexity ($S_N$) depends on the language of implementation. Given input size $N$:\n\n    In Java, `Arrays.sort()` is implemented using a variant of the Quick Sort algorithm which has a space complexity of $O( \\log N)$.\n    In C++, the `sort()` function is implemented as a hybrid of Quick Sort, Heap Sort, and Insertion Sort, with a worst-case space complexity of $O(\\log N)$.\n    In Python, the `sort()` method sorts a list using the Timsort algorithm which is a combination of Merge Sort and Insertion Sort and has a space complexity of $O(N)$.\n\n    Thus, the total space complexity is determined by $O(N + S_N) \\approx (N)$.\n\n### Approach 2: Heap\n\n#### Intuition\n\nIn our first approach, we processed the elements in the correct order by sorting the `nums` array in ascending order. We also used a `marked` array to keep track of elements that had already been processed or marked.\n\nIn our second approach, we can follow a very similar method by using a min heap to sort the elements of `nums`. Specifically, our min heap will be populated with tuples, each consisting of an element from `nums` (`nums[i]`) and its corresponding index (`i`). This is similar to the functionality of the `customSorted` array in Approach 1, which sorted `nums` while maintaining their original indices.\n\nOnce the min heap is populated, we can continuously remove elements from the top of the heap and repeat the procedure explained in Approach 1: \n\n1. Add the element's value to the running score if it hasn't been marked.\n2. Mark the current element as well as any adjacent elements using the `marked` array.\n\n#### Algorithm\n\n1. Initialize our `ans` variable to `0`.\n2. Initialize our boolean array `marked` to maintain which elements have been marked.\n3. Initialize a min heap `heap` to store our `(nums[i], i)` tuples. The min heap should have the elements sorted so that smaller elements are prioritized first, and then smaller indices are used to break ties.\n4. Traverse through `nums` and populate `heap` with all tuples\n5. While `heap` is not empty:\n    * Remove tuple `element` from `heap`.\n    * Initialize `number = element[0]` and `index = element[1]`.\n    * If `!marked[index]`:\n        * Add `number` to our running score: `ans += number`.\n        * Mark the current number: `marked[index] = true`.\n        * Mark the left element if it exists: `marked[index - 1] = true`.\n        * Mark the right element if it exists: `marked[index + 1] = true`.\n\n#### Implementation#### Complexity Analysis\n\nLet $N$ be the size of `nums`.\n\n* Time Complexity: $O(N \\cdot \\log N)$\n\n    Each addition/removal from `heap` takes $O(\\log N)$ time. Thus, adding/removing all $N$ elements from the `heap` takes a total of $O(N \\cdot \\log N)$ time. The other operations inside the while loop (marking elements and checking indices) take $O(1)$ time per iteration, so the total time for these operations is $O(N)$. Combining these, the overall time complexity is dominated by the $O(N \\cdot \\log N)$ operations of building and processing the priority queue.\n\n* Space Complexity: $O(N)$\n\n    Our `heap` and `marked` arrays both have a size of $N$. Thus, the total space complexity is $O(N)$.\n\n---\n\n\n### Approach 3: Sliding Window\n\n#### Intuition\n\nWe can notice that finding the smallest unmarked number repeatedly can be slow if we keep searching through the array. To simplify this, we notice that once we mark a number, its neighbors are also marked. This means we can skip over these elements in our traversal. So, instead of checking every number, we decide to move through the array in steps of 2, which helps us skip over numbers that are already marked.\n\nAs we move through the array, we need to find sequences of numbers where the current number is greater than or equal to the next one (`nums[i] >= nums[i + 1]`). This lets us group together numbers that we can process at the same time. For each sequence we find, we process the numbers from the end of the sequence back to the start. This way, we always handle the smallest unmarked number first, as required by the problem.\n\n#### Algorithm\n\n- Initialize `ans` to 0 to store the cumulative score.\n\n- Iterate through the array `nums` with a step of 2, starting from index `i = 0`.\n  - Set `currentStart` to the current value of `i` to mark the beginning of a sequence.\n  - While the next element `nums[i + 1]` exists and is smaller than the current element `nums[i]`, increment `i` to extend the sequence.\n  \n- After identifying the sequence, iterate backward from the current index `i` to `currentStart`, decrementing by 2 in each step:\n  - Add the value of `nums[currentIndex]` to `ans`.\n\n- Continue processing until all elements in the array are traversed.\n\n- Return the accumulated value of `ans` as the final result.\n\n#### Implementation#### Complexity Analysis\n\nLet $N$ be the size of `nums`.\n\n- Time complexity: $O(N)$\n\n    The algorithm iterates through the `nums` array once, with the outer loop running $N/2$ times (since `i` increments by 2 each time). The inner while loop and the inner for loop both operate within the bounds of the current segment, but together they do not exceed $O(N)$ in total because each element is processed at most a constant number of times. Therefore, the overall time complexity is linear in the size of `nums`.\n\n- Space complexity: $O(1)$\n\n    The algorithm uses a constant amount of extra space. The only additional space used is for the loop variables and the `ans` variable, which do not depend on the size of the input. Therefore, the space complexity is constant.\n\n---"
}