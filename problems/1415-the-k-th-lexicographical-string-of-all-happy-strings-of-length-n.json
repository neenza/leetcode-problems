{
  "title": "The k-th Lexicographical String of All Happy Strings of Length n",
  "problem_id": "1516",
  "frontend_id": "1415",
  "difficulty": "Medium",
  "problem_slug": "the-k-th-lexicographical-string-of-all-happy-strings-of-length-n",
  "topics": [
    "String",
    "Backtracking"
  ],
  "description": "A happy string is a string that:\nFor example, strings \"abc\", \"ac\", \"b\" and \"abcbabcbcb\" are all happy strings and strings \"aa\", \"baa\" and \"ababbc\" are not happy strings.\nGiven two integers n and k, consider a list of all happy strings of length n sorted in lexicographical order.\nReturn the kth string of this list or return an empty string if there are less than k happy strings of length n.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: n = 1, k = 3\nOutput: \"c\"\nExplanation: The list [\"a\", \"b\", \"c\"] contains all happy strings of length 1. The third string is \"c\".",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input: n = 1, k = 4\nOutput: \"\"\nExplanation: There are only 3 happy strings of length 1.",
      "images": []
    },
    {
      "example_num": 3,
      "example_text": "Input: n = 3, k = 9\nOutput: \"cab\"\nExplanation: There are 12 different happy string of length 3 [\"aba\", \"abc\", \"aca\", \"acb\", \"bab\", \"bac\", \"bca\", \"bcb\", \"cab\", \"cac\", \"cba\", \"cbc\"]. You will find the 9th string = \"cab\"",
      "images": []
    }
  ],
  "constraints": [
    "1 <= n <= 10",
    "1 <= k <= 100"
  ],
  "follow_ups": [],
  "hints": [
    "Generate recursively all the happy strings of length n.",
    "Sort them in lexicographical order and return the kth string if it exists."
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    string getHappyString(int n, int k) {\n        \n    }\n};",
    "java": "class Solution {\n    public String getHappyString(int n, int k) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def getHappyString(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: str\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def getHappyString(self, n: int, k: int) -> str:\n        ",
    "c": "char* getHappyString(int n, int k) {\n    \n}",
    "csharp": "public class Solution {\n    public string GetHappyString(int n, int k) {\n        \n    }\n}",
    "javascript": "/**\n * @param {number} n\n * @param {number} k\n * @return {string}\n */\nvar getHappyString = function(n, k) {\n    \n};",
    "typescript": "function getHappyString(n: number, k: number): string {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param Integer $n\n     * @param Integer $k\n     * @return String\n     */\n    function getHappyString($n, $k) {\n        \n    }\n}",
    "swift": "class Solution {\n    func getHappyString(_ n: Int, _ k: Int) -> String {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun getHappyString(n: Int, k: Int): String {\n        \n    }\n}",
    "dart": "class Solution {\n  String getHappyString(int n, int k) {\n    \n  }\n}",
    "golang": "func getHappyString(n int, k int) string {\n    \n}",
    "ruby": "# @param {Integer} n\n# @param {Integer} k\n# @return {String}\ndef get_happy_string(n, k)\n    \nend",
    "scala": "object Solution {\n    def getHappyString(n: Int, k: Int): String = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn get_happy_string(n: i32, k: i32) -> String {\n        \n    }\n}",
    "racket": "(define/contract (get-happy-string n k)\n  (-> exact-integer? exact-integer? string?)\n  )",
    "erlang": "-spec get_happy_string(N :: integer(), K :: integer()) -> unicode:unicode_binary().\nget_happy_string(N, K) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec get_happy_string(n :: integer, k :: integer) :: String.t\n  def get_happy_string(n, k) do\n    \n  end\nend"
  },
  "solution": "[TOC]\n\n## Solution\n\n---\n\n### Overview\n\nWe are given a positive integer `n`, which represents the length of the string, and an integer `k`. Our task is to find the $k^{\\text{th}}$ happy string of length `n` when all *happy* strings are listed in lexicographical order. Letâ€™s break this down:\n\n- **Happy Strings**: A string is called happy if it consists only of the characters `'a'`, `'b'`, and `'c'`, and no two consecutive characters are the same. For example, `\"abc\"` and `\"aba\"` are happy strings, but `\"aa\"` and `\"ad\"` are not.\n\n- **Lexicographical Order**: This is the order in which words appear in a dictionary. When comparing two strings, we look at the first different character. The one with the smaller character (closer to `'a'` in the alphabet) comes first. For example, `\"abc\"` comes before `\"acb\"` because `'b'` comes before `'c'`.\n\n> Note: If there are fewer than $k$ such strings, we return an empty string.\n\n---\n\n### Approach 1: Backtracking (Optimized) \n\n#### Intuition\n\nIn this approach, we use backtracking to generate the `k-`th happy string directly, without needing to generate all happy strings and then sort them. This eliminates the overhead of sorting, which is particularly beneficial for larger values of `n`. We can determine the order in which the happy strings are generated by carefully choosing the order of characters in our backtracking.  \n\n>   For a more comprehensive understanding of backtracking, check out the [Backtracking Explore Card ðŸ”—](https://leetcode.com/explore/learn/card/recursion-ii/472/backtracking/). This resource provides an in-depth look at recursion and backtracking, explaining its key concepts and applications with a variety of problems to solidify understanding of the pattern.\n\nWe start with an empty string and recursively extend it by adding characters `'a'`, `'b'`, or `'c'`, ensuring that no two consecutive characters are the same. Crucially, we maintain the lexicographical order by trying `'a'`, then `'b'`, then `'c'` at each step. Because we generate the strings in lexicographical order and are looking for the `k-`th string, we can stop generating strings as soon as we find it.  \n\nTo implement this, we iterate over the characters `'a'`, `'b'`, and `'c'` in that specific order. For each character, we check if it matches the last character of the string we've constructed so far. If it does, we skip it. Otherwise, we add it to the end of the current string and continue the backtracking. We decrement `k` with each valid character we add to the string. If `k` becomes `0`, we've found our `k-`th string.  \n\n##### Why Sorting is Not Needed:  \n\nA good observation is that we create happy strings in lexicographical order. Since we only need the `k`-th string, we donâ€™t have to generate all possible strings and sort them. Instead, we can stop as soon as we find the `k`-th one. This saves a lot of time, especially for large `n`. We generate strings using the order `'a'`, `'b'`, `'c'`, which naturally keeps them in alphabetical order. By keeping track of how many happy strings we have found, we can skip entire sections of the search that donâ€™t contain the `k`-th string.\n\n### Algorithm  \n\n- Initialize `currentString` as an empty string to build happy strings.\n- Initialize `happyStrings` as a array to store all valid happy strings.\n- Generate all happy strings of length `n` by calling `generateHappyStrings`.\n\n- If the total count of happy strings is less than `k`, return an empty string.\n- Otherwise, return the `k`-th happy string from `happyStrings`.\n\n- In `generateHappyStrings`:\n  - If `currentString` reaches length `n`, add it to `happyStrings` and return.\n  - Iterate over characters `'a'`, `'b'`, and `'c'`:\n    - Skip adding a character if it matches the last character of `currentString`.\n    - Recursively append the valid character and continue generating happy strings.\n\n#### Implementation#### Complexity Analysis\n\nLet $n$ be the desired length of the happy strings.\n\n- Time complexity: $O(2^{n-1} \\cdot 3) \\approx O(2^n)$\n\n    Let $n$ be the desired length of the happy strings. For the first character of the string, there are 3 options (`'a'`, `'b'`, or `'c'`). For each subsequent character, there are 2 options (since the same character cannot be repeated consecutively). Therefore, the total number of happy strings generated is $3 \\cdot 2^{n-1}$.\n\n    The function `generateHappyStrings` explores all these possibilities recursively, resulting in a time complexity of $O(3 \\cdot 2^{n-1})$, which simplifies to $O(2^{n-1} \\cdot 3) \\approx O(2^n)$.\n\n-   Space Complexity: $O(2^n)$.\n\n    We create an array to store all happy strings of length $n$, which will eventually hold $3 \\cdot 2^{n - 1} = O(2^n)$ elements. Additionally, the recursion depth can grow up to $n$, adding another $O(n)$ factor to the total space complexity. However, the amount of extra space used is dominated by the `happyStrings` array and remains equal to $O(2^n)$.\n\n---\n\n### Approach 2: Optimized Recursion\n\n#### Intuition\n\nBuilding on the previous approach, we will again generate happy strings of length `n` by extending an already happy string until it reaches the desired size. However, there's a key observation: the order in which we generate the strings is not random.\n\nSince we add characters in alphabetical order, we naturally explore all strings starting with `'a'` before backtracking and moving to those starting with `'b'`, and so on. This means the strings are generated directly in lexicographical order.\n\nBecause of this, we don't need to store all the strings and sort them later. Instead, we can keep a counter - corresponding to the index of the current string in the sorted list - to track how many strings we've generated. When we reach the $k^{\\text{th}}$ string, we store it as the result and stop the process, saving both time and space.\n\n#### Algorithm\n\n-   In the `generateHappyStrings(n, k, currentString, indexInSortedList, result)` function:\n    -   If we have reached the desired string length, i.e., `currentString.size() == n`:\n        -   Increment `indexInSortedList` by `1`.\n        -   If we have reached the `k-th` string, i.e., `indexInSortedList == k`, store `currentString` in `result`.\n    -   Otherwise, extend the current string by iterating over the candidate characters with `currentChar` from `'a'` to `'c'`:\n        -   If `currentChar` is the same as the last character in the `currentString`, skip it.\n        -   Otherwise, add it to the end of `currentString`.\n        -   Recursively call `generateHappyString(n, k, currentString, indexInSortedList, result)`.\n        -   If we have found the `k-th` string during this traversal, i.e., `result` is not an empty string, return.\n        -   Remove the last character of `currentString` to backtrack with the next one.\n-   In the main `getHappyString` function:\n    -   Initialize `currentString` and `result` to empty strings.\n    -   Initialize `indexInSortedList` to `0`.\n    -   Call `generateHappyStrings(n, k, currentString, indexInSortedList, result)` to generate the happy strings starting from the empty string.\n    -   Return `result`.\n\n#### Implementation#### Complexity Analysis\n\nLet $n$ be the length of the happy strings and $k$ the index of the result string in the sorted list.\n\n-   Time Complexity: $O(k \\cdot n)$ or $O(n \\cdot 2^n)$.\n\n    The algorithm generates happy strings in lexicographical order using backtracking and stops when the $k^{\\text{th}}$ one is found. \n    \n    In the worst case, the algorithm generates $min(k, 3 \\cdot 2^{n - 1})$ strings before terminating. For each string, it performs $n$ recursive calls (one for each character in the string) and each of them involves only constant-time operations such as checking if the current character is valid and updating the current string. \n    \n    Therefore, the total time complexity of the algorithm is $O(k \\cdot n)$ or $O(n \\cdot 2^n)$ the number of strings generated is $O(2^n)$.\n\n-   Space Complexity: $O(n)$.\n\n    Regarding additional space usage, we maintain a string `currentString` for backtracking, which can grow up to size $n$. Since this string is passed by reference in the recursive function, no extra copies are created, keeping its space usage at $O(n)$.\n\n    Additionally, the recursion depth is also $O(n)$ because we make a recursive call for each of the $n$ characters in the string.\n\n    Thus, the overall space complexity is $O(n)$.\n    \n---\n\n### Approach 3: Iterative Using a Stack\n\n#### Intuition\n\nRecursive solutions are often more intuitive for backtracking but can be inefficient due to uncontrolled stack growth. Each recursive call adds a new frame to the call stack, storing local variables and execution details, which can lead to excessive memory usage or even a stack overflow. To avoid this, we will use our own stack to simulate recursion, giving us greater control over memory usage and preventing unnecessary overhead. Feel free to refer to the relative [LeetCode Explore Card](https://leetcode.com/explore/learn/card/queue-stack/) for a more detailed overview of the stack data structure.\n\nSo, instead of making a new function call every time we extend the `currentString`, we store the next string to be processed (i.e., `currentString + currentChar`) in a stack. Then, retrieving a string from the top of the stack is the same as entering the function call that would have this string as `currentString`. The logic from this point remains the same: we go over all valid characters and try to extend the current string by adding them to the end of it. However, it is important to note that the string at the top of the stack is the one that will be processed (or expanded) first. Therefore, we need to push, for example, the string `\"abca\"` onto the stack after `\"abcb\"` so that it is retrieved first, ensuring that the strings are generated in lexicographic order. To achieve this, we will extend the current string by starting from the last valid character (`'c'`) and iterating backward to the first (`'a'`).\n\n#### Algorithm\n\n-   Initialize an empty stack, `stringsStack`.\n-   Initialize `indexInSortedList` to `0`.\n-   Push the empty string into the `stringsStack`.\n-   While the `stringsStack` is not empty:\n    -   Pop the top element of the stack as `currentString`.\n    -   If the `currentString` has a length equal to `n`:\n        -   Increment `indexInSortedList` by `1`.\n        -   If this is the `k-th` string in lexicographical order, i.e., `indexInSortedList == k`, return it.\n    -   Otherwise, extend the current string by iterating over the valid characters in reversed order, i.e., with `currentChar` from `'c'` to `'a'`:\n        -   If the current string is not empty and `currentChar` is equal to its last character, skip it.\n        -   Add `currentString + currentChar` to the stack.\n-   If the traversal ends and the `k-th` happy string is not found, there are less than `k` happy strings of length `n`, so return an empty string.\n\n#### Implementation#### Complexity Analysis\n\nLet $n$ be the length of the happy strings and $k$ the index of the result string in the sorted list.\n\n-   Time Complexity: $O(k \\cdot n)$ or $O(n \\cdot 2^n)$.\n\n    As in the previous approach, we generate $min(k, 3 \\cdot 2^{n - 1})$ strings of length $n$, so the loop will run for $O(k \\cdot n)$ or $O(n \\cdot 2^n)$ times. Extending the current string by one character involves only constant-time operations, like iterating over the 3 valid characters and pushing the next string onto the top of the stack. Therefore, the total time complexity of the algorithm is $O(k \\cdot n)$ or $O(n \\cdot 2^n)$.\n\n-   Space Complexity: $O(n^2)$.\n\n    The algorithm uses an explicit stack (`stringsStack`) to perform backtracking. During the traversal to construct the lexicographically smallest happy string (`\"ababa...\"`), we continuously extend a string of the form `\"ababa...\"`. At each level of recursion, we also push alternative choices onto the stack, such as `\"ababc\"`, which represent different branches of the search.\n\n    When we reach a valid happy string of length $n$, the stack contains $O(n)$ stored strings at most, each of which can be $O(n)$ in length. Therefore, the total space complexity of the algorithm, determined by the size of the stack, is $O(n^2)$.\n\n---\n\n### Approach 4: Combinatorics\n\n#### Intuition\n\nThe main idea of this approach is that we do not need to generate all $k - 1$ happy strings to find the $k^{th}$ smaller one. To better understand this, let's make the following observations:\n\n- The total number of happy strings of length `n` is $3 \\cdot 2^{n - 1}$. This is because the first character has 3 choices (`'a'`, `'b'`, or `'c'`) and each subsequent character has 2 choices, as it must differ from the preceding character. Therefore, if $k$ exceeds this total, it implies that the $k$-th happy string does not exist, and we should return an empty string.\n\n- Moving on to the harder case, note that the set of all happy strings can be divided into three equal groups based on their starting character:\n  - Strings starting with `'a'`: positions $1$ to $2^{n - 1}$.\n  - Strings starting with `'b'`: positions $2^{n - 1} + 1$ to $2 \\cdot 2^{n - 1}$.\n  - Strings starting with `'c'`: positions $2 \\cdot 2^{n - 1} + 1$ to $3 \\cdot 2^{n - 1}$.\n  \n  Each group contains $2^{n - 1}$ strings, as fixing the first character leaves $2^{n - 1}$ ways to choose the remaining characters. By comparing $k$ to these ranges, we can determine the first character of the desired string and adjust $k$ to reflect its position within the subgroup by subtracting the group's starting index.\n\n- Similarly, every subsequent character at the $i^{th}$ position divides the strings of its group into two subgroups of size $2^{n - i - 1}$:\n  - Strings starting with the smallest valid character (`'a'` -> `'b'`, `'b'` -> `'a'` and `'c'` -> `'a'`).\n  - Strings starting with the greatest valid character (`'a'` -> `'c'`, `'b'` -> `'c'` and `'c'` -> `'b'`).\n\n  By comparing $k$ with the midpoint at which the groups are split, i.e., $2^{n - i - 1}$, we can determine whether the result string belongs to the first or last subgroup and set the character at position $i$ accordingly.\n\n#### Algorithm\n\n-   Calculate the total number of happy strings of length `n` as `total = 3 * pow(2, n - 1)`.\n-   If `k` is greater than `total`, return an empty string.\n-   Initialize the `result` string.\n-   Initialize two maps, `nextSmallest` and `nextGreatest`, that map each of the three characters to the smallest and largest characters respectively that can go after them. \n-   Set the index of the first string that starts with `'a'` (`startA`) to `1` (the lexicographically smallest happy string with `'a'`).\n-   Calculate the index of the first string that starts with `'b'` as `startB = startA + pow(2, n - 1)`.\n-   Calculate the index of the first string that starts with `'c'` as `startC = startB + pow(2, n - 1)`.\n-   Determine the first character of the string:\n    -   If `k` is less than `startB`, set the first character of `result` to `'a'` and subtract `startA` from `k`.\n    -   Else if `k` is less than `startC`, set the first character of `result` to `'b'` and subtract `startB` from `k`.\n    -   Else, set the first character of `result` to `'c'` and subtract `startC` from `k`.\n-   For each subsequent character, at `charIndex`:\n    -   Calculate the `midpoint` of its group, as `midpoint = pow(2, n - charIndex - 1)`.\n    -   If `k` is less than `midpoint`, set `result[charIndex] = nextSmallest[result[charIndex - 1]]` to extend `result` with the smallest valid character.\n    -   Otherwise:\n        -   Set `result[charIndex] = nextGreatest[result[charIndex - 1]]`.\n        -   Decrement `k` by `midpoint` so that it corresponds to the index of the result string within the current group.\n-   Return `result`.\n\n#### Implementation#### Complexity Analysis\n\nLet $n$ be the length of the happy strings.\n\n-   Time Complexity: $O(n)$.\n\n    We construct the result string by iterating over its characters and determining each of them in constant time. Therefore, the time complexity of this algorithm is $O(n)$.\n\n-   Space Complexity: $O(1)$.\n\n    Excluding the output string, the algorithm only requires a fixed number of variables and two maps (`nextGreatest` and `nextSmallest`) of fixed size. Thus, the auxiliary space complexity is constant or $O(1)$.\n    \n---"
}