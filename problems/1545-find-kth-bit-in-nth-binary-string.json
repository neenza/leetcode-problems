{
  "title": "Find Kth Bit in Nth Binary String",
  "problem_id": "1667",
  "frontend_id": "1545",
  "difficulty": "Medium",
  "problem_slug": "find-kth-bit-in-nth-binary-string",
  "topics": [
    "String",
    "Recursion",
    "Simulation"
  ],
  "description": "Given two positive integers n and k, the binary string Sn is formed as follows:\nWhere + denotes the concatenation operation, reverse(x) returns the reversed string x, and invert(x) inverts all the bits in x (0 changes to 1 and 1 changes to 0).\nFor example, the first four strings in the above sequence are:\nReturn the kth bit in Sn. It is guaranteed that k is valid for the given n.\nExample 1:\nExample 2:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: n = 3, k = 1\nOutput: \"0\"\nExplanation: S3 is \"0111001\".\nThe 1st bit is \"0\".",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input: n = 4, k = 11\nOutput: \"1\"\nExplanation: S4 is \"011100110110001\".\nThe 11th bit is \"1\".",
      "images": []
    }
  ],
  "constraints": [
    "1 <= n <= 20",
    "1 <= k <= 2n - 1"
  ],
  "follow_ups": [],
  "hints": [
    "Since n is small, we can simply simulate the process of constructing S1 to Sn."
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    char findKthBit(int n, int k) {\n        \n    }\n};",
    "java": "class Solution {\n    public char findKthBit(int n, int k) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def findKthBit(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: str\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def findKthBit(self, n: int, k: int) -> str:\n        ",
    "c": "char findKthBit(int n, int k) {\n    \n}",
    "csharp": "public class Solution {\n    public char FindKthBit(int n, int k) {\n        \n    }\n}",
    "javascript": "/**\n * @param {number} n\n * @param {number} k\n * @return {character}\n */\nvar findKthBit = function(n, k) {\n    \n};",
    "typescript": "function findKthBit(n: number, k: number): string {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param Integer $n\n     * @param Integer $k\n     * @return String\n     */\n    function findKthBit($n, $k) {\n        \n    }\n}",
    "swift": "class Solution {\n    func findKthBit(_ n: Int, _ k: Int) -> Character {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun findKthBit(n: Int, k: Int): Char {\n        \n    }\n}",
    "dart": "class Solution {\n  String findKthBit(int n, int k) {\n    \n  }\n}",
    "golang": "func findKthBit(n int, k int) byte {\n    \n}",
    "ruby": "# @param {Integer} n\n# @param {Integer} k\n# @return {Character}\ndef find_kth_bit(n, k)\n    \nend",
    "scala": "object Solution {\n    def findKthBit(n: Int, k: Int): Char = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn find_kth_bit(n: i32, k: i32) -> char {\n        \n    }\n}",
    "racket": "(define/contract (find-kth-bit n k)\n  (-> exact-integer? exact-integer? char?)\n  )",
    "erlang": "-spec find_kth_bit(N :: integer(), K :: integer()) -> char().\nfind_kth_bit(N, K) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec find_kth_bit(n :: integer, k :: integer) :: char\n  def find_kth_bit(n, k) do\n    \n  end\nend"
  },
  "solution": "[TOC]\n\n## Solution\n\n---\n\n### Approach 1: Brute Force\n\n#### Intuition\n\nGiven that `n` is relatively small, we can solve this problem by simply simulating the operations. We'll maintain a string `sequence` as our binary string. Next, we run a loop until we reach the `n`th string or the length of the `sequence` exceeds `k` (in which case, we can terminate early since the required character is already created). \n\nIn each iteration, we start by appending `1` to `sequence`. Then, we take each bit of the original `sequence` in reverse, invert it, and append it to the end of `sequence`.\n\nFinally, once the loop completes, we return the `k-1`th character (0-indexed) as the result.\n\n#### Algorithm\n\n- Initialize a string `sequence` with the initial sequence \"0\".\n- Start a loop that continues until we reach the `n`th iteration or have generated enough characters:\n  - Append '1' to the current sequence.\n  - Start a nested loop to iterate through the existing sequence in reverse order:\n    - For each bit in the existing sequence (excluding the last '1'):\n      - Invert the bit (change '0' to '1' or '1' to '0').\n      - Append the inverted bit to the end of the sequence.\n- Once the loop completes, return the `k-1`th (0-indexed) character of the sequence.\n\n#### Implementation#### Complexity Analysis\n\n- Time complexity: $O(2^n)$\n\n    In the worst case, we need to generate the entire `n`th string. The length of the string doubles (approximately) with each iteration: $S_1$ has length 1, $S_2$ has length 3 $(2^2 - 1)$ ... $S_n$ has length $2^n - 1$. Thus, the total number of operations is proportional to the sum of $2^i$ for $i$ from $1$ to $n-1$, which is $O(2^n)$.\n\n- Space complexity: $O(2^n)$\n\n    We store the entire generated string in memory, where the length of the `n`th string is $2^n - 1$. Therefore, the space complexity of the algorithm is $O(2^n)$.  \n\n---\n\n### Approach 2: Recursion\n\n#### Intuition\n\nInstead of building the string from the base condition, let’s work backward from the largest string, which is efficient for large values of `k`.\n\nAccording to the problem, each string $S_n$ is formed from $S_{n-1}$. So, to find a specific bit in $S_n$, we can recursively break down $S_n$ to $S_{n-1}$ until reaching $S_1$. This suggests a recursive approach.\n\nWe can break down our recursive method into three parts:\n1. If `k` is in the first half, it lies in $S_{n-1}$. We can recursively call our function with `n-1` and the same `k`.\n2. If `k` is exactly in the middle, we know the value is `1` based on the string construction rules, so we return 1.\n3. The latter half of $S_n$ is actually $S_{n-1}$, but flipped and reversed. To account for the reversal, we need to find the `k`th bit from the end. We can do so by calling the `findKthBit` function on $S_{n-1}$ but instead of `k`, we use the length of $S_n$ minus `k`. The answer we get will be the `k`th bit but flipped. We just need to flip it back before returning it as our final answer.\n\n#### Algorithm\n\n- If `n` equals 1, return '0' as the base case.\n- Calculate the length of the `n`th string by left-shifting 1 by `n` positions.\n- Compare `k` with half of the calculated length and return the result:\n  - If `k` is less than half the length, recursively call the function with `n-1` and the same `k`.\n  - If `k` is exactly half the length, return '1'.\n  - If `k` is greater than half the length:\n    - Calculate the corresponding position in the first half of the string by subtracting `k` from the total length.\n    - Recursively call the function with `n-1` and this new position.\n    - Invert the bit returned from the recursive call (change '0' to '1' or '1' to '0').\n    - Return the inverted bit.\n\n#### Implementation#### Complexity Analysis\n\n* Time complexity: $O(n)$\n\n    The recursion depth is at most `n`, as we decrease `n` by 1 in each call until we reach the base case where `n` is 1. Each recursive call performs constant-time operations. Thus, the time complexity of the algorithm is $O(n)$.\n\n* Space complexity: $O(n)$\n\n    The space complexity is determined by the maximum depth of the recursion stack, which is $O(n)$.\n\n---\n\n### Approach 3: Iterative Divide and Conquer\n\n#### Intuition\n\nWe can convert the recursive approach to an iterative one to avoid the excess stack space taken by the recursion.\n\nOur main idea stays the same: start with the largest string and repeatedly halve it until reaching the smallest string, $S_1$.\n\nIn the recursive approach, finding a bit in the second half of the string allowed us to immediately flip it due to the recursion handling any further inversions. Since that isn’t possible iteratively, we maintain an `invertCount` variable to track how many times we enter an inverted section. Once we find the `k`th bit, we check the parity of `invertCount` to determine if it needs to be flipped.\n\nWe begin with the largest string length $2^n - 1$ and loop while `k` is greater than 1. If `k` is in the middle, it represents the `1` added during string construction, so we simply return the bit based on `invertCount`. If `k` is in the second half, we mirror `k` to the corresponding bit in the first half and increment `invertCount` to indicate the inversion. Then, we move to the previous string in the series by halving the length.\n\nWhen the loop completes, `k` represents the first bit of the string (corresponding to $S_1$). We return this bit, flipping it if necessary based on `invertCount`.\n\n#### Algorithm\n\n- Initialize a variable `invertCount` to 0 to keep track of the number of inversions.\n- Calculate the length of the `n`th string as $2^n - 1$ using bitwise left shift.\n- Enter a loop that continues while `k` is greater than 1:\n  - Check if `k` is exactly in the middle of the current string:\n      - If true, return '1' if `invertCount` is even, otherwise return '0'.\n  - If `k` is in the second half of the current string:\n      - Update `k` to its mirrored position in the first half.\n      - Increment the `invertCount`.\n  - Halve the length of the string for the next iteration.\n- After the loop ends (when `k` reaches 1):\n   - Return '0' if `invertCount` is even, otherwise return '1'.\n\n#### Implementation#### Complexity Analysis \n\n* Time complexity: $O(n)$\n\n    The algorithm uses a while loop that continues as long as `k > 1`. In the worst case, when `k` is always in the second half of the string, the algorithm will perform `n` iterations. Thus, the time complexity is $O(n)$. \n\n* Space complexity: $O(1)$\n\n    The algorithm does not use any additional space which scales with input size.\n\n---\n\n### Approach 4: Bit Manipulation\n\n#### Intuition\n\n> Note: This approach is quite challenging and requires a strong understanding of bit manipulation and pattern recognition. In most interviews, optimizing your solution using Approach 3 would be more than sufficient.\n\nInstead of constructing the entire sequence, we focus on the binary representation of $k$. The position of $k$ helps us understand its relation to the sequence structure.\n\nWe begin by using the expression $k \\& -k$ to find the rightmost set bit in $k$. This operation isolates the smallest power of 2 in $k$. Why is this important? The rightmost set bit indicates how deep we are in the sequence’s structure, guiding us to the appropriate section of the sequence, especially in relation to any inversions.\n\nThe following diagram illustrates how we isolate the rightmost set bit using $k \\& -k$:\n\n![](../Figures/1545/kminusk.png)\n\nTo clarify the above concept, let’s break down the binary representation of positions step by step.\n\nConsider the following sequences:\n- $S_1 = \"0\"$\n- $S_2 = \"0\" + \"1\" + \"1\" = \"011\"$\n- $S_3 = \"011\" + \"1\" + \"001\" = \"0111001\"$\n\nNow, let’s analyze $S_3 = \"0111001\"$ in detail:\n\n| Position | 1 | 2 | 3 | 4 | 5 | 6 | 7 |\n|----------|---|---|---|---|---|---|---|\n| $S_3$   | 0 | 1 | 1 | 1 | 0 | 0 | 1 |\n| Binary   | 001 | 010 | 011 | 100 | 101 | 110 | 111 |\n\n1. First Bit (Leftmost) of the Binary Representation:\n   - If it’s 0, we are in the left half of the string (positions 1-3).\n   - If it’s 1, we are either in the right half (positions 5-7) or the middle (position 4).\n\n2. Second Bit of the Binary Representation:\n   - In the left half (positions 1-3 represented as 001-011):\n     - If it’s 0, we are in the left quarter (position 1).\n     - If it’s 1, we are in the right quarter of the left half (positions 2-3).\n   - In the right half (positions 5-7 represented as 101-111):\n     - If it’s 0, we are in the left quarter of the right half (position 5).\n     - If it’s 1, we are in the right quarter (positions 6-7).\n\n3. Third Bit (Rightmost) of the Binary Representation:\n   - This indicates whether we are at an odd or even position.\n\nThis pattern continues for larger strings. Each bit in the binary representation narrows down which section of the string we are examining.\n\nFor instance, consider position 6 (binary 110):\n- The first bit is 1, indicating we are in the right half of the string.\n- The second bit is 1, showing we are in the right quarter of the right half.\n- The third bit is 0, indicating we are at an even position.\n\nFrom this information, we can determine:\n1. Whether we are in an inverted section (right half).\n2. How many times the bit has been inverted, which depends on our depth in the sections.\n3. What the original bit was based on the odd/even position.\n\nThis is how the binary representation of the position correlates with the string's structure. We know this approach might seem unconventional and is tougher than what you might have originally thought of. We recommend dry-running this approach a couple of times to digest it completely, simply reading this explanation is not enough.\n\nSo to determine if the bit at position $k$ has been inverted, we check the bits to the left of the rightmost set bit. We calculate $k$ divided by `positionInSection` (the result of $k \\& -k$) and then shift the result right by one bit.\n\nIf the resulting bit is 1, it indicates we are in a section of the sequence that has been inverted. We then need to ascertain the original state of the bit, regardless of any inversions. If $k$ is even, the original bit is 1; if $k$ is odd, the original bit is 0. This check tells us the bit's state before any transformations occur.\n\nFinally, we decide what to return based on whether $k$ is in an inverted section:\n- If $k$ is in an inverted part, we flip the original bit (changing 0 to 1 or 1 to 0).\n- If $k$ is not in an inverted part, we return the original bit as it is.\n\n#### Algorithm\n\n- Calculate the position within the current section by performing a bitwise AND operation between `k` and its two's complement (-`k`).\n- Determine if the bit is in an inverted part of the sequence:\n  - Divide `k` by the position in section.\n  - Right shift the result by 1 bit.\n  - Perform a bitwise AND with 1.\n  - Check if the result equals 1.\n- Determine if the original bit (before any inversions) is a 1:\n   - Perform a bitwise AND between `k` and 1.\n   - Check if the result equals 0.\n- If the bit is in an inverted part of the sequence:\n  - Return '0' if the original bit was 1, otherwise return '1'.\n- If the bit is not in an inverted part:\n  - Return '1' if the original bit was 1, otherwise return '0'.\n\n#### Implementation#### Complexity Analysis\n\n* Time complexity: $O(1)$\n\n    The algorithm performs a constant number of bitwise operations and comparisons, regardless of the input values of `n` and `k`. Therefore, the time complexity is $O(1)$ or constant time. \n\n* Space complexity: $O(1)$\n\n    The algorithm does not use any data structures which is dependent on the input size. So, it's space complexity remains constant.\n\n---"
}