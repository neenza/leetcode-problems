{
  "title": "Number of Wonderful Substrings",
  "problem_id": "2044",
  "frontend_id": "1915",
  "difficulty": "Medium",
  "problem_slug": "number-of-wonderful-substrings",
  "topics": [
    "Hash Table",
    "String",
    "Bit Manipulation",
    "Prefix Sum"
  ],
  "description": "A wonderful string is a string where at most one letter appears an odd number of times.\nGiven a string word that consists of the first ten lowercase English letters ('a' through 'j'), return the number of wonderful non-empty substrings in word. If the same substring appears multiple times in word, then count each occurrence separately.\nA substring is a contiguous sequence of characters in a string.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: word = \"aba\"\r\nOutput: 4\r\nExplanation: The four wonderful substrings are underlined below:\r\n- \"aba\" -> \"a\"\r\n- \"aba\" -> \"b\"\r\n- \"aba\" -> \"a\"\r\n- \"aba\" -> \"aba\"",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input: word = \"aabb\"\r\nOutput: 9\r\nExplanation: The nine wonderful substrings are underlined below:\r\n- \"aabb\" -> \"a\"\r\n- \"aabb\" -> \"aa\"\r\n- \"aabb\" -> \"aab\"\r\n- \"aabb\" -> \"aabb\"\r\n- \"aabb\" -> \"a\"\r\n- \"aabb\" -> \"abb\"\r\n- \"aabb\" -> \"b\"\r\n- \"aabb\" -> \"bb\"\r\n- \"aabb\" -> \"b\"",
      "images": []
    },
    {
      "example_num": 3,
      "example_text": "Input: word = \"he\"\r\nOutput: 2\r\nExplanation: The two wonderful substrings are underlined below:\r\n- \"he\" -> \"h\"\r\n- \"he\" -> \"e\"",
      "images": []
    }
  ],
  "constraints": [
    "1 <= word.length <= 105",
    "word consists of lowercase English letters from 'a'Â to 'j'."
  ],
  "follow_ups": [],
  "hints": [
    "For each prefix of the string, check which characters are of even frequency and which are not and represent it by a bitmask.",
    "Find the other prefixes whose masks differs from the current prefix mask by at most one bit."
  ],
  "code_snippets": {
    "cpp": "class Solution {\r\npublic:\r\n    long long wonderfulSubstrings(string word) {\r\n        \r\n    }\r\n};",
    "java": "class Solution {\r\n    public long wonderfulSubstrings(String word) {\r\n        \r\n    }\r\n}",
    "python": "class Solution(object):\r\n    def wonderfulSubstrings(self, word):\r\n        \"\"\"\r\n        :type word: str\r\n        :rtype: int\r\n        \"\"\"",
    "python3": "class Solution:\r\n    def wonderfulSubstrings(self, word: str) -> int:",
    "c": "long long wonderfulSubstrings(char * word){\r\n\r\n}",
    "csharp": "public class Solution {\r\n    public long WonderfulSubstrings(string word) {\r\n        \r\n    }\r\n}",
    "javascript": "/**\r\n * @param {string} word\r\n * @return {number}\r\n */\r\nvar wonderfulSubstrings = function(word) {\r\n    \r\n};",
    "typescript": "function wonderfulSubstrings(word: string): number {\r\n\r\n};",
    "php": "class Solution {\r\n\r\n    /**\r\n     * @param String $word\r\n     * @return Integer\r\n     */\r\n    function wonderfulSubstrings($word) {\r\n        \r\n    }\r\n}",
    "swift": "class Solution {\r\n    func wonderfulSubstrings(_ word: String) -> Int {\r\n        \r\n    }\r\n}",
    "kotlin": "class Solution {\r\n    fun wonderfulSubstrings(word: String): Long {\r\n        \r\n    }\r\n}",
    "golang": "func wonderfulSubstrings(word string) int64 {\r\n    \r\n}",
    "ruby": "# @param {String} word\r\n# @return {Integer}\r\ndef wonderful_substrings(word)\r\n    \r\nend",
    "scala": "object Solution {\r\n    def wonderfulSubstrings(word: String): Long = {\r\n        \r\n    }\r\n}",
    "rust": "impl Solution {\r\n    pub fn wonderful_substrings(word: String) -> i64 {\r\n        \r\n    }\r\n}",
    "racket": "(define/contract (wonderful-substrings word)\r\n  (-> string? exact-integer?)\r\n\r\n  )"
  },
  "solution": "[TOC]\n\n## Solution\n\n--- \n\n### Approach: Count Parity Prefixes\n\n\n#### Intuition\n\nThere are two types of wonderful strings: those with no letters appearing an odd number of times, and those with exactly one letter appearing an odd number of times. After we find a solution to count the first type of strings, we can adapt it to cover all cases.\n\nThe parity of a letter means whether the count of that letter in a word is even or odd. We can find the parity of a letter by taking the frequency of that letter modulo $2$. Letters with odd frequencies have a parity of $1$, and letters with even frequencies have a parity of $0$. For example, the parity of letter \"a\" in \"abccada\" is $1$, whereas the parity of letter \"c\" is $0$. \n\nThe subtask now is to count the number of substrings with all letters appearing an even number of times. In other words, substrings where the parity of every letter is $0$. Because there are only $10$ distinct letters the string can consist of, we can use a bitmask of $10$ bits to represent the parities of all letters in a string. The `0`th (least significant) bit of the mask corresponds to the parity of letter \"a\", the `1`st bit corresponds to letter \"b\", and so on.\n\nFor example, the parity mask corresponding to string \"feffaec\" is $100101$, which equals $37$ in base 10. Letters \"a\", \"c\", and \"f\" appear an odd number of times, so their corresponding bits are set to `1`, and the other letters appear an even number of times, so their bits are set to `0`. We want to count the number of substrings with a mask of $0$ (if every character appears an even number of times, all bits will be set to `0`).\n\nFor any substring in the input string `word`, we can represent it as the difference between two prefixes of `s`. For example, substring $[2, 5]$ is the difference between prefix $[0, 5]$ and $[0, 1]$. Observe that the substring will equate to a mask of $0$ if and only if the masks of the two prefixes are equal. This is because we can \"subtract\" the larger prefix from the smaller prefix to create this substring using the `^` (XOR) operator. The XOR function is equivalent to subtraction under modulo $2$. All bits are independently calculated in the XOR function, where for each bit, the output is true when there is an odd number of true inputs. This gives us an efficient way to find the difference between the larger and smaller prefixes.\n\nThis gives us a linear time way to count strings with all characters appearing an even number of times: maintain the parity mask of the current prefix, and compare it with previous prefixes of the same value in a frequency map. The key is a mask, which corresponds to a prefix of the string, and the value is the frequency of the key mask. To count substrings with all even letters ending at some index $r$, take the prefix ending at $r$ with parity mask $m$, and add `freq[m]` to the answer. The difference of two prefixes with the same bitmask will equal `0`, which corresponds to strings with all even frequency letters.\n\nHere is an example of how parity masks are calculated for the string \"acadac\", which has a mask of $1001$. The `k`th letter of the alphabet will flip the `k`th smallest bit.\n\n![figA](../Figures/1915/1915_acadac_revised.png)\n\nAll that's left is to account for the case where exactly one letter appears an odd number of times. For the current prefix mask, we can find its counterpart in the frequency map by iterating through which bit should be flipped. For example, if the current prefix mask is $111$, and a smaller prefix has mask $101$, the substring generated by removing the intersection of these two prefixes will equal $010$, which means only the letter \"b\" appears an odd number of times.\n\n#### Algorithm\n\n1. Create a frequency table or map. Add the mask $0$ to account for the empty prefix.\n2. Initialize a `mask` int variable to $0$.\n3. For each character in `word`, flip the corresponding bit in `mask`.\n4. Add the frequency of `mask` to the answer.\n5. Increment the value associated with key `mask` by one.\n6. Iterate through each possible character that appears an odd number of times, and add the frequency of `mask ^ (1 << odd_c)`, where `^` is the XOR function.\n7. Return the result when all letters are processed.\n\n#### Implementation#### Complexity Analysis\n\n* Time complexity: $O(NA)$.\n\nThe number of distinct characters that can appear in `word` is defined as $A$. For each of the $N$ characters in `word`, we iterate through all possible characters that can be the odd character. Therefore, the time complexity of $O(NA)$, where $A \\leq 10$, because only letters \"a\" through \"j\" will appear.\n\n* Space complexity: $O(N)$.\n\nThe frequency map can store up to $N$ key/entry pairs, hence the linear space complexity.\n\n---"
}