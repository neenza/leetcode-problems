{
  "title": "Find if Array Can Be Sorted",
  "problem_id": "3291",
  "frontend_id": "3011",
  "difficulty": "Medium",
  "problem_slug": "find-if-array-can-be-sorted",
  "topics": [
    "Array",
    "Bit Manipulation",
    "Sorting"
  ],
  "description": "You are given a 0-indexed array of positive integers nums.\nIn one operation, you can swap any two adjacent elements if they have the same number of set bits. You are allowed to do this operation any number of times (including zero).\nReturn true if you can sort the array in ascending order, else return false.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: nums = [8,4,2,30,15]\nOutput: true\nExplanation: Let's look at the binary representation of every element. The numbers 2, 4, and 8 have one set bit each with binary representation \"10\", \"100\", and \"1000\" respectively. The numbers 15 and 30 have four set bits each with binary representation \"1111\" and \"11110\".\nWe can sort the array using 4 operations:\n- Swap nums[0] with nums[1]. This operation is valid because 8 and 4 have one set bit each. The array becomes [4,8,2,30,15].\n- Swap nums[1] with nums[2]. This operation is valid because 8 and 2 have one set bit each. The array becomes [4,2,8,30,15].\n- Swap nums[0] with nums[1]. This operation is valid because 4 and 2 have one set bit each. The array becomes [2,4,8,30,15].\n- Swap nums[3] with nums[4]. This operation is valid because 30 and 15 have four set bits each. The array becomes [2,4,8,15,30].\nThe array has become sorted, hence we return true.\nNote that there may be other sequences of operations which also sort the array.",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input: nums = [1,2,3,4,5]\nOutput: true\nExplanation: The array is already sorted, hence we return true.",
      "images": []
    },
    {
      "example_num": 3,
      "example_text": "Input: nums = [3,16,8,4,2]\nOutput: false\nExplanation: It can be shown that it is not possible to sort the input array using any number of operations.",
      "images": []
    }
  ],
  "constraints": [
    "1 <= nums.length <= 100",
    "1 <= nums[i] <= 28"
  ],
  "follow_ups": [],
  "hints": [
    "Split the array into segments. Each segment contains consecutive elements with the same number of set bits.",
    "From left to right, the previous segment’s largest element should be smaller than the current segment’s smallest element."
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    bool canSortArray(vector<int>& nums) {\n        \n    }\n};",
    "java": "class Solution {\n    public boolean canSortArray(int[] nums) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def canSortArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def canSortArray(self, nums: List[int]) -> bool:\n        ",
    "c": "bool canSortArray(int* nums, int numsSize) {\n    \n}",
    "csharp": "public class Solution {\n    public bool CanSortArray(int[] nums) {\n        \n    }\n}",
    "javascript": "/**\n * @param {number[]} nums\n * @return {boolean}\n */\nvar canSortArray = function(nums) {\n    \n};",
    "typescript": "function canSortArray(nums: number[]): boolean {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @return Boolean\n     */\n    function canSortArray($nums) {\n        \n    }\n}",
    "swift": "class Solution {\n    func canSortArray(_ nums: [Int]) -> Bool {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun canSortArray(nums: IntArray): Boolean {\n        \n    }\n}",
    "dart": "class Solution {\n  bool canSortArray(List<int> nums) {\n    \n  }\n}",
    "golang": "func canSortArray(nums []int) bool {\n    \n}",
    "ruby": "# @param {Integer[]} nums\n# @return {Boolean}\ndef can_sort_array(nums)\n    \nend",
    "scala": "object Solution {\n    def canSortArray(nums: Array[Int]): Boolean = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn can_sort_array(nums: Vec<i32>) -> bool {\n        \n    }\n}",
    "racket": "(define/contract (can-sort-array nums)\n  (-> (listof exact-integer?) boolean?)\n  )",
    "erlang": "-spec can_sort_array(Nums :: [integer()]) -> boolean().\ncan_sort_array(Nums) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec can_sort_array(nums :: [integer]) :: boolean\n  def can_sort_array(nums) do\n    \n  end\nend"
  },
  "solution": "[TOC]\n\n## Solution\n\n---\n\n### Overview\n\nWe are given an array of positive integers `nums`. Our task is to determine whether we can sort this array in ascending order by using the following operation any number of times (possibly zero):\n\n##### Operation:\n\n-   Pick two consecutive elements of the array.\n-   Count the number of set bits (1s) in their binary representation.\n-   If both elements have the same number of set bits, you are allowed to swap them.\n\nIn all approaches, we will need a `countSetBits` function, which takes a positive integer `n` and returns the number of set bits in it. There are several ways to implement this function:1. Using 2's Complement Method-   Pseudocode:\n\n```plaintext\nfunction countSetBits(n):\n    // Initialize a counter for set bits\n    count = 0\n    // If the number is negative, convert it to its 2's complement representation\n    // Loop until the number becomes 0\n    while n > 0:\n        // Check if the least significant bit (LSB) is 1\n        if (n & 1) == 1:\n            count = count + 1\n        // Right shift the number to process the next bit\n        n = n >> 1\n    return count\n```2. Using Bit Manipulation-   Pseudocode:\n\n```plaintext\n// Function to count the number of set bits\nfunction countSetBits(n):\n    // Initialize a counter for set bits\n    count = 0\n    // Loop until the number becomes 0\n    while n > 0:\n        // Increment the counter as the current number has a set bit\n        count = count + 1\n        // Clear the least significant set bit\n        n = n & (n - 1)\n    return count\n```However, in our solutions, we will take advantage of the language-specific built-in functions because they are easy to use and have optimized implementation, which allows them to operate with a constant time complexity of $O(1)$.\n\nAdditionally, in some approaches we would like to modify the input while trying to sort the array, to save space. However, this is not always a good practice. For example, if the algorithm needs to run in a multi-thread environment, the other threads might need to read the array too, and might not expect it to be modified. Even if there is only a single thread, the array might need to be reused later with its content unchanged.\n\n[](#interview-tip)\n\n##### Interview Tip\n\nIn an interview, you should always check whether or not the interviewer minds you overwriting the input. Be ready to explain the pros and cons of doing so, if asked!\n\n---\n\n### Approach 1: Bubble Sort\n\n#### Intuition\n\nSince our objective is to sort an array, a sorting algorithm could come in handy. And which one should we choose? Bubble Sort, of course! While Bubble Sort is generally inefficient for larger datasets, it can be quite effective here due to the small input size ($n \\leq 100$). The only task remaining is to determine whether the swaps required by the Bubble Sort algorithm are valid, given the sole operation we are allowed to perform.\n\nThe idea can be easily generalized, and the same algorithm can be implemented using other sorting methods, such as Insertion Sort and Selection Sort.\n\n#### Algorithm\n\n-   Get the length of the array, denoted as `n`.\n-   Make a copy `values` of the array, to avoid modifying the input.\n-   The outer loop runs from `i = 0` to `n - 1`.\n-   The inner loop iterates from `j = 0` to `n - i - 2` to compare adjacent elements.\n-   In each iteration of the inner loop, compare the values `values[j]` and `values[j+1]`.\n    -   If `values[j] <= values[j+1]`, no swap is needed; continue.\n    -   If `values[j] > values[j+1]`, the elements must be swapped.\n        -   If the elements have the same number of set bits, swap them.\n        -   Otherwise, return `false`.\n-   If the outer loop ends without returning false, the array is sorted, so return `true`.\n\n#### Implementation#### Complexity Analysis\n\nLet $n$ be the length of the array.\n\n- Time complexity: $O(n^2)$\n\n    The outer loop runs $n$ times, iterating through each element in the array.\n    \n    The inner loop also runs up to $n - i - 1$ times, which averages to $n$ iterations in the worst case.\n    \n    Inside the inner loop, checking whether to swap elements involves a comparison and potentially a swap operation if the condition is met. The operation `popcount` runs in $O(1)$ time for each pair of elements.\n\n    Therefore, the nested loops lead to a time complexity of $O(n^2)$.\n\n- Space complexity: $O(n)$\n\n    We are creating a copy of the original array to avoid directly modifying the input. However, if modifying the input is permitted (see [Interview Tip](#interview-tip)), the space complexity can be reduced to $O(1)$.\n\n---\n\n### Approach 2: Sortable Segments\n\n#### Intuition\n\nUpon closer examination of the allowed operation (or perhaps after reading the hint! :)), we find that we can divide the array into segments of consecutive elements with the same number of set bits. Since these elements can be swapped with one another, we could sort each segment individually. However, we are not permitted to change the order of the segments themselves, nor can we swap elements that belong to different segments, as they have different numbers of set bits.\n\nTherefore, we must verify that the segments are arranged correctly. Specifically, the maximum value of each segment (the one that would be the rightmost in its sorted order) must be less than or equal to the minimum value of the subsequent segment (the leftmost in its sorted order).\n\n#### Algorithm\n\n-   Initialize `maxOfSegment` and `minOfSegment` with the value of the first element of the array.\n-   Set `numOfSetBits` to the number of set bits of the first element of the array.\n-   Initialize `maxOfPrevSegment` to `INT_MIN`.\n-   Loop with `i` from `1` to `n-1`. In each iteration, consider the following cases:\n    -   If the number of set bits of `nums[i]` matches that of the elements in the current segment, update (if needed) `maxOfSegment` and `minOfSegment` with the value of `nums[i]`.\n    -   Otherwise, `nums[i]` belongs to a new segment.\n        -   If `minOfSegment < maxOfPrevSegment` return `false`.\n        -   Update `maxOfPrevSegment` to `maxOfSegment`.\n        -   Set `maxOfSegment` and `minOfSegment` to the value of `nums[i]`\n        -   Update `numOfSetBits` with the number of set bits for `nums[i]`.\n-   If the loop ends without returning `false`, segments are arranged correctly, so return `true`.\n\n> Important: We can safely use the first element of the array to initialize our variables because the constraints guarantee that the array will not be empty ($n \\geq 1$). However, in other situations, we should always account for this edge case.\n\n#### Implementation#### Complexity Analysis\n\nLet $n$ be the length of the array.\n\n-   Time complexity: $O(n)$\n\n    We traverse the entire array only once, performing constant-time operations in each iteration.\n\n-   Space complexity: $O(1)$\n\n    We only use a fixed number of integer variables, which does not depend on the input size.\n\n---\n\n### Approach 3: Forward and Backward Pass\n\n#### Intuition\n\nTo simplify the previous approach, we can utilize a two-pass method to determine whether the array can be sorted under the given constraints. In the first pass, we iterate through the array from left to right, aiming to move the maximum value of each segment as far to the right as possible by swapping adjacent elements when allowed.\n\nThen, in the second pass, we switch directions and iterate from right to left. This time, we focus on moving the minimum value of each segment as far to the left as possible. \n\nWhile we’re making these passes, if we come across a pair of elements that should be swapped but can't be—because they have different numbers of set bits—we immediately return false. This means that sorting the array under the given constraints isn't possible.\n\n#### Algorithm\n\n-   Get the length of the array, denoted as `n`.\n-   Make a copy `values` of the array, to avoid modifying the input.\n-   Iterate for `i = 0` to `i = n - 1`. In each iteration, check the following conditions:\n    -   If `values[i] <= values[i+1]`, continue.\n    -   Otherwise, the elements must be swapped, so that the greater (`values[i]`) moves to the right.\n        -   If they have the same number of set bits, swap them.\n        -   Else, return `false`.\n-   Iterate for `i = n - 1` to `i = 1`. In each iteration, check the following conditions:\n    -   If `values[i] >= values[i-1]`, continue.\n    -   Otherwise, the elements must be swapped, so that the smaller (`values[i]`) moves to the left.\n        -   If they have the same number of set bits, swap them.\n        -   Else, return `false`.\n-   If both loops end without returning `false`, return `true`.\n\n#### Implementation#### Complexity Analysis\n\nLet $n$ be the length of the array.\n\n-   Time complexity: $O(n)$\n\n    The algorithm consists of two independent for loops, which perform constant-time operations in each iteration.\n\n-   Space complexity: $O(n)$\n\n    We are creating a copy of the original array to avoid directly modifying the input. However, if modifying the input is permitted (see [Interview Tip](#interview-tip)), the space complexity can be reduced to $O(1)$.\n\n---"
}