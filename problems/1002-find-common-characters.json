{
  "title": "Find Common Characters",
  "problem_id": "1044",
  "frontend_id": "1002",
  "difficulty": "Easy",
  "problem_slug": "find-common-characters",
  "topics": [
    "Array",
    "Hash Table",
    "String"
  ],
  "description": "Given a string array words, return an array of all characters that show up in all strings within the words (including duplicates). You may return the answer in any order.\nExample 1:\nExample 2:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: words = [\"bella\",\"label\",\"roller\"]\nOutput: [\"e\",\"l\",\"l\"]",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input: words = [\"cool\",\"lock\",\"cook\"]\nOutput: [\"c\",\"o\"]",
      "images": []
    }
  ],
  "constraints": [
    "1 <= words.length <= 100",
    "1 <= words[i].length <= 100",
    "words[i] consists of lowercase English letters."
  ],
  "follow_ups": [],
  "hints": [],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    vector<string> commonChars(vector<string>& words) {\n        \n    }\n};",
    "java": "class Solution {\n    public List<String> commonChars(String[] words) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def commonChars(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def commonChars(self, words: List[str]) -> List[str]:\n        ",
    "c": "/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nchar** commonChars(char** words, int wordsSize, int* returnSize) {\n    \n}",
    "csharp": "public class Solution {\n    public IList<string> CommonChars(string[] words) {\n        \n    }\n}",
    "javascript": "/**\n * @param {string[]} words\n * @return {string[]}\n */\nvar commonChars = function(words) {\n    \n};",
    "typescript": "function commonChars(words: string[]): string[] {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param String[] $words\n     * @return String[]\n     */\n    function commonChars($words) {\n        \n    }\n}",
    "swift": "class Solution {\n    func commonChars(_ words: [String]) -> [String] {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun commonChars(words: Array<String>): List<String> {\n        \n    }\n}",
    "dart": "class Solution {\n  List<String> commonChars(List<String> words) {\n    \n  }\n}",
    "golang": "func commonChars(words []string) []string {\n    \n}",
    "ruby": "# @param {String[]} words\n# @return {String[]}\ndef common_chars(words)\n    \nend",
    "scala": "object Solution {\n    def commonChars(words: Array[String]): List[String] = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn common_chars(words: Vec<String>) -> Vec<String> {\n        \n    }\n}",
    "racket": "(define/contract (common-chars words)\n  (-> (listof string?) (listof string?))\n  )",
    "erlang": "-spec common_chars(Words :: [unicode:unicode_binary()]) -> [unicode:unicode_binary()].\ncommon_chars(Words) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec common_chars(words :: [String.t]) :: [String.t]\n  def common_chars(words) do\n    \n  end\nend"
  },
  "solution": "[TOC]\n\n## Solution\n\n---\n\n### Overview\n\nWe need to keep track of the frequencies of the letters in each string, and the frequencies of letters that the different strings have in common. \n\nAny time we have an array of strings and want to track how often each character appears, we should think about a way to efficiently store and update the frequency of the characters as we iterate over the array/string. \n\nHere are some other problems that use this idea: \n\n* [49. Group Anagrams](https://leetcode.com/problems/group-anagrams/description/)\n* [242. Valid Anagram](https://leetcode.com/problems/valid-anagram/description/)\n* [350. Intersection of Two Arrays II](https://leetcode.com/problems/intersection-of-two-arrays-ii/description/)\n\nA common mistake when solving this type of problem is to overlook whether or not we need to track duplicate characters. Example 1 in this problem highlights the need to return the letters that the strings have in common the same number of times they appear in all of the strings. This small detail is easy to miss and can potentially steer you away from the right solution. \n\n---\n\n### Approach: Array + Frequency Intersection\n\n#### Intuition\n\nTo find common characters in `words`, we traverse the array and incrementally accumulate character frequencies of each string as we go. We need to make sure we store both the list of common characters and their counts.  \n\nLet's say we have the list and count of the common characters for the previous strings in `words` up to a certain point. To find the common characters for the next string immediately following this point, we compare this list with the character counts of that next string. We update the list to keep the smaller count for each character, setting the count to zero if the character is absent in the next string.\n\nWe keep the smaller count because it ensures the character is present in all the strings processed so far.\n\n!?!../Documents/1002/slideshow.json:960,540!?!\n\nOne option would be to use a hash set to store the frequencies of the characters for a string, iterating the characters one by one and incrementing their entry in the hash set. Can you think of a more efficient data structure, knowing that all characters of our strings are lowercase English letters? We can solve this problem more efficiently with an array with a fixed size of 26 for each letter of the alphabet. \n\n> Note: This is a very common optimization technique, if you are asked a question in an interview that involves counting the occurrences of characters in a string, clarify the constraints of the characters with the interviewer and adjust your data structure according to that constraint. \n\n#### Algorithm\n\n1. Initialization:\n    - Create a list `commonCharacterCounts` of size `26`, initialized to `0`.\n    - Create a list `currentCharacterCounts` of size `26`, initialized to `0`.\n    - Create an empty list `result`.\n2. Iterate through `words` from left to right:\n    - For the first string in `words`:\n        - For each character in the first string, increment the corresponding position in `commonCharacterCounts`.\n    - For each subsequent word in `words`:\n        - Reset `currentCharacterCounts` to `0`.\n        - For each character in the current word, increment the corresponding position in `currentCharacterCounts`.\n        - For each letter from 'a' to 'z':\n            - Update `commonCharacterCounts` at that letter to be the minimum of its current value and the value in `currentCharacterCounts`.\n3. Collect common characters:\n    - For each letter from 'a' to 'z':\n        - For the number of times indicated by `commonCharacterCounts` at that letter, append the character corresponding to the letter to `result`.\n4. Return the `result` list.\n\n#### Implementation#### Complexity Analysis\n\nLet $n$ be the number of strings in `words`, and $k$ be the average length of the strings in `words`.  \n\n- Time Complexity: $O(n \\cdot k)$\n\n    Initializing the `commonCharacterCounts` array with the characters from the first word takes $O(k)$ time.\n\n    For each of the remaining $n - 1$ words, we count the characters in the current word and update the `commonCharacterCounts` array. \n    \n    Counting characters in each word and updating the `commonCharacterCounts` array both take $O(k)$ time.\n\n    Summing these times across all the strings in `words` gives $O(k + (n - 1) \n    \\cdot k) = O(n \\cdot k)$.\n    \n- Space Complexity: O(1)\n\n    The space used by the `commonCharacterCounts` and `currentCharacterCounts` arrays are constant, as they always have a size of `26` (the number of lowercase English letters).\n\n    Beyond these arrays, the algorithm uses a constant amount of additional space for variables `words_size`, `i`, and `letter`.\n\n    Therefore, the space complexity is O(1).\n\n---"
}