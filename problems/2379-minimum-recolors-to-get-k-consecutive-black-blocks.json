{
  "title": "Minimum Recolors to Get K Consecutive Black Blocks",
  "problem_id": "2463",
  "frontend_id": "2379",
  "difficulty": "Easy",
  "problem_slug": "minimum-recolors-to-get-k-consecutive-black-blocks",
  "topics": [
    "String",
    "Sliding Window"
  ],
  "description": "You are given a 0-indexed string blocks of length n, where blocks[i] is either 'W' or 'B', representing the color of the ith block. The characters 'W' and 'B' denote the colors white and black, respectively.\nYou are also given an integer k, which is the desired number of consecutive black blocks.\nIn one operation, you can recolor a white block such that it becomes a black block.\nReturn the minimum number of operations needed such that there is at least one occurrence of k consecutive black blocks.\nExample 1:\nExample 2:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: blocks = \"WBBWWBBWBW\", k = 7\nOutput: 3\nExplanation:\nOne way to achieve 7 consecutive black blocks is to recolor the 0th, 3rd, and 4th blocks\nso that blocks = \"BBBBBBBWBW\". \nIt can be shown that there is no way to achieve 7 consecutive black blocks in less than 3 operations.\nTherefore, we return 3.",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input: blocks = \"WBWBBBW\", k = 2\nOutput: 0\nExplanation:\nNo changes need to be made, since 2 consecutive black blocks already exist.\nTherefore, we return 0.",
      "images": []
    }
  ],
  "constraints": [
    "n == blocks.length",
    "1 <= n <= 100",
    "blocks[i] is either 'W' or 'B'.",
    "1 <= k <= n"
  ],
  "follow_ups": [],
  "hints": [
    "Iterate through all possible consecutive substrings of k characters.",
    "Find the number of changes for each substring to make all blocks black, and return the minimum of these."
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    int minimumRecolors(string blocks, int k) {\n        \n    }\n};",
    "java": "class Solution {\n    public int minimumRecolors(String blocks, int k) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def minimumRecolors(self, blocks, k):\n        \"\"\"\n        :type blocks: str\n        :type k: int\n        :rtype: int\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def minimumRecolors(self, blocks: str, k: int) -> int:\n        ",
    "c": "int minimumRecolors(char* blocks, int k) {\n    \n}",
    "csharp": "public class Solution {\n    public int MinimumRecolors(string blocks, int k) {\n        \n    }\n}",
    "javascript": "/**\n * @param {string} blocks\n * @param {number} k\n * @return {number}\n */\nvar minimumRecolors = function(blocks, k) {\n    \n};",
    "typescript": "function minimumRecolors(blocks: string, k: number): number {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param String $blocks\n     * @param Integer $k\n     * @return Integer\n     */\n    function minimumRecolors($blocks, $k) {\n        \n    }\n}",
    "swift": "class Solution {\n    func minimumRecolors(_ blocks: String, _ k: Int) -> Int {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun minimumRecolors(blocks: String, k: Int): Int {\n        \n    }\n}",
    "dart": "class Solution {\n  int minimumRecolors(String blocks, int k) {\n    \n  }\n}",
    "golang": "func minimumRecolors(blocks string, k int) int {\n    \n}",
    "ruby": "# @param {String} blocks\n# @param {Integer} k\n# @return {Integer}\ndef minimum_recolors(blocks, k)\n    \nend",
    "scala": "object Solution {\n    def minimumRecolors(blocks: String, k: Int): Int = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn minimum_recolors(blocks: String, k: i32) -> i32 {\n        \n    }\n}",
    "racket": "(define/contract (minimum-recolors blocks k)\n  (-> string? exact-integer? exact-integer?)\n  )",
    "erlang": "-spec minimum_recolors(Blocks :: unicode:unicode_binary(), K :: integer()) -> integer().\nminimum_recolors(Blocks, K) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec minimum_recolors(blocks :: String.t, k :: integer) :: integer\n  def minimum_recolors(blocks, k) do\n    \n  end\nend"
  },
  "solution": "[TOC]\n\n## Solution\n\n---\n\n### Overview\n\nWe are given a string `blocks`, where each character represents a block that is either black ('B') or white ('W') and the ability to apply an operation to change a white block black an unlimited number of times. Our goal is to find the **minimum number of recoloring operations** needed to create a segment of `k` consecutive black blocks. \n\n---\n\n### Approach 1: Queue\n\n#### Intuition\n\nSince existing black blocks don’t require recolors, our required number of operations is determined by the number of white blocks within each segment of `k` consecutive blocks. The fewer white blocks in a segment, the fewer recolors we need. This immediately tells us that our task is to identify the segment of `k` consecutive blocks that contains the fewest white blocks.\n\nWith this foundation in mind, we can now look at example:\n\n!?!../Documents/2379/slideshow.json:960,540!?!\n\n\nNow that we know we must evaluate all segments of length `k`, the natural way to approach this is to start from the beginning of the string, count the number of white blocks in the first `k` characters, and then slide forward one position at a time. For each step, we discard the leftmost character from the previous segment and include the next character from the string, updating our count of white blocks accordingly. This allows us to efficiently track the number of white blocks in each segment without recalculating from scratch every time.\n\nTo manage this process efficiently, we need a data structure that allows us to maintain a fixed-size window of `k` elements while quickly removing the oldest element and adding a new one. A [queue](https://leetcode.com/explore/learn/card/queue-stack/228/first-in-first-out-data-structure/) is well-suited for this task because it follows the First-In-First-Out (FIFO) principle: the oldest element (leftmost in our segment) is removed first when shifting to the next segment, and the newest element is added at the end.\n\nWith this logic, we start by initializing a queue with the first `k` elements and counting the white blocks. As we slide through the string, we remove the first element in the queue and add the next character from the string, adjusting our white block count accordingly. By the end of this process, we will have checked all possible segments of `k` blocks, and we simply return the minimum number of white blocks found.\n\n#### Algorithm\n- Initialize `blockQueue` as a queue to hold `k` consecutive elements.\n- Initialize `numWhites` to 0 to track the current number of white blocks.\n- Iterate through the first `k` elements of `blocks`. \n    - If the current element is white, increase `numWhites` by 1.\n    - Add the current element to `blockQueue`.\n- Initialize `numRecolors` to `numWhites` to represent the minimum number of recolors needed to have `k` consecutive black blocks.\n- Iterate through the remaining elements of `blocks`, starting at index `k`. For each element:\n    - Remove the top element of the queue and decrease `numWhites` by 1 if the top element is white.\n    - Add the current element to `blockQueue` and increase `numWhites` by 1 if the element is white.\n    - Update `numRecolors` to the minimum of `numRecolors` and `numWhites`.\n- Return `numRecolors`.\n\n#### Implementation#### Complexity Analysis\n\nLet $N$ be the length of `blocks` and $M$ be the value of `k`.\n\n* Time Complexity: $O(N)$\n\n    The algorithm iterates through each element of `blocks` exactly once, performing constant-time operations on each element. Specifically in each iteration, it checks and updates `blockQueue` and performs arithmetic operations. Both of these operations are $O(1)$ on average due to the use of a queue and being independent of the input size. Therefore, the overall time complexity is linear to the number of elements in `blocks`, $O(n)$.\n\n    Note: The operations on `blockQueue` (such as `front`, `push`, and `pop`) are considered $O(1)$ on average due to the nature of queues.\n\n* Space Complexity: $O(M)$\n\n    The space complexity is determined by `blockQueue`.\n\n    The algorithm continues adding elements to `blockQueue` until it contains `k` elements. From there, we remove an element from `blockQueue` before adding a new one.\n\n    As a result, the size of `blockQueue` is bound by `k`, leading to an overall space complexity of $O(M)$.\n---\n\n### Approach 2: Sliding Window\n\n#### Intuition\n\nIn the previous approach, we used a queue to manage the elements in the `blocks` array, but this came at the cost of additional space allocation. For each segment of `k` blocks, we had to store up to `k` characters in the queue, resulting in linear space complexity relative to `k`. To avoid this overhead, we need a solution that doesn't require extra space for storing the segments.\n\nWe can achieve this by adopting a **Fixed Sliding Window Approach**. The idea here is to slide a window of size `k` across the array while maintaining two pointers, `left` and `right`, that represent the start and end of the window. By incrementing both pointers together, we can efficiently track and check each segment of size `k` without needing extra space.\n\nTo implement this approach, we start by initializing both `left` and `right` pointers at the beginning of the array. Then, we move the `right` pointer until we have exactly `k` elements in the window, which is the range we’re interested in. Once we’ve captured a window of size `k`, we check how many white blocks are in this segment. \n\nAfter that, we increment both `left` and `right` by one position at each step. This moves the window to the next segment, and we again check how many white blocks are present. We repeat this process until the window has slid across the entire array. \n\nBy the end, we will have checked every possible segment of `k` consecutive blocks. At each step, we can track and update the minimum number of recolors needed. The beauty of this approach is that it allows us to explore all potential segments without the need for any extra space, other than a few variables to track the window and the number of recolors.\n\n#### Algorithm\n\n- Initialize `left` to 0 to act as the left pointer for the sliding window.\n- Initialize `numWhites` to 0 to track the number of white blocks in the current iteration.\n- Initialize `numRecolors` to the maximum integer value to represent the minimum number of recolors needed to have `k` consecutive black blocks.\n- Iterate through the first `k` elements of `blocks`. For each element at index `right`:\n    - If `blocks[right]` is white, increase `numWhites` by 1\n    - If the current window is of size `k`, meaning `right - left + 1` is equal to `k`:\n        - Update `numRecolors` to the minimum of `numRecolors` and `numWhites`.\n        - If `blocks[left]` is white, decrease `numWhites` by 1.\n        - Increase `left` by 1.\n- Return `numRecolors`.\n\n#### Implementation#### Complexity Analysis\n\nLet $N$ be the size of `blocks`.\n\n* Time Complexity: $O(N)$\n\n    The algorithm iterates through each element of `blocks` exactly once, performing constant-time operations on each element. Specificially, in each iteration, it performs arithmetic operations, whose time complexities are independent of the input size. Therefore, the overall time complexity is linear to the number of elements in `blocks`, $O(n)$.\n\n* Space Complexity: $O(1)$\n\n    The space required does not depend on the size of the input value or any data structures that require additional space, so only constant $O(1)$ space is used.\n\n---"
}