{
  "title": "Insertion Sort List",
  "problem_id": "147",
  "frontend_id": "147",
  "difficulty": "Medium",
  "problem_slug": "insertion-sort-list",
  "topics": [
    "Linked List",
    "Sorting"
  ],
  "description": "Given the head of a singly linked list, sort the list using insertion sort, and return the sorted list's head.\nThe steps of the insertion sort algorithm:\nThe following is a graphical example of the insertion sort algorithm. The partially sorted list (black) initially contains only the first element in the list. One element (red) is removed from the input data and inserted in-place into the sorted list with each iteration.\nExample 1:\nExample 2:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: head = [4,2,1,3]\nOutput: [1,2,3,4]",
      "images": [
        "https://assets.leetcode.com/uploads/2021/03/04/sort1linked-list.jpg"
      ]
    },
    {
      "example_num": 2,
      "example_text": "Input: head = [-1,5,3,4,0]\nOutput: [-1,0,3,4,5]",
      "images": [
        "https://assets.leetcode.com/uploads/2021/03/04/sort2linked-list.jpg"
      ]
    }
  ],
  "constraints": [
    "The number of nodes in the list is in the range [1, 5000].",
    "-5000 <= Node.val <= 5000"
  ],
  "follow_ups": [],
  "hints": [],
  "code_snippets": {
    "cpp": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* insertionSortList(ListNode* head) {\n        \n    }\n};",
    "java": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode insertionSortList(ListNode head) {\n        \n    }\n}",
    "python": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def insertionSortList(self, head):\n        \"\"\"\n        :type head: Optional[ListNode]\n        :rtype: Optional[ListNode]\n        \"\"\"\n        ",
    "python3": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def insertionSortList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        ",
    "c": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     struct ListNode *next;\n * };\n */\nstruct ListNode* insertionSortList(struct ListNode* head) {\n    \n}",
    "csharp": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     public int val;\n *     public ListNode next;\n *     public ListNode(int val=0, ListNode next=null) {\n *         this.val = val;\n *         this.next = next;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode InsertionSortList(ListNode head) {\n        \n    }\n}",
    "javascript": "/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar insertionSortList = function(head) {\n    \n};",
    "typescript": "/**\n * Definition for singly-linked list.\n * class ListNode {\n *     val: number\n *     next: ListNode | null\n *     constructor(val?: number, next?: ListNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.next = (next===undefined ? null : next)\n *     }\n * }\n */\n\nfunction insertionSortList(head: ListNode | null): ListNode | null {\n    \n};",
    "php": "/**\n * Definition for a singly-linked list.\n * class ListNode {\n *     public $val = 0;\n *     public $next = null;\n *     function __construct($val = 0, $next = null) {\n *         $this->val = $val;\n *         $this->next = $next;\n *     }\n * }\n */\nclass Solution {\n\n    /**\n     * @param ListNode $head\n     * @return ListNode\n     */\n    function insertionSortList($head) {\n        \n    }\n}",
    "swift": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     public var val: Int\n *     public var next: ListNode?\n *     public init() { self.val = 0; self.next = nil; }\n *     public init(_ val: Int) { self.val = val; self.next = nil; }\n *     public init(_ val: Int, _ next: ListNode?) { self.val = val; self.next = next; }\n * }\n */\nclass Solution {\n    func insertionSortList(_ head: ListNode?) -> ListNode? {\n        \n    }\n}",
    "kotlin": "/**\n * Example:\n * var li = ListNode(5)\n * var v = li.`val`\n * Definition for singly-linked list.\n * class ListNode(var `val`: Int) {\n *     var next: ListNode? = null\n * }\n */\nclass Solution {\n    fun insertionSortList(head: ListNode?): ListNode? {\n        \n    }\n}",
    "dart": "/**\n * Definition for singly-linked list.\n * class ListNode {\n *   int val;\n *   ListNode? next;\n *   ListNode([this.val = 0, this.next]);\n * }\n */\nclass Solution {\n  ListNode? insertionSortList(ListNode? head) {\n    \n  }\n}",
    "golang": "/**\n * Definition for singly-linked list.\n * type ListNode struct {\n *     Val int\n *     Next *ListNode\n * }\n */\nfunc insertionSortList(head *ListNode) *ListNode {\n    \n}",
    "ruby": "# Definition for singly-linked list.\n# class ListNode\n#     attr_accessor :val, :next\n#     def initialize(val = 0, _next = nil)\n#         @val = val\n#         @next = _next\n#     end\n# end\n# @param {ListNode} head\n# @return {ListNode}\ndef insertion_sort_list(head)\n    \nend",
    "scala": "/**\n * Definition for singly-linked list.\n * class ListNode(_x: Int = 0, _next: ListNode = null) {\n *   var next: ListNode = _next\n *   var x: Int = _x\n * }\n */\nobject Solution {\n    def insertionSortList(head: ListNode): ListNode = {\n        \n    }\n}",
    "rust": "// Definition for singly-linked list.\n// #[derive(PartialEq, Eq, Clone, Debug)]\n// pub struct ListNode {\n//   pub val: i32,\n//   pub next: Option<Box<ListNode>>\n// }\n// \n// impl ListNode {\n//   #[inline]\n//   fn new(val: i32) -> Self {\n//     ListNode {\n//       next: None,\n//       val\n//     }\n//   }\n// }\nimpl Solution {\n    pub fn insertion_sort_list(head: Option<Box<ListNode>>) -> Option<Box<ListNode>> {\n        \n    }\n}",
    "racket": "; Definition for singly-linked list:\n#|\n\n; val : integer?\n; next : (or/c list-node? #f)\n(struct list-node\n  (val next) #:mutable #:transparent)\n\n; constructor\n(define (make-list-node [val 0])\n  (list-node val #f))\n\n|#\n\n(define/contract (insertion-sort-list head)\n  (-> (or/c list-node? #f) (or/c list-node? #f))\n  )",
    "erlang": "%% Definition for singly-linked list.\n%%\n%% -record(list_node, {val = 0 :: integer(),\n%%                     next = null :: 'null' | #list_node{}}).\n\n-spec insertion_sort_list(Head :: #list_node{} | null) -> #list_node{} | null.\ninsertion_sort_list(Head) ->\n  .",
    "elixir": "# Definition for singly-linked list.\n#\n# defmodule ListNode do\n#   @type t :: %__MODULE__{\n#           val: integer,\n#           next: ListNode.t() | nil\n#         }\n#   defstruct val: 0, next: nil\n# end\n\ndefmodule Solution do\n  @spec insertion_sort_list(head :: ListNode.t | nil) :: ListNode.t | nil\n  def insertion_sort_list(head) do\n    \n  end\nend"
  },
  "solution": "[TOC]\n\n## Video Solution\n---## Solution Article\n\n---\n\n### Overview\n\n\n[Insertion sort](https://en.wikipedia.org/wiki/Insertion_sort) is an intuitive sorting algorithm, although it is much less efficient than the more advanced algorithms such as quicksort or merge sort.\n\nOften that we perform the sorting algorithm on an [Array](https://leetcode.com/explore/learn/card/fun-with-arrays) structure,\nthis problem though asks us to perform the insertion sort on a **linked list** data structure, which makes the implementation a bit challenging.\n\nIn this article, we will present some tricks to manipulate the linked list, which would help us to simplify the logics of implementation.\n\n\n---\n\n### Approach 1: Insertion Sort\n\n#### Intuition\n\nLet us first review the idea of insertion sort algorithm, which can be broke down into the following steps:\n\n- First of all, we create an empty list which would be used to hold the results of sorting.\n\n- We then iterate through each element in the _input_ list. For each element, we need to find a proper position in the resulting list to insert the element, so that the order of the resulting list is maintained.\n\n- As one can see, once the iteration in the above step terminates, we will obtain the resulting list where the elements are _ordered_.\n\nNow, let us walk through a simple example, by applying the above intuition.\n\nGiven the input list `input=[4, 3, 5]`, we have initially an empty resulting list `result=[]`.\n\n- We then iterate over the input list. For the first element `4`, we need to find a proper position in the resulting list to place it.\nSince the resulting list is still empty, we then simply _append_ it to the resulting list, _i.e._ `result=[4]`.\n\n![step 1](../Figures/147/147_linked_list_step_1.png)\n\n- Now for the second element (_i.e._ `3`) in the input list, similarly we need to insert it properly into the resulting list.\nAs one can see, we need to insert it right before the element `4`.\nAs a result, the resulting list becomes `[3, 4]`.\n\n![step 2](../Figures/147/147_linked_list_step_2.png)\n\n- Finally, for the last element (_i.e._ `5`) in the input list, as it turns out, the proper position to place it is the _tail_ of the resulting list.\nWith this last iteration, we obtain a _sorted_ list as `result=[3, 4, 5]`.\n\n![step 3](../Figures/147/147_linked_list_step_3.png)\n\n\n#### Algorithm\n\nTo translate the above intuition into the implementation, we applied two **tricks**.\n\n>The first trick is that we will create a `dummy` (`pseudo_head`) node which serves as a pointer pointing to the resulting list.\n\nMore precisely, this node facilitates us to always get a _hold_ on the resulting list, especially when we need to insert a new element to the head of the resulting list.\nOne will see later in more details how it can greatly simplify the logic.\n\nIn a _singly-linked list_, each node has only one pointer that points to the next node.\nIf we would like to insert a new node (say `B`) before certain node (say `A`), we need to know the node (say `C`) that is currently before the node `A`, _i.e._ `C -> A`.\nWith the reference in the node `C`, we could now insert the new node, _i.e._ `C -> B -> A`.\n\nGiven the above insight, in order to insert a new element into a singly-linked list, we apply another trick.\n\n>The idea is that we use a _**pair of pointers**_ (namely `prev -> next`) which serve as place-holders to guard the position where in-between we would insert a new element (_i.e._ `prev -> new_node -> next`).\n\nWith the same example before, _i.e._ `input=[4, 3, 5]`, we illustrate what the above helper pointers look like at the moment of insertion, in the following graph:\n\n![pointers](../Figures/147/147_pointers.png)\n\n#### Implementation\n\nHere are some sample implementations based on the above ideas:#### Complexity Analysis\n\nLet $N$ be the number of elements in the input list.\n\n- Time Complexity: $\\mathcal{O}(N^2)$\n\n    - First of all, we run an iteration over the input list.\n\n    - At each iteration, we insert an element into the resulting list. In the worst case where the position to insert is the tail of the list, we have to walk through the entire resulting list.\n\n    - As a result, the total steps that we need to walk in the worst case would be $\\sum_{i=1}^{N} i = \\frac{N(N+1)}{2}$.\n\n    - To sum up, the overall time complexity of the algorithm is $\\mathcal{O}(N^2)$.\n\n\n- Space Complexity: $\\mathcal{O}(1)$\n\n    - We used some pointers within the algorithm. However, their memory consumption is constant regardless of the input.\n\n    - **Note**, we did not create new nodes to hold the values of input list, but simply _reorder_ the existing nodes.\n\n\n---"
}