{
  "title": "Coin Change",
  "problem_id": "322",
  "frontend_id": "322",
  "difficulty": "Medium",
  "problem_slug": "coin-change",
  "topics": [
    "Array",
    "Dynamic Programming",
    "Breadth-First Search"
  ],
  "description": "You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money.\nReturn the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.\nYou may assume that you have an infinite number of each kind of coin.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: coins = [1,2,5], amount = 11\nOutput: 3\nExplanation: 11 = 5 + 5 + 1",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input: coins = [2], amount = 3\nOutput: -1",
      "images": []
    },
    {
      "example_num": 3,
      "example_text": "Input: coins = [1], amount = 0\nOutput: 0",
      "images": []
    }
  ],
  "constraints": [
    "1 <= coins.length <= 12",
    "1 <= coins[i] <= 231 - 1",
    "0 <= amount <= 104"
  ],
  "follow_ups": [],
  "hints": [],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    int coinChange(vector<int>& coins, int amount) {\n        \n    }\n};",
    "java": "class Solution {\n    public int coinChange(int[] coins, int amount) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def coinChange(self, coins, amount):\n        \"\"\"\n        :type coins: List[int]\n        :type amount: int\n        :rtype: int\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        ",
    "c": "int coinChange(int* coins, int coinsSize, int amount) {\n    \n}",
    "csharp": "public class Solution {\n    public int CoinChange(int[] coins, int amount) {\n        \n    }\n}",
    "javascript": "/**\n * @param {number[]} coins\n * @param {number} amount\n * @return {number}\n */\nvar coinChange = function(coins, amount) {\n    \n};",
    "typescript": "function coinChange(coins: number[], amount: number): number {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param Integer[] $coins\n     * @param Integer $amount\n     * @return Integer\n     */\n    function coinChange($coins, $amount) {\n        \n    }\n}",
    "swift": "class Solution {\n    func coinChange(_ coins: [Int], _ amount: Int) -> Int {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun coinChange(coins: IntArray, amount: Int): Int {\n        \n    }\n}",
    "dart": "class Solution {\n  int coinChange(List<int> coins, int amount) {\n    \n  }\n}",
    "golang": "func coinChange(coins []int, amount int) int {\n    \n}",
    "ruby": "# @param {Integer[]} coins\n# @param {Integer} amount\n# @return {Integer}\ndef coin_change(coins, amount)\n    \nend",
    "scala": "object Solution {\n    def coinChange(coins: Array[Int], amount: Int): Int = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn coin_change(coins: Vec<i32>, amount: i32) -> i32 {\n        \n    }\n}",
    "racket": "(define/contract (coin-change coins amount)\n  (-> (listof exact-integer?) exact-integer? exact-integer?)\n  )",
    "erlang": "-spec coin_change(Coins :: [integer()], Amount :: integer()) -> integer().\ncoin_change(Coins, Amount) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec coin_change(coins :: [integer], amount :: integer) :: integer\n  def coin_change(coins, amount) do\n    \n  end\nend"
  }
}