{
  "title": "Reverse Pairs",
  "problem_id": "493",
  "frontend_id": "493",
  "difficulty": "Hard",
  "problem_slug": "reverse-pairs",
  "topics": [
    "Array",
    "Binary Search",
    "Divide and Conquer",
    "Binary Indexed Tree",
    "Segment Tree",
    "Merge Sort",
    "Ordered Set"
  ],
  "description": "Given an integer array nums, return the number of reverse pairs in the array.\nA reverse pair is a pair (i, j) where:\nExample 1:\nExample 2:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: nums = [1,3,2,3,1]\nOutput: 2\nExplanation: The reverse pairs are:\n(1, 4) --> nums[1] = 3, nums[4] = 1, 3 > 2 * 1\n(3, 4) --> nums[3] = 3, nums[4] = 1, 3 > 2 * 1",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input: nums = [2,4,3,5,1]\nOutput: 3\nExplanation: The reverse pairs are:\n(1, 4) --> nums[1] = 4, nums[4] = 1, 4 > 2 * 1\n(2, 4) --> nums[2] = 3, nums[4] = 1, 3 > 2 * 1\n(3, 4) --> nums[3] = 5, nums[4] = 1, 5 > 2 * 1",
      "images": []
    }
  ],
  "constraints": [
    "1 <= nums.length <= 5 * 104",
    "-231 <= nums[i] <= 231 - 1"
  ],
  "follow_ups": [],
  "hints": [
    "Use the merge-sort technique.",
    "Divide the array into two parts and sort them.",
    "For each integer in the first part, count the number of integers that satisfy the condition from the second part. Use the pointer to help you in the counting process."
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    int reversePairs(vector<int>& nums) {\n        \n    }\n};",
    "java": "class Solution {\n    public int reversePairs(int[] nums) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def reversePairs(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def reversePairs(self, nums: List[int]) -> int:\n        ",
    "c": "int reversePairs(int* nums, int numsSize) {\n    \n}",
    "csharp": "public class Solution {\n    public int ReversePairs(int[] nums) {\n        \n    }\n}",
    "javascript": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar reversePairs = function(nums) {\n    \n};",
    "typescript": "function reversePairs(nums: number[]): number {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @return Integer\n     */\n    function reversePairs($nums) {\n        \n    }\n}",
    "swift": "class Solution {\n    func reversePairs(_ nums: [Int]) -> Int {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun reversePairs(nums: IntArray): Int {\n        \n    }\n}",
    "dart": "class Solution {\n  int reversePairs(List<int> nums) {\n    \n  }\n}",
    "golang": "func reversePairs(nums []int) int {\n    \n}",
    "ruby": "# @param {Integer[]} nums\n# @return {Integer}\ndef reverse_pairs(nums)\n    \nend",
    "scala": "object Solution {\n    def reversePairs(nums: Array[Int]): Int = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn reverse_pairs(nums: Vec<i32>) -> i32 {\n        \n    }\n}",
    "racket": "(define/contract (reverse-pairs nums)\n  (-> (listof exact-integer?) exact-integer?)\n  )",
    "erlang": "-spec reverse_pairs(Nums :: [integer()]) -> integer().\nreverse_pairs(Nums) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec reverse_pairs(nums :: [integer]) :: integer\n  def reverse_pairs(nums) do\n    \n  end\nend"
  }
}