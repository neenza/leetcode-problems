{
  "title": "Take Gifts From the Richest Pile",
  "problem_id": "2692",
  "frontend_id": "2558",
  "difficulty": "Easy",
  "problem_slug": "take-gifts-from-the-richest-pile",
  "topics": [
    "Array",
    "Heap (Priority Queue)",
    "Simulation"
  ],
  "description": "You are given an integer array gifts denoting the number of gifts in various piles. Every second, you do the following:\nReturn the number of gifts remaining after k seconds.\nExample 1:\nExample 2:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: gifts = [25,64,9,4,100], k = 4\nOutput: 29\nExplanation: \nThe gifts are taken in the following way:\n- In the first second, the last pile is chosen and 10 gifts are left behind.\n- Then the second pile is chosen and 8 gifts are left behind.\n- After that the first pile is chosen and 5 gifts are left behind.\n- Finally, the last pile is chosen again and 3 gifts are left behind.\nThe final remaining gifts are [5,8,9,4,3], so the total number of gifts remaining is 29.",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input: gifts = [1,1,1,1], k = 4\nOutput: 4\nExplanation: \nIn this case, regardless which pile you choose, you have to leave behind 1 gift in each pile. \nThat is, you can't take any pile with you. \nSo, the total gifts remaining are 4.",
      "images": []
    }
  ],
  "constraints": [
    "1 <= gifts.length <= 103",
    "1 <= gifts[i] <= 109",
    "1 <= k <= 103"
  ],
  "follow_ups": [],
  "hints": [
    "How can you keep track of the largest gifts in the array",
    "What is an efficient way to find the square root of a number?",
    "Can you keep adding up the values of the gifts while ensuring they are in a certain order?",
    "Can we use a priority queue or heap here?"
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    long long pickGifts(vector<int>& gifts, int k) {\n        \n    }\n};",
    "java": "class Solution {\n    public long pickGifts(int[] gifts, int k) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def pickGifts(self, gifts, k):\n        \"\"\"\n        :type gifts: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def pickGifts(self, gifts: List[int], k: int) -> int:\n        ",
    "c": "long long pickGifts(int* gifts, int giftsSize, int k) {\n    \n}",
    "csharp": "public class Solution {\n    public long PickGifts(int[] gifts, int k) {\n        \n    }\n}",
    "javascript": "/**\n * @param {number[]} gifts\n * @param {number} k\n * @return {number}\n */\nvar pickGifts = function(gifts, k) {\n    \n};",
    "typescript": "function pickGifts(gifts: number[], k: number): number {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param Integer[] $gifts\n     * @param Integer $k\n     * @return Integer\n     */\n    function pickGifts($gifts, $k) {\n        \n    }\n}",
    "swift": "class Solution {\n    func pickGifts(_ gifts: [Int], _ k: Int) -> Int {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun pickGifts(gifts: IntArray, k: Int): Long {\n        \n    }\n}",
    "dart": "class Solution {\n  int pickGifts(List<int> gifts, int k) {\n    \n  }\n}",
    "golang": "func pickGifts(gifts []int, k int) int64 {\n    \n}",
    "ruby": "# @param {Integer[]} gifts\n# @param {Integer} k\n# @return {Integer}\ndef pick_gifts(gifts, k)\n    \nend",
    "scala": "object Solution {\n    def pickGifts(gifts: Array[Int], k: Int): Long = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn pick_gifts(gifts: Vec<i32>, k: i32) -> i64 {\n        \n    }\n}",
    "racket": "(define/contract (pick-gifts gifts k)\n  (-> (listof exact-integer?) exact-integer? exact-integer?)\n  )",
    "erlang": "-spec pick_gifts(Gifts :: [integer()], K :: integer()) -> integer().\npick_gifts(Gifts, K) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec pick_gifts(gifts :: [integer], k :: integer) :: integer\n  def pick_gifts(gifts, k) do\n    \n  end\nend"
  },
  "solution": "[TOC]\n\n## Solution\n\n---\n\n### Overview\n\nWe are given an integer array `gifts`, where the $i^{th}$ element represents a pile with `gifts[i]` gifts. We are also given an integer `k`, which is equal to the number of times we should perform the following operation:\n\n1. Find the pile with the most gifts (i.e., the maximum element in the `gifts` array).\n2. Replace the number of gifts in that pile with its square root rounded down to the nearest integer (i.e., the *floor* of its square root).\n\nIn the end, we should return the total number of gifts remaining, which is the sum of the elements of the array after performing all `k` operations.\n\n> **Floor operation**: The *floor* of a number $x$, denoted as $\\lfloor x \\rfloor$, is the greatest integer that is less than or equal to $x$.\n> For example, $\\lfloor 4.3 \\rfloor = 4$, $\\lfloor -4.3 \\rfloor = -5$.\n> In most programming languages (including C/C++, Java, and Python), typecasting a **positive** floating-point number to an integer gives the same result as using the floor function. This is because typecasting simply removes the decimal part.\n\n---\n\n### Approach 1: Brute Force\n\n#### Intuition\n\nIn this approach, we will directly follow the steps outlined in the problem. We will iterate through the array `k` times. On each iteration, we will find the maximum element and replace it with its square root rounded down to the nearest integer. Then, we will iterate over the array one more time to calculate the sum of its elements (i.e., the total number of the remaining gifts).\n\n###### 1. Usage of built-in functions\n\nMost modern programming languages, such as C++, Java, and Python, provide built-in functions to perform common operations like finding the maximum value or summing the elements of an array. These built-in functions are optimized for ease of use but typically have the same time complexity as a basic, manual implementation. We will explain the more generic, step-by-step operations for these in the Algorithm section below.\n\n###### 2. Modifying the input\n\nIn this problem, it is convenient to perform the given operation directly on the input data rather than copying it to save space. However, sometimes this can cause problems. Here are a few cases where in-place algorithms might not be suitable:\n\n-   The algorithm needs to run in a multi-threaded environment, where other threads might need to read the array as well and may not expect it to be modified.\n-   Even if there is only a single thread, the array may need to be reused later, and its content should remain unchanged.\n\n> **Interview Tip**: During an interview, always check with the interviewer if overwriting the input is acceptable, and be prepared to discuss the pros and cons of doing so!\n\n#### Algorithm\n\n-   Initialize `n` as the size of the `gifts` array.\n-   Repeat the following `k` times:\n    -   Initialize `richestPileIndex` to `0`.\n    -   Iterate over the array with `currentPileIndex` from `0` to `n - 1`:\n        -   If `gifts[richestPileIndex] < gifts[currentPileIndex]`, update `richestPileIndex` to `currentPileIndex`.\n    -   Update the value at `richestPileIndex` by setting it to the floor of its square root, i.e., `floor(sqrt(gifts[richestPileIndex]))`.\n-   Initialize `numberOfRemaningGifts` to `0`.\n-   Loop through the `gifts` with `i` from `0` to `n - 1`:\n    -   On each iteration, add `gifts[i]` to `numberOfRemaningGifts`.\n-   Return `numberOfRemaningGifts`.\n\n#### Implementation#### Complexity Analysis\n\nLet $n$ be the size of the `gifts` array.\n\n-   Time complexity: $O(k \\times n)$\n\n    We use two nested for loops: the outer loop runs $k$ times, and the inner loop runs $n$ times. After the loops, summing the array values requires an additional pass through the array, which adds an extra $O(n)$ complexity. However, the overall time complexity remains $O(k \\times n) + O(n) = O(k \\times n)$.\n\n-   Space complexity: $O(1)$\n\n    If we are allowed to modify the input, we can apply the operations directly on it, requiring only a constant amount of extra space. However, if we need to create a copy of the input, the space complexity would increase to $O(n)$.\n\n---\n\n### Approach 2: Sorted Array\n\n#### Intuition\n\nWhile trying to improve the previous approach, we realize that its main bottleneck is the operation of finding the maximum value during each step. For this next approach, instead of scanning the array each time, we maintain the array in sorted order, allowing us to access the maximum element in constant time (it’s always the last element).\n\nBy sorting the array initially, we can quickly access the largest element at the first step. After that, we replace it with its square root. The challenge is to keep the array sorted after this modification. To do so, we need to figure out the right spot for the square root. This is where the *upper-bound function* comes in—it helps us find the first position in the array where the square root is strictly less than the next element. We then insert the square root in this position, ensuring the array remains in sorted order.\n\nMost programming languages provide built-in functions for the upper-bound operation. For example, C++ has `upper_bound`, Java offers `binary_search` or the `TreeSet` data structure, and Python uses `next`. These functions are typically implemented using binary search, making them efficient for finding the insertion point in a sorted container.\n\n!?!../Documents/2558/2558_second_approach.json:960,540!?!\n\n> In this approach, we will treat the input as read-only and work with a copy of it.\n\n#### Algorithm\n\n-   Initialize `n` as the size of the `gifts` array.\n-   Create a copy of the `gifts` array, called `sortedGifts` and sort it.\n-   Repeat the following `k` times:\n    -   Set `maxElement` to `sortedGifts[n - 1]` (the last element).\n    -   Remove the last element of `sortedGifts`.\n    -   Find the correct position for the square root of `maxElement` using the upper bound function, and store it in `spotOfSqrt`.\n    -   Insert `floor(sqrt(maxElement))` at `spotOfSqrt` in the `sortedGifts` array.\n-   Initialize `numberOfRemaningGifts` to `0`.\n-   Loop through the `gifts` with `i` from `0` to `n - 1`:\n    -   On each iteration, add `gifts[i]` to `numberOfRemaningGifts`.\n-   Return `numberOfRemaningGifts`.\n\n#### Implementation#### Complexity Analysis\n\nLet $n$ be the size of the `gifts` array.\n\n-   Time complexity: $O(k \\times (n + \\log n ))$\n\n    At each step, we use the upper bound function to find the correct position for the square root of the maximum element. This function is implemented using binary search, so its time complexity is $O(\\log n)$. Additionally, we insert a value into the array at the correct position, which has a time complexity of $O(n)$, because all elements after the insertion point need to be shifted to the right. Since we are performing $k$ operations in total, the overall time complexity becomes $O(k \\times (n + \\log n))$.\n\n-   Space complexity: $O(n)$\n\n    Here, we avoid modifying the input directly by creating an array, `sortedGifts`, of size $n$. However, if we were allowed to modify the input in place, the space complexity could be reduced to $O(1)$.\n\n---\n\n### Approach 3: Heap\n\n#### Intuition\n\nEven though the second approach makes it faster to find the maximum element, it ends up being slower overall. Why? Probably because we’re putting too much effort into keeping the whole array sorted, when all we really need is quick access to the maximum element. This is where a max-heap (or priority queue) can help.\n\nTo solve the problem, we’ll start by creating a max-heap with all the elements from the `gifts` array. Then, for each operation, we’ll remove the maximum element, take the floor of its square root, and add it back to the heap. Finally, we will add up all the values left in the heap and return the result.\n\n> For a more comprehensive understanding of heaps and priority queues, check out the [Heap Explore Card 🔗](https://leetcode.com/explore/learn/card/heap/). This resource offers an in-depth look at heap-based algorithms, explaining their key concepts and applications with a variety of problems to solidify understanding of the pattern.\n\n#### Algorithm\n\n-   Initialize a priority queue (max-heap) with all the elements of the `gifts` array, called `giftsHeap`.\n-   Repeat the following `k` times:\n    -   Set `maxElement` to the top element of the `giftsHeap`.\n    -   Pop the top element of the `giftsHeap`.\n    -   Push `floor(sqrt(maxElement))` into the `giftsHeap`.\n-   Initialize `numberOfRemaningGifts` to `0`.\n-   While the `giftsHeap` is not empty:\n    -   Add the top element to `numberOfRemaningGifts` and pop it from the `giftsHeap`.\n-   Return `numberOfRemaningGifts`.\n\n#### Implementation#### Complexity Analysis\n\nLet $n$ be the size of the `gifts` array.\n\n-   Time complexity: $O(n + k \\times \\log n)$\n\n    The initialization of the heap requires $O(n)$ time. On each step, we pop the maximum element and push the square root of that element back into the heap. Both operations (pop and push) have a time complexity of $O(\\log n)$ because a heap is a balanced binary tree. Since we perform this operation $k$ times, the overall time complexity is $O(n + k \\times \\log n)$.\n\n-   Space complexity: $O(n)$\n\n    The space complexity is $O(n)$ since the heap contains exactly $n$ elements.\n\n---"
}