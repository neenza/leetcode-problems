{
  "title": "Network Recovery Pathways",
  "problem_id": "3919",
  "frontend_id": "3620",
  "difficulty": "Hard",
  "problem_slug": "network-recovery-pathways",
  "topics": [
    "Array",
    "Binary Search",
    "Dynamic Programming",
    "Graph",
    "Topological Sort",
    "Heap (Priority Queue)",
    "Shortest Path"
  ],
  "description": "You are given a directed acyclic graph of n nodes numbered from 0 to n − 1. This is represented by a 2D array edges of length m, where edges[i] = [ui, vi, costi] indicates a one‑way communication from node ui to node vi with a recovery cost of costi.\nSome nodes may be offline. You are given a boolean array online where online[i] = true means node i is online. Nodes 0 and n − 1 are always online.\nA path from 0 to n − 1 is valid if:\nFor each valid path, define its score as the minimum edge‑cost along that path.\nReturn the maximum path score (i.e., the largest minimum-edge cost) among all valid paths. If no valid path exists, return -1.\nExample 1:\nExample 2:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: edges = [[0,1,5],[1,3,10],[0,2,3],[2,3,4]], online = [true,true,true,true], k = 10\nOutput: 3\nExplanation:\n\nThe graph has two possible routes from node 0 to node 3:\nPath 0 → 1 → 3\nTotal cost = 5 + 10 = 15 , which exceeds k ( 15 > 10 ), so this path is invalid.\nPath 0 → 2 → 3\nTotal cost = 3 + 4 = 7 <= k , so this path is valid.\nThe minimum edge‐cost along this path is min(3, 4) = 3 .\nThere are no other valid paths. Hence, the maximum among all valid path‐scores is 3.",
      "images": [
        "https://assets.leetcode.com/uploads/2025/06/06/graph-10.png"
      ]
    },
    {
      "example_num": 2,
      "example_text": "Input: edges = [[0,1,7],[1,4,5],[0,2,6],[2,3,6],[3,4,2],[2,4,6]], online = [true,true,true,false,true], k = 12\nOutput: 6\nExplanation:\n\nNode 3 is offline, so any path passing through 3 is invalid.\nConsider the remaining routes from 0 to 4:\nPath 0 → 1 → 4\nTotal cost = 7 + 5 = 12 <= k , so this path is valid.\nThe minimum edge‐cost along this path is min(7, 5) = 5 .\nPath 0 → 2 → 3 → 4\nNode 3 is offline, so this path is invalid regardless of cost.\nPath 0 → 2 → 4\nTotal cost = 6 + 6 = 12 <= k , so this path is valid.\nThe minimum edge‐cost along this path is min(6, 6) = 6 .\nAmong the two valid paths, their scores are 5 and 6. Therefore, the answer is 6.",
      "images": [
        "https://assets.leetcode.com/uploads/2025/06/06/graph-11.png"
      ]
    }
  ],
  "constraints": [
    "n == online.length",
    "2 <= n <= 5 * 104",
    "0 <= m == edges.length <= min(105, n * (n - 1) / 2)",
    "edges[i] = [ui, vi, costi]",
    "0 <= ui, vi < n",
    "ui != vi",
    "0 <= costi <= 109",
    "0 <= k <= 5 * 1013",
    "online[i] is either true or false, and both online[0] and online[n − 1] are true.",
    "The given graph is a directed acyclic graph."
  ],
  "follow_ups": [],
  "hints": [
    "Use binary search on <code>ans</code>.",
    "Check if a particular <code>ans</code> is possible by including only the edges with weights ≥ <code>mid</code> (the current binary‐search pivot).",
    "Implement the check function using either <code>Dijkstra</code> or DP (via topological sorting, since the graph is a DAG)."
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    int findMaxPathScore(vector<vector<int>>& edges, vector<bool>& online, long long k) {\n        \n    }\n};",
    "java": "class Solution {\n    public int findMaxPathScore(int[][] edges, boolean[] online, long k) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def findMaxPathScore(self, edges, online, k):\n        \"\"\"\n        :type edges: List[List[int]]\n        :type online: List[bool]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def findMaxPathScore(self, edges: List[List[int]], online: List[bool], k: int) -> int:\n        ",
    "c": "int findMaxPathScore(int** edges, int edgesSize, int* edgesColSize, bool* online, int onlineSize, long long k) {\n    \n}",
    "csharp": "public class Solution {\n    public int FindMaxPathScore(int[][] edges, bool[] online, long k) {\n        \n    }\n}",
    "javascript": "/**\n * @param {number[][]} edges\n * @param {boolean[]} online\n * @param {number} k\n * @return {number}\n */\nvar findMaxPathScore = function(edges, online, k) {\n    \n};",
    "typescript": "function findMaxPathScore(edges: number[][], online: boolean[], k: number): number {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param Integer[][] $edges\n     * @param Boolean[] $online\n     * @param Integer $k\n     * @return Integer\n     */\n    function findMaxPathScore($edges, $online, $k) {\n        \n    }\n}",
    "swift": "class Solution {\n    func findMaxPathScore(_ edges: [[Int]], _ online: [Bool], _ k: Int) -> Int {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun findMaxPathScore(edges: Array<IntArray>, online: BooleanArray, k: Long): Int {\n        \n    }\n}",
    "dart": "class Solution {\n  int findMaxPathScore(List<List<int>> edges, List<bool> online, int k) {\n    \n  }\n}",
    "golang": "func findMaxPathScore(edges [][]int, online []bool, k int64) int {\n    \n}",
    "ruby": "# @param {Integer[][]} edges\n# @param {Boolean[]} online\n# @param {Integer} k\n# @return {Integer}\ndef find_max_path_score(edges, online, k)\n    \nend",
    "scala": "object Solution {\n    def findMaxPathScore(edges: Array[Array[Int]], online: Array[Boolean], k: Long): Int = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn find_max_path_score(edges: Vec<Vec<i32>>, online: Vec<bool>, k: i64) -> i32 {\n        \n    }\n}",
    "racket": "(define/contract (find-max-path-score edges online k)\n  (-> (listof (listof exact-integer?)) (listof boolean?) exact-integer? exact-integer?)\n  )",
    "erlang": "-spec find_max_path_score(Edges :: [[integer()]], Online :: [boolean()], K :: integer()) -> integer().\nfind_max_path_score(Edges, Online, K) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec find_max_path_score(edges :: [[integer]], online :: [boolean], k :: integer) :: integer\n  def find_max_path_score(edges, online, k) do\n    \n  end\nend"
  }
}