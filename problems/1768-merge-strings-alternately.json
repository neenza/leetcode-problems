{
  "title": "Merge Strings Alternately",
  "problem_id": "1894",
  "frontend_id": "1768",
  "difficulty": "Easy",
  "problem_slug": "merge-strings-alternately",
  "topics": [
    "Two Pointers",
    "String"
  ],
  "description": "You are given two strings word1 and word2. Merge the strings by adding letters in alternating order, starting with word1. If a string is longer than the other, append the additional letters onto the end of the merged string.\nReturn the merged string.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: word1 = \"abc\", word2 = \"pqr\"\r\nOutput: \"apbqcr\"\r\nExplanation: The merged string will be merged as so:\r\nword1:  a   b   c\r\nword2:    p   q   r\r\nmerged: a p b q c r",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input: word1 = \"ab\", word2 = \"pqrs\"\r\nOutput: \"apbqrs\"\r\nExplanation: Notice that as word2 is longer, \"rs\" is appended to the end.\r\nword1:  a   b \r\nword2:    p   q   r   s\r\nmerged: a p b q   r   s",
      "images": []
    },
    {
      "example_num": 3,
      "example_text": "Input: word1 = \"abcd\", word2 = \"pq\"\r\nOutput: \"apbqcd\"\r\nExplanation: Notice that as word1 is longer, \"cd\" is appended to the end.\r\nword1:  a   b   c   d\r\nword2:    p   q \r\nmerged: a p b q c   d",
      "images": []
    }
  ],
  "constraints": [
    "1 <= word1.length, word2.length <= 100",
    "word1 and word2 consist of lowercase English letters."
  ],
  "follow_ups": [],
  "hints": [
    "Use two pointers, one pointer for each string. Alternately choose the character from each pointer, and move the pointer upwards."
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    string mergeAlternately(string word1, string word2) {\n        \n    }\n};",
    "java": "class Solution {\n    public String mergeAlternately(String word1, String word2) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def mergeAlternately(self, word1, word2):\n        \"\"\"\n        :type word1: str\n        :type word2: str\n        :rtype: str\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def mergeAlternately(self, word1: str, word2: str) -> str:\n        ",
    "c": "\n\nchar * mergeAlternately(char * word1, char * word2){\n\n}",
    "csharp": "public class Solution {\n    public string MergeAlternately(string word1, string word2) {\n        \n    }\n}",
    "javascript": "/**\n * @param {string} word1\n * @param {string} word2\n * @return {string}\n */\nvar mergeAlternately = function(word1, word2) {\n    \n};",
    "typescript": "function mergeAlternately(word1: string, word2: string): string {\n\n};",
    "php": "class Solution {\n\n    /**\n     * @param String $word1\n     * @param String $word2\n     * @return String\n     */\n    function mergeAlternately($word1, $word2) {\n        \n    }\n}",
    "swift": "class Solution {\n    func mergeAlternately(_ word1: String, _ word2: String) -> String {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun mergeAlternately(word1: String, word2: String): String {\n        \n    }\n}",
    "golang": "func mergeAlternately(word1 string, word2 string) string {\n    \n}",
    "ruby": "# @param {String} word1\n# @param {String} word2\n# @return {String}\ndef merge_alternately(word1, word2)\n    \nend",
    "scala": "object Solution {\n    def mergeAlternately(word1: String, word2: String): String = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn merge_alternately(word1: String, word2: String) -> String {\n        \n    }\n}",
    "racket": "(define/contract (merge-alternately word1 word2)\n  (-> string? string? string?)\n\n  )"
  },
  "solution": "[TOC]\n\n## Video Solution\n\n---## Solution\n\n---\n\n### Overview\n\nWe are given two strings `word1` and `word2`. \n\nOur task is to merge the strings by adding letters in alternating order, starting with `word1`. If one string is longer than the other, the additional letters must be appended to the end of the merged string.\n\nWe must return the merged string that has been formed.\n\n---\n\n### Approach 1: Two Pointers\n\n#### Intuition\n\nThere are numerous ways in which we can combine the given strings. We've covered a few of them in this article.\n\nAn intuitive method is to use two pointers to iterate over both strings. Assume we have two pointers, `i` and `j`, with `i` pointing to the first letter of `word1` and `j` pointing to the first letter of `word2`. We also create an empty string `result` to store the outcome.\n\nWe append the letter pointed to by pointer `i` i.e., `word1[i]`, and increment `i` by `1` to point to the next letter of `word1`. Because we need to add the letters in alternating order, next we append `word2[j]` to `result`. We also increase `j` by `1`.\n\nWe continue iterating over the given strings until both are exhausted. We stop appending letters from `word1` when `i` reaches the end of `word1`, and we stop appending letters from `word2'` when `j` reaches the end of `word2`.\n\nHere's a visual representation of how the approach works in the second example given in the problem description:\n\n!?!../Documents/1768/1768-slides.json:601,301!?!\n\n#### Algorithm\n\n1. Create two variables, `m` and `n`, to store the length of `word1` and `word2`.\n2. Create an empty string variable `result` to store the result of merged words.\n3. Create two pointers, `i` and `j` to point to indices of `word1` and `word2`. We initialize both of them to `0`.\n4. While `i < m || j < n`:\n    - If `i < m`, it means that we have not completely traversed `word1`. As a result, we append `word1[i]` to `result`. We increment `i` to point to next index of `word1`.\n    - If `j < n`, it means that we have not completely traversed `word2`. As a result, we append `word2[j]` to `result`. We increment `j` to point to next index of `word2`.\n5. Return `result`.\n\nIt is important to note how we form the `result` string in the following codes:\n    - `cpp`: The strings are mutable in cpp, which means they can be changed. As a result, we used the `string` variable and performed all operations on it. It takes constant time to append a character to the string.\n    - `java`: The `String` class is immutable in java. So we used the mutable `StringBuilder` to concatenate letters to `result`.\n    - `python`: Strings are immutable in python as well. As a result, we used the list `result` to append letters and later joined the list with an empty string to return it as a string object. The `join` operation takes linear time equal to the length of `result` to merge `result` with empty string. \n\n#### Implementation#### Complexity Analysis\n\nHere, $m$ is the length of `word1` and $n$ is the length of `word2`.\n\n* Time complexity: $O(m + n)$\n\n    - We iterate over `word1` and `word2` once and push their letters into `result`. It would take $O(m + n)$ time.\n\n* Space complexity: $O(1)$ or $O(m + n)$\n\n    - Without considering the space consumed by the input strings (`word1` and `word2`) and the output string (`result`), we do not use more than constant space.\n\n> In Java, the `StringBuilder` requires $O(n + m)$ space to store the merged result. Thus, while auxiliary space is $O(1)$, total space complexity is $O(n + m)$.\n\n---\n\n### Approach 2: One Pointer\n\n#### Intuition\n\nTo merge the given words, we can also use a single pointer.\n\nLet `i` be the pointer that we'll use. We begin with `i = 0` and progress to the size of the longer word between `word1` and `word2`, i.e., till `i = max(word1.length(), word2.length())`.\n\nAs we progress to the size of a longer word, we check each time if `i` points to an index that is in bounds of the words or not. If `i < word1.length()`, we append `word1[i]` to `result`. Similarly if `i < word2.length()`, we append `word2[i]` to results. \n\nHowever, if `i` exceeds the length of any word, we don't have any letters to add from that word, so we ignore it and continue adding the letter from the longer word.\n\n#### Algorithm\n\n1. Create two variables, `m` and `n`, to store the length of `word1` and `word2`.\n2. Create an empty string variable `result` to store the result of merged words.\n3. Iterate over `word1` and `word2` using a loop running from `i = 0` to `i < max(m, n)` and keep incrementing `i` by `1` after each iteration:\n    - If `i < m`, it means that we have not completely traversed `word1`. As a result, we append `word1[i]` to `result`.\n    - If `i < n`, it means that we have not completely traversed `word2`. As a result, we append `word2[i]` to `result`.\n4. Return `result`.\n\n#### Implementation#### Complexity Analysis\n\nHere, $m$ is the length of `word1` and $n$ is the length of `word2`.\n\n* Time complexity: $O(m + n)$\n\n    - We iterate over `word1` and `word2` once pushing their letters into `result`. It would take $O(m + n)$ time.\n\n* Space complexity: $O(1)$\n\n    - Without considering the space consumed by the input strings (`word1` and `word2`) and the output string (`result`), we do not use more than constant space."
}