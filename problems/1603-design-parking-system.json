{
  "title": "Design Parking System",
  "problem_id": "1708",
  "frontend_id": "1603",
  "difficulty": "Easy",
  "problem_slug": "design-parking-system",
  "topics": [
    "Design",
    "Simulation",
    "Counting"
  ],
  "description": "Design a parking system for a parking lot. The parking lot has three kinds of parking spaces: big, medium, and small, with a fixed number of slots for each size.\nImplement the ParkingSystem class:\nExample 1:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input\n[\"ParkingSystem\", \"addCar\", \"addCar\", \"addCar\", \"addCar\"]\n[[1, 1, 0], [1], [2], [3], [1]]\nOutput\n[null, true, true, false, false]\n\nExplanation\nParkingSystem parkingSystem = new ParkingSystem(1, 1, 0);\nparkingSystem.addCar(1); // return true because there is 1 available slot for a big car\nparkingSystem.addCar(2); // return true because there is 1 available slot for a medium car\nparkingSystem.addCar(3); // return false because there is no available slot for a small car\nparkingSystem.addCar(1); // return false because there is no available slot for a big car. It is already occupied.",
      "images": []
    }
  ],
  "constraints": [
    "0 <= big, medium, small <= 1000",
    "carType is 1, 2, or 3",
    "At most 1000 calls will be made to addCar"
  ],
  "follow_ups": [],
  "hints": [
    "Record number of parking slots still available for each car type."
  ],
  "code_snippets": {
    "cpp": "class ParkingSystem {\npublic:\n    ParkingSystem(int big, int medium, int small) {\n        \n    }\n    \n    bool addCar(int carType) {\n        \n    }\n};\n\n/**\n * Your ParkingSystem object will be instantiated and called as such:\n * ParkingSystem* obj = new ParkingSystem(big, medium, small);\n * bool param_1 = obj->addCar(carType);\n */",
    "java": "class ParkingSystem {\n\n    public ParkingSystem(int big, int medium, int small) {\n        \n    }\n    \n    public boolean addCar(int carType) {\n        \n    }\n}\n\n/**\n * Your ParkingSystem object will be instantiated and called as such:\n * ParkingSystem obj = new ParkingSystem(big, medium, small);\n * boolean param_1 = obj.addCar(carType);\n */",
    "python": "class ParkingSystem(object):\n\n    def __init__(self, big, medium, small):\n        \"\"\"\n        :type big: int\n        :type medium: int\n        :type small: int\n        \"\"\"\n        \n\n    def addCar(self, carType):\n        \"\"\"\n        :type carType: int\n        :rtype: bool\n        \"\"\"\n        \n\n\n# Your ParkingSystem object will be instantiated and called as such:\n# obj = ParkingSystem(big, medium, small)\n# param_1 = obj.addCar(carType)",
    "python3": "class ParkingSystem:\n\n    def __init__(self, big: int, medium: int, small: int):\n        \n\n    def addCar(self, carType: int) -> bool:\n        \n\n\n# Your ParkingSystem object will be instantiated and called as such:\n# obj = ParkingSystem(big, medium, small)\n# param_1 = obj.addCar(carType)",
    "c": "\n\n\ntypedef struct {\n    \n} ParkingSystem;\n\n\nParkingSystem* parkingSystemCreate(int big, int medium, int small) {\n    \n}\n\nbool parkingSystemAddCar(ParkingSystem* obj, int carType) {\n    \n}\n\nvoid parkingSystemFree(ParkingSystem* obj) {\n    \n}\n\n/**\n * Your ParkingSystem struct will be instantiated and called as such:\n * ParkingSystem* obj = parkingSystemCreate(big, medium, small);\n * bool param_1 = parkingSystemAddCar(obj, carType);\n \n * parkingSystemFree(obj);\n*/",
    "csharp": "public class ParkingSystem {\n\n    public ParkingSystem(int big, int medium, int small) {\n        \n    }\n    \n    public bool AddCar(int carType) {\n        \n    }\n}\n\n/**\n * Your ParkingSystem object will be instantiated and called as such:\n * ParkingSystem obj = new ParkingSystem(big, medium, small);\n * bool param_1 = obj.AddCar(carType);\n */",
    "javascript": "/**\n * @param {number} big\n * @param {number} medium\n * @param {number} small\n */\nvar ParkingSystem = function(big, medium, small) {\n    \n};\n\n/** \n * @param {number} carType\n * @return {boolean}\n */\nParkingSystem.prototype.addCar = function(carType) {\n    \n};\n\n/** \n * Your ParkingSystem object will be instantiated and called as such:\n * var obj = new ParkingSystem(big, medium, small)\n * var param_1 = obj.addCar(carType)\n */",
    "typescript": "class ParkingSystem {\n    constructor(big: number, medium: number, small: number) {\n        \n    }\n\n    addCar(carType: number): boolean {\n        \n    }\n}\n\n/**\n * Your ParkingSystem object will be instantiated and called as such:\n * var obj = new ParkingSystem(big, medium, small)\n * var param_1 = obj.addCar(carType)\n */",
    "php": "class ParkingSystem {\n    /**\n     * @param Integer $big\n     * @param Integer $medium\n     * @param Integer $small\n     */\n    function __construct($big, $medium, $small) {\n        \n    }\n  \n    /**\n     * @param Integer $carType\n     * @return Boolean\n     */\n    function addCar($carType) {\n        \n    }\n}\n\n/**\n * Your ParkingSystem object will be instantiated and called as such:\n * $obj = ParkingSystem($big, $medium, $small);\n * $ret_1 = $obj->addCar($carType);\n */",
    "swift": "\nclass ParkingSystem {\n\n    init(_ big: Int, _ medium: Int, _ small: Int) {\n        \n    }\n    \n    func addCar(_ carType: Int) -> Bool {\n        \n    }\n}\n\n/**\n * Your ParkingSystem object will be instantiated and called as such:\n * let obj = ParkingSystem(big, medium, small)\n * let ret_1: Bool = obj.addCar(carType)\n */",
    "kotlin": "class ParkingSystem(big: Int, medium: Int, small: Int) {\n\n    fun addCar(carType: Int): Boolean {\n        \n    }\n\n}\n\n/**\n * Your ParkingSystem object will be instantiated and called as such:\n * var obj = ParkingSystem(big, medium, small)\n * var param_1 = obj.addCar(carType)\n */",
    "dart": "class ParkingSystem {\n\n  ParkingSystem(int big, int medium, int small) {\n    \n  }\n  \n  bool addCar(int carType) {\n    \n  }\n}\n\n/**\n * Your ParkingSystem object will be instantiated and called as such:\n * ParkingSystem obj = ParkingSystem(big, medium, small);\n * bool param1 = obj.addCar(carType);\n */",
    "golang": "type ParkingSystem struct {\n    \n}\n\n\nfunc Constructor(big int, medium int, small int) ParkingSystem {\n    \n}\n\n\nfunc (this *ParkingSystem) AddCar(carType int) bool {\n    \n}\n\n\n/**\n * Your ParkingSystem object will be instantiated and called as such:\n * obj := Constructor(big, medium, small);\n * param_1 := obj.AddCar(carType);\n */",
    "ruby": "class ParkingSystem\n\n=begin\n    :type big: Integer\n    :type medium: Integer\n    :type small: Integer\n=end\n    def initialize(big, medium, small)\n        \n    end\n\n\n=begin\n    :type car_type: Integer\n    :rtype: Boolean\n=end\n    def add_car(car_type)\n        \n    end\n\n\nend\n\n# Your ParkingSystem object will be instantiated and called as such:\n# obj = ParkingSystem.new(big, medium, small)\n# param_1 = obj.add_car(car_type)",
    "scala": "class ParkingSystem(_big: Int, _medium: Int, _small: Int) {\n\n    def addCar(carType: Int): Boolean = {\n        \n    }\n\n}\n\n/**\n * Your ParkingSystem object will be instantiated and called as such:\n * val obj = new ParkingSystem(big, medium, small)\n * val param_1 = obj.addCar(carType)\n */",
    "rust": "struct ParkingSystem {\n\n}\n\n\n/** \n * `&self` means the method takes an immutable reference.\n * If you need a mutable reference, change it to `&mut self` instead.\n */\nimpl ParkingSystem {\n\n    fn new(big: i32, medium: i32, small: i32) -> Self {\n        \n    }\n    \n    fn add_car(&self, car_type: i32) -> bool {\n        \n    }\n}\n\n/**\n * Your ParkingSystem object will be instantiated and called as such:\n * let obj = ParkingSystem::new(big, medium, small);\n * let ret_1: bool = obj.add_car(carType);\n */",
    "racket": "(define parking-system%\n  (class object%\n    (super-new)\n    \n    ; big : exact-integer?\n    ; medium : exact-integer?\n    ; small : exact-integer?\n    (init-field\n      big\n      medium\n      small)\n    \n    ; add-car : exact-integer? -> boolean?\n    (define/public (add-car car-type)\n      )))\n\n;; Your parking-system% object will be instantiated and called as such:\n;; (define obj (new parking-system% [big big] [medium medium] [small small]))\n;; (define param_1 (send obj add-car car-type))",
    "erlang": "-spec parking_system_init_(Big :: integer(), Medium :: integer(), Small :: integer()) -> any().\nparking_system_init_(Big, Medium, Small) ->\n  .\n\n-spec parking_system_add_car(CarType :: integer()) -> boolean().\nparking_system_add_car(CarType) ->\n  .\n\n\n%% Your functions will be called as such:\n%% parking_system_init_(Big, Medium, Small),\n%% Param_1 = parking_system_add_car(CarType),\n\n%% parking_system_init_ will be called before every test case, in which you can do some necessary initializations.",
    "elixir": "defmodule ParkingSystem do\n  @spec init_(big :: integer, medium :: integer, small :: integer) :: any\n  def init_(big, medium, small) do\n    \n  end\n\n  @spec add_car(car_type :: integer) :: boolean\n  def add_car(car_type) do\n    \n  end\nend\n\n# Your functions will be called as such:\n# ParkingSystem.init_(big, medium, small)\n# param_1 = ParkingSystem.add_car(car_type)\n\n# ParkingSystem.init_ will be called before every test case, in which you can do some necessary initializations."
  },
  "solution": "[TOC]\n\n## Solution\n\n--- \n\n### Overview\n\nThe problem is to **design** a parking system. \n\n> A **design** problem is a problem where we have to **implement** a class or a data structure. This class usually has multiple functions that we have to implement. This falls under the category of [**Object Oriented Programming**](https://leetcode.com/tag/oop/)\n\nIn this problem, we have to implement the `ParkingSystem` class. It will have the following components:\n\n- `ParkingSystem` constructor. Whenever any user or test case wants to create a new parking system, they will call this constructor. They need to specify the number of parking slots available for each type of car (`small`, `medium`, or `large`). \n\n    **We** have to write code to store this information in the class. This information will perhaps be used in other functions.\n\n    > Different languages have different ways to implement constructors.   \n    > - In Python, we use `__init__` function to implement the constructor. \n    > - In C++ and Java, the name of the constructor is the same as the name of the class.\n\n- `addCar` function. Whenever any user or test case wants to add a car to the parking system, they will call this function. They need to specify the type of the car, `carType` using an integer.\n    \n    - if they want to add a `big` car, they will pass `1` as the argument.\n    - if they want to add a `medium` car, they will pass `2` as the argument.\n    - if they want to add a `small` car, they will pass `3` as the argument.**We** have to write code to check if there is a parking slot available for the given type of car.\n         \n    - If there is a parking slot available, we have to add the car to the parking system and return `true`. \n    - Otherwise, we have to return `false`.In these problems, users often faces difficulty in understanding theinputandoutputformats. Let's pick oneexampleand understand itsinputandoutputstructure. If you are not familiar with design problems, it is advisable to expand the section by clicking here.```Input []\n[\"ParkingSystem\", \"addCar\", \"addCar\", \"addCar\", \"addCar\"]\n[[1, 1, 0], [1], [2], [3], [1]]\n```\n\nThis input is actually **NOT** an array. The array has been given to describe a **sequence of function calls** by the online judge.\n\n> If readers want to explore more, they can read [Dispatch Table](https://en.wikipedia.org/wiki/Dispatch_table)\n\nIn our code, we **won't be able to access the array**. This array only helps in letting us know the function calls that will be made by the online judge.\n\nMore particularly, \n- the first array stores the sequence of function calls, and  \n- the second array stores the **respective** arguments for each function call.\n\nThus, the above input can be interpreted as:\n\n- First, the online judge will call the `ParkingSystem` constructor with arguments `1, 1, 0`.\n\n    We were given in the description that `ParkingSystem` requires three arguments, `big`, `medium`, and `small`. These `[1, 1, 0]` are the respective values for these arguments.\n\n    Do we have to return anything from the constructor? No. We just have to store some (or all) of these arguments so that we can use them in other functions if needed. Thus, the first element of the **output** array is `null`.\n\n- Then, the online judge will call the `addCar` function with argument `1`.\n\n    We were given in the description that `addCar` requires one argument, `carType`. This `1` is the value for this argument and represents a `big` car.\n\n    This has to be interpreted as, \"Is there a parking slot available for a `big` car?\". If yes, then add the car to the parking system and return `true`. Otherwise, return `false`.\n\n    Now, we know that while creating our object, we were given that there is `1` parking slot available for a `big` car. And we know that no car has been added to the parking system yet. Thus, we will return `true` and add the car to the slot available for a `big` car.\n\n    Hence, the second element of the **output** array is `true`.\n\n- Then, the online judge will call the `addCar` function with argument `2`.\n\n    This `2` is the value for this argument and represents a `medium` car.\n    \n    This has to be interpreted as, \"Is there a parking slot available for a `medium` car?\". If yes, then add the car to the parking system and return `true`. Otherwise, return `false`.\n\n    Now, we know that while creating our object, we were given that there is `1` parking slot available for a `medium` car. Additionally, we know that no car has been added to the parking system yet. Thus, we will return `true` and add the car to the slot available for a `medium` car.\n\n    Hence, the third element of the **output** array is `true`.\n\n- Then, the online judge will call the `addCar` function with argument `3`.\n    \n    This `3` is the value for this argument and represents a `small` car.\n    \n    This has to be interpreted as, \"Is there a parking slot available for a `small` car?\". If yes, then add the car to the parking system and return `true`. Otherwise, return `false`.\n\n    Now, we know that while creating our object, we were given that there is `0` parking slot available for `small` car. Thus, we cannot add the car to the parking system because no slots are available. Hence, we will return `false`.\n\n    Hence, the fourth element of the **output** array is `false`.\n\n- Lastly, the online judge will call the `addCar` function with argument `1`.\n    \n    This `1` is the value for this argument and represents a `big` car.\n    \n    This has to be interpreted as, \"Is there a parking slot available for `big` car?\". If yes, then add the car to the parking system and return `true`. Otherwise, return `false`.\n\n    Now, we know that while creating our object, we were given that there is `1` parking slot available for `big` car. And we know that one car has already been added to the parking system. Thus, we will return `false` because no slots are available.\n\n    Hence, the fifth element of the **output** array is `false`.\n\nThus, the **output** array as illustrated in the example is\n\n```Output []\n[null, true, true, false, false]\n```\n\nIt's worth mentioning that we **don't** have to return any array. We just have to make sure that all functions return the correct value. The array is just a representation of the correct output sequence, and need not be explicitly returned.$\\downarrow_{\\text{Section below structure}}$\n\nThere are tons of similar [Design Problems](https://leetcode.com/tag/design/) on LeetCode. A few of them are listed below:\n\n- [LRU Cache](https://leetcode.com/problems/lru-cache/)\n- [Implement Trie (Prefix Tree)](https://leetcode.com/problems/implement-trie-prefix-tree/)\n- [Implement Stack using Queues](https://leetcode.com/problems/implement-stack-using-queues/)\n- [Implement Queue using Stacks](https://leetcode.com/problems/implement-queue-using-stacks/)\n- [Design Browser History](https://leetcode.com/problems/design-browser-history/)\n- [Design Linked List](https://leetcode.com/problems/design-linked-list/)\n\n---\n\n### Approach: Array for Parking Slots\n\n#### Intuition\n\nWe want to initialize our object given slots for each type of car. \n\n**What exactly do we need to store in our object?**  \nIt depends on the desired function of the object. The required function is `addCar` and we should check if there is a parking space for `carType`. If so, then we should add the car to the parking system and return `true`. Otherwise, we should return `false`.\n\nThus, while creating an object, we *perhaps* need to store the  \n- Parking limit for `big` cars\n- Parking limit for `medium` cars\n- Parking limit for `small` cars\n\n**Do we need anything else in the constructor?**  \nWe know the limits for each type of car. But we don't know the number of cars parked in the parking system. We need to store this information as well.\n\nTherefore, it may also be necessary to store the following three pieces of information in the object:\n- Count of `big` cars parked in the parking system. \n- Count of `medium` cars parked in the parking system. \n- Count of `small` cars parked in the parking system.\n\nAll of them will be initialized to `0`.\n\nInitially, **constructor** in pseudo-code will look like this:\n\n```pseudocode []\nParkingSystem(int big, int medium, int small) {\n\n    // Store the parking limit for each type of car\n    this.bigLimit = big\n    this.mediumLimit = medium\n    this.smallLimit = small\n\n    // Store the count of cars parked in the parking system\n    this.bigCount = 0\n    this.mediumCount = 0\n    this.smallCount = 0\n}\n```\n\n> The `this` keyword is used to access the current object's attributes and methods. Different languages have different ways to access the current object's attributes and methods. For example, in Python, we can use the `self` keyword to access the current object's attributes and methods. \n\nWe are currently storing the count and limits of cars for each type in six variables. However, what if we have hundreds of types of cars? Is it a good idea to have two variables for each type of car?\n\nIt turns out that if data represents the same type of thing *(or data is **homogeneous**)*, then we can use an array to store them.\n\n> An [Array](https://leetcode.com/explore/learn/card/fun-with-arrays/) is a data structure that stores a collection of elements. It is a linear data structure, which means that elements are stored sequentially. Each element in an array is identified by an index. Readers can learn more about Array from [Leetcode Explore Card](https://leetcode.com/explore/learn/card/fun-with-arrays/).\n\nThus, we can club the three variables `bigCount`, `mediumCount`, and `smallCount` into one array `count`. Also, we can club the three variables `bigLimit`, `mediumLimit`, and `smallLimit` into one array `limit`.\n\nHence, so far, we are planning to use two arrays, `count` and `limit`. Can we brainstorm a way to use only one array?\n\nThe condition to check if we can `addCar` or not will be\n\n$\\rightsquigarrow$ `count[i] < limit[i]`\n\n$\\rightsquigarrow$ `limit[i] > count[i]`\n\n$\\rightsquigarrow$ `limit[i] - count[i] > 0`\n\nWhat exactly does `limit[i] - count[i]` represent? It represents the number of empty slots available for a particular type of car. Hence, we can use this value to store the empty slots for each type of car in one array, `empty`.\n\nInitially, all available slots will be empty. Hence, we can initialize `empty` with the parking limit of each type of car provided as arguments to the **constructor**.\n\nNow, does the order of these variables matter, or **can we gain any advantage if they are stored in one specific order instead of another?**   \nFor answering this, let's re-read the following portion of the problem statement\n\n> `carType` can be of three kinds: big, medium, or small, which are represented by `1`, `2`, and `3` respectively.\n\nThis hints that if we store \n\n- big cars at index `1`,    \n- medium cars at index `2`,   \n- and small cars at index `3`, \n\nthen we can directly access the count of cars of a particular type by using `carType` as the index.\n\n\n**What about index-0, then?** \n\n> Arrays in most programming languages are 0-indexed. This means that the first element of the array is stored at index `0`.\n\nThere are two ways to handle this. \n\n1. We can allocate an array of size 4, and store the number of empty slots of cars at index `1`, `2`, and `3`. On Index `0`, we can store some dummy value. \n  \n    The `carType` here will directly act as an index.\n\n2. We can allocate an array of size 3, and store the number of empty slots of cars at index `0`, `1`, and `2`. \n\n    The `carType` here will act as an index after subtracting `1` from it.\n\nReaders can choose any of the two ways. We will proceed with the second way.\n\nThus, now our **constructor** in pseudo-code will look like this\n\n```pseudocode []\nParkingSystem(int big, int medium, int small) {\n\n    // Store the empty slots for each type of car\n    this.empty = [big, medium, small]\n}\n```\n\nReaders can appreciate the compactness obtained by using an array. We have reduced the number of variables from six to one.\n\n> **Interview Tip:** Reading the problem statement multiple times helps to formulate solutions elegantly.\n\nIn the `addCar` function, we check if the number of empty slots is greater than `0`. If it is, we add the car and decrement the number of empty slots by `1`. In this case, we return `true`. Otherwise, we return `false`.\n\n```pseudocode []\nboolean addCar(int carType) {\n\n    // Depending on carType, decide\n    if empty[carType - 1] > 0 {\n        empty[carType - 1] -= 1\n        return true\n    }\n    else {\n        return false\n    }\n}\n```\n\nThus using this approach we can solve the problem. Once solved, readers are advised to see codes in other languages and compare how classes and objects are implemented in different languages. Also, it's worth noting that we can also use a Hash map to solve this problem. Readers can try to solve the problem using a Hash map as well.\n\n#### Algorithm\n\n1. In the **constructor**, create one array of size 3. Let's call it `empty`.\n    \n    `empty` will store the number of empty slots available for each type of car. Index `0` will be used for big cars, index `1` will be used for medium cars, and index `2` will be used for small cars. These limits will be passed as `big`, `medium`, and `small` respectively as parameters to the **constructor**. Initially, all the empty slots will be equal to the parking limit of each type of car.\n\n2. In the **addCar** function, if the number of empty slots for `carType` is greater than `0`, then decrement the number of empty slots by 1 and return `true`. Else, return `false`.\n\n    The `if` condition will be similar to `if empty[carType - 1] > 0`.Here is the visual representation of the above algorithm.   \n!?!../Documents/1603/1603_Array.json:1280,720!?!#### Implementation#### Complexity Analysis\n\nLet $N$ be the number of function calls.\n\n* Time complexity: $O(N)$.\n    \n    - In the **constructor**, we create one array of constant size, `empty`. Hence, the time complexity will be $O(1)$.\n\n    - In the **addCar** function, we check if the number of empty slots for a particular type of car is greater than `0`. This is done in constant time.\n    \n    Hence, the overall time complexity will be $O(N)$ since there are $N$ function-calls.\n  \n* Space complexity: $O(1)$.\n    \n    - In the **constructor**, we create one array of constant size, `empty`. Hence, the space complexity will be $O(1)$.\n\n    - In the **addCar** function, we do not use any extra space. Hence, the space complexity will be $O(1)$.\n\n    Hence, the overall space complexity will be $O(1)$.\n  \n---\n\n### ExtraMany Programming Language has somecool functionalitiesthat can be used to solve problems smartly. While this way is often not beginner-friendly, they often compact the code. Sometimes, they are even faster than conventional approaches. A few times they are slower too.These functionalities are not always intuitive and are not always easy to understand. But, they are worth learning. They are often labeled as syntactic sugar.Readers can click here to go through some of these cool functionalities.The condition to check if we can `addCar` was\n\n```\nif empty[carType - 1] > 0\n```\n\nWe can use the decrement operator `--` to **post**-decrement the value of `empty[carType - 1]` by `1` and check if the value is greater than `0` in a single line. If greater than `0`, return `True`, decrementation already happened. Else, return `False`.\n\nThe `if` condition will be similar to what we have to return. Thus we can compact the code.\n\n```java []\npublic boolean addCar(int carType) {\n    return empty[carType - 1]-- > 0;\n}\n```\n\nThis will always decrement the value of `empty[carType - 1]` by `1` and then check if the value is positive. The value will be decremented always, even if the condition is `false`. Thus, `empty[carType - 1]` may be negative which is absurd logically. Although, the code will still work fine.\n\nMoreover, in the **constraints**, it is mentioned that\n\n> At most `1000` calls will be made to `addCar`\n\nIf we call `addCar` 1000 times, then `empty[carType - 1]` will be decremented 1000 times. \n  \n  However, if there were more calls than the magnitude of `Integer.MIN_VALUE`, then the value of `empty[carType - 1]` from negative may **overflow** to positive. Thus, the code will not work as expected.\n\nA minute change in the condition can solve this problem.\n\n```java []\npublic boolean addCar(int carType) {\n    return empty[carType - 1] > 0 && --empty[carType - 1] >= 0;\n}\n```\n\nThis uses the **short-circuiting** property of the `&&` operator. If the first condition is `false`, then the second condition will not be evaluated. Thus, the value of `empty[carType - 1]` will not be decremented.\n\nAnother minute optimization is that we can use `short` instead of `int` for an `empty` array. This will reduce the space complexity. This we are doing because the parking limit is less than `1000`. Thus, we can use `short` instead of `int`. However, if the parking limit was `1000000`, then we would have to use `int` instead of `short`.\n\nHere is the new code.\n\n```java []\nclass ParkingSystem {\n\n    short[] empty;\n\n    public ParkingSystem(int big, int medium, int small) {\n        this.empty = new short[]{(short) big, (short) medium, (short) small};\n    }\n\n    public boolean addCar(int carType) {\n        return empty[carType - 1] > 0 && --empty[carType - 1] >= 0;\n    }\n}\n```\n\nProgrammers often use the `false` value of `0` to check if a variable is `false`. \n\nThus, this line in Python3\n\n```python3 []\nif self.empty[carType - 1] > 0:\n```\n\ncan be written as\n\n```python3 []\nif self.empty[carType - 1]:\n```\n\nAll these small things are often impressive. Readers can gain these skills by solving more problems.---"
}