{
  "title": "Maximum Number of Ways to Partition an Array",
  "problem_id": "2135",
  "frontend_id": "2025",
  "difficulty": "Hard",
  "problem_slug": "maximum-number-of-ways-to-partition-an-array",
  "topics": [
    "Array",
    "Hash Table",
    "Counting",
    "Enumeration",
    "Prefix Sum"
  ],
  "description": "You are given a 0-indexed integer array nums of length n. The number of ways to partition nums is the number of pivot indices that satisfy both conditions:\nYou are also given an integer k. You can choose to change the value of one element of nums to k, or to leave the array unchanged.\nReturn the maximum possible number of ways to partition nums to satisfy both conditions after changing at most one element.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: nums = [2,-1,2], k = 3\nOutput: 1\nExplanation: One optimal approach is to change nums[0] to k. The array becomes [3,-1,2].\nThere is one way to partition the array:\n- For pivot = 2, we have the partition [3,-1 | 2]: 3 + -1 == 2.",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input: nums = [0,0,0], k = 1\nOutput: 2\nExplanation: The optimal approach is to leave the array unchanged.\nThere are two ways to partition the array:\n- For pivot = 1, we have the partition [0 | 0,0]: 0 == 0 + 0.\n- For pivot = 2, we have the partition [0,0 | 0]: 0 + 0 == 0.",
      "images": []
    },
    {
      "example_num": 3,
      "example_text": "Input: nums = [22,4,-25,-20,-15,15,-16,7,19,-10,0,-13,-14], k = -33\nOutput: 4\nExplanation: One optimal approach is to change nums[2] to k. The array becomes [22,4,-33,-20,-15,15,-16,7,19,-10,0,-13,-14].\nThere are four ways to partition the array.",
      "images": []
    }
  ],
  "constraints": [
    "n == nums.length",
    "2 <= n <= 105",
    "-105 <= k, nums[i] <= 105"
  ],
  "follow_ups": [],
  "hints": [
    "A pivot point splits the array into equal prefix and suffix. If no change is made to the array, the goal is to find the number of pivot p such that prefix[p-1] == suffix[p].",
    "Consider how prefix and suffix will change when we change a number nums[i] to k.",
    "When sweeping through each element, can you find the total number of pivots where the difference of prefix and suffix happens to equal to the changes of k-nums[i]."
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    int waysToPartition(vector<int>& nums, int k) {\n        \n    }\n};",
    "java": "class Solution {\n    public int waysToPartition(int[] nums, int k) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def waysToPartition(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def waysToPartition(self, nums: List[int], k: int) -> int:\n        ",
    "c": "int waysToPartition(int* nums, int numsSize, int k) {\n    \n}",
    "csharp": "public class Solution {\n    public int WaysToPartition(int[] nums, int k) {\n        \n    }\n}",
    "javascript": "/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number}\n */\nvar waysToPartition = function(nums, k) {\n    \n};",
    "typescript": "function waysToPartition(nums: number[], k: number): number {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @param Integer $k\n     * @return Integer\n     */\n    function waysToPartition($nums, $k) {\n        \n    }\n}",
    "swift": "class Solution {\n    func waysToPartition(_ nums: [Int], _ k: Int) -> Int {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun waysToPartition(nums: IntArray, k: Int): Int {\n        \n    }\n}",
    "dart": "class Solution {\n  int waysToPartition(List<int> nums, int k) {\n    \n  }\n}",
    "golang": "func waysToPartition(nums []int, k int) int {\n    \n}",
    "ruby": "# @param {Integer[]} nums\n# @param {Integer} k\n# @return {Integer}\ndef ways_to_partition(nums, k)\n    \nend",
    "scala": "object Solution {\n    def waysToPartition(nums: Array[Int], k: Int): Int = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn ways_to_partition(nums: Vec<i32>, k: i32) -> i32 {\n        \n    }\n}",
    "racket": "(define/contract (ways-to-partition nums k)\n  (-> (listof exact-integer?) exact-integer? exact-integer?)\n  )",
    "erlang": "-spec ways_to_partition(Nums :: [integer()], K :: integer()) -> integer().\nways_to_partition(Nums, K) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec ways_to_partition(nums :: [integer], k :: integer) :: integer\n  def ways_to_partition(nums, k) do\n    \n  end\nend"
  }
}