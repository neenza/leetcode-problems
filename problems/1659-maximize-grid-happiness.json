{
  "title": "Maximize Grid Happiness",
  "problem_id": "1778",
  "frontend_id": "1659",
  "difficulty": "Hard",
  "problem_slug": "maximize-grid-happiness",
  "topics": [
    "Dynamic Programming",
    "Bit Manipulation",
    "Memoization",
    "Bitmask"
  ],
  "description": "You are given four integers, m, n, introvertsCount, and extrovertsCount. You have an m x n grid, and there are two types of people: introverts and extroverts. There are introvertsCount introverts and extrovertsCount extroverts.\nYou should decide how many people you want to live in the grid and assign each of them one grid cell. Note that you do not have to have all the people living in the grid.\nThe happiness of each person is calculated as follows:\nNeighbors live in the directly adjacent cells north, east, south, and west of a person's cell.\nThe grid happiness is the sum of each person's happiness. Return the maximum possible grid happiness.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: m = 2, n = 3, introvertsCount = 1, extrovertsCount = 2\nOutput: 240\nExplanation: Assume the grid is 1-indexed with coordinates (row, column).\nWe can put the introvert in cell (1,1) and put the extroverts in cells (1,3) and (2,3).\n- Introvert at (1,1) happiness: 120 (starting happiness) - (0 * 30) (0 neighbors) = 120\n- Extrovert at (1,3) happiness: 40 (starting happiness) + (1 * 20) (1 neighbor) = 60\n- Extrovert at (2,3) happiness: 40 (starting happiness) + (1 * 20) (1 neighbor) = 60\nThe grid happiness is 120 + 60 + 60 = 240.\nThe above figure shows the grid in this example with each person's happiness. The introvert stays in the light green cell while the extroverts live on the light purple cells.",
      "images": [
        "https://assets.leetcode.com/uploads/2020/11/05/grid_happiness.png"
      ]
    },
    {
      "example_num": 2,
      "example_text": "Input: m = 3, n = 1, introvertsCount = 2, extrovertsCount = 1\nOutput: 260\nExplanation: Place the two introverts in (1,1) and (3,1) and the extrovert at (2,1).\n- Introvert at (1,1) happiness: 120 (starting happiness) - (1 * 30) (1 neighbor) = 90\n- Extrovert at (2,1) happiness: 40 (starting happiness) + (2 * 20) (2 neighbors) = 80\n- Introvert at (3,1) happiness: 120 (starting happiness) - (1 * 30) (1 neighbor) = 90\nThe grid happiness is 90 + 80 + 90 = 260.",
      "images": [
        "https://assets.leetcode.com/uploads/2020/11/05/grid_happiness.png"
      ]
    },
    {
      "example_num": 3,
      "example_text": "Input: m = 2, n = 2, introvertsCount = 4, extrovertsCount = 0\nOutput: 240",
      "images": [
        "https://assets.leetcode.com/uploads/2020/11/05/grid_happiness.png"
      ]
    }
  ],
  "constraints": [
    "1 <= m, n <= 5",
    "0 <= introvertsCount, extrovertsCount <= min(m * n, 6)"
  ],
  "follow_ups": [],
  "hints": [
    "For each cell, it has 3 options, either it is empty, or contains an introvert, or an extrovert.",
    "You can do DP where you maintain the state of the previous row, the number of remaining introverts and extroverts, the current row and column, and try the 3 options for each cell.",
    "Assume that the previous columns in the current row already belong to the previous row."
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    int getMaxGridHappiness(int m, int n, int introvertsCount, int extrovertsCount) {\n        \n    }\n};",
    "java": "class Solution {\n    public int getMaxGridHappiness(int m, int n, int introvertsCount, int extrovertsCount) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def getMaxGridHappiness(self, m, n, introvertsCount, extrovertsCount):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :type introvertsCount: int\n        :type extrovertsCount: int\n        :rtype: int\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def getMaxGridHappiness(self, m: int, n: int, introvertsCount: int, extrovertsCount: int) -> int:\n        ",
    "c": "int getMaxGridHappiness(int m, int n, int introvertsCount, int extrovertsCount) {\n    \n}",
    "csharp": "public class Solution {\n    public int GetMaxGridHappiness(int m, int n, int introvertsCount, int extrovertsCount) {\n        \n    }\n}",
    "javascript": "/**\n * @param {number} m\n * @param {number} n\n * @param {number} introvertsCount\n * @param {number} extrovertsCount\n * @return {number}\n */\nvar getMaxGridHappiness = function(m, n, introvertsCount, extrovertsCount) {\n    \n};",
    "typescript": "function getMaxGridHappiness(m: number, n: number, introvertsCount: number, extrovertsCount: number): number {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param Integer $m\n     * @param Integer $n\n     * @param Integer $introvertsCount\n     * @param Integer $extrovertsCount\n     * @return Integer\n     */\n    function getMaxGridHappiness($m, $n, $introvertsCount, $extrovertsCount) {\n        \n    }\n}",
    "swift": "class Solution {\n    func getMaxGridHappiness(_ m: Int, _ n: Int, _ introvertsCount: Int, _ extrovertsCount: Int) -> Int {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun getMaxGridHappiness(m: Int, n: Int, introvertsCount: Int, extrovertsCount: Int): Int {\n        \n    }\n}",
    "dart": "class Solution {\n  int getMaxGridHappiness(int m, int n, int introvertsCount, int extrovertsCount) {\n    \n  }\n}",
    "golang": "func getMaxGridHappiness(m int, n int, introvertsCount int, extrovertsCount int) int {\n    \n}",
    "ruby": "# @param {Integer} m\n# @param {Integer} n\n# @param {Integer} introverts_count\n# @param {Integer} extroverts_count\n# @return {Integer}\ndef get_max_grid_happiness(m, n, introverts_count, extroverts_count)\n    \nend",
    "scala": "object Solution {\n    def getMaxGridHappiness(m: Int, n: Int, introvertsCount: Int, extrovertsCount: Int): Int = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn get_max_grid_happiness(m: i32, n: i32, introverts_count: i32, extroverts_count: i32) -> i32 {\n        \n    }\n}",
    "racket": "(define/contract (get-max-grid-happiness m n introvertsCount extrovertsCount)\n  (-> exact-integer? exact-integer? exact-integer? exact-integer? exact-integer?)\n  )",
    "erlang": "-spec get_max_grid_happiness(M :: integer(), N :: integer(), IntrovertsCount :: integer(), ExtrovertsCount :: integer()) -> integer().\nget_max_grid_happiness(M, N, IntrovertsCount, ExtrovertsCount) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec get_max_grid_happiness(m :: integer, n :: integer, introverts_count :: integer, extroverts_count :: integer) :: integer\n  def get_max_grid_happiness(m, n, introverts_count, extroverts_count) do\n    \n  end\nend"
  }
}