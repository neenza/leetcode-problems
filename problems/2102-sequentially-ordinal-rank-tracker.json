{
  "title": "Sequentially Ordinal Rank Tracker",
  "problem_id": "2207",
  "frontend_id": "2102",
  "difficulty": "Hard",
  "problem_slug": "sequentially-ordinal-rank-tracker",
  "topics": [
    "Design",
    "Heap (Priority Queue)",
    "Data Stream",
    "Ordered Set"
  ],
  "description": "A scenic location is represented by its name and attractiveness score, where name is a unique string among all locations and score is an integer. Locations can be ranked from the best to the worst. The higher the score, the better the location. If the scores of two locations are equal, then the location with the lexicographically smaller name is better.\nYou are building a system that tracks the ranking of locations with the system initially starting with no locations. It supports:\nNote that the test data are generated so that at any time, the number of queries does not exceed the number of locations added to the system.\nImplement the SORTracker class:\nExample 1:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input\n[\"SORTracker\", \"add\", \"add\", \"get\", \"add\", \"get\", \"add\", \"get\", \"add\", \"get\", \"add\", \"get\", \"get\"]\n[[], [\"bradford\", 2], [\"branford\", 3], [], [\"alps\", 2], [], [\"orland\", 2], [], [\"orlando\", 3], [], [\"alpine\", 2], [], []]\nOutput\n[null, null, null, \"branford\", null, \"alps\", null, \"bradford\", null, \"bradford\", null, \"bradford\", \"orland\"]\n\nExplanation\nSORTracker tracker = new SORTracker(); // Initialize the tracker system.\ntracker.add(\"bradford\", 2); // Add location with name=\"bradford\" and score=2 to the system.\ntracker.add(\"branford\", 3); // Add location with name=\"branford\" and score=3 to the system.\ntracker.get();              // The sorted locations, from best to worst, are: branford, bradford.\n                            // Note that branford precedes bradford due to its higher score (3 > 2).\n                            // This is the 1st time get() is called, so return the best location: \"branford\".\ntracker.add(\"alps\", 2);     // Add location with name=\"alps\" and score=2 to the system.\ntracker.get();              // Sorted locations: branford, alps, bradford.\n                            // Note that alps precedes bradford even though they have the same score (2).\n                            // This is because \"alps\" is lexicographically smaller than \"bradford\".\n                            // Return the 2nd best location \"alps\", as it is the 2nd time get() is called.\ntracker.add(\"orland\", 2);   // Add location with name=\"orland\" and score=2 to the system.\ntracker.get();              // Sorted locations: branford, alps, bradford, orland.\n                            // Return \"bradford\", as it is the 3rd time get() is called.\ntracker.add(\"orlando\", 3);  // Add location with name=\"orlando\" and score=3 to the system.\ntracker.get();              // Sorted locations: branford, orlando, alps, bradford, orland.\n                            // Return \"bradford\".\ntracker.add(\"alpine\", 2);   // Add location with name=\"alpine\" and score=2 to the system.\ntracker.get();              // Sorted locations: branford, orlando, alpine, alps, bradford, orland.\n                            // Return \"bradford\".\ntracker.get();              // Sorted locations: branford, orlando, alpine, alps, bradford, orland.\n                            // Return \"orland\".",
      "images": []
    }
  ],
  "constraints": [
    "name consists of lowercase English letters, and is unique among all locations.",
    "1 <= name.length <= 10",
    "1 <= score <= 105",
    "At any time, the number of calls to get does not exceed the number of calls to add.",
    "At most 4 * 104 calls in total will be made to add and get."
  ],
  "follow_ups": [],
  "hints": [
    "If the problem were to find the median of a stream of scenery locations while they are being added, can you solve it?",
    "We can use a similar approach as an optimization to avoid repeated sorting.",
    "Employ two heaps: left heap and right heap. The left heap is a max-heap, and the right heap is a min-heap. The size of the left heap is k + 1 (best locations), where k is the number of times the get method was invoked. The other locations are maintained in the right heap.",
    "Every time when add is being called, we add it to the left heap. If the size of the left heap exceeds k + 1, we move the head element to the right heap.",
    "When the get method is invoked again (the k + 1 time it is invoked), we can return the head element of the left heap. But before returning it, if the right heap is not empty, we maintain the left heap to have the best k + 2 items by moving the best location from the right heap to the left heap."
  ],
  "code_snippets": {
    "cpp": "class SORTracker {\npublic:\n    SORTracker() {\n        \n    }\n    \n    void add(string name, int score) {\n        \n    }\n    \n    string get() {\n        \n    }\n};\n\n/**\n * Your SORTracker object will be instantiated and called as such:\n * SORTracker* obj = new SORTracker();\n * obj->add(name,score);\n * string param_2 = obj->get();\n */",
    "java": "class SORTracker {\n\n    public SORTracker() {\n        \n    }\n    \n    public void add(String name, int score) {\n        \n    }\n    \n    public String get() {\n        \n    }\n}\n\n/**\n * Your SORTracker object will be instantiated and called as such:\n * SORTracker obj = new SORTracker();\n * obj.add(name,score);\n * String param_2 = obj.get();\n */",
    "python": "class SORTracker(object):\n\n    def __init__(self):\n        \n\n    def add(self, name, score):\n        \"\"\"\n        :type name: str\n        :type score: int\n        :rtype: None\n        \"\"\"\n        \n\n    def get(self):\n        \"\"\"\n        :rtype: str\n        \"\"\"\n        \n\n\n# Your SORTracker object will be instantiated and called as such:\n# obj = SORTracker()\n# obj.add(name,score)\n# param_2 = obj.get()",
    "python3": "class SORTracker:\n\n    def __init__(self):\n        \n\n    def add(self, name: str, score: int) -> None:\n        \n\n    def get(self) -> str:\n        \n\n\n# Your SORTracker object will be instantiated and called as such:\n# obj = SORTracker()\n# obj.add(name,score)\n# param_2 = obj.get()",
    "c": "\n\n\ntypedef struct {\n    \n} SORTracker;\n\n\nSORTracker* sORTrackerCreate() {\n    \n}\n\nvoid sORTrackerAdd(SORTracker* obj, char* name, int score) {\n    \n}\n\nchar* sORTrackerGet(SORTracker* obj) {\n    \n}\n\nvoid sORTrackerFree(SORTracker* obj) {\n    \n}\n\n/**\n * Your SORTracker struct will be instantiated and called as such:\n * SORTracker* obj = sORTrackerCreate();\n * sORTrackerAdd(obj, name, score);\n \n * char* param_2 = sORTrackerGet(obj);\n \n * sORTrackerFree(obj);\n*/",
    "csharp": "public class SORTracker {\n\n    public SORTracker() {\n        \n    }\n    \n    public void Add(string name, int score) {\n        \n    }\n    \n    public string Get() {\n        \n    }\n}\n\n/**\n * Your SORTracker object will be instantiated and called as such:\n * SORTracker obj = new SORTracker();\n * obj.Add(name,score);\n * string param_2 = obj.Get();\n */",
    "javascript": "\nvar SORTracker = function() {\n    \n};\n\n/** \n * @param {string} name \n * @param {number} score\n * @return {void}\n */\nSORTracker.prototype.add = function(name, score) {\n    \n};\n\n/**\n * @return {string}\n */\nSORTracker.prototype.get = function() {\n    \n};\n\n/** \n * Your SORTracker object will be instantiated and called as such:\n * var obj = new SORTracker()\n * obj.add(name,score)\n * var param_2 = obj.get()\n */",
    "typescript": "class SORTracker {\n    constructor() {\n        \n    }\n\n    add(name: string, score: number): void {\n        \n    }\n\n    get(): string {\n        \n    }\n}\n\n/**\n * Your SORTracker object will be instantiated and called as such:\n * var obj = new SORTracker()\n * obj.add(name,score)\n * var param_2 = obj.get()\n */",
    "php": "class SORTracker {\n    /**\n     */\n    function __construct() {\n        \n    }\n  \n    /**\n     * @param String $name\n     * @param Integer $score\n     * @return NULL\n     */\n    function add($name, $score) {\n        \n    }\n  \n    /**\n     * @return String\n     */\n    function get() {\n        \n    }\n}\n\n/**\n * Your SORTracker object will be instantiated and called as such:\n * $obj = SORTracker();\n * $obj->add($name, $score);\n * $ret_2 = $obj->get();\n */",
    "swift": "\nclass SORTracker {\n\n    init() {\n        \n    }\n    \n    func add(_ name: String, _ score: Int) {\n        \n    }\n    \n    func get() -> String {\n        \n    }\n}\n\n/**\n * Your SORTracker object will be instantiated and called as such:\n * let obj = SORTracker()\n * obj.add(name, score)\n * let ret_2: String = obj.get()\n */",
    "kotlin": "class SORTracker() {\n\n    fun add(name: String, score: Int) {\n        \n    }\n\n    fun get(): String {\n        \n    }\n\n}\n\n/**\n * Your SORTracker object will be instantiated and called as such:\n * var obj = SORTracker()\n * obj.add(name,score)\n * var param_2 = obj.get()\n */",
    "dart": "class SORTracker {\n\n  SORTracker() {\n    \n  }\n  \n  void add(String name, int score) {\n    \n  }\n  \n  String get() {\n    \n  }\n}\n\n/**\n * Your SORTracker object will be instantiated and called as such:\n * SORTracker obj = SORTracker();\n * obj.add(name,score);\n * String param2 = obj.get();\n */",
    "golang": "type SORTracker struct {\n    \n}\n\n\nfunc Constructor() SORTracker {\n    \n}\n\n\nfunc (this *SORTracker) Add(name string, score int)  {\n    \n}\n\n\nfunc (this *SORTracker) Get() string {\n    \n}\n\n\n/**\n * Your SORTracker object will be instantiated and called as such:\n * obj := Constructor();\n * obj.Add(name,score);\n * param_2 := obj.Get();\n */",
    "ruby": "class SORTracker\n    def initialize()\n        \n    end\n\n\n=begin\n    :type name: String\n    :type score: Integer\n    :rtype: Void\n=end\n    def add(name, score)\n        \n    end\n\n\n=begin\n    :rtype: String\n=end\n    def get()\n        \n    end\n\n\nend\n\n# Your SORTracker object will be instantiated and called as such:\n# obj = SORTracker.new()\n# obj.add(name, score)\n# param_2 = obj.get()",
    "scala": "class SORTracker() {\n\n    def add(name: String, score: Int): Unit = {\n        \n    }\n\n    def get(): String = {\n        \n    }\n\n}\n\n/**\n * Your SORTracker object will be instantiated and called as such:\n * val obj = new SORTracker()\n * obj.add(name,score)\n * val param_2 = obj.get()\n */",
    "rust": "struct SORTracker {\n\n}\n\n\n/** \n * `&self` means the method takes an immutable reference.\n * If you need a mutable reference, change it to `&mut self` instead.\n */\nimpl SORTracker {\n\n    fn new() -> Self {\n        \n    }\n    \n    fn add(&self, name: String, score: i32) {\n        \n    }\n    \n    fn get(&self) -> String {\n        \n    }\n}\n\n/**\n * Your SORTracker object will be instantiated and called as such:\n * let obj = SORTracker::new();\n * obj.add(name, score);\n * let ret_2: String = obj.get();\n */",
    "racket": "(define sor-tracker%\n  (class object%\n    (super-new)\n    \n    (init-field)\n    \n    ; add : string? exact-integer? -> void?\n    (define/public (add name score)\n      )\n    ; get : -> string?\n    (define/public (get)\n      )))\n\n;; Your sor-tracker% object will be instantiated and called as such:\n;; (define obj (new sor-tracker%))\n;; (send obj add name score)\n;; (define param_2 (send obj get))",
    "erlang": "-spec sor_tracker_init_() -> any().\nsor_tracker_init_() ->\n  .\n\n-spec sor_tracker_add(Name :: unicode:unicode_binary(), Score :: integer()) -> any().\nsor_tracker_add(Name, Score) ->\n  .\n\n-spec sor_tracker_get() -> unicode:unicode_binary().\nsor_tracker_get() ->\n  .\n\n\n%% Your functions will be called as such:\n%% sor_tracker_init_(),\n%% sor_tracker_add(Name, Score),\n%% Param_2 = sor_tracker_get(),\n\n%% sor_tracker_init_ will be called before every test case, in which you can do some necessary initializations.",
    "elixir": "defmodule SORTracker do\n  @spec init_() :: any\n  def init_() do\n    \n  end\n\n  @spec add(name :: String.t, score :: integer) :: any\n  def add(name, score) do\n    \n  end\n\n  @spec get() :: String.t\n  def get() do\n    \n  end\nend\n\n# Your functions will be called as such:\n# SORTracker.init_()\n# SORTracker.add(name, score)\n# param_2 = SORTracker.get()\n\n# SORTracker.init_ will be called before every test case, in which you can do some necessary initializations."
  }
}