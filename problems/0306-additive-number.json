{
  "title": "Additive Number",
  "problem_id": "306",
  "frontend_id": "306",
  "difficulty": "Medium",
  "problem_slug": "additive-number",
  "topics": [
    "String",
    "Backtracking"
  ],
  "description": "An additive number is a string whose digits can form an additive sequence.\nA valid additive sequence should contain at least three numbers. Except for the first two numbers, each subsequent number in the sequence must be the sum of the preceding two.\nGiven a string containing only digits, return true if it is an additive number or false otherwise.\nNote: Numbers in the additive sequence cannot have leading zeros, so sequence 1, 2, 03 or 1, 02, 3 is invalid.\nExample 1:\nExample 2:\nConstraints:\nFollow up: How would you handle overflow for very large input integers?",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: \"112358\"\nOutput: true\nExplanation: \nThe digits can form an additive sequence: 1, 1, 2, 3, 5, 8. \n1 + 1 = 2, 1 + 2 = 3, 2 + 3 = 5, 3 + 5 = 8",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input: \"199100199\"\nOutput: true\nExplanation: \nThe additive sequence is: 1, 99, 100, 199.Â \n1 + 99 = 100, 99 + 100 = 199",
      "images": []
    }
  ],
  "constraints": [
    "1 <= num.length <= 35",
    "num consists only of digits."
  ],
  "follow_ups": [
    "How would you handle overflow for very large input integers?"
  ],
  "hints": [],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    bool isAdditiveNumber(string num) {\n        \n    }\n};",
    "java": "class Solution {\n    public boolean isAdditiveNumber(String num) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def isAdditiveNumber(self, num):\n        \"\"\"\n        :type num: str\n        :rtype: bool\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def isAdditiveNumber(self, num: str) -> bool:\n        ",
    "c": "bool isAdditiveNumber(char* num) {\n    \n}",
    "csharp": "public class Solution {\n    public bool IsAdditiveNumber(string num) {\n        \n    }\n}",
    "javascript": "/**\n * @param {string} num\n * @return {boolean}\n */\nvar isAdditiveNumber = function(num) {\n    \n};",
    "typescript": "function isAdditiveNumber(num: string): boolean {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param String $num\n     * @return Boolean\n     */\n    function isAdditiveNumber($num) {\n        \n    }\n}",
    "swift": "class Solution {\n    func isAdditiveNumber(_ num: String) -> Bool {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun isAdditiveNumber(num: String): Boolean {\n        \n    }\n}",
    "dart": "class Solution {\n  bool isAdditiveNumber(String num) {\n    \n  }\n}",
    "golang": "func isAdditiveNumber(num string) bool {\n    \n}",
    "ruby": "# @param {String} num\n# @return {Boolean}\ndef is_additive_number(num)\n    \nend",
    "scala": "object Solution {\n    def isAdditiveNumber(num: String): Boolean = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn is_additive_number(num: String) -> bool {\n        \n    }\n}",
    "racket": "(define/contract (is-additive-number num)\n  (-> string? boolean?)\n  )",
    "erlang": "-spec is_additive_number(Num :: unicode:unicode_binary()) -> boolean().\nis_additive_number(Num) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec is_additive_number(num :: String.t) :: boolean\n  def is_additive_number(num) do\n    \n  end\nend"
  }
}