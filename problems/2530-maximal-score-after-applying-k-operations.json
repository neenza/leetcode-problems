{
  "title": "Maximal Score After Applying K Operations",
  "problem_id": "2616",
  "frontend_id": "2530",
  "difficulty": "Medium",
  "problem_slug": "maximal-score-after-applying-k-operations",
  "topics": [
    "Array",
    "Greedy",
    "Heap (Priority Queue)"
  ],
  "description": "You are given a 0-indexed integer array nums and an integer k. You have a starting score of 0.\nIn one operation:\nReturn the maximum possible score you can attain after applying exactly k operations.\nThe ceiling function ceil(val) is the least integer greater than or equal to val.\nExample 1:\nExample 2:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: nums = [10,10,10,10,10], k = 5\nOutput: 50\nExplanation: Apply the operation to each array element exactly once. The final score is 10 + 10 + 10 + 10 + 10 = 50.",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input: nums = [1,10,3,3,3], k = 3\nOutput: 17\nExplanation: You can do the following operations:\nOperation 1: Select i = 1, so nums becomes [1,4,3,3,3]. Your score increases by 10.\nOperation 2: Select i = 1, so nums becomes [1,2,3,3,3]. Your score increases by 4.\nOperation 3: Select i = 2, so nums becomes [1,2,1,3,3]. Your score increases by 3.\nThe final score is 10 + 4 + 3 = 17.",
      "images": []
    }
  ],
  "constraints": [
    "1 <= nums.length, k <= 105",
    "1 <= nums[i] <= 109"
  ],
  "follow_ups": [],
  "hints": [
    "It is always optimal to select the greatest element in the array.",
    "Use a heap to query for the maximum in O(log n) time."
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    long long maxKelements(vector<int>& nums, int k) {\n        \n    }\n};",
    "java": "class Solution {\n    public long maxKelements(int[] nums, int k) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def maxKelements(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def maxKelements(self, nums: List[int], k: int) -> int:\n        ",
    "c": "long long maxKelements(int* nums, int numsSize, int k) {\n    \n}",
    "csharp": "public class Solution {\n    public long MaxKelements(int[] nums, int k) {\n        \n    }\n}",
    "javascript": "/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number}\n */\nvar maxKelements = function(nums, k) {\n    \n};",
    "typescript": "function maxKelements(nums: number[], k: number): number {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @param Integer $k\n     * @return Integer\n     */\n    function maxKelements($nums, $k) {\n        \n    }\n}",
    "swift": "class Solution {\n    func maxKelements(_ nums: [Int], _ k: Int) -> Int {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun maxKelements(nums: IntArray, k: Int): Long {\n        \n    }\n}",
    "dart": "class Solution {\n  int maxKelements(List<int> nums, int k) {\n    \n  }\n}",
    "golang": "func maxKelements(nums []int, k int) int64 {\n    \n}",
    "ruby": "# @param {Integer[]} nums\n# @param {Integer} k\n# @return {Integer}\ndef max_kelements(nums, k)\n    \nend",
    "scala": "object Solution {\n    def maxKelements(nums: Array[Int], k: Int): Long = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn max_kelements(nums: Vec<i32>, k: i32) -> i64 {\n        \n    }\n}",
    "racket": "(define/contract (max-kelements nums k)\n  (-> (listof exact-integer?) exact-integer? exact-integer?)\n  )",
    "erlang": "-spec max_kelements(Nums :: [integer()], K :: integer()) -> integer().\nmax_kelements(Nums, K) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec max_kelements(nums :: [integer], k :: integer) :: integer\n  def max_kelements(nums, k) do\n    \n  end\nend"
  },
  "solution": "[TOC]\n\n## Solution\n\n---\n\n### Approach : Priority Queue\n\n#### Intuition\n\nWe are given an integer array `nums` and a number `k`. The goal is to maximize a starting score of 0 by performing an operation exactly `k` times. In each operation, we choose an index `i`, add `nums[i]` to the score, and replace `nums[i]` with `nums[i] / 3`.\n\nWe can solve this using a max heap, which allows us to access the largest element in the array efficiently. We need to select the largest number, add it to the score, and then replace it with one-third of its value, doing this `k` times.\n\nFirst, we build a max heap from the numbers in `nums`. For each operation, we extract the largest number, add it to the score, and replace it with its one-third value. We then push this new value back into the heap. Repeating this process `k` times ensures that the score is maximized.\n\n#### Algorithm\n\n1. Initialize an integer `ans` to store the total score:\n2. Create a max-heap (priority_queue) given by `pq` and push necessary elements of the array `nums` into the heap.\n3. Repeat the following steps `k` times:\n    - Extract the largest element from the heap using `pq.top()`, and remove it from the heap using `pq.pop()`.\n    - Add this largest element to `ans` to update the total score.\n    - Push the one-third value of the largest element (rounded up) into the heap.\n4. Return the value of `ans`.\n\n#### Implementation#### Complexity Analysis\n\nLet $n$ be the size of the given `nums` array.\n\n- Time complexity: $O(k \\log n + n \\log n)$\n\n    Initially, in worst case inserting all $n$ elements into the max-heap takes $O(n \\log n)$ time. \n    \n    Each of the $k$ operations involves extracting the largest element from the heap and inserting a new value back into it, both of which take $O(\\log n)$ time. Performing $k$ such operations results in a time complexity of $O(k \\log n)$.\n\n    Therefore, total time complexity is given by $O(k \\log n + n \\log n)$.\n\n- Space complexity: $O(n)$\n\n    The space complexity is dominated by the size of the max-heap, which contains at most $n$ elements. Therefore, the space complexity is $O(n)$.\n\n---"
}