{
  "title": "Check if Strings Can be Made Equal With Operations I",
  "problem_id": "2999",
  "frontend_id": "2839",
  "difficulty": "Easy",
  "problem_slug": "check-if-strings-can-be-made-equal-with-operations-i",
  "topics": [
    "String"
  ],
  "description": "You are given two strings s1 and s2, both of length 4, consisting of lowercase English letters.\nYou can apply the following operation on any of the two strings any number of times:\nReturn true if you can make the strings s1 and s2 equal, and false otherwise.\nExample 1:\nExample 2:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: s1 = \"abcd\", s2 = \"cdab\"\nOutput: true\nExplanation: We can do the following operations on s1:\n- Choose the indices i = 0, j = 2. The resulting string is s1 = \"cbad\".\n- Choose the indices i = 1, j = 3. The resulting string is s1 = \"cdab\" = s2.",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input: s1 = \"abcd\", s2 = \"dacb\"\nOutput: false\nExplanation: It is not possible to make the two strings equal.",
      "images": []
    }
  ],
  "constraints": [
    "s1.length == s2.length == 4",
    "s1 and s2 consist only of lowercase English letters."
  ],
  "follow_ups": [],
  "hints": [
    "<div class=\"_1l1MA\">Since the strings are very small you can try a brute-force approach.</div>",
    "<div class=\"_1l1MA\">There are only <code>2</code> different swaps that are possible in a string.</div>"
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    bool canBeEqual(string s1, string s2) {\n        \n    }\n};",
    "java": "class Solution {\n    public boolean canBeEqual(String s1, String s2) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def canBeEqual(self, s1, s2):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :rtype: bool\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def canBeEqual(self, s1: str, s2: str) -> bool:\n        ",
    "c": "bool canBeEqual(char* s1, char* s2) {\n    \n}",
    "csharp": "public class Solution {\n    public bool CanBeEqual(string s1, string s2) {\n        \n    }\n}",
    "javascript": "/**\n * @param {string} s1\n * @param {string} s2\n * @return {boolean}\n */\nvar canBeEqual = function(s1, s2) {\n    \n};",
    "typescript": "function canBeEqual(s1: string, s2: string): boolean {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param String $s1\n     * @param String $s2\n     * @return Boolean\n     */\n    function canBeEqual($s1, $s2) {\n        \n    }\n}",
    "swift": "class Solution {\n    func canBeEqual(_ s1: String, _ s2: String) -> Bool {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun canBeEqual(s1: String, s2: String): Boolean {\n        \n    }\n}",
    "dart": "class Solution {\n  bool canBeEqual(String s1, String s2) {\n    \n  }\n}",
    "golang": "func canBeEqual(s1 string, s2 string) bool {\n    \n}",
    "ruby": "# @param {String} s1\n# @param {String} s2\n# @return {Boolean}\ndef can_be_equal(s1, s2)\n    \nend",
    "scala": "object Solution {\n    def canBeEqual(s1: String, s2: String): Boolean = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn can_be_equal(s1: String, s2: String) -> bool {\n        \n    }\n}",
    "racket": "(define/contract (can-be-equal s1 s2)\n  (-> string? string? boolean?)\n  )",
    "erlang": "-spec can_be_equal(S1 :: unicode:unicode_binary(), S2 :: unicode:unicode_binary()) -> boolean().\ncan_be_equal(S1, S2) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec can_be_equal(s1 :: String.t, s2 :: String.t) :: boolean\n  def can_be_equal(s1, s2) do\n    \n  end\nend"
  }
}