{
  "title": "Stickers to Spell Word",
  "problem_id": "691",
  "frontend_id": "691",
  "difficulty": "Hard",
  "problem_slug": "stickers-to-spell-word",
  "topics": [
    "Array",
    "Hash Table",
    "String",
    "Dynamic Programming",
    "Backtracking",
    "Bit Manipulation",
    "Memoization",
    "Bitmask"
  ],
  "description": "We are given n different types of stickers. Each sticker has a lowercase English word on it.\nYou would like to spell out the given string target by cutting individual letters from your collection of stickers and rearranging them. You can use each sticker more than once if you want, and you have infinite quantities of each sticker.\nReturn the minimum number of stickers that you need to spell out target. If the task is impossible, return -1.\nNote: In all test cases, all words were chosen randomly from the 1000 most common US English words, and target was chosen as a concatenation of two random words.\nExample 1:\nExample 2:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: stickers = [\"with\",\"example\",\"science\"], target = \"thehat\"\nOutput: 3\nExplanation:\nWe can use 2 \"with\" stickers, and 1 \"example\" sticker.\nAfter cutting and rearrange the letters of those stickers, we can form the target \"thehat\".\nAlso, this is the minimum number of stickers necessary to form the target string.",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input: stickers = [\"notice\",\"possible\"], target = \"basicbasic\"\nOutput: -1\nExplanation:\nWe cannot form the target \"basicbasic\" from cutting letters from the given stickers.",
      "images": []
    }
  ],
  "constraints": [
    "n == stickers.length",
    "1 <= n <= 50",
    "1 <= stickers[i].length <= 10",
    "1 <= target.length <= 15",
    "stickers[i] and target consist of lowercase English letters."
  ],
  "follow_ups": [],
  "hints": [
    "We want to perform an exhaustive search, but we need to speed it up based on the input data being random.  \r\n\r\nFor all stickers, we can ignore any letters that are not in the target word.  \r\n\r\nWhen our candidate answer won't be smaller than an answer we have already found, we can stop searching this path.  \r\n\r\nWhen a sticker dominates another, we shouldn't include the dominated sticker in our sticker collection.  [Here, we say a sticker `A` dominates `B` if `A.count(letter) >= B.count(letter)` for all letters.]"
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    int minStickers(vector<string>& stickers, string target) {\n        \n    }\n};",
    "java": "class Solution {\n    public int minStickers(String[] stickers, String target) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def minStickers(self, stickers, target):\n        \"\"\"\n        :type stickers: List[str]\n        :type target: str\n        :rtype: int\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def minStickers(self, stickers: List[str], target: str) -> int:\n        ",
    "c": "int minStickers(char** stickers, int stickersSize, char* target) {\n    \n}",
    "csharp": "public class Solution {\n    public int MinStickers(string[] stickers, string target) {\n        \n    }\n}",
    "javascript": "/**\n * @param {string[]} stickers\n * @param {string} target\n * @return {number}\n */\nvar minStickers = function(stickers, target) {\n    \n};",
    "typescript": "function minStickers(stickers: string[], target: string): number {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param String[] $stickers\n     * @param String $target\n     * @return Integer\n     */\n    function minStickers($stickers, $target) {\n        \n    }\n}",
    "swift": "class Solution {\n    func minStickers(_ stickers: [String], _ target: String) -> Int {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun minStickers(stickers: Array<String>, target: String): Int {\n        \n    }\n}",
    "dart": "class Solution {\n  int minStickers(List<String> stickers, String target) {\n    \n  }\n}",
    "golang": "func minStickers(stickers []string, target string) int {\n    \n}",
    "ruby": "# @param {String[]} stickers\n# @param {String} target\n# @return {Integer}\ndef min_stickers(stickers, target)\n    \nend",
    "scala": "object Solution {\n    def minStickers(stickers: Array[String], target: String): Int = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn min_stickers(stickers: Vec<String>, target: String) -> i32 {\n        \n    }\n}",
    "racket": "(define/contract (min-stickers stickers target)\n  (-> (listof string?) string? exact-integer?)\n  )",
    "erlang": "-spec min_stickers(Stickers :: [unicode:unicode_binary()], Target :: unicode:unicode_binary()) -> integer().\nmin_stickers(Stickers, Target) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec min_stickers(stickers :: [String.t], target :: String.t) :: integer\n  def min_stickers(stickers, target) do\n    \n  end\nend"
  },
  "solution": "[TOC]\n\n### Approach 1: Optimized Exhaustive Search**Intuition**\n\nA natural answer is to exhaustively search for combinations of stickers. Because the data is randomized, there are many heuristics available to us that will make this faster.\n\n* For all stickers, we can ignore any letters that are not in the target word.\n\n* When our candidate's answer won't be smaller than an answer we have already found, we can stop searching this path.\n\n* We should try to have our exhaustive search bound to the answer as soon as possible, so the effect described in the above point happens more often.\n\n* When a sticker dominates another, we shouldn't include the dominant sticker in our sticker collection.  [Here, we say a sticker `A` dominates `B` if `A.count(letter) >= B.count(letter)` for all letters.]**Algorithm**\n\nFirstly, for each sticker, let's create a count of that sticker (a mapping `letter -> sticker.count(letter)`) that does not consider letters not in the target word.  Let `A` be an array of these counts.  Also, let's create `t_count`, a count of our `target` word.\n\nSecondly, let's remove dominated stickers. Because dominance is a transitive relation, we only need to check if a sticker is not dominated by any other sticker once - the ones that aren't dominated are included in our collection.\n\nWe are now ready to begin our exhaustive search. A call to `search(ans)` denotes that we want to decide the minimum number of stickers we can use in `A` to satisfy the target count `t_count`. `ans` will store the currently formed answer, and `best` will store the current best answer.\n\nIf our current answer can't beat our current best answer, we should stop searching.  Also, if there are no stickers left and our target is satisfied, we should update our answer.\n\nOtherwise, we want to know the maximum number of these stickers we can use. For example, if this sticker is `'abb'` and our target is `'aaabbbbccccc'`, then we could use a maximum of 3 stickers.  This is the maximum of `math.ceil(target.count(letter) / sticker.count(letter))`, taken over all `letter`s in `sticker`.  Let's call this quantity `used`.\n\nAfter, for the sticker we are currently considering, we try to use `used` of them, then `used - 1`, `used - 2`, and so on. The reason we do it in this order is so that we can arrive at a value for `best` more quickly, which will stop other branches of our exhaustive search from continuing.\n\nThe Python version of this solution showcases using `collections.Counter` as a way to simplify some code sections, whereas the Java solution sticks to arrays.**Complexity Analysis**\n\n* Time Complexity: Let $$N$$ be the number of stickers, and $$T$$ be the number of letters in the target word. A bound for time complexity is $$O(N^{T+1} T^2)$$: for each sticker, we'll have to try using it up to $$T+1$$ times, and updating our target count costs $$O(T)$$, which we do up to $$T$$ times. Alternatively, since the answer is bounded at $$T$$, we can prove that we can only search up to $$\\binom{N+T-1}{T-1}$$ times. This would be $$O(\\binom{N+T-1}{T-1} T^2)$$.\n\n* Space Complexity: $$O(N+T)$$, to store `stickersCount`, `targetCount`, and handle the recursive call stack when calling `search`.---\n### Approach 2: Dynamic Programming**Intuition**\n\nSuppose we need `dp[state]` stickers to satisfy all `target[i]`'s for which the `i`-th bit of `state` is set. We would like to know `dp[(1 << len(target)) - 1]`.**Algorithm**\n\nFor each `state`, let's work with it as `now` and look at what happens to it after applying a sticker. For each letter in the sticker that can satisfy an unset bit of `state`, we set the bit (`now |= 1 << i`). In the end, we know `now` is the result of applying that sticker to `state`, and we update our `dp` appropriately.\n\nWhen using Python, we will need some extra techniques from *Approach #1* to pass in time.**Complexity Analysis**\n\n* Time Complexity: $$O(2^T * S * T)$$ where $$S$$ is the total number of letters in all stickers, and $$T$$ is the number of letters in the target word. We can examine each loop carefully to arrive at this conclusion.\n\n* Space Complexity: $$O(2^T)$$, the space used by `dp`."
}