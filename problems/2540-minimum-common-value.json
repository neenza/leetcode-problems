{
  "title": "Minimum Common Value",
  "problem_id": "2634",
  "frontend_id": "2540",
  "difficulty": "Easy",
  "problem_slug": "minimum-common-value",
  "topics": [
    "Array",
    "Hash Table",
    "Two Pointers",
    "Binary Search"
  ],
  "description": "Given two integer arrays nums1 and nums2, sorted in non-decreasing order, return the minimum integer common to both arrays. If there is no common integer amongst nums1 and nums2, return -1.\nNote that an integer is said to be common to nums1 and nums2 if both arrays have at least one occurrence of that integer.\nExample 1:\nExample 2:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: nums1 = [1,2,3], nums2 = [2,4]\nOutput: 2\nExplanation: The smallest element common to both arrays is 2, so we return 2.",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input: nums1 = [1,2,3,6], nums2 = [2,3,4,5]\nOutput: 2\nExplanation: There are two common elements in the array 2 and 3 out of which 2 is the smallest, so 2 is returned.",
      "images": []
    }
  ],
  "constraints": [
    "1 <= nums1.length, nums2.length <= 105",
    "1 <= nums1[i], nums2[j] <= 109",
    "Both nums1 and nums2 are sorted in non-decreasing order."
  ],
  "follow_ups": [],
  "hints": [
    "Try to use a set.",
    "Otherwise, try to use a two-pointer approach."
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    int getCommon(vector<int>& nums1, vector<int>& nums2) {\n        \n    }\n};",
    "java": "class Solution {\n    public int getCommon(int[] nums1, int[] nums2) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def getCommon(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: int\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def getCommon(self, nums1: List[int], nums2: List[int]) -> int:\n        ",
    "c": "int getCommon(int* nums1, int nums1Size, int* nums2, int nums2Size) {\n    \n}",
    "csharp": "public class Solution {\n    public int GetCommon(int[] nums1, int[] nums2) {\n        \n    }\n}",
    "javascript": "/**\n * @param {number[]} nums1\n * @param {number[]} nums2\n * @return {number}\n */\nvar getCommon = function(nums1, nums2) {\n    \n};",
    "typescript": "function getCommon(nums1: number[], nums2: number[]): number {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param Integer[] $nums1\n     * @param Integer[] $nums2\n     * @return Integer\n     */\n    function getCommon($nums1, $nums2) {\n        \n    }\n}",
    "swift": "class Solution {\n    func getCommon(_ nums1: [Int], _ nums2: [Int]) -> Int {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun getCommon(nums1: IntArray, nums2: IntArray): Int {\n        \n    }\n}",
    "dart": "class Solution {\n  int getCommon(List<int> nums1, List<int> nums2) {\n    \n  }\n}",
    "golang": "func getCommon(nums1 []int, nums2 []int) int {\n    \n}",
    "ruby": "# @param {Integer[]} nums1\n# @param {Integer[]} nums2\n# @return {Integer}\ndef get_common(nums1, nums2)\n    \nend",
    "scala": "object Solution {\n    def getCommon(nums1: Array[Int], nums2: Array[Int]): Int = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn get_common(nums1: Vec<i32>, nums2: Vec<i32>) -> i32 {\n        \n    }\n}",
    "racket": "(define/contract (get-common nums1 nums2)\n  (-> (listof exact-integer?) (listof exact-integer?) exact-integer?)\n  )",
    "erlang": "-spec get_common(Nums1 :: [integer()], Nums2 :: [integer()]) -> integer().\nget_common(Nums1, Nums2) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec get_common(nums1 :: [integer], nums2 :: [integer]) :: integer\n  def get_common(nums1, nums2) do\n    \n  end\nend"
  },
  "solution": "[TOC]\n\n## Solution\n\n---\n\n### Overview\n\nGiven the arrays `nums1` and `nums2`, we aim to find the minimum integer common to both arrays. `nums1` and `nums2` are both sorted in increasing order. If there is no common integer, return `-1`.\n\nA common value between two arrays appears in both arrays at least once.\n\n---\n\n### Approach 1: Hash Set\n\n#### Intuition\n\nThe brute force approach to solving this problem would be to use nested loops to iterate through each number in each array, searching for common values, and then calculate the minimum of the common values. Nested loops are inefficient. It would be helpful if, instead of searching through an array to find a value, we could look up an element in constant time. Hash tables are a data structure that facilitate constant time lookups. \n\nThere are two main kinds of hash tables: hash maps, which store (key, value) pairs, and hash sets, which store unique values. For this problem, we chose a hash set because we are concerned with whether an element exists, not the number of times it occurs. A hashmap could alternatively be used to solve this problem, where the element is the key and the frequency is the value. Check out the [hash table explore card](https://leetcode.com/explore/learn/card/hash-table/) to learn more about hash tables.\n\nWe can add the elements in `nums1` to a hash set `set1`, where the element is the key. \n\nThen, we can loop through `nums2`, and check whether each element is in `set1`. Since `nums2` is in sorted order, the first common element we find is the minimum common element.\n\n#### Algorithm\n\n1. Initialize a set `set1` and add the elements from `nums1`.\n2. For each `num` in `nums2`:\n    - If `num` is in `set1`, return `num`. We found a common element. Since `nums2` is sorted in ascending order, the first common element is the minimum common element.\n3. Return `-1` if there are no common elements.\n\n#### Implementation#### Complexity Analysis\n\nLet $n$ be the length of `nums1` and $m$ be the length of `nums2.`\n\n* Time complexity: $O(n + m)$\n\n    Creating `set1` takes $O(n)$.\n\n    We search for each element of `nums2` in `set1`. Searching for an element in a hash set takes $O(1)$ on average, so the time complexity of this step is $O(m)$.\n\n    The total time complexity will be $O(n + m)$.\n\n\n* Space complexity: $O(n)$\n\n    We initialize the set `set1`, which is size $O(e)$ where $e$ is the number of distinct elements in `nums1`. At worst, there can be $n$ distinct elements, so the space complexity is $O(n)$.\n\n##### Set Intersection\n\nNote that given two sets, their intersection is all of their common elements. Another approach to solving this problem would be to create sets out of `nums1` and `nums2`, then find the minimum value of the intersection. Below is the Python3 code for this approach. This approach is less straightforward for languages that do not have built-in set functions and requires more space than the other approaches without an improvement in time complexity, so it is not discussed in depth.---\n\n### Approach 2: Two Pointers\n\n#### Intuition\n\n Our objective is to find the minimum common value between two arrays. As discussed previously, the brute force approach would be to iterate through both arrays, searching for common values. This approach would be inefficient, with a time complexity of $O(n \\cdot m)$.\n\nCan we develop a more efficient approach without using extra space?\n\nLet's look at some examples to develop a strategy.\n\n##### Example 1:\n\n> **Input:** nums1 = [1, 2, 3, 4, 5], nums2 = [1, 3, 5]\n>\n> **Output:** 1\n>\n> **Explanation:** There are three common elements in the arrays, 1, 3, and 5, out of which 1 is the smallest, so 1 is returned.\n\n##### Example 2:\n\n> **Input:** nums1 = [2, 4, 6, 8, 10], nums2 = [1, 2, 3, 4, 5]\n>\n> **Output:** 2\n>\n> **Explanation:** There are two common elements in the arrays, 2, and 4, out of which 2 is the smallest, so 2 is returned.\n\nWhat patterns can we deduce from examining these examples? \n\nNotice that since the arrays are sorted, and our objective is to find the minimum common value, the first common value we find when traversing both arrays left to right is the minimum common value.\n\nWe can leverage this fact to develop an efficient solution.\n\nWe can use two pointers to traverse both arrays simultaneously without a nested loop.\n\n `first` will indicate the position in `nums1`, and `second` will indicate the position in `nums2`.\n \n During each iteration, we compare the values of `nums1[first]` and `nums2[second]`. There are three possibilities.\n \n 1. The elements are equal. We have found a common value, and we return it.\n\n 2. `nums1[first] < nums2[second]`. Because `nums2` is sorted, every element after `second` will also be greater than `nums1[first]`. However, there is a chance that an element in `nums1` after `first` will be equal to `nums2[second]`. Thus, we should increment `first`.\n\n3. `nums1[first] > nums2[second]`. The logic works the other way visa versa. We should increment `second`.\n\nBy traversing the arrays in this manner, we will find the first common value, if it exists.\n\n> How do we know this approach will consistently provide the correct solution?\n>\n> We always increment the pointer which points to the lower value. This means we will process all the elements from both arrays in ascending order. \n>\n> Our algorithm stops in three cases:\n>\n> 1. A common element is found: it must be the minimum common value because elements are processed in order.\n>\n> 2. Both pointers reach the end of their array: all elements were checked, and there were no common values.\n> \n> 3. One pointer reaches the end of its array, and the element it points to is less than the current element in the other array: all remaining elements in the other array are larger than this element, so there are no common elements.\n\n\nBelow is a visualization of this algorithm:\n\n\n!?!../Documents/2540/2540_slideshow.json:960,540!?!\n\n\n#### Algorithm\n\n1. Initialize two variables: `first`, which will store the position in `nums1`, and `second`, which will store the position in `nums2` to `0`, the starting index.\n2. Iterate through `nums1` and `nums2` while `first` is less than the size of `nums1` and `second` is less than the size of `nums2`:\n    - If `nums1[first]` is less than `nums2[second]`, increment `first` by `1` because we need a larger value from `nums1` to match the value at `nums2[second]`.\n    - If `nums1[first]` is greater than `nums2[second]`, increment `second` by `1` because we need a larger value from `nums2` to match the value at `nums1[first]`.\n    - Otherwise, `nums1[first]` must equal `nums2[second]`, so return the value of `nums1[first]`. We have found the minimum common value.\n4. Return `-1` if the loop completes without returning an answer. This means there is no common value between `nums1` and `nums2`.\n\n\n#### Implementation#### Complexity Analysis\n\nLet $n$ be the length of `nums1` and $m$ be the length of `nums2`.\n\n* Time complexity: $O(n + m)$\n\n    We iterate through `nums1` and `nums2` using two pointers. On each iteration of the loop, one of the pointers is incremented, but not both. Each pointer can be incremented as many times as $n$ or $m$, respectively, meaning we will iterate at most $n + m$ times. With each iteration, we performed $O(1)$ work. Therefore, the time complexity is $O(n + m)$.\n\n\n* Space complexity: $O(1)$\n\n    We use a couple of variables and no additional data structures that grow with input size, so the space complexity is constant, $O(1)$.\n\n\n### Approach 3: Binary Search\n\n#### Intuition\n\n\nTo solve this problem, we need to search for common values between two arrays. The arrays are sorted, which means we can utilize binary search. \n\n> Binary search is a search algorithm that finds the position of a target value within a sorted array.\n\nIf you are unfamiliar with binary search, check out the [binary search explore card](https://leetcode.com/explore/learn/card/binary-search/). \n\nBinary search uses three pointers. We can call them `left`, `mid`, and `right`.\n\nInitially, `left` points to the first index of the array and `right` points to the last. At each step, we calculate `mid` as the middle element between `left` and `right`.\n\nBinary search compares the target value with the middle element at each iteration.\n\n - If the target value is equal to the middle element, the target has been found.\n\n- If the target value is less than the middle element, continue to search in the left half.\n\n- If the target value is greater than the middle element, continue to search in the right half.\n\nWith every iteration, the search window is divided in half, and the search is continued in either the right or the left side until either the target is found or `left` becomes greater than `right`.\n\nWe can solve the problem by iterating through each element in `nums1`, and using binary search to find that element in `nums2`. We want to perform binary search on the longer array, which will make the algorithm more efficient, so if `nums1` is longer, we swap the arrays.\n\nBelow is a visualization of this algorithm:\n\n\n!?!../Documents/2540/2540_slideshow2.json:960,540!?!\n\n\n#### Algorithm\n\n##### Implementation Note: \n`mid`, the middle of the subarray, is set to the index in the middle of the array. The basic midpoint formula is `(left + right) / 2`.\nYou'll notice that the below implementations instead use `left + (right - left) / 2`. This is because if `left + right` is greater than the maximum integer value, $2^{31} - 1$, it overflows and causes errors. \n\n`left + (right - left) / 2` is an equivalent formula, and never stores a value larger than `left` or `right`. Thus, if `left` and `right` are within the integer limits, we will never overflow.\n\n\n1. Declare a function `binarySearch` that takes an array `nums` and a target value as parameters and returns `true` if the target is in the array.\n    - Initialize `left` pointer to `0` and `right` pointer to `nums.length -1`. These represent the first and last indices of the array.\n    - While `left` is less than or equal to `right`, iteratively perform a binary search:\n        - Set `mid` to `left + (right - left) / 2`, which is the middle of this section of `nums`. We will compare `nums[mid]` to `target`.\n        - If `nums[mid]` is greater than `target`, set `right` to `mid - 1`, we will continue to search in the left half `nums`.\n        - If `nums[mid]` is less than `target`, set `left` to `mid + 1`, we will continue to search in the right half `nums`.\n        - Otherwise, `nums[mid]` equals `target`, return `true`.\n2. If `nums1` is longer than `nums2`, call getCommon with the arrays swapped.\n3. Iterate through each `num` in `nums1`, using binary search to determine whether that element is in `nums2`:\n    - If `num` is found in `nums2`, we can return `num`. This is guaranteed to be the minimum common value, because both arrays are sorted.\n4. If we did not find any common elements, return `-1`. There is no common value.\n\n\n#### Implementation#### Complexity Analysis\n\nLet $n$ be the length of the shorter array and $m$ be the length of the longer array.\n\n* Time complexity: $O(n \\log m)$\n\n    We iterate through the shorter array, using binary search to look for each element in the longer array. Binary Search takes $O( \\log m)$ time to search through $m$ elements, so the overall time complexity is $O(n \\log m)$.\n    \n    If one of the arrays is very large relative to the other, this approach will be more efficient than the previous two.\n\n\n* Space complexity: $O(1)$\n\n     We use a couple of variables and no additional data structures that grow with input size, so the space complexity is constant, $O(1)$."
}