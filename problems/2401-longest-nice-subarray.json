{
  "title": "Longest Nice Subarray",
  "problem_id": "2478",
  "frontend_id": "2401",
  "difficulty": "Medium",
  "problem_slug": "longest-nice-subarray",
  "topics": [
    "Array",
    "Bit Manipulation",
    "Sliding Window"
  ],
  "description": "You are given an array nums consisting of positive integers.\nWe call a subarray of nums nice if the bitwise AND of every pair of elements that are in different positions in the subarray is equal to 0.\nReturn the length of the longest nice subarray.\nA subarray is a contiguous part of an array.\nNote that subarrays of length 1 are always considered nice.\nExample 1:\nExample 2:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: nums = [1,3,8,48,10]\nOutput: 3\nExplanation: The longest nice subarray is [3,8,48]. This subarray satisfies the conditions:\n- 3 AND 8 = 0.\n- 3 AND 48 = 0.\n- 8 AND 48 = 0.\nIt can be proven that no longer nice subarray can be obtained, so we return 3.",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input: nums = [3,1,5,11,13]\nOutput: 1\nExplanation: The length of the longest nice subarray is 1. Any subarray of length 1 can be chosen.",
      "images": []
    }
  ],
  "constraints": [
    "1 <= nums.length <= 105",
    "1 <= nums[i] <= 109"
  ],
  "follow_ups": [],
  "hints": [
    "What is the maximum possible length of a nice subarray?",
    "If two numbers have bitwise AND equal to zero, they do not have any common set bit. A number <code>x <= 10<sup>9</sup></code> only has 30 bits, hence the length of the longest nice subarray cannot exceed 30."
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    int longestNiceSubarray(vector<int>& nums) {\n        \n    }\n};",
    "java": "class Solution {\n    public int longestNiceSubarray(int[] nums) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def longestNiceSubarray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def longestNiceSubarray(self, nums: List[int]) -> int:\n        ",
    "c": "int longestNiceSubarray(int* nums, int numsSize) {\n    \n}",
    "csharp": "public class Solution {\n    public int LongestNiceSubarray(int[] nums) {\n        \n    }\n}",
    "javascript": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar longestNiceSubarray = function(nums) {\n    \n};",
    "typescript": "function longestNiceSubarray(nums: number[]): number {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @return Integer\n     */\n    function longestNiceSubarray($nums) {\n        \n    }\n}",
    "swift": "class Solution {\n    func longestNiceSubarray(_ nums: [Int]) -> Int {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun longestNiceSubarray(nums: IntArray): Int {\n        \n    }\n}",
    "dart": "class Solution {\n  int longestNiceSubarray(List<int> nums) {\n    \n  }\n}",
    "golang": "func longestNiceSubarray(nums []int) int {\n    \n}",
    "ruby": "# @param {Integer[]} nums\n# @return {Integer}\ndef longest_nice_subarray(nums)\n    \nend",
    "scala": "object Solution {\n    def longestNiceSubarray(nums: Array[Int]): Int = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn longest_nice_subarray(nums: Vec<i32>) -> i32 {\n        \n    }\n}",
    "racket": "(define/contract (longest-nice-subarray nums)\n  (-> (listof exact-integer?) exact-integer?)\n  )",
    "erlang": "-spec longest_nice_subarray(Nums :: [integer()]) -> integer().\nlongest_nice_subarray(Nums) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec longest_nice_subarray(nums :: [integer]) :: integer\n  def longest_nice_subarray(nums) do\n    \n  end\nend"
  },
  "solution": "[TOC]\n\n## Solution\n\n---\n\n### Approach 1: Brute Force\n\n#### Intuition\n\nOur task is to find the longest contiguous sequence in the array where the bitwise AND of any two elements is 0. First, let's understand what makes a subarray \"nice\" according to the given definition. A nice subarray is one where the bitwise AND of any two distinct elements equals zero. This means that for any pair of numbers in our subarray, their binary representations must not have any overlapping set bits (`1`s in the same positions).\n\nWhen two numbers have no overlapping set bits, we can say they are \"bit-disjoint.\" For example, 5 (`101` in binary) and 7 (`111` in binary) are not bit-disjoint since they both have a `1` in the first and third positions from the right. However, 5 (`101`) and 8 (`1000`) are bit-disjoint since they have no `1`s in the same bit positions.\n\nA brute force approach would be to try each possible starting position and extend the subarray as far as possible. We can keep a running counter `maxLength` which can store the longest subarray we encounter in the traversals. But how do we efficiently check whether a subarray is \"nice\"?\n\nOne approach would be to examine each subarray using nested loops to check if they are \"nice.\" However, this would have a quadratic complexity just to identify each subarray, making it too slow for the given constraints.\n\nThe key insight is that we need to track which bit positions are already \"used\" within our current subarray. If a new number wants to join our nice subarray, it must not have any bits set in positions that are already used by other numbers in the subarray.\n\nA **bitmask** is the perfect tool for this job. As we traverse a potential subarray, we maintain a single integer (the bitmask) where each bit represents whether that position has been \"used\" by any number so far.\n\nFor example, consider numbers 4 (`100` in binary), 2 (`010` in binary), and 1 (`001` in binary). When considering a new element, we test if any of its bits overlap with our existing bitmask. If there is an overlap, the subarray is no longer \"nice\" since two numbers now share a set bit.\n\nOtherwise, we add the current number's bits into our bitmask using the OR operation. This operation updates our tracking of occupied bit positions. \n\nAfter updating our bitmask, we increment our current subarray length and continue this process until we encounter a number that conflicts with our existing bits. Once we find such a number, we update our `maxLength` if the current subarray is longer than any we've seen before, and then we start a new potential nice subarray from the next position.\n\n> For a more comprehensive understanding of bit manipulation, check out the [Bit Manipulation Explore Card](https://leetcode.com/explore/learn/card/bit-manipulation/). This resource provides an in-depth look at bit-level operations, explaining their key concepts and applications with a variety of problems to solidify understanding of the pattern.\n\n#### Algorithm\n\n- Initialize a variable `maxLength` to `1`, which will track the maximum nice subarray length found.\n- Iterate through each possible starting position `start` in the array, up to the length minus the current `maxLength`:\n  - Initialize variables:\n    - `currentLength` to `1`, which represents the length of the current nice subarray.\n    - `usedBits` to the value at the current starting position, which tracks which bits are used in our subarray.\n  - Iterate through subsequent positions `end` in the array, starting from the position after `start`. For each position:\n    - If the bitwise AND of the `usedBits` and the value at the current position is `0`:\n      - Update `usedBits` by performing a bitwise OR with the value at the current position.\n      - Increment `currentLength` by `1`.\n    - If it is not `0`, break the inner loop since we can't extend the nice subarray further.\n  - Update `maxLength` to be the maximum of the current `maxLength` and `currentLength`.\n- Return `maxLength` as the result.\n\n#### Implementation#### Complexity Analysis\n\nLet $n$ be the length of the input array `nums`.\n\n- Time complexity: $O(n^2)$\n\n    The algorithm uses two nested loops. The outer loop iterates through all possible starting positions, which is $O(n)$. For each starting position, the inner loop can potentially iterate through all remaining elements in the worst case, which is also $O(n)$. Therefore, the overall time complexity is $O(n^2)$.\n\n- Space complexity: $O(1)$\n\n    The algorithm only uses a constant amount of extra space regardless of the input size. It maintains a few variables (`maxLength`, `currentLength`, `usedBits`) that do not scale with the input size, so the space complexity is $O(1)$.\n\n---\n\n### Approach 2: Sliding Window\n\n#### Intuition\n\nOur previous approach examined all possible starting positions and extended each subarray as far as possible. Now, let's try a more efficient technique. We'll build our solution by taking larger and larger subarrays until adding a new element breaks the \"nice\" property. When this happens, we need to remove elements from the beginning until we restore that property.\n\nThis idea naturally translates to a variable-size sliding window approach. To check the validity of each window, we can use a similar concept as the previous approach, by using a bitmask to store all the bits already used in the window (let's call it `usedBits`). \n\nWe start with an empty window and expand it by adding elements one by one. Each time we add a new element, we check whether it conflicts with our existing window by seeing if any of its bits overlap with `usedBits`. If there is an overlap, the subarray is no longer \"nice\" because two elements now share a set bit.  \n\nWhen a conflict occurs, we shrink the window from the left by removing elements until the conflict is resolved. Each time we remove an element, we clear its bits from the `usedBits` tracker by XOR'ing it with the element being removed. \n\nThroughout this process, we maintain a variable `maxLength` to track the longest \"nice\" subarray we have found. Whenever we expand the window without conflicts, we update `maxLength`. By the end of the iteration, `maxLength` will contain the length of the longest valid subarray.\n\nHere's a slideshow to demonstrate this algorithm in action:\n\n!?!../Documents/2401/slideshow.json:682,602!?!\n\n> For a more comprehensive understanding of the sliding window technique, check out the [Sliding Window Explore Card](https://leetcode.com/explore/learn/card/array-and-string/204/sliding-window/). This resource provides an in-depth look at the sliding window approach, explaining its key concepts and applications with a variety of problems to solidify understanding of the pattern.\n\n#### Algorithm\n\n- Initialize variables:\n  - `usedBits` to `0`, which tracks the bits currently used in the sliding window.\n  - `windowStart` to `0`, representing the starting position of the current window.\n  - `maxLength` to `0`, which will store the length of the longest nice subarray found.\n- Iterate through the array with a variable `windowEnd` from `0` to the length of `nums`:\n  - While the current number at `windowEnd` shares any bits with the `usedBits` (their bitwise AND is not 0):\n    - Remove the bits of the leftmost element in the window from `usedBits` using bitwise XOR.\n    - Increment `windowStart` to shrink the window from the left.\n  - Add the bits of the current number to `usedBits` using bitwise OR.\n  - Update `maxLength` to the maximum of the current `maxLength` and the current window size (calculated as `windowEnd - windowStart + 1`).\n- Return the final `maxLength`.\n\n#### Implementation#### Complexity Analysis\n\nLet $n$ be the length of the input array `nums`.  \n\n- Time complexity: $O(n)$  \n\n    The algorithm maintains a sliding window that dynamically adjusts its size to ensure the subarray remains nice. Each element is added to the window at most once and removed at most once, resulting in a total of $O(n)$ operations. The bitwise operations inside the loop run in constant time per element, keeping the overall complexity linear.  \n\n- Space complexity: $O(1)$  \n\n    The algorithm uses only a few integer variables (`usedBits`, `windowStart`, and `maxLength`), all of which require constant space. Since no additional data structures are used that grow with $n$, the space complexity remains constant.\n\n---"
}