{
  "title": "Shifting Letters II",
  "problem_id": "2465",
  "frontend_id": "2381",
  "difficulty": "Medium",
  "problem_slug": "shifting-letters-ii",
  "topics": [
    "Array",
    "String",
    "Prefix Sum"
  ],
  "description": "You are given a string s of lowercase English letters and a 2D integer array shifts where shifts[i] = [starti, endi, directioni]. For every i, shift the characters in s from the index starti to the index endi (inclusive) forward if directioni = 1, or shift the characters backward if directioni = 0.\nShifting a character forward means replacing it with the next letter in the alphabet (wrapping around so that 'z' becomes 'a'). Similarly, shifting a character backward means replacing it with the previous letter in the alphabet (wrapping around so that 'a' becomes 'z').\nReturn the final string after all such shifts to s are applied.\nExample 1:\nExample 2:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: s = \"abc\", shifts = [[0,1,0],[1,2,1],[0,2,1]]\nOutput: \"ace\"\nExplanation: Firstly, shift the characters from index 0 to index 1 backward. Now s = \"zac\".\nSecondly, shift the characters from index 1 to index 2 forward. Now s = \"zbd\".\nFinally, shift the characters from index 0 to index 2 forward. Now s = \"ace\".",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input: s = \"dztz\", shifts = [[0,0,0],[1,1,1]]\nOutput: \"catz\"\nExplanation: Firstly, shift the characters from index 0 to index 0 backward. Now s = \"cztz\".\nFinally, shift the characters from index 1 to index 1 forward. Now s = \"catz\".",
      "images": []
    }
  ],
  "constraints": [
    "1 <= s.length, shifts.length <= 5 * 104",
    "shifts[i].length == 3",
    "0 <= starti <= endi < s.length",
    "0 <= directioni <= 1",
    "s consists of lowercase English letters."
  ],
  "follow_ups": [],
  "hints": [
    "Instead of shifting every character in each shift, could you keep track of which characters are shifted and by how much across all shifts?",
    "Try marking the start and ends of each shift, then perform a prefix sum of the shifts."
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\n        \n    }\n};",
    "java": "class Solution {\n    public String shiftingLetters(String s, int[][] shifts) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def shiftingLetters(self, s, shifts):\n        \"\"\"\n        :type s: str\n        :type shifts: List[List[int]]\n        :rtype: str\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\n        ",
    "c": "char* shiftingLetters(char* s, int** shifts, int shiftsSize, int* shiftsColSize) {\n    \n}",
    "csharp": "public class Solution {\n    public string ShiftingLetters(string s, int[][] shifts) {\n        \n    }\n}",
    "javascript": "/**\n * @param {string} s\n * @param {number[][]} shifts\n * @return {string}\n */\nvar shiftingLetters = function(s, shifts) {\n    \n};",
    "typescript": "function shiftingLetters(s: string, shifts: number[][]): string {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param String $s\n     * @param Integer[][] $shifts\n     * @return String\n     */\n    function shiftingLetters($s, $shifts) {\n        \n    }\n}",
    "swift": "class Solution {\n    func shiftingLetters(_ s: String, _ shifts: [[Int]]) -> String {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun shiftingLetters(s: String, shifts: Array<IntArray>): String {\n        \n    }\n}",
    "dart": "class Solution {\n  String shiftingLetters(String s, List<List<int>> shifts) {\n    \n  }\n}",
    "golang": "func shiftingLetters(s string, shifts [][]int) string {\n    \n}",
    "ruby": "# @param {String} s\n# @param {Integer[][]} shifts\n# @return {String}\ndef shifting_letters(s, shifts)\n    \nend",
    "scala": "object Solution {\n    def shiftingLetters(s: String, shifts: Array[Array[Int]]): String = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn shifting_letters(s: String, shifts: Vec<Vec<i32>>) -> String {\n        \n    }\n}",
    "racket": "(define/contract (shifting-letters s shifts)\n  (-> string? (listof (listof exact-integer?)) string?)\n  )",
    "erlang": "-spec shifting_letters(S :: unicode:unicode_binary(), Shifts :: [[integer()]]) -> unicode:unicode_binary().\nshifting_letters(S, Shifts) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec shifting_letters(s :: String.t, shifts :: [[integer]]) :: String.t\n  def shifting_letters(s, shifts) do\n    \n  end\nend"
  },
  "solution": "[TOC]\n\n## Solution\n\n---\n\n### Overview\n\nWe are given a string `s` consisting of lowercase English letters and a 2D array `shifts`, where each entry is a triplet `[start, end, direction]`. Each shift operation in `shifts` updates a range of characters `[start, end]` in the string `s` in the following way:\n\n-   If `direction == 1`: Shift each character in the range forward in the alphabet. For example, 'a' becomes 'b', and 'z' wraps around to 'a'.\n-   If `direction == 0`: Shift each character in the range backward in the alphabet. For example, 'b' becomes 'a', and 'a' wraps around to 'z'.\n\nA direct implementation would involve iterating over each range `[start, end]` for every shift operation and updating the characters in that range individually.\nSince applying each shift involves iterating over a substring of `s`, and this approach has a quadratic time complexity which is inefficient for the problem's constraints.\n\nInstead of applying each shift directly, we can optimize by focusing on the net effect of all shifts on each character. This means that rather than updating the string multiple times for each operation, we calculate how many total shifts each character undergoes. Once the total shifts `numberOfShifts` for each character have been calculated, we can use the following formula to create the final string in one pass:\n\n$$\n\\begin{aligned}\n\\text{newChar} = \\text{'a'} + (\\text{oldChar} - \\text{'a'} + \\text{numberOfShifts}) \\text{ mod } 26.\n\\end{aligned}\n$$\n\nHere,\n-   $\\text{oldChar} - \\text{'a'}$: Converts the character to a 0-based index in the range [0, 25] (e.g., 'a' = 0, 'b' = 1, ..., 'z' = 25).\n-   $\\text{numberOfShifts}$: Applies the total shifts to the character.\n-   $\\text{ mod } 26$: Ensures the result wraps around the alphabet if necessary (e.g., shifting 'z' forward yields 'a').\n-   $\\text{'a'} + ...$ : Converts the 0-based index back to a character.\n\n\nCalculating the total effect of all shifts on each character is a key step toward optimizing the solution. However, this calculation does not reduce the time complexity compared to the naive approach. This is because it still involves iterating over all the substrings specified by the shifts array and updating a counter for every character in those ranges.\n\n---\n\n### Approach: Difference Array\n\n#### Intuition\n\nBuilding on the idea of cumulative sums, we can use a difference array to handle range updates more efficiently. A difference array helps us record changes in values between consecutive elements rather than updating every element in a range directly.   \n\nInstead of keeping track of how many shifts should be applied to each character in the alphabet, weâ€™ll use the difference array to store how many more shifts should be applied to the current character compared to the previous one. This allows us to record changes only at the starting and ending points of shifts, rather than updating each character in the range.  \n\nFor convenience, a positive shift means that the character must move forward in the alphabet, and a negative shift means that it must move backward.\n\n!?!../Documents/2381/2381_slideshow.json:960,540!?!\n\n#### Algorithm\n\n-   Initialize `n` to the size of the string `s`.\n-   Initialize an array of length `n`, called `diffArray`, and set all its elements to `0`.\n-   For every `shift = [start, end, direction]` in `shifts`:\n    -   If `direction == 1` (shift forward):\n        -   Increment `diffArray[start]` by `1`, indicating that `s[start]` is shifted forward one more time than the previous character.\n        -   If `end + 1 < n`:\n            -   Decrement `diffArray[end + 1]` by `1`, as the character exactly after the shift range is shifted forward one time less than the previous character.\n    -   If `direction == 0` (shift backward):\n        -   Decrement `diffArray[start]` by `1`, as `s[start]` is shifted backward one more time than the previous character.\n        -   If `end + 1 < n`:\n            -   Increment `diffArray[end + 1]` by `1`, as the character exactly after the shift range is shifted backward one time less than the previous character.\n-   Initialize `numberOfShifts` to `0`.\n-   Initialize a string `result` of length `n`.\n-   Iterate over `s` with `i` from `0` to `n - 1`:\n    -   Add `diffArray[i]` to `numberOfShifts` and take it `mod 26`.\n    -   If `numberOfShifts < 0`, increment `numberOfShifts` by `26`.\n    -   Set `result[i]` to the shifted character: `'a' + (s[i] - 'a' + numberOfShifts) % 26`.\n-   Return `result`.\n\n#### Implementation#### Complexity Analysis\n\nLet $n$ be the size of the string `s` and $m$ the size of the `shifts` array.\n\n-   Time complexity: $O(n + m)$\n\n    We are iterating over the `shifts` array to find the difference between the shifts of any two consecutive characters of `s`. On each iteration, we only perform constant-time operations (accessing and updating two elements of the `diffArray`) and therefore the initialization of the `diffArray` requires $O(m)$ time. Then, we create the resulting string with a single pass over the original, which contributes $O(n)$ to the total time complexity.\n\n-   Space complexity: $O(n)$\n\n    We are using an array of size `n` to store the differences in the shifts between consecutive characters. We are also creating a new string `result` of length `n` to avoid modifying the input directly. These data structures have a size that is linear to the length of the input string and therefore the algorithm requires $O(n)$ extra space.\n\n---\n\n##### Further Thoughts on the Editorial:\n\nThis problem can also be solved using a Fenwick Tree (also known as a Binary Indexed Tree), a data structure designed for efficiently querying the prefix sum of an array and updating its elements in logarithmic time. Using a Fenwick Tree, we can represent the difference array and handle the range update operations efficiently.\n\nWhile this approach is more advanced and typically used in harder problems, it provides an alternative perspective on solving the same problem. If you're familiar with Fenwick Trees or want to challenge yourself, you can try implementing this solution for fun or challenge yourself with problems from this list: [Binary Indexed Tree Problems](https://leetcode.com/problem-list/binary-indexed-tree/)!"
}