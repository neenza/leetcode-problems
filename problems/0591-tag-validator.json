{
  "title": "Tag Validator",
  "problem_id": "591",
  "frontend_id": "591",
  "difficulty": "Hard",
  "problem_slug": "tag-validator",
  "topics": [
    "String",
    "Stack"
  ],
  "description": "Given a string representing a code snippet, implement a tag validator to parse the code and return whether it is valid.\nA code snippet is valid if all the following rules hold:\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: code = \"<DIV>This is the first line <![CDATA[<div>]]></DIV>\"\nOutput: true\nExplanation: \nThe code is wrapped in a closed tag : <DIV> and </DIV>. \nThe TAG_NAME is valid, the TAG_CONTENT consists of some characters and cdata. \nAlthough CDATA_CONTENT has an unmatched start tag with invalid TAG_NAME, it should be considered as plain text, not parsed as a tag.\nSo TAG_CONTENT is valid, and then the code is valid. Thus return true.",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input: code = \"<DIV>>>  ![cdata[]] <![CDATA[<div>]>]]>]]>>]</DIV>\"\nOutput: true\nExplanation:\nWe first separate the code into : start_tag|tag_content|end_tag.\nstart_tag -> \"<DIV>\"\nend_tag -> \"</DIV>\"\ntag_content could also be separated into : text1|cdata|text2.\ntext1 -> \">>  ![cdata[]] \"\ncdata -> \"<![CDATA[<div>]>]]>\", where the CDATA_CONTENT is \"<div>]>\"\ntext2 -> \"]]>>]\"\nThe reason why start_tag is NOT \"<DIV>>>\" is because of the rule 6.\nThe reason why cdata is NOT \"<![CDATA[<div>]>]]>]]>\" is because of the rule 7.",
      "images": []
    },
    {
      "example_num": 3,
      "example_text": "Input: code = \"<A>  <B> </A>   </B>\"\nOutput: false\nExplanation: Unbalanced. If \"<A>\" is closed, then \"<B>\" must be unmatched, and vice versa.",
      "images": []
    }
  ],
  "constraints": [
    "1 <= code.length <= 500",
    "code consists of English letters, digits, '<', '>', '/', '!', '[', ']', '.', and ' '."
  ],
  "follow_ups": [],
  "hints": [],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    bool isValid(string code) {\n        \n    }\n};",
    "java": "class Solution {\n    public boolean isValid(String code) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def isValid(self, code):\n        \"\"\"\n        :type code: str\n        :rtype: bool\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def isValid(self, code: str) -> bool:\n        ",
    "c": "bool isValid(char* code) {\n    \n}",
    "csharp": "public class Solution {\n    public bool IsValid(string code) {\n        \n    }\n}",
    "javascript": "/**\n * @param {string} code\n * @return {boolean}\n */\nvar isValid = function(code) {\n    \n};",
    "typescript": "function isValid(code: string): boolean {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param String $code\n     * @return Boolean\n     */\n    function isValid($code) {\n        \n    }\n}",
    "swift": "class Solution {\n    func isValid(_ code: String) -> Bool {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun isValid(code: String): Boolean {\n        \n    }\n}",
    "dart": "class Solution {\n  bool isValid(String code) {\n    \n  }\n}",
    "golang": "func isValid(code string) bool {\n    \n}",
    "ruby": "# @param {String} code\n# @return {Boolean}\ndef is_valid(code)\n    \nend",
    "scala": "object Solution {\n    def isValid(code: String): Boolean = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn is_valid(code: String) -> bool {\n        \n    }\n}",
    "racket": "(define/contract (is-valid code)\n  (-> string? boolean?)\n  )",
    "erlang": "-spec is_valid(Code :: unicode:unicode_binary()) -> boolean().\nis_valid(Code) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec is_valid(code :: String.t) :: boolean\n  def is_valid(code) do\n    \n  end\nend"
  },
  "solution": "[TOC]\n\n## Solution\n\n---\n### Approach 1: Stack\n\nSummarizing the given problem, we can say that we need to determine whether a tag is valid or not, by checking the following properties.\n\n1. The code should be wrapped in a valid closed tag.\n\n2. The `TAG_NAME` should be valid.\n\n3. The `TAG_CONTENT` should be valid.\n\n4. The **cdata** should be valid.\n\n5. All the tags should be closed. i.e. each start-tag should have a corresponding end-tag and vice-versa and the order of the tags should be correct as well.\n\nIn order to check the validity of all these, firstly, we need to identify which parts of the given $$code$$ string act as which part from the above-mentioned categories. To understand how it's done, we'll go through the implementation and the reasoning behind it step by step.\n\nWe iterate over the given $$code$$ string. Whenever a `<` is encountered(unless we are currently inside `...`), it indicates the beginning of either a `TAG_NAME`(start tag or end tag) or the beginning of cdata as per the conditions given in the problem statement. \n\nIf the character immediately following this `<` is an `!`, the characters following this `<` can't be a part of a valid `TAG_NAME`, since only upper-case letters(in case of a start tag) or `/` followed by upper-case letters(in the case of an end tag). Thus, the choice now narrows down to only **cdata**. Thus, we need to check if the current bunch of characters following `` following the current `` exists, the $$code$$ string is considered as invalid. Apart from this, the `` do not have any constraints on them.\n\nIf the character immediately following the `<` encountered isn't an `!`, this `<` can only mark the beginning of `TAG_NAME`. Now, since a valid start tag can't contain anything except upper-case letters if a `/` is found after `<`, the `` following the `<` to find out the substring(say $$s$$), that constitutes the `TAG_NAME`. This $$s$$ should satisfy all the criteria to constitute a valid `TAG_NAME`. Thus, for every such $$s$$, we check if it contains all upper-case letters and also check its length(It should be between 1 to 9). If any of the criteria isn't fulfilled, $$s$$ doesn't constitute a valid `TAG_NAME`. Hence, the $$code$$ string turns out to be invalid as well.\n\nApart from checking the validity of the `TAG_NAME`, we also need to ensure that the tags always exist in pairs. i.e. for every start-tag, a corresponding end-tag should always exist. Further, we can note that in case of multiple `TAG_NAME`'s, the `TAG_NAME` whose start-tag comes later than the other ones, should have its end-tag appearing before the end-tags of those other `TAG_NAME`'s. i.e. the tag that starts later should end first. \n\nFrom this, we get the intuition that we can make use of a $$stack$$ to check the existence of matching start and end-tags. Thus, whenever we find out a valid start-tag, as mentioned above, we push its `TAG_NAME` string onto a $$stack$$. Now, whenever an end-tag is found, we compare its `TAG_NAME` with the `TAG_NAME` at the top of the $$stack$$ and remove this element from the $$stack$$. If the two don't match, this implies that either the current end-tag has no corresponding start-tag or there is a problem with the ordering of the tags. The two need to match for the tag-pair to be valid since there can't exist an end-tag without a corresponding start-tag and vice-versa. Thus, if a match isn't found, we can conclude that the given $$code$$ string is invalid.\n\nNow, after the complete $$code$$ string has been traversed, the $$stack$$ should be empty if all the start-tags have their corresponding end-tags as well. If the $$stack$$ isn't empty, this implies that some start-tag doesn't have the corresponding end-tag, violating the closed-tag's validity condition.\n\nFurther, we also need to ensure that the given $$code$$ is completely enclosed within closed tags. For this, we need to ensure that the first **cdata** found is also inside the closed tags. Thus, when we find a possibility of the presence of **cdata**, we proceed further only if we've already found a start tag, indicated by a non-empty stack. Further, to ensure that no data lies after the last end-tag, we need to ensure that the $$stack$$ doesn't become empty before we reach the end of the given $$code$$ string since an empty $$stack$$ indicates that the last end-tag has been encountered.\n\nThe following animation depicts the process.\n\n!?!../Documents/Tag_Validator_Stack.json:1000,563!?!**Complexity Analysis**\n\n* Time complexity : $$O(n)$$. We traverse over the given $$code$$ string of length $$n$$.\n\n* Space complexity : $$O(n)$$. The stack can grow upto a size of $$n/3$$ in the worst case. e.g. In case of ``, $$n$$=12 and number of tags = 12/3 = 4.---\n### Approach 2: Regex\n\nInstead of manually checking the given $$code$$ string for checking the validity of `TAG_NAME`, `TAG_CONTENT` and **cdata**, we can make use of an inbuilt java functionality known as regular expressions.\n\nA regular expression is a special sequence of characters that helps you match or find other strings or sets of strings, using a specialized syntax held in a pattern. They can be used to search, edit, or manipulate text and data. The most common quantifiers used in regular expressions are listed below. A quantifier after a token (such as a character) or group specifies how often that preceding element is allowed to occur.\n\n`?`\tThe question mark indicates zero or one occurrence of the preceding element. For example, colou?r matches both \"color\" and \"colour\".\n\n`*`\tThe asterisk indicates zero or more occurrences of the preceding element. For example, ab*c matches \"ac\", \"abc\", \"abbc\", \"abbbc\", and so on.\n\n`+`\tThe plus sign indicates one or more occurrences of the preceding element. For example, ab+c matches \"abc\", \"abbc\", \"abbbc\", and so on, but not \"ac\".\n\n`{n}` The preceding item is matched exactly **n** times.\n\n`{min,}` The preceding item is matched **min** or more times.\n\n`{min,max}`\tThe preceding item is matched at least **min** times, but not more than **max** times.\n\n`|` A vertical bar separates alternatives. For example, gray|grey can match \"gray\" or \"grey\".\n\n`()` Parentheses are used to define the scope and precedence of the operators (among other uses). For example, gray|grey and gr(a|e)y are equivalent patterns that both describe the set of \"gray\" or \"grey\".\n\n`[...]`\tMatches any single character in brackets.\n\n`[^...]`\tMatches any single character not in brackets.\n\nThus, by making use of regex, we can directly check the validity of the $$code$$ string directly(except the nesting of the inner tags) by using the regex expression below:\n\n`<([A-Z]{1,9})>([^<]*((<\\/?[A-Z]{1,9}>)|())?[^<]*)*<\\/\\1>`\n\nThe image below shows the portion of the string that each part of the expression helps to match:\n\n![Regex](../Figures/591/591_Tag_Validator.PNG)\n\n\n\nBut, if we make use of back-referencing as mentioned above, the matching process takes a very large amount of CPU time. Thus, we use the regex only to check the validity of the `TAG_CONTENT`, `TAG_NAME` and the **cdata**. We check the presence of the outermost closed tags by making use of a $$stack$$ as done in the last approach.\n\nThe rest of the process remains the same as in the last approach, except that we need not manually check the validity of `TAG_CONTENT`, `TAG_NAME`, and the **cdata**, since it is already done by the regex expression. We only need to check the presence of inner closed tags.\n\nCheck [this](http://regexr.com/) link for testing any regular expression on a sample text.**Complexity Analysis**\n\n* Time complexity: Regular Expressions are/can be implemented in the form of finite-state machines. Thus, the time complexity is dependent on the internal representation. In the case of any suggestions, please comment below.\n\n* Space complexity: $$O(n)$$. The stack can grow up to a size of $$n/3$$ in the worst case. e.g. In case of ``, $$n$$=12 and number of tags = 12/3 = 4."
}