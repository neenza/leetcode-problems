{
  "title": "Find Center of Star Graph",
  "problem_id": "1916",
  "frontend_id": "1791",
  "difficulty": "Easy",
  "problem_slug": "find-center-of-star-graph",
  "topics": [
    "Graph"
  ],
  "description": "There is an undirected star graph consisting of n nodes labeled from 1 to n. A star graph is a graph where there is one center node and exactly n - 1 edges that connect the center node with every other node.\nYou are given a 2D integer array edges where each edges[i] = [ui, vi] indicates that there is an edge between the nodes ui and vi. Return the center of the given star graph.\nExample 1:\nExample 2:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: edges = [[1,2],[2,3],[4,2]]\nOutput: 2\nExplanation: As shown in the figure above, node 2 is connected to every other node, so 2 is the center.",
      "images": [
        "https://assets.leetcode.com/uploads/2021/02/24/star_graph.png"
      ]
    },
    {
      "example_num": 2,
      "example_text": "Input: edges = [[1,2],[5,1],[1,3],[1,4]]\nOutput: 1",
      "images": [
        "https://assets.leetcode.com/uploads/2021/02/24/star_graph.png"
      ]
    }
  ],
  "constraints": [
    "3 <= n <= 105",
    "edges.length == n - 1",
    "edges[i].length == 2",
    "1 <= ui, vi <= n",
    "ui != vi",
    "The given edges represent a valid star graph."
  ],
  "follow_ups": [],
  "hints": [
    "The center is the only node that has more than one edge.",
    "The center is also connected to all other nodes.",
    "Any two edges must have a common node, which is the center."
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    int findCenter(vector<vector<int>>& edges) {\n        \n    }\n};",
    "java": "class Solution {\n    public int findCenter(int[][] edges) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def findCenter(self, edges):\n        \"\"\"\n        :type edges: List[List[int]]\n        :rtype: int\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def findCenter(self, edges: List[List[int]]) -> int:\n        ",
    "c": "int findCenter(int** edges, int edgesSize, int* edgesColSize) {\n    \n}",
    "csharp": "public class Solution {\n    public int FindCenter(int[][] edges) {\n        \n    }\n}",
    "javascript": "/**\n * @param {number[][]} edges\n * @return {number}\n */\nvar findCenter = function(edges) {\n    \n};",
    "typescript": "function findCenter(edges: number[][]): number {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param Integer[][] $edges\n     * @return Integer\n     */\n    function findCenter($edges) {\n        \n    }\n}",
    "swift": "class Solution {\n    func findCenter(_ edges: [[Int]]) -> Int {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun findCenter(edges: Array<IntArray>): Int {\n        \n    }\n}",
    "dart": "class Solution {\n  int findCenter(List<List<int>> edges) {\n    \n  }\n}",
    "golang": "func findCenter(edges [][]int) int {\n    \n}",
    "ruby": "# @param {Integer[][]} edges\n# @return {Integer}\ndef find_center(edges)\n    \nend",
    "scala": "object Solution {\n    def findCenter(edges: Array[Array[Int]]): Int = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn find_center(edges: Vec<Vec<i32>>) -> i32 {\n        \n    }\n}",
    "racket": "(define/contract (find-center edges)\n  (-> (listof (listof exact-integer?)) exact-integer?)\n  )",
    "erlang": "-spec find_center(Edges :: [[integer()]]) -> integer().\nfind_center(Edges) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec find_center(edges :: [[integer]]) :: integer\n  def find_center(edges) do\n    \n  end\nend"
  },
  "solution": "## Solution\n\n---\n\n### Approach 1: Degree Count\n\n#### Intuition\n\nWe have a graph with N nodes connected by `N-1` edges in a star formation. Our task is to find the center node of this star.\n\nThe center node has a unique property: it's connected to every other node. This means it has `N-1` connections, while all other nodes have only one connection each.\n\nIn graph theory, we call the number of connections a node has its \"degree\". The center node has a degree of `N-1`, and all other nodes have a degree of `1`.\n\nTo find the center, we can count the degree of each node. We'll iterate through all edges, incrementing a degree counter for both nodes each edge connects. We'll store these counts in an array or map. After iterating all edges, we find the node with a degree of `N-1`. This node is our center.\n\n#### Algorithm\n\n1. Initialize an empty unordered hashmap `degree` to store the degree of all nodes.\n2. Iterate over the edges in the list `edges` and, for each edge, increment the degree of nodes this edge connects in the map `degree`.\n3. Iterate over the hash map `degree` and check if the degree is equal to $N - 1$, i.e., `edges.size()`.\n4. Return the node that satisfies the above condition.\n5. Return `-1`, although this is an unreachable part of the code as the input is always valid.\n\n#### Implementation#### Complexity Analysis\n\nHere, $N$ is the number of nodes in the graph.\n\n* Time complexity: $O(N)$.\n\n  To find the degree of each node, we iterate over each of the $N - 1$ edges. Then we check the degree of each of the $N$ nodes. Hence, the total time complexity is equal to $O(N)$.\n\n* Space complexity: $O(N)$.\n\n  The hash map `degree` stores the degree of all $N$ nodes and hence the space complexity is equal to $O(N)$.\n---\n\n### Approach 2: Greedy\n\n#### Intuition\n\nWe're given that the input is always a star graph, with a center node connected to all others. This simplifies our approach.\n\nIn a star graph, the center node appears on every edge, as it's connected to all other nodes. Instead of counting degrees, we can find the node present in all edges. This node must be the center.\n\nWe only need to check any two edges in the list. The common node between these edges is guaranteed to be the center. This works because, in a star graph with `N-1` edges, only the center node has a degree greater than 1.\n\nFor simplicity, we can just check the first two edges in the list. The node common to both is our center.\n\nThis approach is more efficient than counting degrees, as we only need to examine two edges regardless of the graph's size.\n\n![fig](../Figures/1791/1791A.png)\n\n#### Algorithm\n\n1. Declare the `firstEdge` and `secondEdge` as the first two edges in the list `edges` respectively.\n2. Check if the first node in the `firstEdge` is equal to any of the two nodes in the `secondEdge`, if yes return the first node in `firstEdge`. Otherwise, return the second node in the `secondEdge`.\n\n#### Implementation#### Complexity Analysis\n\n* Time complexity: $O(1)$.\n\n  We only compare the two nodes in the `firstEdge` with the nodes in the `secondEdge`. This is a constant operation and hence the time complexity is constant.\n\n* Space complexity: $O(1)$.\n\n  We don't need any extra space. Note that two edges `firstEdge` and `secondEdge` will only have two nodes irrespective of the number of nodes in the graph, and even these two declarations can be avoided but are added for better readability. Hence the space complexity is also constant.\n\n---"
}