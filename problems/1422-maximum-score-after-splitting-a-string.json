{
  "title": "Maximum Score After Splitting a String",
  "problem_id": "1537",
  "frontend_id": "1422",
  "difficulty": "Easy",
  "problem_slug": "maximum-score-after-splitting-a-string",
  "topics": [
    "String",
    "Prefix Sum"
  ],
  "description": "Given a string s of zeros and ones, return the maximum score after splitting the string into two non-empty substrings (i.e. left substring and right substring).\nThe score after splitting a string is the number of zeros in the left substring plus the number of ones in the right substring.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: s = \"011101\"\nOutput: 5 \nExplanation: \nAll possible ways of splitting s into two non-empty substrings are:\nleft = \"0\" and right = \"11101\", score = 1 + 4 = 5 \nleft = \"01\" and right = \"1101\", score = 1 + 3 = 4 \nleft = \"011\" and right = \"101\", score = 1 + 2 = 3 \nleft = \"0111\" and right = \"01\", score = 1 + 1 = 2 \nleft = \"01110\" and right = \"1\", score = 2 + 1 = 3",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input: s = \"00111\"\nOutput: 5\nExplanation: When left = \"00\" and right = \"111\", we get the maximum score = 2 + 3 = 5",
      "images": []
    },
    {
      "example_num": 3,
      "example_text": "Input: s = \"1111\"\nOutput: 3",
      "images": []
    }
  ],
  "constraints": [
    "2 <= s.length <= 500",
    "The string s consists of characters '0' and '1' only."
  ],
  "follow_ups": [],
  "hints": [
    "Precompute a prefix sum of ones ('1').",
    "Iterate from left to right counting the number of zeros ('0'), then use the precomputed prefix sum for counting ones ('1'). Update the answer."
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    int maxScore(string s) {\n        \n    }\n};",
    "java": "class Solution {\n    public int maxScore(String s) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def maxScore(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def maxScore(self, s: str) -> int:\n        ",
    "c": "int maxScore(char* s) {\n    \n}",
    "csharp": "public class Solution {\n    public int MaxScore(string s) {\n        \n    }\n}",
    "javascript": "/**\n * @param {string} s\n * @return {number}\n */\nvar maxScore = function(s) {\n    \n};",
    "typescript": "function maxScore(s: string): number {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param String $s\n     * @return Integer\n     */\n    function maxScore($s) {\n        \n    }\n}",
    "swift": "class Solution {\n    func maxScore(_ s: String) -> Int {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun maxScore(s: String): Int {\n        \n    }\n}",
    "dart": "class Solution {\n  int maxScore(String s) {\n    \n  }\n}",
    "golang": "func maxScore(s string) int {\n    \n}",
    "ruby": "# @param {String} s\n# @return {Integer}\ndef max_score(s)\n    \nend",
    "scala": "object Solution {\n    def maxScore(s: String): Int = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn max_score(s: String) -> i32 {\n        \n    }\n}",
    "racket": "(define/contract (max-score s)\n  (-> string? exact-integer?)\n  )",
    "erlang": "-spec max_score(S :: unicode:unicode_binary()) -> integer().\nmax_score(S) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec max_score(s :: String.t) :: integer\n  def max_score(s) do\n    \n  end\nend"
  },
  "solution": "[TOC]\n\n## Solution\n\n---\n\n### Approach 1: Brute Force\n\n**Intuition**\n\nIn this problem, we need to make a \"split\" which involves separating the input into a left part and a right part.\n\nTo start, we can check every possible split. We will use an integer `i` to iterate over the string, where `i` represents the index of the final character in the left part.\n\nFor a given `i`, we iterate on the indices of `s` from `0` to `i` and count how many times `0` occurs. We then iterate on the indices from `i + 1` until the last index and count how many times `1` occurs. The sum of these counts represents the score for the current split, and we take the maximum of all scores.\n\nNote that we cannot iterate `i` until the final index, but rather the second last index. If we were to iterate to the final index, the right part would be empty, which is not allowed by the problem.\n\n**Algorithm**\n\n1. Initialize the answer `ans = 0`.\n2. Iterate `i` from `0` until `s.length - 1`:\n    - Initialize the current score `curr = 0`.\n    - Iterate `j` from `0` to `i`:\n        - If `s[j] == '0'`, increment `curr`.\n    - Iterate `j` from `i + 1` until `s.length`:\n        - If `s[j] == '1'`, increment `curr`.\n    - Update `ans` with `curr` if it is larger.\n3. Return `ans`.\n\n**Implementation****Complexity Analysis**\n\nGiven $$n$$ as the length of `nums`,\n\n* Time complexity: $$O(n^2)$$\n\n    We iterate `i` over $$n - 1$$ indices. For each iteration, we have two iterations over `j`, traversing over a total of $$n$$ indices. Thus, we iterate $$O(n \\cdot (n - 1)) = O(n^2)$$ times.\n\n* Space complexity: $$O(1)$$\n\n    We aren't using any extra space other than a few integers.---\n\n### Approach 2: Count Left Zeros and Right Ones\n\n**Intuition**\n\nWe can improve on the previous solution by noticing that between a split at index `i` and index `i + 1`, we are only changing one character (more specifically, moving it from the right substring to the left substring), leaving the other characters unchanged. Instead of iterating over the entire string for each split, we only need to check the moved character and calculate the score for the new split based on the previous split.\n\nWe start by counting how many times `1` occurs in `s`. Let's store this value in a variable `ones`. We will also have a variable `zeros` that represents how many `0` are in the left part. Initially, our variables `ones` and `zeros` are set as if the left part is empty and the right part is the entire string.\n\nNow, we iterate `i` in the same manner as the previous approach: each index `i` represents the final index of the left part. At each iteration `i`, we remove `s[i]` from the right part and add it to the left part.\n\n![example](../Figures/1422/1.png)There are two possibilities for each index `i`:\n\n- If `s[i] == '1'`: this `1` was in the right part, but it is now joining the left part. Thus, we lose `1` score since the right part is losing a `1`. Decrement `ones`.\n- If `s[i] == '0'`, this `0` was in the right part, but it is now joining the left part. Thus, we gain `1` score since the left part is gaining a `0`. Increment `zeros`.\n\nWe update the answer with `zeros + ones` at each iteration if it is larger.\n\n**Algorithm**\n\n1. Initialize `ones` as the number of times `1` occurs in `s`.\n2. Initialize `zeros = 0` and the answer `ans = 0`.\n3. Iterate `i` from `0` until `s.length - 1`:\n    - If `s[i] == '1'`, decrement `ones`.\n    - Otherwise, increment `zeros`.\n    - Update `ans` with `zeros + ones` if it is larger.\n4. Return `ans`.\n\n**Implementation****Complexity Analysis**\n\nGiven $$n$$ as the length of `nums`,\n\n* Time complexity: $$O(n)$$\n\n    We start by finding the frequency of `1`, which costs $$O(n)$$. Next, we iterate over the string once, performing $$O(1)$$ work at each iteration. Thus, our time complexity is $$O(2n) = O(n)$$.\n\n* Space complexity: $$O(1)$$\n\n    We aren't using any extra space other than a few integers.---\n\n### Approach 3: One Pass\n\n**Intuition**\n\nIn the previous approach, we used two passes over the input string: once to calculate `ones`, and another time to calculate `ans`. We can further optimize the algorithm to only use one pass!\n\nThe answer to our problem is the maximum score for all valid splits, as represented by the following equation:\n\n$$\\text{score} = Z_L + O_R$$, where $$Z_L$$ is the number of zeros in the left substring and $$O_R$$ is the number of ones in the right substring.\n\nWe can express $$O_R$$ as $$O_T - O_L$$, where $$O_T$$ is the total number of ones in `s`, and $$O_L$$ is the number of ones in the left substring.\n\nUsing the above expression, our first equation can be represented as:\n\n$$\\text{score} = Z_L + O_T - O_L$$\n\nIn the above equation, $$O_T$$ is a constant, we need to find the maximum value of $$Z_L - O_L$$ for all valid splits. Notice that both of these values depend solely on the left substring. Therefore, we don't need to consider the right substring, which saves the need for the first traversal in the previous solution.\n\nIn the code, we will use the variable `zeros` to represent $$Z_L$$ and the variables `ones` to represent $$O_L$$. As `zeros - ones` may be negative, we initialize an integer `best` to a very small value, like negative infinity. Here, `best` represents the largest value of `zeros - ones` we have seen so far.\n\nWe now iterate `i` in the same manner as the first two approaches: at each iteration, `i` represents the final index of the left part. On each iteration, we are adding `s[i]` to the left part. Thus, if `s[i] = '1'` we increment `ones`, otherwise `s[i] = '0'` and we increment `zeros`. Then, we update `best` with `zeros - ones` if it is larger.\n\nRecall that we don't iterate `i` over the final index since it would mean having an empty right part. Once we are done iterating over `s`, we will check the final index to see if it is a `1`. If it is, we increment `ones`.\n\nThe reason we explicitly check the final index for `1` is that we want `ones` to represent $$O_T$$ in the end, but when we calculate `ones`, we don't iterate over the last index, so we need to account for it. Now, we have `best` as the maximum of all $$Z_L - O_L$$ and `ones` represents $$O_T$$, we can return `best + ones` as the answer.\n\n**Algorithm**\n\n1. Initialize `ones = 0`, `zeros = 0`, and `best` to a very small value like negative infinity.\n2. Iterate `i` from `0` until `s.length - 1`:\n    - If `s[i] == '1'`, increment `ones`.\n    - Otherwise, increment `zeros`.\n    - Update `best` with `zeros - ones` if it is larger.\n3. If the final character of `s` is equal to `'1'`, increment `ones`.\n4. Return `best + ones`.\n\n**Implementation****Complexity Analysis**\n\nGiven $$n$$ as the length of `nums`,\n\n* Time complexity: $$O(n)$$\n\n    We make one pass over `nums`, performing $$O(1)$$ work at each iteration.\n\n* Space complexity: $$O(1)$$\n\n    We aren't using any extra space other than a few integers.---"
}