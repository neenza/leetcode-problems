{
  "title": "Build an Array With Stack Operations",
  "problem_id": "1552",
  "frontend_id": "1441",
  "difficulty": "Medium",
  "problem_slug": "build-an-array-with-stack-operations",
  "topics": [
    "Array",
    "Stack",
    "Simulation"
  ],
  "description": "You are given an integer array target and an integer n.\nYou have an empty stack with the two following operations:\nYou also have a stream of the integers in the range [1, n].\nUse the two stack operations to make the numbers in the stack (from the bottom to the top) equal to target. You should follow the following rules:\nReturn the stack operations needed to build target following the mentioned rules. If there are multiple valid answers, return any of them.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: target = [1,3], n = 3\nOutput: [\"Push\",\"Push\",\"Pop\",\"Push\"]\nExplanation: Initially the stack s is empty. The last element is the top of the stack.\nRead 1 from the stream and push it to the stack. s = [1].\nRead 2 from the stream and push it to the stack. s = [1,2].\nPop the integer on the top of the stack. s = [1].\nRead 3 from the stream and push it to the stack. s = [1,3].",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input: target = [1,2,3], n = 3\nOutput: [\"Push\",\"Push\",\"Push\"]\nExplanation: Initially the stack s is empty. The last element is the top of the stack.\nRead 1 from the stream and push it to the stack. s = [1].\nRead 2 from the stream and push it to the stack. s = [1,2].\nRead 3 from the stream and push it to the stack. s = [1,2,3].",
      "images": []
    },
    {
      "example_num": 3,
      "example_text": "Input: target = [1,2], n = 4\nOutput: [\"Push\",\"Push\"]\nExplanation: Initially the stack s is empty. The last element is the top of the stack.\nRead 1 from the stream and push it to the stack. s = [1].\nRead 2 from the stream and push it to the stack. s = [1,2].\nSince the stack (from the bottom to the top) is equal to target, we stop the stack operations.\nThe answers that read integer 3 from the stream are not accepted.",
      "images": []
    }
  ],
  "constraints": [
    "1 <= target.length <= 100",
    "1 <= n <= 100",
    "1 <= target[i] <= n",
    "target is strictly increasing."
  ],
  "follow_ups": [],
  "hints": [
    "Use “Push” for numbers to be kept in target array and [“Push”, “Pop”] for numbers to be discarded."
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    vector<string> buildArray(vector<int>& target, int n) {\n        \n    }\n};",
    "java": "class Solution {\n    public List<String> buildArray(int[] target, int n) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def buildArray(self, target, n):\n        \"\"\"\n        :type target: List[int]\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def buildArray(self, target: List[int], n: int) -> List[str]:\n        ",
    "c": "/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nchar** buildArray(int* target, int targetSize, int n, int* returnSize) {\n    \n}",
    "csharp": "public class Solution {\n    public IList<string> BuildArray(int[] target, int n) {\n        \n    }\n}",
    "javascript": "/**\n * @param {number[]} target\n * @param {number} n\n * @return {string[]}\n */\nvar buildArray = function(target, n) {\n    \n};",
    "typescript": "function buildArray(target: number[], n: number): string[] {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param Integer[] $target\n     * @param Integer $n\n     * @return String[]\n     */\n    function buildArray($target, $n) {\n        \n    }\n}",
    "swift": "class Solution {\n    func buildArray(_ target: [Int], _ n: Int) -> [String] {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun buildArray(target: IntArray, n: Int): List<String> {\n        \n    }\n}",
    "dart": "class Solution {\n  List<String> buildArray(List<int> target, int n) {\n    \n  }\n}",
    "golang": "func buildArray(target []int, n int) []string {\n    \n}",
    "ruby": "# @param {Integer[]} target\n# @param {Integer} n\n# @return {String[]}\ndef build_array(target, n)\n    \nend",
    "scala": "object Solution {\n    def buildArray(target: Array[Int], n: Int): List[String] = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn build_array(target: Vec<i32>, n: i32) -> Vec<String> {\n        \n    }\n}",
    "racket": "(define/contract (build-array target n)\n  (-> (listof exact-integer?) exact-integer? (listof string?))\n  )",
    "erlang": "-spec build_array(Target :: [integer()], N :: integer()) -> [unicode:unicode_binary()].\nbuild_array(Target, N) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec build_array(target :: [integer], n :: integer) :: [String.t]\n  def build_array(target, n) do\n    \n  end\nend"
  },
  "solution": "[TOC]\n\n## Solution\n\n---\n\n### Approach: Simulate\n\n**Intuition**\n\nIn this problem, we are given two stack operations:\n\n- Push a number to the stack\n- Pop off the top of the stack\n\nThe numbers that we push to the stack are ordered from `1` to `n`. Each number is available only once, so if we pop a number from the stack, that number is permanently gone. This means we want to pop every number that does not appear in `target` and should never pop any number that does appear in `target`.\n\nWe stop once the stack is equal to `target` and we are allowed to return any valid answer. Because `target` is always sorted and the stream of numbers always comes in ascending order, we can build `target` one element at a time, starting with the first element.\n\nLet's use an integer `i` that represents the most recently pushed number. Initially, `i = 0` as no numbers have been pushed yet.\n\n![example](../Figures/1441/1.png)In this example, the first number we need to reach in `target` is `3`. Before we can reach `3`, we need to go through `1, 2`. However, we don't want either `1` or `2` in the answer, so we can immediately pop `1` after pushing it, and pop `2` after pushing it. Essentially, we are only pushing them to move forward until we reach `3`.\n\n![example](../Figures/1441/2.png)![example](../Figures/1441/3.png)Now, we are ready to push `3`, so we do so.\n\n![example](../Figures/1441/4.png)To get to the next number `6`, we must first go through `4, 5`. Again, we don't want either `4` or `5` in the answer, so we can immediately pop `4` after pushing it, and pop `5` after pushing it.\n\n![example](../Figures/1441/5.png)![example](../Figures/1441/6.png)Now, we are ready to push `6`, so we do so.\n\n![example](../Figures/1441/7.png)We continue this process for each number in `target`. This brings us to our solution. We iterate over each `num` in `target`:\n\n- We push and immediately pop the current number, then increment `i`, and repeat the process until we are ready to push `num`.\n- When are we ready to push `num`? Recall that `i` represents the most recently pushed number. Thus, we are ready to push `num` when the most recently pushed number is `i = num - 1`.\n- Once we are ready, we simply push and increment `i`.\n\n**Algorithm**\n\n1. Initialize the answer `ans` and the integer `i = 0`.\n2. For each `num` in `target`:\n    - While `i < num - 1`:\n        - Add `\"Push\"` to `ans`.\n        - Add `\"Pop\"` to `ans`.\n        - Increment `i`.\n    - Add `\"Push\"` to `ans`.\n    - Increment `i`.\n3. Return `ans`.\n\n**Implementation****Complexity Analysis**\n\n* Time complexity: $$O(n)$$\n\n    Let `k` denote the largest (final) element in `target`. We push (and maybe pop) every number from `1` until `k`. This gives us a maximum of $$2k$$ operations. In the worst case scenario, `k = n`, which gives us a time complexity of $$O(n)$$.\n\n* Space complexity: $$O(1)$$\n\n    We don't count the answer as part of the space complexity. Thus, we aren't using any extra space other than the integer `i`.---"
}