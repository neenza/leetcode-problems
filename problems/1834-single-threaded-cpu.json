{
  "title": "Single-Threaded CPU",
  "problem_id": "1962",
  "frontend_id": "1834",
  "difficulty": "Medium",
  "problem_slug": "single-threaded-cpu",
  "topics": [
    "Array",
    "Sorting",
    "Heap (Priority Queue)"
  ],
  "description": "You are given n​​​​​​ tasks labeled from 0 to n - 1 represented by a 2D integer array tasks, where tasks[i] = [enqueueTimei, processingTimei] means that the i​​​​​​th​​​​ task will be available to process at enqueueTimei and will take processingTimei to finish processing.\nYou have a single-threaded CPU that can process at most one task at a time and will act in the following way:\nReturn the order in which the CPU will process the tasks.\nExample 1:\nExample 2:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: tasks = [[1,2],[2,4],[3,2],[4,1]]\nOutput: [0,2,3,1]\nExplanation: The events go as follows: \n- At time = 1, task 0 is available to process. Available tasks = {0}.\n- Also at time = 1, the idle CPU starts processing task 0. Available tasks = {}.\n- At time = 2, task 1 is available to process. Available tasks = {1}.\n- At time = 3, task 2 is available to process. Available tasks = {1, 2}.\n- Also at time = 3, the CPU finishes task 0 and starts processing task 2 as it is the shortest. Available tasks = {1}.\n- At time = 4, task 3 is available to process. Available tasks = {1, 3}.\n- At time = 5, the CPU finishes task 2 and starts processing task 3 as it is the shortest. Available tasks = {1}.\n- At time = 6, the CPU finishes task 3 and starts processing task 1. Available tasks = {}.\n- At time = 10, the CPU finishes task 1 and becomes idle.",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input: tasks = [[7,10],[7,12],[7,5],[7,4],[7,2]]\nOutput: [4,3,2,0,1]\nExplanation: The events go as follows:\n- At time = 7, all the tasks become available. Available tasks = {0,1,2,3,4}.\n- Also at time = 7, the idle CPU starts processing task 4. Available tasks = {0,1,2,3}.\n- At time = 9, the CPU finishes task 4 and starts processing task 3. Available tasks = {0,1,2}.\n- At time = 13, the CPU finishes task 3 and starts processing task 2. Available tasks = {0,1}.\n- At time = 18, the CPU finishes task 2 and starts processing task 0. Available tasks = {1}.\n- At time = 28, the CPU finishes task 0 and starts processing task 1. Available tasks = {}.\n- At time = 40, the CPU finishes task 1 and becomes idle.",
      "images": []
    }
  ],
  "constraints": [
    "tasks.length == n",
    "1 <= n <= 105",
    "1 <= enqueueTimei, processingTimei <= 109"
  ],
  "follow_ups": [],
  "hints": [
    "To simulate the problem we first need to note that if at any point in time there are no enqueued tasks we need to wait to the smallest enqueue time of a non-processed element",
    "We need a data structure like a min-heap to support choosing the task with the smallest processing time from all the enqueued tasks"
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    vector<int> getOrder(vector<vector<int>>& tasks) {\n        \n    }\n};",
    "java": "class Solution {\n    public int[] getOrder(int[][] tasks) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def getOrder(self, tasks):\n        \"\"\"\n        :type tasks: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def getOrder(self, tasks: List[List[int]]) -> List[int]:\n        ",
    "c": "/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nint* getOrder(int** tasks, int tasksSize, int* tasksColSize, int* returnSize) {\n    \n}",
    "csharp": "public class Solution {\n    public int[] GetOrder(int[][] tasks) {\n        \n    }\n}",
    "javascript": "/**\n * @param {number[][]} tasks\n * @return {number[]}\n */\nvar getOrder = function(tasks) {\n    \n};",
    "typescript": "function getOrder(tasks: number[][]): number[] {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param Integer[][] $tasks\n     * @return Integer[]\n     */\n    function getOrder($tasks) {\n        \n    }\n}",
    "swift": "class Solution {\n    func getOrder(_ tasks: [[Int]]) -> [Int] {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun getOrder(tasks: Array<IntArray>): IntArray {\n        \n    }\n}",
    "dart": "class Solution {\n  List<int> getOrder(List<List<int>> tasks) {\n    \n  }\n}",
    "golang": "func getOrder(tasks [][]int) []int {\n    \n}",
    "ruby": "# @param {Integer[][]} tasks\n# @return {Integer[]}\ndef get_order(tasks)\n    \nend",
    "scala": "object Solution {\n    def getOrder(tasks: Array[Array[Int]]): Array[Int] = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn get_order(tasks: Vec<Vec<i32>>) -> Vec<i32> {\n        \n    }\n}",
    "racket": "(define/contract (get-order tasks)\n  (-> (listof (listof exact-integer?)) (listof exact-integer?))\n  )",
    "erlang": "-spec get_order(Tasks :: [[integer()]]) -> [integer()].\nget_order(Tasks) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec get_order(tasks :: [[integer]]) :: [integer]\n  def get_order(tasks) do\n    \n  end\nend"
  }
}