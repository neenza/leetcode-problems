{
  "title": "Count the Hidden Sequences",
  "problem_id": "2249",
  "frontend_id": "2145",
  "difficulty": "Medium",
  "problem_slug": "count-the-hidden-sequences",
  "topics": [
    "Array",
    "Prefix Sum"
  ],
  "description": "You are given a 0-indexed array of n integers differences, which describes the differences between each pair of consecutive integers of a hidden sequence of length (n + 1). More formally, call the hidden sequence hidden, then we have that differences[i] = hidden[i + 1] - hidden[i].\nYou are further given two integers lower and upper that describe the inclusive range of values [lower, upper] that the hidden sequence can contain.\nReturn the number of possible hidden sequences there are. If there are no possible sequences, return 0.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: differences = [1,-3,4], lower = 1, upper = 6\nOutput: 2\nExplanation: The possible hidden sequences are:\n- [3, 4, 1, 5]\n- [4, 5, 2, 6]\nThus, we return 2.",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input: differences = [3,-4,5,1,-2], lower = -4, upper = 5\nOutput: 4\nExplanation: The possible hidden sequences are:\n- [-3, 0, -4, 1, 2, 0]\n- [-2, 1, -3, 2, 3, 1]\n- [-1, 2, -2, 3, 4, 2]\n- [0, 3, -1, 4, 5, 3]\nThus, we return 4.",
      "images": []
    },
    {
      "example_num": 3,
      "example_text": "Input: differences = [4,-7,2], lower = 3, upper = 6\nOutput: 0\nExplanation: There are no possible hidden sequences. Thus, we return 0.",
      "images": []
    }
  ],
  "constraints": [
    "n == differences.length",
    "1 <= n <= 105",
    "-105 <= differences[i] <= 105",
    "-105 <= lower <= upper <= 105"
  ],
  "follow_ups": [],
  "hints": [
    "Fix the first element of the hidden sequence to any value x and ignore the given bounds. Notice that we can then determine all the other elements of the sequence by using the differences array.",
    "We will also be able to determine the difference between the minimum and maximum elements of the sequence. Notice that the value of x does not affect this.",
    "We now have the ‘range’ of the sequence (difference between min and max element), we can then calculate how many ways there are to fit this range into the given range of lower to upper.",
    "Answer is (upper - lower + 1) - (range of sequence)"
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    int numberOfArrays(vector<int>& differences, int lower, int upper) {\n        \n    }\n};",
    "java": "class Solution {\n    public int numberOfArrays(int[] differences, int lower, int upper) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def numberOfArrays(self, differences, lower, upper):\n        \"\"\"\n        :type differences: List[int]\n        :type lower: int\n        :type upper: int\n        :rtype: int\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def numberOfArrays(self, differences: List[int], lower: int, upper: int) -> int:\n        ",
    "c": "int numberOfArrays(int* differences, int differencesSize, int lower, int upper) {\n    \n}",
    "csharp": "public class Solution {\n    public int NumberOfArrays(int[] differences, int lower, int upper) {\n        \n    }\n}",
    "javascript": "/**\n * @param {number[]} differences\n * @param {number} lower\n * @param {number} upper\n * @return {number}\n */\nvar numberOfArrays = function(differences, lower, upper) {\n    \n};",
    "typescript": "function numberOfArrays(differences: number[], lower: number, upper: number): number {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param Integer[] $differences\n     * @param Integer $lower\n     * @param Integer $upper\n     * @return Integer\n     */\n    function numberOfArrays($differences, $lower, $upper) {\n        \n    }\n}",
    "swift": "class Solution {\n    func numberOfArrays(_ differences: [Int], _ lower: Int, _ upper: Int) -> Int {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun numberOfArrays(differences: IntArray, lower: Int, upper: Int): Int {\n        \n    }\n}",
    "dart": "class Solution {\n  int numberOfArrays(List<int> differences, int lower, int upper) {\n    \n  }\n}",
    "golang": "func numberOfArrays(differences []int, lower int, upper int) int {\n    \n}",
    "ruby": "# @param {Integer[]} differences\n# @param {Integer} lower\n# @param {Integer} upper\n# @return {Integer}\ndef number_of_arrays(differences, lower, upper)\n    \nend",
    "scala": "object Solution {\n    def numberOfArrays(differences: Array[Int], lower: Int, upper: Int): Int = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn number_of_arrays(differences: Vec<i32>, lower: i32, upper: i32) -> i32 {\n        \n    }\n}",
    "racket": "(define/contract (number-of-arrays differences lower upper)\n  (-> (listof exact-integer?) exact-integer? exact-integer? exact-integer?)\n  )",
    "erlang": "-spec number_of_arrays(Differences :: [integer()], Lower :: integer(), Upper :: integer()) -> integer().\nnumber_of_arrays(Differences, Lower, Upper) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec number_of_arrays(differences :: [integer], lower :: integer, upper :: integer) :: integer\n  def number_of_arrays(differences, lower, upper) do\n    \n  end\nend"
  },
  "solution": "[TOC]\n\n## Solution\n\n--- \n\n### Approach: Determine the Difference Between the Hidden Array's Upper and Lower Bounds\n\n#### Intuition\n\nLet $a_0, a_1, \\cdots, a_n$ be the final array. We can find that if the array $a$ meets the requirements, then:\n\n$$\na_0 + k, a_1 + k, \\cdots, a_n + k\n$$\n\nalso meets the requirements. The term \"requirement\" here refers to the difference between adjacent elements corresponding to the given array $\\textit{differences}$.\n\nWe can arbitrarily specify $a_0$. For convenience, let's directly set $a_0 = 0$, and then we can restore the array $a_0, a_1, \\cdots, a_n$. If we continue to consider the requirement that all array elements are within the range $[\\textit{lower}, \\textit{upper}]$, let's denote the smallest element of the array as $a_i$, and the largest element as $a_j$. It is obviously necessary to satisfy:\n\n$$\n\\textit{lower} \\leq a_i \\leq a_j \\leq \\textit{upper}\n$$\n\nThen the lower bound of the value of $a_i$ is $\\textit{lower}$, and the upper bound is $\\textit{upper} - (a_j - a_i)$, which means that the maximum value $a_j$ must not exceed $\\textit{upper}$. Here, $a_j - a_i$ is actually unrelated to the actual values of $a_i, a_j$, and it is equal to:\n\n$$\n\\sum_{k=i}^{j-1} \\textit{differences}[k]\n$$\n\nTherefore, the number of hidden arrays that meet the requirements is $\\textit{upper} - (a_j - a_i) - \\textit{lower} + 1$, and after arrangement, we get:\n\n$$\n(\\textit{upper} - \\textit{lower}) - (a_j - a_i) + 1\n$$\n\nIn fact, it is the length of the interval of the specified array elements, minus the difference between the maximum and minimum values of the array elements, plus $1$. We can consider it as the number of positions where a small window of length $a_j - a_i$ can be placed while sliding within a large window of length $\\textit{upper} - \\textit{lower}$.\n\nDuring the process of restoring the array $a$, we do not need to record the entire array, but only need to record the maximum and minimum values. If at any moment the difference between the maximum and minimum values is greater than $\\textit{upper} - \\textit{lower}$, we can directly return $0$.\n\n#### Implementation#### Complexity Analysis\n\n- Time complexity: $O(n)$.\n\nWe only need to traverse the $\\textit{differences}$ array once.\n\n- Space complexity: $O(1)$.\n\nOnly a few additional variables are needed."
}