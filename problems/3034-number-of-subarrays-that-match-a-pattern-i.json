{
  "title": "Number of Subarrays That Match a Pattern I",
  "problem_id": "3269",
  "frontend_id": "3034",
  "difficulty": "Medium",
  "problem_slug": "number-of-subarrays-that-match-a-pattern-i",
  "topics": [
    "Array",
    "Rolling Hash",
    "String Matching",
    "Hash Function"
  ],
  "description": "You are given a 0-indexed integer array nums of size n, and a 0-indexed integer array pattern of size m consisting of integers -1, 0, and 1.\nA subarray nums[i..j] of size m + 1 is said to match the pattern if the following conditions hold for each element pattern[k]:\nReturn the count of subarrays in nums that match the pattern.\nExample 1:\nExample 2:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: nums = [1,2,3,4,5,6], pattern = [1,1]\nOutput: 4\nExplanation: The pattern [1,1] indicates that we are looking for strictly increasing subarrays of size 3. In the array nums, the subarrays [1,2,3], [2,3,4], [3,4,5], and [4,5,6] match this pattern.\nHence, there are 4 subarrays in nums that match the pattern.",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input: nums = [1,4,4,1,3,5,5,3], pattern = [1,0,-1]\nOutput: 2\nExplanation: Here, the pattern [1,0,-1] indicates that we are looking for a sequence where the first number is smaller than the second, the second is equal to the third, and the third is greater than the fourth. In the array nums, the subarrays [1,4,4,1], and [3,5,5,3] match this pattern.\nHence, there are 2 subarrays in nums that match the pattern.",
      "images": []
    }
  ],
  "constraints": [
    "2 <= n == nums.length <= 100",
    "1 <= nums[i] <= 109",
    "1 <= m == pattern.length < n",
    "-1 <= pattern[i] <= 1"
  ],
  "follow_ups": [],
  "hints": [
    "Iterate over all indices <code>i</code> then, using a second loop, check if the subarray starting at index <code>i</code> matches the pattern."
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    int countMatchingSubarrays(vector<int>& nums, vector<int>& pattern) {\n        \n    }\n};",
    "java": "class Solution {\n    public int countMatchingSubarrays(int[] nums, int[] pattern) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def countMatchingSubarrays(self, nums, pattern):\n        \"\"\"\n        :type nums: List[int]\n        :type pattern: List[int]\n        :rtype: int\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def countMatchingSubarrays(self, nums: List[int], pattern: List[int]) -> int:\n        ",
    "c": "int countMatchingSubarrays(int* nums, int numsSize, int* pattern, int patternSize) {\n    \n}",
    "csharp": "public class Solution {\n    public int CountMatchingSubarrays(int[] nums, int[] pattern) {\n        \n    }\n}",
    "javascript": "/**\n * @param {number[]} nums\n * @param {number[]} pattern\n * @return {number}\n */\nvar countMatchingSubarrays = function(nums, pattern) {\n    \n};",
    "typescript": "function countMatchingSubarrays(nums: number[], pattern: number[]): number {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @param Integer[] $pattern\n     * @return Integer\n     */\n    function countMatchingSubarrays($nums, $pattern) {\n        \n    }\n}",
    "swift": "class Solution {\n    func countMatchingSubarrays(_ nums: [Int], _ pattern: [Int]) -> Int {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun countMatchingSubarrays(nums: IntArray, pattern: IntArray): Int {\n        \n    }\n}",
    "dart": "class Solution {\n  int countMatchingSubarrays(List<int> nums, List<int> pattern) {\n    \n  }\n}",
    "golang": "func countMatchingSubarrays(nums []int, pattern []int) int {\n    \n}",
    "ruby": "# @param {Integer[]} nums\n# @param {Integer[]} pattern\n# @return {Integer}\ndef count_matching_subarrays(nums, pattern)\n    \nend",
    "scala": "object Solution {\n    def countMatchingSubarrays(nums: Array[Int], pattern: Array[Int]): Int = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn count_matching_subarrays(nums: Vec<i32>, pattern: Vec<i32>) -> i32 {\n        \n    }\n}",
    "racket": "(define/contract (count-matching-subarrays nums pattern)\n  (-> (listof exact-integer?) (listof exact-integer?) exact-integer?)\n  )",
    "erlang": "-spec count_matching_subarrays(Nums :: [integer()], Pattern :: [integer()]) -> integer().\ncount_matching_subarrays(Nums, Pattern) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec count_matching_subarrays(nums :: [integer], pattern :: [integer]) :: integer\n  def count_matching_subarrays(nums, pattern) do\n    \n  end\nend"
  }
}