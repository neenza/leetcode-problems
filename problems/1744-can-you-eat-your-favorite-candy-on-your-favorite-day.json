{
  "title": "Can You Eat Your Favorite Candy on Your Favorite Day?",
  "problem_id": "1872",
  "frontend_id": "1744",
  "difficulty": "Medium",
  "problem_slug": "can-you-eat-your-favorite-candy-on-your-favorite-day",
  "topics": [
    "Array",
    "Prefix Sum"
  ],
  "description": "You are given a (0-indexed) array of positive integers candiesCount where candiesCount[i] represents the number of candies of the ith type you have. You are also given a 2D array queries where queries[i] = [favoriteTypei, favoriteDayi, dailyCapi].\nYou play a game with the following rules:\nConstruct a boolean array answer such that answer.length == queries.length and answer[i] is true if you can eat a candy of type favoriteTypei on day favoriteDayi without eating more than dailyCapi candies on any day, and false otherwise. Note that you can eat different types of candy on the same day, provided that you follow rule 2.\nReturn the constructed array answer.\nExample 1:\nExample 2:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: candiesCount = [7,4,5,3,8], queries = [[0,2,2],[4,2,4],[2,13,1000000000]]\nOutput: [true,false,true]\nExplanation:\n1- If you eat 2 candies (type 0) on day 0 and 2 candies (type 0) on day 1, you will eat a candy of type 0 on day 2.\n2- You can eat at most 4 candies each day.\n   If you eat 4 candies every day, you will eat 4 candies (type 0) on day 0 and 4 candies (type 0 and type 1) on day 1.\n   On day 2, you can only eat 4 candies (type 1 and type 2), so you cannot eat a candy of type 4 on day 2.\n3- If you eat 1 candy each day, you will eat a candy of type 2 on day 13.",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input: candiesCount = [5,2,6,4,1], queries = [[3,1,2],[4,10,3],[3,10,100],[4,100,30],[1,3,1]]\nOutput: [false,true,true,false,false]",
      "images": []
    }
  ],
  "constraints": [
    "1 <= candiesCount.length <= 105",
    "1 <= candiesCount[i] <= 105",
    "1 <= queries.length <= 105",
    "queries[i].length == 3",
    "0 <= favoriteTypei < candiesCount.length",
    "0 <= favoriteDayi <= 109",
    "1 <= dailyCapi <= 109"
  ],
  "follow_ups": [],
  "hints": [
    "The query is true if and only if your favorite day is in between the earliest and latest possible days to eat your favorite candy.",
    "To get the earliest day, you need to eat dailyCap candies every day. To get the latest day, you need to eat 1 candy every day.",
    "The latest possible day is the total number of candies with a smaller type plus the number of your favorite candy minus 1.",
    "The earliest possible day that you can eat your favorite candy is the total number of candies with a smaller type divided by dailyCap."
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    vector<bool> canEat(vector<int>& candiesCount, vector<vector<int>>& queries) {\n        \n    }\n};",
    "java": "class Solution {\n    public boolean[] canEat(int[] candiesCount, int[][] queries) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def canEat(self, candiesCount, queries):\n        \"\"\"\n        :type candiesCount: List[int]\n        :type queries: List[List[int]]\n        :rtype: List[bool]\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def canEat(self, candiesCount: List[int], queries: List[List[int]]) -> List[bool]:\n        ",
    "c": "/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nbool* canEat(int* candiesCount, int candiesCountSize, int** queries, int queriesSize, int* queriesColSize, int* returnSize) {\n    \n}",
    "csharp": "public class Solution {\n    public bool[] CanEat(int[] candiesCount, int[][] queries) {\n        \n    }\n}",
    "javascript": "/**\n * @param {number[]} candiesCount\n * @param {number[][]} queries\n * @return {boolean[]}\n */\nvar canEat = function(candiesCount, queries) {\n    \n};",
    "typescript": "function canEat(candiesCount: number[], queries: number[][]): boolean[] {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param Integer[] $candiesCount\n     * @param Integer[][] $queries\n     * @return Boolean[]\n     */\n    function canEat($candiesCount, $queries) {\n        \n    }\n}",
    "swift": "class Solution {\n    func canEat(_ candiesCount: [Int], _ queries: [[Int]]) -> [Bool] {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun canEat(candiesCount: IntArray, queries: Array<IntArray>): BooleanArray {\n        \n    }\n}",
    "dart": "class Solution {\n  List<bool> canEat(List<int> candiesCount, List<List<int>> queries) {\n    \n  }\n}",
    "golang": "func canEat(candiesCount []int, queries [][]int) []bool {\n    \n}",
    "ruby": "# @param {Integer[]} candies_count\n# @param {Integer[][]} queries\n# @return {Boolean[]}\ndef can_eat(candies_count, queries)\n    \nend",
    "scala": "object Solution {\n    def canEat(candiesCount: Array[Int], queries: Array[Array[Int]]): Array[Boolean] = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn can_eat(candies_count: Vec<i32>, queries: Vec<Vec<i32>>) -> Vec<bool> {\n        \n    }\n}",
    "racket": "(define/contract (can-eat candiesCount queries)\n  (-> (listof exact-integer?) (listof (listof exact-integer?)) (listof boolean?))\n  )",
    "erlang": "-spec can_eat(CandiesCount :: [integer()], Queries :: [[integer()]]) -> [boolean()].\ncan_eat(CandiesCount, Queries) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec can_eat(candies_count :: [integer], queries :: [[integer]]) :: [boolean]\n  def can_eat(candies_count, queries) do\n    \n  end\nend"
  }
}