{
  "title": "Product Sales Analysis III",
  "problem_id": "1155",
  "frontend_id": "1070",
  "difficulty": "Medium",
  "problem_slug": "product-sales-analysis-iii",
  "topics": [
    "Database"
  ],
  "description": "Table: Sales\nWrite a solution to find all sales that occurred in the first year each product was sold.\nReturn a table with the following columns: product_id, first_year, quantity, and price.\nReturn the result in any order.\nExample 1:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "+-------------+-------+\n| Column Name | Type  |\n+-------------+-------+\n| sale_id     | int   |\n| product_id  | int   |\n| year        | int   |\n| quantity    | int   |\n| price       | int   |\n+-------------+-------+\n(sale_id, year) is the primary key (combination of columns with unique values) of this table.\nproduct_id is a foreign key (reference column) to Product table.\nEach row records a sale of a product in a given year.\nA product may have multiple sales entries in the same year.\nNote that the per-unit price.",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input: \nSales table:\n+---------+------------+------+----------+-------+\n| sale_id | product_id | year | quantity | price |\n+---------+------------+------+----------+-------+ \n| 1       | 100        | 2008 | 10       | 5000  |\n| 2       | 100        | 2009 | 12       | 5000  |\n| 7       | 200        | 2011 | 15       | 9000  |\n+---------+------------+------+----------+-------+\n\nOutput: \n+------------+------------+----------+-------+\n| product_id | first_year | quantity | price |\n+------------+------------+----------+-------+ \n| 100        | 2008       | 10       | 5000  |\n| 200        | 2011       | 15       | 9000  |\n+------------+------------+----------+-------+",
      "images": []
    }
  ],
  "constraints": [],
  "follow_ups": [],
  "hints": [],
  "code_snippets": {
    "mysql": "# Write your MySQL query statement below\n",
    "mssql": "/* Write your T-SQL query statement below */\n",
    "oraclesql": "/* Write your PL/SQL query statement below */\n",
    "pythondata": "import pandas as pd\n\ndef sales_analysis(sales: pd.DataFrame) -> pd.DataFrame:\n    ",
    "postgresql": "-- Write your PostgreSQL query statement below\n"
  },
  "solution": "[TOC]\n\n# Solution\n\n---\n\n## pandas\n### Approach: Group-Merge-Filter\n\n**Visualization of general idea**\n![fig](../Figures/1070/1070-1.png)\n\n#### Intuition\n\nLet's break down this approach step by step using the following input DataFrames:\n\n`sales`:sale_idproduct_idyearquantityprice110020081050002100200912500072002011159000`product`:product_idproduct_name100Nokia200Apple300Samsung1. **Group By & Min**\n   We start with grouping because it allows us to efficiently aggregate our sales data by product. By obtaining the minimum `year` for each `product_id`, we can swiftly pinpoint the debut sale year for each product.\n\n   ```python\n   df = sales.groupby('product_id', as_index=False)['year'].min()\n   ```\n   - This line groups the `sales` DataFrame by `product_id` and selects the minimum `year` for each group, which signifies the first year a product was sold.\n   - The resulting DataFrame `df` has columns `product_id` and `year`.\n\n`df` will be as follows:product_idyear100200820020112. **Merge DataFrames**\n   Merging is a natural step after grouping, especially when you need to fetch related data based on the aggregated result. By merging on `product_id`, we ensure that we capture the entire sales record for the debut year.\n   \n   ```python\n   sales.merge(df, on='product_id', how='inner')\n   ```\n   - This line merges the original `sales` DataFrame with the `df` DataFrame (containing the first year of sale for each product) based on the `product_id` column.\n   - Since an inner join is used, only the rows with matching `product_id`s in both DataFrames will be retained.\n\n`sales` will look like:product_idyear_xquantitypriceyear_y1002008105000200810020091250002008200201115900020113. **Filter Rows**\n  This is essential to eliminate any extraneous data, ensuring we only get the records from the debut year of the product. Without this step, we might get sales data from non-debut years, defeating the approach's purpose.\n\n   ```python\n   .query('year_x == year_y')\n   ```\n   - After the merge, the DataFrame will have two `year` columns, one from each of the original DataFrames, renamed as `year_x` and `year_y` by pandas.\n   - This line filters the rows where `year_x` (the original sale year) is equal to `year_y` (the first year of sale), retaining only the sales information for the first year each product was sold.\n\n`sales` will look like:product_idyear_xquantitypriceyear_y10020081050002008200201115900020114. **Rename Column & Select Columns**\n   ```python\n   .rename(columns={'year_x': 'first_year'})[['product_id', 'first_year', 'quantity', 'price']]\n   ```\n   - This line renames the `year_x` column to `first_year`, making the DataFrame more understandable.\n   - Finally, it selects only the desired columns, resulting in a DataFrame with columns: `product_id`, `first_year`, `quantity`, and `price`.\n\n`sales` will be as follows:product_idfirst_yearquantityprice100200810500020020111590005. **Return Result**\n   - The final DataFrame, after all the transformations, is returned from the function.\n\nIntuitively, this function is finding the first year of sale for each product and then fetching the corresponding sales information for those years.\n\n#### Implementation---\n\n## Database\n### Approach: Filtering from Minimum Value Subquery\n\n#### Intuition\n\nLet's break down this approach step by step:\n\n1. **Inner Subquery**:\n   ```sql\n   SELECT \n     product_id, \n     MIN(year) AS year \n   FROM \n     Sales \n   GROUP BY \n     product_id\n   ```\n   - The inner subquery is grouping the `Sales` table by `product_id`.\n   - For each `product_id`, it's finding the minimum `year`, i.e., the first year a product was sold.\n   - This subquery returns a list of `product_id`s along with the corresponding first year they were sold.\n\n2. **Main Query**:\n   ```sql\n   SELECT \n     product_id, \n     year AS first_year, \n     quantity, \n     price \n   FROM \n     Sales \n   WHERE \n     (product_id, year) IN (subquery)\n   ```\n   - The main query is selecting `product_id`, `year`, `quantity`, and `price` from the `Sales` table.\n   - The `WHERE` clause is using a condition `(product_id, year) IN (subquery)`. This means it's filtering the rows from the `Sales` table where the combination of `product_id` and `year` is present in the list generated by the subquery.\n   - Essentially, this condition ensures that only the rows corresponding to the first year of sale for each product are returned.\n\n3. **Result**:\n   - The final result of this query is a table containing the `product_id`, the `first_year` a product was sold, the `quantity` sold, and the `price` per unit for that year.\n\nIntuitively, what the query does is that it first identifies the first year each product was sold using the inner subquery, and then it fetches the corresponding `product_id`, `year`, `quantity`, and `price` for those identified years from the main `Sales` table using the main query.\n\n\n#### Implementation\n\n```mysql []\nSELECT \n  product_id, \n  year AS first_year, \n  quantity, \n  price \nFROM \n  Sales \nWHERE \n  (product_id, year) IN (\n    SELECT \n      product_id, \n      MIN(year) AS year \n    FROM \n      Sales \n    GROUP BY \n      product_id\n  );\n```"
}