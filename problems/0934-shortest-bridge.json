{
  "title": "Shortest Bridge",
  "problem_id": "971",
  "frontend_id": "934",
  "difficulty": "Medium",
  "problem_slug": "shortest-bridge",
  "topics": [
    "Array",
    "Depth-First Search",
    "Breadth-First Search",
    "Matrix"
  ],
  "description": "You are given an n x n binary matrix grid where 1 represents land and 0 represents water.\nAn island is a 4-directionally connected group of 1's not connected to any other 1's. There are exactly two islands in grid.\nYou may change 0's to 1's to connect the two islands to form one island.\nReturn the smallest number of 0's you must flip to connect the two islands.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: grid = [[0,1],[1,0]]\nOutput: 1",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input: grid = [[0,1,0],[0,0,0],[0,0,1]]\nOutput: 2",
      "images": []
    },
    {
      "example_num": 3,
      "example_text": "Input: grid = [[1,1,1,1,1],[1,0,0,0,1],[1,0,1,0,1],[1,0,0,0,1],[1,1,1,1,1]]\nOutput: 1",
      "images": []
    }
  ],
  "constraints": [
    "n == grid.length == grid[i].length",
    "2 <= n <= 100",
    "grid[i][j] is either 0 or 1.",
    "There are exactly two islands in grid."
  ],
  "follow_ups": [],
  "hints": [],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    int shortestBridge(vector<vector<int>>& grid) {\n        \n    }\n};",
    "java": "class Solution {\n    public int shortestBridge(int[][] grid) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def shortestBridge(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def shortestBridge(self, grid: List[List[int]]) -> int:\n        ",
    "c": "int shortestBridge(int** grid, int gridSize, int* gridColSize) {\n    \n}",
    "csharp": "public class Solution {\n    public int ShortestBridge(int[][] grid) {\n        \n    }\n}",
    "javascript": "/**\n * @param {number[][]} grid\n * @return {number}\n */\nvar shortestBridge = function(grid) {\n    \n};",
    "typescript": "function shortestBridge(grid: number[][]): number {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param Integer[][] $grid\n     * @return Integer\n     */\n    function shortestBridge($grid) {\n        \n    }\n}",
    "swift": "class Solution {\n    func shortestBridge(_ grid: [[Int]]) -> Int {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun shortestBridge(grid: Array<IntArray>): Int {\n        \n    }\n}",
    "dart": "class Solution {\n  int shortestBridge(List<List<int>> grid) {\n    \n  }\n}",
    "golang": "func shortestBridge(grid [][]int) int {\n    \n}",
    "ruby": "# @param {Integer[][]} grid\n# @return {Integer}\ndef shortest_bridge(grid)\n    \nend",
    "scala": "object Solution {\n    def shortestBridge(grid: Array[Array[Int]]): Int = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn shortest_bridge(grid: Vec<Vec<i32>>) -> i32 {\n        \n    }\n}",
    "racket": "(define/contract (shortest-bridge grid)\n  (-> (listof (listof exact-integer?)) exact-integer?)\n  )",
    "erlang": "-spec shortest_bridge(Grid :: [[integer()]]) -> integer().\nshortest_bridge(Grid) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec shortest_bridge(grid :: [[integer]]) :: integer\n  def shortest_bridge(grid) do\n    \n  end\nend"
  },
  "solution": "[TOC]\n\n## Solution\n\n--- \n\n### Overview\n\nAs shown in the examples below, we need to flip at least **3** cells to connect island `A` and island `B` in the left case, and flip at least **5** cells in the right case.\n\n![img](../Figures/934/intro.png)\n\n\n\n---\n\n### Approach 1: Depth-First-Search + Breadth-First-Search\n\n#### Intuition  \n\nIf you are not familiar with the Depth-First-Search (DFS) or the Breadth-First-Search (BFS) algorithms, please refer to our explore cards: \n\n- [Depth-First-Search Explore Card](https://leetcode.com/explore/featured/card/graph/619/depth-first-search-in-graph/)\n- [Breadth-First-Search Explore Card](https://leetcode.com/explore/featured/card/graph/620/breadth-first-search-in-graph/)\n\n\nIn order to find the minimum number of flips required to reach the destination island, or in other words, the minimum distance between the two islands, we can use a combination of DFS and BFS algorithms. Start by finding all the land cells on the first island (let's call it island `A`) using the DFS method. \n\n\nHere's how: we start with one cell of island `A` and try to move to its four neighboring cells. If there is an unvisited neighboring land cell, we move to that cell and change its value to a number like `2` to avoid revisiting it again in the future and distinguish it from the land cells of the other island. We then repeat the same strategy from the new cell. If we find that the current cell has no unvisited neighbors, we will backtrack to the previous cell and try the next neighboring cell from there. The numbers on the cells in the following figure represent the order of our visits.\n\n\n\n![img](../Figures/934/2.png)\n\nNow that we have found all the cells in island `A` and set them to `2`, in `grid` we have:\n\n- `0` for the water cells.\n- `2` for the land cells of the first island (island `A`)\n- `1` for the land cells of the second island (island `B`)\n\n\nThen, we can use BFS to find the shortest distance from island `A` to island `B`. Here is the step-by-step process for the BFS algorithm:\n\n1) We start with all the cells in island `A` as the source, and set `distance` to `0`.\n2) Add all the cells of island `A` to a list `bfs_queue`.\n3) While `bfs_queue` is not empty, we build an empty list `new_bfs` as the candidate cells for the next BFS round, then we iterate over every cell `(x, y)` in `bfs_queue`.\n4) Check the four neighbors of `(x, y)` (up, down, left, and right). If a valid neighbor has value of `0`, we can mark it as visited by setting the value as `-1`, then we can add this cell to the list `new_bfs`. If a neighbor cell has a value of `1`, it means that we have found a land cell of the second island (island `B`). Since we are traversing water cells in BFS approach, it means that the first cell of island `B` we found has the shortest distance from island `A` among all cells on island `B`.\n5) Once the iteration (current round) ends, if we still haven't reached island `B`, it means that we should look for cells that have a longer distance from island `A`. Therefore, we increment `distance` by 1, set `bfs_queue = new_bfs`, and repeat step 3.\n\nThis approach is shown in the picture below. The distance of each cell from island `A` is also shown.\n- We start with all cells in island `A` that have a distance of 0.\n- In the first round, we visit all water cells that have a distance of 1 from island `A`.\n- In the second round, we visit all water cells that have a distance of 2 from island `A`.\n- In the third round, we visit all water cells that have a distance of 3 from island `A`.\n\nAfter 3 rounds of BFS search, we find some land cells of island `B` being the neighbors of water cells that have a distance of `3` from island `A`, we can stop the BFS search.\n\n\n![img](../Figures/934/4.png)\n\nThe shortest distance between the two islands is 3, so we need at least 3 flips (highlighted in yellow) to connect them.\n\n\n> Note that in this approach we are directly modifying the input to help us distinguish cells. It is generally not good practice to modify the input, and if the interviewer is against it, you can accomplish the same functionality by using a set to store cells that have already been visited instead.#### Algorithm\n\n1) Iterate over the grid `grid` until we find a land cell, suppose it is `grid[first_x][first_y]`.\n\n2) Start from `grid[first_x][first_y]` and use depth-first search to find and set the values of all cells of the same island (island `A`) to `2`.\n\n\n3) Create a list `bfs_queue` and add all cells on island `A` to it, starting with `distance = 0`.\n\n4) While `bfs_queue` is not empty, we create another list `new_bfs` to collect the water cells we need to visit in the next round. Iterate over cells in `bfs_queue`, for each cell `(x, y)`:\n    - if `grid[x][y] = 1`, it means we have reached the second island, return `distance`. \n    - Otherwise, we look for its unvisited water neighbors (cells with value `0`), mark them as `-1`, and add them to `new_bfs`.\n    \n5) Once the iteration ends, set `bfs_queue = new_bfs`, increment `distance` by 1, and start the next round by repeating step 4.\n\n\n\n#### Implementation#### Complexity Analysis\n\nLet $$n \\times n$$ be the size of the input matrix `grid`.\n\n* Time complexity: $$O(n^2)$$\n\n    - The general time complexity of Depth-First-Search is $$O(V + E)$$, where $$V$$ stands for the number of vertices. The maximum number of cells in the first island is $$n^2$$, so iterating over its cells will take $$O(n^2)$$ time. $$E$$ is a constant here since we are only allowed to traverse in up to 4 directions.\n\n    - The general time complexity of Breadth-First-Search is $$O(V + E)$$, where $$V$$ stands for the number of vertices. The maximum number of water cells we need to check before reaching the second island is $$n^2$$, which will take $$O(n^2)$$ time.\n    \n\n* Space complexity: $$O(n^2)$$\n\n    - The general space complexity of Depth-First-Search is $$O(V)$$, where $$V$$ stands for the number of vertices. The maximum number of cells in the first island is $$n^2$$, thus the space used by the recursive stack during DFS is $$O(n^2)$$\n\n    - The general space complexity of Breadth-First-Search is $$O(V)$$, where $$V$$ stands for the number of vertices. The maximum number of water cells we need to check using BFS before reaching the second island is $$n^2$$, thus the space used by the queue is $$O(n^2)$$.\n    - To sum up, the overall space complexity is $$O(n^2)$$---\n\n### Approach 2: Breadth-First-Search\n\n#### Intuition   \n\nIn this approach, we will use the same strategy as in the previous approach, but we will use BFS instead of DFS to search for all cells of island `A`. Again, we will first traverse `grid`, take the first land found (assume it is `grid[first_x][first_y]`) and treat it as a land cell of Island `A`. Then, we BFS over all cells of island `A` and set their values to `2` to distinguish them from the other island. \n\n\n![img](../Figures/934/3.png)#### Algorithm\n\n1) Iterate over the `grid` until we find the first land cell, suppose it is `grid[first_x][first_y]`.\n\n2) Create:\n    - a list `bfs_queue` and add `grid[first_x][first_y]` on island `A` to it.\n    - an empty list `new_bfs` for the next round's search.\n    - an empty list `second_bfs_queue` for searching the distance between two islands later.\n\n3) Iterate over `bfs_queue`, for each cell `grid[x][y]`, if `grid[x][y] = 1`:\n    - set `grid[x][y] = 2`\n    - add `(x, y)` to `new_bfs` for the next round's search.\n    - add `(x, y)` to `second_bfs_queue` for searching over water cells later.\n\n4) If `new_bfs` is not empty, we set `bfs_queue = new_bfs` and repeat step 3. Otherwise, move on to step 5.\n\n5) Set `distance = 0`. \n\n6) Now we start BFS on water cells. While `second_bfs_queue` is not empty, we create an empty list `new_bfs` to collect the cells we need to visit in the next round. Iterate over cells in `second_bfs_queue`, for each cell `(x, y)`:\n    - if `grid[x][y] = 1`, it means we have reached the second island, return `distance`. \n    - Otherwise, we look for its unvisited water neighbors (cells with value of `0`), mark them as `-1` and add them to `new_bfs`.\n    \n5) Once the iteration ends, set `second_bfs_queue = new_bfs`, increment `distance` by 1, and repeat the step 6.\n\n#### Implementation#### Complexity Analysis\n\nLet $$n \\times n$$ be the size of the input matrix `grid`.\n\n* Time complexity: $$O(n^2)$$\n\n    - The maximum number of water cells and the maximum number of land cells in island `A` we need to check are $$n^2$$, which will take $$O(n^2)$$ time.\n    \n\n* Space complexity: $$O(n^2)$$\n\n    - The maximum number of land cells of island `A` that we need to check with BFS is $$n^2$$, thus the space used by `bfs_queue` is $$O(n^2)$$.\n    - The maximum number of water cells we need to check using BFS before reaching the second island is $$n^2$$, thus the space used by `second_bfs_queue` is also $$O(n^2)$$.\n    - To sum up, the overall space complexity is $$O(n^2)$$"
}