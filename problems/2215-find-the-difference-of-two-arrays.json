{
  "title": "Find the Difference of Two Arrays",
  "problem_id": "1392",
  "frontend_id": "2215",
  "difficulty": "Easy",
  "problem_slug": "find-the-difference-of-two-arrays",
  "topics": [
    "Array",
    "Hash Table"
  ],
  "description": "Given two 0-indexed integer arrays nums1 and nums2, return a list answer of size 2 where:\nNote that the integers in the lists may be returned in any order.\nExample 1:\nExample 2:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: nums1 = [1,2,3], nums2 = [2,4,6]\nOutput: [[1,3],[4,6]]\nExplanation:\nFor nums1, nums1[1] = 2 is present at index 0 of nums2, whereas nums1[0] = 1 and nums1[2] = 3 are not present in nums2. Therefore, answer[0] = [1,3].\nFor nums2, nums2[0] = 2 is present at index 1 of nums1, whereas nums2[1] = 4 and nums2[2] = 6 are not present in nums1. Therefore, answer[1] = [4,6].",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input: nums1 = [1,2,3,3], nums2 = [1,1,2,2]\nOutput: [[3],[]]\nExplanation:\nFor nums1, nums1[2] and nums1[3] are not present in nums2. Since nums1[2] == nums1[3], their value is only included once and answer[0] = [3].\nEvery integer in nums2 is present in nums1. Therefore, answer[1] = [].",
      "images": []
    }
  ],
  "constraints": [
    "1 <= nums1.length, nums2.length <= 1000",
    "-1000 <= nums1[i], nums2[i] <= 1000"
  ],
  "follow_ups": [],
  "hints": [
    "For each integer in nums1, check if it exists in nums2.",
    "Do the same for each integer in nums2."
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    vector<vector<int>> findDifference(vector<int>& nums1, vector<int>& nums2) {\n        \n    }\n};",
    "java": "class Solution {\n    public List<List<Integer>> findDifference(int[] nums1, int[] nums2) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def findDifference(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def findDifference(self, nums1: List[int], nums2: List[int]) -> List[List[int]]:\n        ",
    "c": "/**\n * Return an array of arrays of size *returnSize.\n * The sizes of the arrays are returned as *returnColumnSizes array.\n * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().\n */\nint** findDifference(int* nums1, int nums1Size, int* nums2, int nums2Size, int* returnSize, int** returnColumnSizes) {\n    \n}",
    "csharp": "public class Solution {\n    public IList<IList<int>> FindDifference(int[] nums1, int[] nums2) {\n        \n    }\n}",
    "javascript": "/**\n * @param {number[]} nums1\n * @param {number[]} nums2\n * @return {number[][]}\n */\nvar findDifference = function(nums1, nums2) {\n    \n};",
    "typescript": "function findDifference(nums1: number[], nums2: number[]): number[][] {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param Integer[] $nums1\n     * @param Integer[] $nums2\n     * @return Integer[][]\n     */\n    function findDifference($nums1, $nums2) {\n        \n    }\n}",
    "swift": "class Solution {\n    func findDifference(_ nums1: [Int], _ nums2: [Int]) -> [[Int]] {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun findDifference(nums1: IntArray, nums2: IntArray): List<List<Int>> {\n        \n    }\n}",
    "dart": "class Solution {\n  List<List<int>> findDifference(List<int> nums1, List<int> nums2) {\n    \n  }\n}",
    "golang": "func findDifference(nums1 []int, nums2 []int) [][]int {\n    \n}",
    "ruby": "# @param {Integer[]} nums1\n# @param {Integer[]} nums2\n# @return {Integer[][]}\ndef find_difference(nums1, nums2)\n    \nend",
    "scala": "object Solution {\n    def findDifference(nums1: Array[Int], nums2: Array[Int]): List[List[Int]] = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn find_difference(nums1: Vec<i32>, nums2: Vec<i32>) -> Vec<Vec<i32>> {\n        \n    }\n}",
    "racket": "(define/contract (find-difference nums1 nums2)\n  (-> (listof exact-integer?) (listof exact-integer?) (listof (listof exact-integer?)))\n  )",
    "erlang": "-spec find_difference(Nums1 :: [integer()], Nums2 :: [integer()]) -> [[integer()]].\nfind_difference(Nums1, Nums2) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec find_difference(nums1 :: [integer], nums2 :: [integer]) :: [[integer]]\n  def find_difference(nums1, nums2) do\n    \n  end\nend"
  },
  "solution": "[TOC]\n\n## Solution\n\n--- \n\n### Overview\n\nWe are given two integer arrays, `nums1` and `nums2`, and need to return a list of two lists. The first list has the elements that are present only in `nums1`, while the second list has the elements that are present only in `nums2`.---\n\n### Approach 1: Brute Force\n\n**Intuition**\n\nTo find the elements in a list that are not present in another list, we can loop over every element in the first list and for each element we loop over the elements in the second list to check if it's present or not. If we find the element, we will not store it in the answer list; otherwise, we can store it.\n\nThis way, we will have to apply the above method twice once for the elements that are only in `nums1` and then again for the elements that are only present in `nums2`.\n\n**Algorithm**\n\n- `getElementsOnlyInFirstList` function:\n  - Initialize an empty set `onlyInNums1` to store elements that are only in `nums1`.\n  \n  - Iterate over each element `num` in `nums1`:\n    - Set a boolean flag `existInNums2` to `false`.\n    - Iterate over each element `x` in `nums2`:\n      - If `num` is found in `nums2` (i.e., `x == num`), set `existInNums2` to `true` and break the inner loop.\n    \n    - If `existInNums2` is still `false`, add `num` to the set `onlyInNums1` (i.e., `num` exists in `nums1` but not in `nums2`).\n  \n  - Convert `onlyInNums1` set to a list and return it.\n\n- `findDifference` function:\n  - Call `getElementsOnlyInFirstList(nums1, nums2)` to get elements only in `nums1` and store the result.\n  - Call `getElementsOnlyInFirstList(nums2, nums1)` to get elements only in `nums2` and store the result.\n  - Return a list of both results as a list of lists).\n\n- The overall result contains two lists:\n  - The first list contains elements in `nums1` that are not in `nums2`.\n  - The second list contains elements in `nums2` that are not in `nums1`.\n\n**Implementation****Complexity Analysis**\n\nHere, $N$ is the length of list `nums1`, and $M$ is the length of `nums2`.\n\n* Time complexity: $O(N \\times M)$.\n\n  The outer function `findDifference` calls the helper function `getElementsOnlyInFirstList` twice, once for `nums1` and once for `nums2`. For each element in `nums1`, we loop through all elements in `nums2` to check for existence, which results in a nested loop. The first loop runs for $N$ iterations, and for each iteration, the inner loop runs for $M$ iterations. This leads to a time complexity of $O(N \\times M)$.\n\n  Additionally, the process of inserting elements into the set and converting the set into a list both take linear time, which is $O(N)$ for each. However, since $N \\times M$ dominates, the overall time complexity remains $O(N \\times M)$.\n\n  The second call to `getElementsOnlyInFirstList(nums2, nums1)` has similar behavior with $M \\times N$, but since multiplication is commutative, this still results in $O(N \\times M)$ overall.\n\n* Space complexity: $O(N + M)$.\n\n  The space complexity is primarily determined by the set and the list used to store unique elements. In the worst case, all elements of `nums1` and `nums2` are unique, leading to $O(N)$ space for the set in the first call and $O(M)$ space in the second call.\n\n  Since both data structures exist separately for each call and are converted to list, the overall space usage is $O(N + M)$. The extra space for variables like `existInNums2` and loop counters is negligible, making the auxiliary space $O(1)$.\n\n---\n\n### Approach 2: HashSet\n\n**Intuition**\n\nInstead of iterating over each element in the second array to check if it exists in the list or not, we can store the elements in a HashSet. Then we can find if an element exists in the list or not in $O(1)$ time compared to $O(N)$ time in the previous approach.\n\nIn this approach, we follow the above intuition. To find the elements that only exist in `nums1`, we first store the elements in `nums2` in the HashSet. Then we iterate over each element in the list `nums1`, and for each element, we check if it's there in the HashSet; if yes, we skip the element; otherwise, we store it in the list `onlyInNums1`.\n\n![fig](../Figures/2215/2215A.png)\n\n**Algorithm**\n\n- `getElementsOnlyInFirstList` function:\n  - Initialize an empty set `onlyInNums1` to store elements that are only in `nums1`.\n  \n  - Create a set `existsInNums2` to store all elements from `nums2`:\n    - Iterate over each element `num` in `nums2` and add it to the set `existsInNums2`.\n\n  - Iterate over each element `num` in `nums1`:\n    - If `num` is not in `existsInNums2`, add it to the set `onlyInNums1` (i.e., `num` exists in `nums1` but not in `nums2`).\n\n  - Convert `onlyInNums1` set to a list and return it.\n\n- `findDifference` function:\n  - Call `getElementsOnlyInFirstList(nums1, nums2)` to get elements only in `nums1` and store the result.\n  - Call `getElementsOnlyInFirstList(nums2, nums1)` to get elements only in `nums2` and store the result.\n  - Return a list of both results as a list of lists (i.e., `Arrays.asList`).\n\n- The overall result contains two lists:\n  - The first list contains elements in `nums1` that are not in `nums2`.\n  - The second list contains elements in `nums2` that are not in `nums1`.\n\n**Implementation****Complexity Analysis**\n\nHere, $N$ is the length of list `nums1`, and $M$ is the length of `nums2`.\n\n* Time complexity: $O(N + M)$.\n\n  In this implementation, the function `getElementsOnlyInFirstList` is called twice. For each call, we first iterate over `nums2` to store its elements in a set. This operation takes $O(M)$ time, where $M$ is the length of `nums2`. Inserting elements into a set is on average an $O(1)$ operation, so this step runs in $O(M)$ time.\n\n  Next, we iterate over `nums1` and for each element, we check if it exists in the `existsInNums2` set. This lookup operation in a set also takes $O(1)$ on average, meaning the entire iteration over `nums1` takes $O(N)$ time.\n\n  Since we perform these two operations (storing elements in a set and iterating over another set) for both `nums1` and `nums2`, the total time complexity is $O(N + M)$ for each call to `getElementsOnlyInFirstList`. Thus, the overall time complexity is $O(N + M)$.\n\n* Space complexity: $O(N + M)$.\n\n  The space complexity is primarily determined by the set data structures used to store the elements of `nums2` and the unique elements from `nums1`. In the worst case, all elements of `nums1` and `nums2` are unique, meaning the set for `nums2` will take $O(M)$ space, and the set for the unique elements of `nums1` will take $O(N)$ space.\n\n  Additionally, the list created to store the result takes up $O(N)$ space, as it needs to hold the elements from the set. Therefore, the total space complexity is $O(N + M)$, as the two sets and the lists are the main contributors to space usage.\n\n---"
}