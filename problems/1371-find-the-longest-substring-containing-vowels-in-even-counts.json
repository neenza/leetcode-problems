{
  "title": "Find the Longest Substring Containing Vowels in Even Counts",
  "problem_id": "1473",
  "frontend_id": "1371",
  "difficulty": "Medium",
  "problem_slug": "find-the-longest-substring-containing-vowels-in-even-counts",
  "topics": [
    "Hash Table",
    "String",
    "Bit Manipulation",
    "Prefix Sum"
  ],
  "description": "Given the string s, return the size of the longest substring containing each vowel an even number of times. That is, 'a', 'e', 'i', 'o', and 'u' must appear an even number of times.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: s = \"eleetminicoworoep\"\nOutput: 13\nExplanation: The longest substring is \"leetminicowor\" which contains two each of the vowels: e, i and o and zero of the vowels: a and u.",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input: s = \"leetcodeisgreat\"\nOutput: 5\nExplanation: The longest substring is \"leetc\" which contains two e's.",
      "images": []
    },
    {
      "example_num": 3,
      "example_text": "Input: s = \"bcbcbc\"\nOutput: 6\nExplanation: In this case, the given string \"bcbcbc\" is the longest because all vowels: a, e, i, o and u appear zero times.",
      "images": []
    }
  ],
  "constraints": [
    "1 <= s.length <= 5 x 10^5",
    "s contains only lowercase English letters."
  ],
  "follow_ups": [],
  "hints": [
    "Represent the counts (odd or even) of vowels with a bitmask.",
    "Precompute the prefix xor for the bitmask of vowels and then get the longest valid substring."
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    int findTheLongestSubstring(string s) {\n        \n    }\n};",
    "java": "class Solution {\n    public int findTheLongestSubstring(String s) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def findTheLongestSubstring(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def findTheLongestSubstring(self, s: str) -> int:\n        ",
    "c": "int findTheLongestSubstring(char* s) {\n    \n}",
    "csharp": "public class Solution {\n    public int FindTheLongestSubstring(string s) {\n        \n    }\n}",
    "javascript": "/**\n * @param {string} s\n * @return {number}\n */\nvar findTheLongestSubstring = function(s) {\n    \n};",
    "typescript": "function findTheLongestSubstring(s: string): number {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param String $s\n     * @return Integer\n     */\n    function findTheLongestSubstring($s) {\n        \n    }\n}",
    "swift": "class Solution {\n    func findTheLongestSubstring(_ s: String) -> Int {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun findTheLongestSubstring(s: String): Int {\n        \n    }\n}",
    "dart": "class Solution {\n  int findTheLongestSubstring(String s) {\n    \n  }\n}",
    "golang": "func findTheLongestSubstring(s string) int {\n    \n}",
    "ruby": "# @param {String} s\n# @return {Integer}\ndef find_the_longest_substring(s)\n    \nend",
    "scala": "object Solution {\n    def findTheLongestSubstring(s: String): Int = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn find_the_longest_substring(s: String) -> i32 {\n        \n    }\n}",
    "racket": "(define/contract (find-the-longest-substring s)\n  (-> string? exact-integer?)\n  )",
    "erlang": "-spec find_the_longest_substring(S :: unicode:unicode_binary()) -> integer().\nfind_the_longest_substring(S) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec find_the_longest_substring(s :: String.t) :: integer\n  def find_the_longest_substring(s) do\n    \n  end\nend"
  },
  "solution": "[TOC]\n\n## Solution\n\n---\n\n### Approach: Bitmasking\n\n#### Intuition\n\nGiven a string `s`, we need to find the length of the longest substring in which any vowel present must appear an even number of times. A brute force approach would involve iterating through every substring and counting vowels, but this would result in a Time Limit Exceeded (TLE). Instead, we need to think of a more efficient solution, aiming for a linear or log-linear time complexity.\n\nObserve that we don't need to know the exact count of the vowels to solve this problem; we only need to know the parity of each vowel (whether it appears an even or odd number of times). The parity of each vowel can be stored in a boolean or bit, where `0` means even and `1` means odd. We need five bits to track the parity of all five vowels (a, e, i, o, u), resulting in 2^5 = 32 possible states.\n\nWe can assign the first bit to `a`, the second to `e`, and so on. The state of the vowels can be represented as a binary string. For instance, `00000` means all vowels have even counts, while `10000` means only `a` has an odd count. \nBy converting these binary states to integers, we can assign values to the vowels: `a = 1`, `e = 2`, `i = 4`, `o = 8`, and `u = 16`. If both `a` and `i` have odd counts, their total value would be `1 + 4 = 5`. A total value of `0` means all vowels have even counts.\n\n![fig](../Figures/1371/slide1_repub.drawio.png)\n\nTo find substrings with even vowels, we can use the XOR operator to update and track the parity of the vowels. If a vowel appears an even number of times, the result of XOR will be 0; if it appears an odd number of times, the result will be 1.\n\nWe compute a running XOR for each vowel as we traverse the string. To check for substrings with even vowels, we consider two cases:\n\n1. If the current XOR value is `00000` (i.e., all vowels have even counts), the substring from the start of the string to the current position contains even vowels.\n2. If the current XOR value has occurred before, the substring between the first occurrence of that XOR value and the current position also contains even vowels.\n\n![fig](../Figures/1371/image2_repub.drawio.png)\n\n#### Algorithm\n\n1. Initialize an integer variable `prefixXOR` and set it to 0.\n2. Initialize a character array `characterMap[26]` where specific vowel characters `('a', 'e', 'i', 'o', 'u')` have unique mask values `(1, 2, 4, 8, 16)`.\n3. Initialize an array `mp` of size 32, where all elements are set to -1. This will store the index of the first occurrence of each `prefixXOR` value.\n4. Initialize an integer variable `longestSubstring` and set it to `0`.\n5. Iterate through each character in the string `s`:\n    - Update `prefixXOR` by XORing it with the mask value of the current character (from `characterMap`).\n    - If the current `prefixXOR` value is not found in `mp` and `prefixXOR` is not 0:\n        - Store the current index in `mp` at the position corresponding to `prefixXOR`.\n    - Update `longestSubstring` by comparing it with the difference between the current index and `mp[prefixXOR]`.\n6. Return `longestSubstring` as the final result.\n\n#### Implementation#### Complexity Analysis\n\nLet $m$ be the size of the given `s` string.\n\n- Time complexity: $O(n)$\n\n    We iterate through the string `s` exactly once. Apart from this, all operations are constant time. Therefore, the total time complexity is given by $O(max(m,n))$.\n\n- Space complexity: $O(1)$\n\n   Apart from the `characterMap` and `mp` array, no additional space is used to solve the problem. Therefore, the space complexity is given by $O(26) + O(32) ≈ O(1)$.\n\n---"
}