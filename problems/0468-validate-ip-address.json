{
  "title": "Validate IP Address",
  "problem_id": "468",
  "frontend_id": "468",
  "difficulty": "Medium",
  "problem_slug": "validate-ip-address",
  "topics": [
    "String"
  ],
  "description": "Given a string queryIP, return \"IPv4\" if IP is a valid IPv4 address, \"IPv6\" if IP is a valid IPv6 address or \"Neither\" if IP is not a correct IP of any type.\nA valid IPv4 address is an IP in the form \"x1.x2.x3.x4\" where 0 <= xi <= 255 and xi cannot contain leading zeros. For example, \"192.168.1.1\" and \"192.168.1.0\" are valid IPv4 addresses while \"192.168.01.1\", \"192.168.1.00\", and \"192.168@1.1\" are invalid IPv4 addresses.\nA valid IPv6 address is an IP in the form \"x1:x2:x3:x4:x5:x6:x7:x8\" where:\nFor example, \"2001:0db8:85a3:0000:0000:8a2e:0370:7334\" and \"2001:db8:85a3:0:0:8A2E:0370:7334\" are valid IPv6 addresses, while \"2001:0db8:85a3::8A2E:037j:7334\" and \"02001:0db8:85a3:0000:0000:8a2e:0370:7334\" are invalid IPv6 addresses.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: queryIP = \"172.16.254.1\"\nOutput: \"IPv4\"\nExplanation: This is a valid IPv4 address, return \"IPv4\".",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input: queryIP = \"2001:0db8:85a3:0:0:8A2E:0370:7334\"\nOutput: \"IPv6\"\nExplanation: This is a valid IPv6 address, return \"IPv6\".",
      "images": []
    },
    {
      "example_num": 3,
      "example_text": "Input: queryIP = \"256.256.256.256\"\nOutput: \"Neither\"\nExplanation: This is neither a IPv4 address nor a IPv6 address.",
      "images": []
    }
  ],
  "constraints": [
    "queryIP consists only of English letters, digits and the characters '.' and ':'."
  ],
  "follow_ups": [],
  "hints": [],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    string validIPAddress(string queryIP) {\n        \n    }\n};",
    "java": "class Solution {\n    public String validIPAddress(String queryIP) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def validIPAddress(self, queryIP):\n        \"\"\"\n        :type queryIP: str\n        :rtype: str\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def validIPAddress(self, queryIP: str) -> str:\n        ",
    "c": "char* validIPAddress(char* queryIP) {\n    \n}",
    "csharp": "public class Solution {\n    public string ValidIPAddress(string queryIP) {\n        \n    }\n}",
    "javascript": "/**\n * @param {string} queryIP\n * @return {string}\n */\nvar validIPAddress = function(queryIP) {\n    \n};",
    "typescript": "function validIPAddress(queryIP: string): string {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param String $queryIP\n     * @return String\n     */\n    function validIPAddress($queryIP) {\n        \n    }\n}",
    "swift": "class Solution {\n    func validIPAddress(_ queryIP: String) -> String {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun validIPAddress(queryIP: String): String {\n        \n    }\n}",
    "dart": "class Solution {\n  String validIPAddress(String queryIP) {\n    \n  }\n}",
    "golang": "func validIPAddress(queryIP string) string {\n    \n}",
    "ruby": "# @param {String} query_ip\n# @return {String}\ndef valid_ip_address(query_ip)\n    \nend",
    "scala": "object Solution {\n    def validIPAddress(queryIP: String): String = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn valid_ip_address(query_ip: String) -> String {\n        \n    }\n}",
    "racket": "(define/contract (valid-ip-address queryIP)\n  (-> string? string?)\n  )",
    "erlang": "-spec valid_ip_address(QueryIP :: unicode:unicode_binary()) -> unicode:unicode_binary().\nvalid_ip_address(QueryIP) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec valid_ip_address(query_ip :: String.t) :: String.t\n  def valid_ip_address(query_ip) do\n    \n  end\nend"
  },
  "solution": "[TOC]\n\n## Solution\n\n---\n\n### Overview\n\nThe first idea is to use try/catch construct with built-in \nfacilities: [ipaddress](https://docs.python.org/3/library/ipaddress.html) \nlib in Python and [InetAddress](https://docs.oracle.com/javase/7/docs/api/java/net/InetAddress.html) \nclass in Java.\n\n**Note that the code below validates the _real-life_ IPv4, \nand _real-life_ IPv6. \nIt will not work for this problem because the problem validates \nnot _real-life_ but _\"simplified\"_ versions of IPv4 and IPv6.**\n\nSome big companies, for example, Microsoft and Amazon, \nredefine IPv4 and IPv6 on the interviews for the sake of simplicity.\nBelow one could find an extended discussion about the differences.Note that these facilities both refer to \n[POSIX-compatible](https://linux.die.net/man/3/inet_addr) \n`inet-addr()` routine for parsing addresses. \nThat's why they consider chunks with leading zeros\nnot as an error, but as an _octal_ representation.\n\n> Components of the dotted address can be specified in decimal, \n_octal (with a leading 0)_, or hexadecimal, with a leading 0X). \n\nAs a result, `01.01.01.012` will be a valid IP address in \noctal representation, as it should be. \nTo check this behaviour, one can run the command `ping 01.01.01.012` \nin the console. The address `01.01.01.012` will be considered \nas the one in octal representation, \nconverted into its decimal representation `1.1.1.10`,\ntherefore the ping command would be executed without errors.\n\nBy contrary, problem description directly states that \n_leading zeros in the IPv4 is invalid_.\nThat's not a real-life case, but probably done for the sake \nof simplicity.\nImho, that makes the problem to be a bit schoolish and less fun.\nThough let's deal with it anyway, since the problem is very popular recently \nin Microsoft and Amazon. \n\nThere are three main ways to solve it:\n \n- Regex (_i.e._ regular expression). Less performing one, though it's a good way to demonstrate \nyour knowledge of regex.\n\n- Divide and Conquer, the simplest one.\n\n- Mix of \"Divide and Conquer\" and \"Try/Catch with built-in facilities\", \nthis time with ones to convert string to integer. \nTry/catch in this situation is a sort of \"dirty\"\nsolution because [usually the code inside try blocks is not optimized as \nit'd otherwise be by the compiler](https://blogs.msmvps.com/peterritchie/2007/06/22/performance-implications-of-try-catch-finally/),\nand it's better not to use it during the interview.---\n### Approach 1: Regex\n\nLet's construct step by step regex for \"IPv4\" \nas it's described in the problem description. Note, that it's not\na real-life IPv4 because of leading zeros problem as we've discussed above. \n\nAnyway, we start to construct regex pattern by using raw string in Python \n`r''` and standard string `\"\"` in Java. Here is how its skeleton looks like for Python\n\n![diff](../Figures/468/regex_ipv4.png)\n\nand here is for Java\n\n![diff](../Figures/468/java_ipv4.png)\n\nNow the problem is reduced to the construction of pattern to match each chunk.\nIt's an integer in range (0, 255), and the leading zeros are not allowed.\nThat results in five possible situations:\n\n1. Chunk contains only one digit, from 0 to 9.\n\n2. Chunk contains two digits. The first one could be from 1 to 9, and the second \none from 0 to 9.\n\n3. Chunk contains three digits, and the first one is `1`. The second and the third ones \ncould be from 0 to 9.\n\n4. Chunk contains three digits, the first one is `2` and the second one is from 0 to 4.\nThen the third one could be from 0 to 9.\n\n5. Chunk contains three digits, the first one is `2`,  and the second one is `5`.\nThen the third one could be from 0 to 5.\n\nLet's use pipe to create a regular expression that will match either case 1, or \ncase 2, ..., or case 5. \n\n![diff](../Figures/468/chunk_regex.png) \n\nThe job is done. The same logic could be used to construct \"IPv6\" regex pattern.\n\n**Implementation****Complexity Analysis**\n\n* Time complexity: $$\\mathcal{O}(1)$$ because the patterns to match have \nconstant length.\n    \n* Space complexity: $$\\mathcal{O}(1)$$.---\n### Approach 2: Divide and Conquer\n\n**Intuition**\n\nBoth IPv4 and IPv6 addresses are composed of several substrings separated by certain delimiter,\nand each of the substrings is of the same format.\n\n![diff](../Figures/468/divide_conquer.png)\n\nTherefore, intuitively, we could break down the address into chunks, \nand then verify them one by one.\n\nThe address is valid _if and only if_ each of the chunks is valid.\nWe can call this methodology _divide and conquer_.\n\n**Algorithm**\n\n- For the IPv4 address, we split IP into four chunks by the delimiter `.`,\nwhile for IPv6 address, we split IP into eight chunks by the delimiter `:`.\n\n- For each substring of \"IPv4\" address, \nwe check if it is an integer between `0 - 255`, and there is no leading zeros.\n\n- For each substring of \"IPv6\" address, \nwe check if it's a hexadecimal number of length `1 - 4`.\n \n**Implementation****Complexity Analysis**\n\n* Time complexity: $$\\mathcal{O}(N)$$ because to count number of dots requires to\nparse the entire input string.\n    \n* Space complexity: $$\\mathcal{O}(1)$$."
}