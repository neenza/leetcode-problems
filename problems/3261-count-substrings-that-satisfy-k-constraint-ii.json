{
  "title": "Count Substrings That Satisfy K-Constraint II",
  "problem_id": "3546",
  "frontend_id": "3261",
  "difficulty": "Hard",
  "problem_slug": "count-substrings-that-satisfy-k-constraint-ii",
  "topics": [
    "Array",
    "String",
    "Binary Search",
    "Sliding Window",
    "Prefix Sum"
  ],
  "description": "You are given a binary string s and an integer k.\nYou are also given a 2D integer array queries, where queries[i] = [li, ri].\nA binary string satisfies the k-constraint if either of the following conditions holds:\nReturn an integer array answer, where answer[i] is the number of substrings of s[li..ri] that satisfy the k-constraint.\nExample 1:\nExample 2:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: s = \"0001111\", k = 2, queries = [[0,6]]\nOutput: [26]\nExplanation:\nFor the query [0, 6] , all substrings of s[0..6] = \"0001111\" satisfy the k-constraint except for the substrings s[0..5] = \"000111\" and s[0..6] = \"0001111\" .",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input: s = \"010101\", k = 1, queries = [[0,5],[1,4],[2,3]]\nOutput: [15,9,3]\nExplanation:\nThe substrings of s with a length greater than 3 do not satisfy the k-constraint.",
      "images": []
    }
  ],
  "constraints": [
    "1 <= s.length <= 105",
    "s[i] is either '0' or '1'.",
    "1 <= k <= s.length",
    "1 <= queries.length <= 105",
    "queries[i] == [li, ri]",
    "0 <= li <= ri < s.length",
    "All queries are distinct."
  ],
  "follow_ups": [],
  "hints": [
    "Answering online queries is tough. Try to answer them offline since the queries are known beforehand.",
    "For each index, how do you calculate the left boundary so that the given condition is satisfied?",
    "Using the precomputed left boundaries and a range data structure, you can now answer the queries optimally."
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    vector<long long> countKConstraintSubstrings(string s, int k, vector<vector<int>>& queries) {\n        \n    }\n};",
    "java": "class Solution {\n    public long[] countKConstraintSubstrings(String s, int k, int[][] queries) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def countKConstraintSubstrings(self, s, k, queries):\n        \"\"\"\n        :type s: str\n        :type k: int\n        :type queries: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def countKConstraintSubstrings(self, s: str, k: int, queries: List[List[int]]) -> List[int]:\n        ",
    "c": "/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nlong long* countKConstraintSubstrings(char* s, int k, int** queries, int queriesSize, int* queriesColSize, int* returnSize) {\n    \n}",
    "csharp": "public class Solution {\n    public long[] CountKConstraintSubstrings(string s, int k, int[][] queries) {\n        \n    }\n}",
    "javascript": "/**\n * @param {string} s\n * @param {number} k\n * @param {number[][]} queries\n * @return {number[]}\n */\nvar countKConstraintSubstrings = function(s, k, queries) {\n    \n};",
    "typescript": "function countKConstraintSubstrings(s: string, k: number, queries: number[][]): number[] {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param String $s\n     * @param Integer $k\n     * @param Integer[][] $queries\n     * @return Integer[]\n     */\n    function countKConstraintSubstrings($s, $k, $queries) {\n        \n    }\n}",
    "swift": "class Solution {\n    func countKConstraintSubstrings(_ s: String, _ k: Int, _ queries: [[Int]]) -> [Int] {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun countKConstraintSubstrings(s: String, k: Int, queries: Array<IntArray>): LongArray {\n        \n    }\n}",
    "dart": "class Solution {\n  List<int> countKConstraintSubstrings(String s, int k, List<List<int>> queries) {\n    \n  }\n}",
    "golang": "func countKConstraintSubstrings(s string, k int, queries [][]int) []int64 {\n    \n}",
    "ruby": "# @param {String} s\n# @param {Integer} k\n# @param {Integer[][]} queries\n# @return {Integer[]}\ndef count_k_constraint_substrings(s, k, queries)\n    \nend",
    "scala": "object Solution {\n    def countKConstraintSubstrings(s: String, k: Int, queries: Array[Array[Int]]): Array[Long] = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn count_k_constraint_substrings(s: String, k: i32, queries: Vec<Vec<i32>>) -> Vec<i64> {\n        \n    }\n}",
    "racket": "(define/contract (count-k-constraint-substrings s k queries)\n  (-> string? exact-integer? (listof (listof exact-integer?)) (listof exact-integer?))\n  )",
    "erlang": "-spec count_k_constraint_substrings(S :: unicode:unicode_binary(), K :: integer(), Queries :: [[integer()]]) -> [integer()].\ncount_k_constraint_substrings(S, K, Queries) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec count_k_constraint_substrings(s :: String.t, k :: integer, queries :: [[integer]]) :: [integer]\n  def count_k_constraint_substrings(s, k, queries) do\n    \n  end\nend"
  }
}