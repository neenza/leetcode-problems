{
  "title": "Number of Closed Islands",
  "problem_id": "1380",
  "frontend_id": "1254",
  "difficulty": "Medium",
  "problem_slug": "number-of-closed-islands",
  "topics": [
    "Array",
    "Depth-First Search",
    "Breadth-First Search",
    "Union Find",
    "Matrix"
  ],
  "description": "Given a 2D grid consists of 0s (land) and 1s (water).  An island is a maximal 4-directionally connected group of 0s and a closed island is an island totally (all left, top, right, bottom) surrounded by 1s.\nReturn the number of closed islands.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: grid = [[1,1,1,1,1,1,1,0],[1,0,0,0,0,1,1,0],[1,0,1,0,1,1,1,0],[1,0,0,0,0,1,0,1],[1,1,1,1,1,1,1,0]]\nOutput: 2\nExplanation: \nIslands in gray are closed because they are completely surrounded by water (group of 1s).",
      "images": [
        "https://assets.leetcode.com/uploads/2019/10/31/sample_3_1610.png"
      ]
    },
    {
      "example_num": 2,
      "example_text": "Input: grid = [[0,0,1,0,0],[0,1,0,1,0],[0,1,1,1,0]]\nOutput: 1",
      "images": [
        "https://assets.leetcode.com/uploads/2019/10/31/sample_4_1610.png"
      ]
    },
    {
      "example_num": 3,
      "example_text": "Input: grid = [[1,1,1,1,1,1,1],\n               [1,0,0,0,0,0,1],\n               [1,0,1,1,1,0,1],\n               [1,0,1,0,1,0,1],\n               [1,0,1,1,1,0,1],\n               [1,0,0,0,0,0,1],\n               [1,1,1,1,1,1,1]]\nOutput: 2",
      "images": [
        "https://assets.leetcode.com/uploads/2019/10/31/sample_4_1610.png"
      ]
    }
  ],
  "constraints": [
    "1 <= grid.length, grid[0].length <= 100",
    "0 <= grid[i][j] <=1"
  ],
  "follow_ups": [],
  "hints": [
    "Exclude connected group of 0s on the corners because they are not closed island.",
    "Return number of connected component of 0s on the grid."
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    int closedIsland(vector<vector<int>>& grid) {\n        \n    }\n};",
    "java": "class Solution {\n    public int closedIsland(int[][] grid) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def closedIsland(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def closedIsland(self, grid: List[List[int]]) -> int:\n        ",
    "c": "int closedIsland(int** grid, int gridSize, int* gridColSize) {\n    \n}",
    "csharp": "public class Solution {\n    public int ClosedIsland(int[][] grid) {\n        \n    }\n}",
    "javascript": "/**\n * @param {number[][]} grid\n * @return {number}\n */\nvar closedIsland = function(grid) {\n    \n};",
    "typescript": "function closedIsland(grid: number[][]): number {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param Integer[][] $grid\n     * @return Integer\n     */\n    function closedIsland($grid) {\n        \n    }\n}",
    "swift": "class Solution {\n    func closedIsland(_ grid: [[Int]]) -> Int {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun closedIsland(grid: Array<IntArray>): Int {\n        \n    }\n}",
    "dart": "class Solution {\n  int closedIsland(List<List<int>> grid) {\n    \n  }\n}",
    "golang": "func closedIsland(grid [][]int) int {\n    \n}",
    "ruby": "# @param {Integer[][]} grid\n# @return {Integer}\ndef closed_island(grid)\n    \nend",
    "scala": "object Solution {\n    def closedIsland(grid: Array[Array[Int]]): Int = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn closed_island(grid: Vec<Vec<i32>>) -> i32 {\n        \n    }\n}",
    "racket": "(define/contract (closed-island grid)\n  (-> (listof (listof exact-integer?)) exact-integer?)\n  )",
    "erlang": "-spec closed_island(Grid :: [[integer()]]) -> integer().\nclosed_island(Grid) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec closed_island(grid :: [[integer]]) :: integer\n  def closed_island(grid) do\n    \n  end\nend"
  },
  "solution": "[TOC]\n\n## Solution\n\n---\n\n### Overview\n\nWe are given a 2D `grid`. Each cell of `grid` represents a land or water cell denoted by `0` and `1` respectively.\n\n\nOur task is to return the number of closed islands where a closed island is an island totally (all left, top, right, bottom) surrounded by `1s`.\n\n---\n\n### Approach 1: Breadth First Search\n\n#### Intuition\n\nThe problem states that an island is formed by connecting all of the '0s' in all four directions (left, top, right, and bottom), which leads us to model the problem as a graph.\n\nWe can treat the 2D grid as an undirected graph. A land cell in `grid` corresponds to a node in such a graph with an undirected edge between horizontally or vertically adjacent land cells.\n\nLet's see what forms an island in such a graph. So, we begin at any node and proceed to its neighbors, i.e., all nodes one edge away. From the nodes 1 edge away, we move to their neighbors, i.e., all the nodes 2 edges away from the starting node, and so on. If we keep traversing until we can't anymore, all the nodes that are visited in this traversal together form an island.\n\nWhile traversing the island, we look to see if any node in the graph corresponds to a cell at the `grid`'s boundary. The island does not form a closed island if any node on it is on the `grid`'s boundary. Otherwise, a closed island is formed if there is no node on the `grid`'s boundary.\n\nWe can use a graph traversal algorithm like breadth-first search (BFS) to traverse over the islands. BFS is an algorithm for traversing or searching a graph. It traverses in a level-wise manner, i.e., all the nodes at the present level (say `l`) are explored before moving on to the nodes at the next level (`l + 1`), where a level's number is the distance from a starting node. BFS is implemented with a queue.\n\nIf you are not familiar with BFS traversal, we suggest you read our [Leetcode Explore Card](https://leetcode.com/explore/featured/card/graph/620/breadth-first-search-in-graph/).\n\nWe perform a BFS from every unvisited land cell, treating it as a node. While traversing the island, we check if any node in the island is present on the `grid`'s boundary. If we have such a node, the island is not a closed island. Otherwise, we have a closed island if we never visit a cell at the `grid`'s edge. As a result, we add one to our answer variable.\n\nIt is important to note that we will not stop the BFS traversal if we come across a node on the boundary. We will perform the complete BFS traversal to cover the entire island so that we can mark all the nodes of the island and not visit any of its nodes again.\n\nHere's a visual step-by-step example:\n\n!?!../Documents/1254/1254_number_of_closed_islands.json:601,301!?!\n\n#### Algorithm\n\n1. Create two variables, `m` and `n`, to store the number of rows and columns in the given `grid`.\n2. Create an answer variable `count` to keep track of the number of closed islands in `grid`. We initialize it with `0`.\n3. Create a 2D array called `visit` to keep track of visited cells.\n4. Iterate over all the cells of `grid` and for every cell `(i, j)` check if it is a land cell or not. If it is a land cell and it has not been visited yet, begin a BFS traversal from `(i, j)` cell:\n    - We use the `bfs` function to perform the traversal. For each call, pass `x`, `y`, `m`, `n`, `grid` and `visit` as the parameters. The `x` and `y` parameters represent the row and column of the cell from which BFS should begin. We start with `(i ,j)` cell.\n    - We initialize a queue `q` of pair of integers and push `(x, y)` into it. We also mark `(x, y)` as visited.\n    - Create a boolean variable `isClosed` that stores whether or not the current island is a closed island or not. We initialize it to `true` because we haven't found any nodes in the island that are on the `grid` boundary yet.\n    - While the queue is not empty, we dequeue the first pair `(x, y)` from the queue and iterate over all its neighbors. If any neighboring cell is not in bounds of `grid`, it means the current `(x, y)` cell is present at the boundary of `grid`. We do not have a closed island, and we mark `isClosed = false`. For each neighboring cell, we check if it is a land cell or not. If it is a land cell and has not been visited yet, we mark it as visited and push `(r, c)` into the queue.\n    - After the queue is empty, we return `isClosed`.\n    - If `bfs` returns `true`, we increment `count` by 1 .\n5. Return `count`.\n\n#### Implementation#### Complexity Analysis\n\nHere, $m$ and $n$ are the number of rows and columns in the given grid.\n\n* Time complexity: $O(m \\cdot n)$\n\n    - Initializing the `visit` array takes $O(m \\cdot n)$ time.\n    - We iterate over all the cells and find unvisited land cells to perform BFS traversal from those. This takes $O(m \\cdot n)$ time.\n    - Each queue operation in the BFS algorithm takes $O(1)$ time, and a single node can be pushed once, leading to $O(m \\cdot n)$ operations for $m \\cdot n$ nodes. We iterate over all the neighbors of each node that is popped out of the queue. So for every node, we would iterate four times to iterate over the neighbors, resulting in $O(4 \\cdot m \\cdot n) = O(m \\cdot n)$ operations total for all the nodes.\n\n* Space complexity: $O(m \\cdot n)$\n\n    - The `visit` array takes $O(m \\cdot n)$ space.\n    - The BFS queue takes $O(m \\cdot n)$ space in the worst-case because each node is added once.\n\n---\n\n### Approach 2: Depth First Search\n\n#### Intuition\n\nAs we have to traverse over `grid` modeled as a graph to find the closed islands, another method is to use a depth-first search (DFS).\n\nIn DFS, we use a recursive function to explore nodes as far as possible along each branch. Upon reaching the end of a branch, we backtrack to the previous node and continue exploring the next branches.\n\nOnce we encounter an unvisited node, we will take one of its neighbor nodes (if exists) as the next node on this branch. Recursively call the function to take the next node as the 'starting node' and solve the subproblem.\n\nIf you are new to Depth First Search, please see our [Leetcode Explore Card](https://leetcode.com/explore/featured/card/graph/619/depth-first-search-in-graph/3882/) for more information on it!\n\n#### Algorithm\n\n1. Create two variables, `m` and `n`, to store the number of rows and columns in the given `grid`.\n2. Create an answer variable `count` to keep track of the number of closed islands in `grid`. We initialize it with `0`.\n3. Create a 2D array called `visit` to keep track of visited cells.\n4. Iterate over all the cells of `grid` and for every cell `(i, j)` check if it is a land cell or not. If it is a land cell and it has not been visited yet, begin a DFS traversal from `(i, j)` cell:\n    - We use the `dfs` function to perform the traversal. For each call, pass `x`, `y`, and `grid` as the parameters. The `x` and `y` parameters represent the row and column of the cell from which DFS should begin. We start with `(i ,j)` cell.\n   - If the cell `(x, y)` is out of bounds, it means there was a land cell at the boundary of `grid` whose neighbor is `(x, y)`. So, we return `false` to indicate that this island is not closed.\n    - Else if it is a water cell or an already visited cell, we return `true`.\n    - Otherwise, we visit this cell and mark it as visited. We create a boolean variable `isClosed` that stores whether or not the current island is a closed island or not. We initialize it to `true` because we haven't found any nodes in the island that are on the `grid` boundary yet.\n    - We then call `dfs` recursively from each of the neighbors of `(x, y)`.\n    - If any of the directions leads to a cell in the island at the `grid` boundary, the island is not closed, and we mark `isClosed = false`. As discussed above, it is worth noting that in order to mark all the cells of the island, we called `dfs` individually over each of the four neighbors. We can't simply use `dfs(x - 1, y, m, n, grid, visit) && dfs(x + 1, y, m, n, grid, visit) && dfs(x, y - 1, m, n, grid, visit) && dfs(x, y + 1, m, n, grid, visit)` because if the first `dfs` call returns `false`, the next three `dfs` calls will not be executed.\n    - If `dfs` returns `true`, we increment `count` by 1.\n4. Return `count`.\n\n#### Implementation#### Complexity Analysis\n\nHere, $m$ and $n$ are the number of rows and columns in the given grid.\n\n* Time complexity: $O(m \\cdot n)$\n\n    - Initializing the `visit` array takes $O(m \\cdot n)$ time.\n    - We iterate over all the cells and find unvisited land cells to perform DFS traversal from those. This takes $O(m \\cdot n)$ time.\n    - The `dfs` function visits each node once, leading to $O(m \\cdot n)$ operations for $m \\cdot n$ nodes. We iterate over all the neighbors of each node that is popped out of the queue. So for every node, we would iterate four times to iterate over the neighbors, resulting in $O(4 \\cdot m \\cdot n) = O(m \\cdot n)$ operations total for all the nodes.\n\n* Space complexity: $O(m \\cdot n)$\n\n    - The `visit` array takes $O(m \\cdot n)$ space.\n    - The recursion stack used by `dfs` can have no more than $O(m \\cdot n)$ elements in the worst-case scenario. It would take up $O(m \\cdot n)$ space in that case."
}