{
  "title": "Robot Collisions",
  "problem_id": "2846",
  "frontend_id": "2751",
  "difficulty": "Hard",
  "problem_slug": "robot-collisions",
  "topics": [
    "Array",
    "Stack",
    "Sorting",
    "Simulation"
  ],
  "description": "There are n 1-indexed robots, each having a position on a line, health, and movement direction.\nYou are given 0-indexed integer arrays positions, healths, and a string directions (directions[i] is either 'L' for left or 'R' for right). All integers in positions are unique.\nAll robots start moving on the line simultaneously at the same speed in their given directions. If two robots ever share the same position while moving, they will collide.\nIf two robots collide, the robot with lower health is removed from the line, and the health of the other robot decreases by one. The surviving robot continues in the same direction it was going. If both robots have the same health, they are both removed from the line.\nYour task is to determine the health of the robots that survive the collisions, in the same order that the robots were given, i.e. final health of robot 1 (if survived), final health of robot 2 (if survived), and so on. If there are no survivors, return an empty array.\nReturn an array containing the health of the remaining robots (in the order they were given in the input), after no further collisions can occur.\nNote: The positions may be unsorted.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: positions = [5,4,3,2,1], healths = [2,17,9,15,10], directions = \"RRRRR\"\nOutput: [2,17,9,15,10]\nExplanation: No collision occurs in this example, since all robots are moving in the same direction. So, the health of the robots in order from the first robot is returned, [2, 17, 9, 15, 10].",
      "images": [
        "https://assets.leetcode.com/uploads/2023/05/15/image-20230516011718-12.png"
      ]
    },
    {
      "example_num": 2,
      "example_text": "Input: positions = [3,5,2,6], healths = [10,10,15,12], directions = \"RLRL\"\nOutput: [14]\nExplanation: There are 2 collisions in this example. Firstly, robot 1 and robot 2 will collide, and since both have the same health, they will be removed from the line. Next, robot 3 and robot 4 will collide and since robot 4's health is smaller, it gets removed, and robot 3's health becomes 15 - 1 = 14. Only robot 3 remains, so we return [14].",
      "images": [
        "https://assets.leetcode.com/uploads/2023/05/15/image-20230516004433-7.png"
      ]
    },
    {
      "example_num": 3,
      "example_text": "Input: positions = [1,2,5,6], healths = [10,10,11,11], directions = \"RLRL\"\nOutput: []\nExplanation: Robot 1 and robot 2 will collide and since both have the same health, they are both removed. Robot 3 and 4 will collide and since both have the same health, they are both removed. So, we return an empty array, [].",
      "images": [
        "https://assets.leetcode.com/uploads/2023/05/15/image-20230516005114-9.png"
      ]
    }
  ],
  "constraints": [
    "1 <= positions.length == healths.length == directions.length == n <= 105",
    "1 <= positions[i], healths[i] <= 109",
    "directions[i] == 'L' or directions[i] == 'R'",
    "All values in positions are distinct"
  ],
  "follow_ups": [],
  "hints": [
    "Process the robots in the order of their positions to ensure that we process the collisions correctly.",
    "To optimize the solution, use a stack to keep track of the surviving robots as we iterate through the positions.",
    "Instead of simulating each collision, check the current robot against the top of the stack (if it exists) to determine if a collision occurs."
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    vector<int> survivedRobotsHealths(vector<int>& positions, vector<int>& healths, string directions) {\n        \n    }\n};",
    "java": "class Solution {\n    public List<Integer> survivedRobotsHealths(int[] positions, int[] healths, String directions) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def survivedRobotsHealths(self, positions, healths, directions):\n        \"\"\"\n        :type positions: List[int]\n        :type healths: List[int]\n        :type directions: str\n        :rtype: List[int]\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def survivedRobotsHealths(self, positions: List[int], healths: List[int], directions: str) -> List[int]:\n        ",
    "c": "/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nint* survivedRobotsHealths(int* positions, int positionsSize, int* healths, int healthsSize, char* directions, int* returnSize) {\n    \n}",
    "csharp": "public class Solution {\n    public IList<int> SurvivedRobotsHealths(int[] positions, int[] healths, string directions) {\n        \n    }\n}",
    "javascript": "/**\n * @param {number[]} positions\n * @param {number[]} healths\n * @param {string} directions\n * @return {number[]}\n */\nvar survivedRobotsHealths = function(positions, healths, directions) {\n    \n};",
    "typescript": "function survivedRobotsHealths(positions: number[], healths: number[], directions: string): number[] {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param Integer[] $positions\n     * @param Integer[] $healths\n     * @param String $directions\n     * @return Integer[]\n     */\n    function survivedRobotsHealths($positions, $healths, $directions) {\n        \n    }\n}",
    "swift": "class Solution {\n    func survivedRobotsHealths(_ positions: [Int], _ healths: [Int], _ directions: String) -> [Int] {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun survivedRobotsHealths(positions: IntArray, healths: IntArray, directions: String): List<Int> {\n        \n    }\n}",
    "dart": "class Solution {\n  List<int> survivedRobotsHealths(List<int> positions, List<int> healths, String directions) {\n    \n  }\n}",
    "golang": "func survivedRobotsHealths(positions []int, healths []int, directions string) []int {\n    \n}",
    "ruby": "# @param {Integer[]} positions\n# @param {Integer[]} healths\n# @param {String} directions\n# @return {Integer[]}\ndef survived_robots_healths(positions, healths, directions)\n    \nend",
    "scala": "object Solution {\n    def survivedRobotsHealths(positions: Array[Int], healths: Array[Int], directions: String): List[Int] = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn survived_robots_healths(positions: Vec<i32>, healths: Vec<i32>, directions: String) -> Vec<i32> {\n        \n    }\n}",
    "racket": "(define/contract (survived-robots-healths positions healths directions)\n  (-> (listof exact-integer?) (listof exact-integer?) string? (listof exact-integer?))\n  )",
    "erlang": "-spec survived_robots_healths(Positions :: [integer()], Healths :: [integer()], Directions :: unicode:unicode_binary()) -> [integer()].\nsurvived_robots_healths(Positions, Healths, Directions) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec survived_robots_healths(positions :: [integer], healths :: [integer], directions :: String.t) :: [integer]\n  def survived_robots_healths(positions, healths, directions) do\n    \n  end\nend"
  },
  "solution": "[TOC]\n\n## Solution\n\n--- \n\n### Overview\n\nWe have a set of robots on a line, each robot is described with three variables: a unique position on the line, health, and direction of movement (`L` for left and `R` for right). \n\nAll robots start moving simultaneously and at the same speed. If two robots collide, the one with lower health is destroyed, and the health of the surviving robot decreases by one. If both robots have the same health, they are both destroyed. \n\nWe aim to determine the health of the robots that survive all collisions and list it in the order of their initial positions.\n\n---\n\n### Approach: Sorting & Stack \n\n#### Intuition\n\nTo solve this problem, we need to simulate the robots' movements and handle collisions step by step. The key challenge is managing the collisions in the correct sequence.\n\nBecause all the robots move at the same speed, they will only collide if a robot with the lower position is moving to the right (`R`), and another robot with a higher position is moving to the left (`L`). Robots moving in the same direction or moving away from each other will never meet.\n\nThe crucial step here is to sort the robots by their position so we can simulate their potential collisions in the correct order, which starts from the leftmost robot to the rightmost robot.\n\nOnce we have the robots sorted by position, the next challenge is to handle the collisions as they occur. Let's break down the mechanism of what happens during collisions and why a stack is the right tool for this job.\n\nWhen we encounter a robot moving to the left (`L`), it might collide with one or more robots moving to the right (`R`) that are located to the left of the current robot. We need to compare the health of the left-moving robot with the health of each right-moving robot it collides with, in the order they were encountered. \n\nThis comparison must continue until one of these scenarios happens:\n\n1. The left-moving robot is destroyed.\n2. The right-moving robot(s) are destroyed.\n3. Both are destroyed if their health is equal.\n\nA stack is highly effective for managing this sequence of comparisons and updates.\n\nA stack operates on a last-in-first-out principle (`LIFO`), which aligns with how we need to manage the collisions. The most recent robot moving to the right (`R`) will be the first to potentially collide with a left-moving robot (`L`).\n\n> Note: Every time you encounter a problem where recent elements need to be revisited or managed in reverse order, consider if a stack might be appropriate. Recognizing these patterns can help you identify the right data structure. In interviews, this approach can guide you to the correct solution when it isn't immediately clear.\n\nWe push right-moving robots onto the stack to keep track of any that could potentially collide with a left-moving robot located a higher position. When we encounter a left-moving robot, we simply pop robots off the stack to handle each collision in the correct order.\n\nMore specifically, when a left-moving robot (`L`) is encountered, we start by popping the robot at the top of the stack, which represents the most recent right-moving robot (`R`). We compare the health of these two robots:\n\n\n* If the health of the left-moving robot is greater, the right-moving robot is destroyed. The left-moving robot's health decreases by one, and we continue popping the next robot from the stack if there are any.\n\n\n* If the health of the right-moving robot is greater, the left-moving robot is destroyed, and the right-moving robot's health decreases by one. We push the right-moving robot back onto the stack with its updated health.\n\n* If both robots have the same health, both are destroyed and we do not push anything back onto the stack.\n\nThis process continues until the left-moving robot is destroyed, all right-moving robots that could collide have been handled, or both robots are destroyed.\n\nAfter processing all robots, the stack will contain only the right-moving robots that survived all collisions.\n\nAny left-moving robots that survived will not have encountered further right-moving robots, so they are also added to the final result.\n\nConsider a list of robots sorted by their position:\n\n`Positions: [1, 2, 3, 4]`, `Healths: [3, 2, 5, 4]`, `Directions: ['R', 'R', 'L', 'L']`\n\n1. Start with an empty stack.\n2. Process the first robot at position 1 (`R`): push onto the stack.\n3. Process the second robot at position 2 (`R`): push onto the stack.\n4. Process the third robot at position 3 (`L`): \n    - Compare with the robot at position 2 (`R`). If the robot's health at position 3 is higher, it survives with decreased health. Otherwise, the robot at position 2 survives.\n5. Continue this process until either the left-moving robot is destroyed, all right-moving robots in the stack are handled, or both are destroyed.\n6. Process the fourth robot at position 4 (`L`) similarly.\n\nHere are some popular questions that use the stack as their central idea:\n\n* [20. Valid Parentheses](https://leetcode.com/problems/valid-parentheses/editorial/)\n* [678. Valid Parenthesis String](https://leetcode.com/problems/valid-parenthesis-string/editorial/)\n\n* [227. Basic Calculator II](https://leetcode.com/problems/basic-calculator-ii/editorial/)\n\nThis question in particular is very similar to our current one, albeit a little more straightforward:\n\n* [735. Asteroid Collision](https://leetcode.com/problems/asteroid-collision/description/)\n\n\n#### Algorithm\n\n1. Initialization:\n    - Determine the number of robots and store it in `n`.\n    - Create an array `indices` to keep track of the original indices of the robots.\n    - Create a list `result` to store the health of the surviving robots.\n    - Initialize an empty stack to manage right-moving robots.\n2. Sort Robots by Position:\n    - Sort the `indices` array based on the positions of the robots to ensure they are processed from left to right.\n3. Process Each Robot:\n    - Iterate through each `current_index` in the sorted `indices` array:\n        - If the robot is moving to the right (`'R'`):\n            - Push `current_index` onto the stack.\n        - If the robot is moving to the left (`'L'`):\n            - While the stack is not empty and the current robot's health is greater than `0`:\n                - Pop the top robot from the stack (this is the most recent right-moving robot).\n                - Compare the health of the current left-moving robot and the top right-moving robot:\n                    - If the top right-moving robot has more health:\n                        - Decrease its health by `1` and push it back onto the stack.\n                        - Set the current left-moving robot's health to `0`.\n                    - If the current left-moving robot has more health:\n                        - Decrease its health by `1`.\n                        - Set the top right-moving robot's health to `0`.\n                    - If both robots have the same health:\n                        - Set both robots' health to `0`.\n4. Collect Surviving Robots:\n    - Iterate through each robot index from `0` to `n - 1`:\n        - If the robot's health is greater than `0`:\n            - Append the robot's health to the `result` list.\n5. Return the `result` list, which contains the health of the surviving robots.\n\n#### Implementation#### Complexity Analysis\n\nLet $n$ be the number of robots.\n\n- Time Complexity: $O(n \\cdot \\log n)$\n\n    Sorting the robots based on their positions takes $O(n \\log n)$ time. \n  \n    Initializing the `indices` array takes $O(n)$ time.\n    \n    The for loop that processes each robot runs in $O(n)$ time since each robot is processed once. \n    \n    Therefore, the overall time complexity is dominated by the sorting step, making it $O(n \\cdot \\log n)$.\n\n- Space Complexity: $O(n)$\n\n    In Python, the `sort` method uses Timsort, which has a worst-case space complexity of $O(n)$ due to the additional space used by the merge operations. \n    \n    In Java, `Arrays.sort()` uses a variant of Quick Sort for primitive types, with a space complexity of $O(\\log n)$. \n    \n    In C++, the `sort()` function typically uses a hybrid of Quick Sort, Heap Sort, and Insertion Sort, with a worst-case space complexity of $O(\\log n)$.\n\n    Apart from the sorting step, we use an additional space of $O(n)$ for the `indices` array.\n    \n    The stack in the worst case holds $O(n)$ elements. \n    \n    Therefore, the total space complexity is $O(n)$.\n\n---"
}