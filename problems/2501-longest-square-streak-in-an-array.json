{
  "title": "Longest Square Streak in an Array",
  "problem_id": "2586",
  "frontend_id": "2501",
  "difficulty": "Medium",
  "problem_slug": "longest-square-streak-in-an-array",
  "topics": [
    "Array",
    "Hash Table",
    "Binary Search",
    "Dynamic Programming",
    "Sorting"
  ],
  "description": "You are given an integer array nums. A subsequence of nums is called a square streak if:\nReturn the length of the longest square streak in nums, or return -1 if there is no square streak.\nA subsequence is an array that can be derived from another array by deleting some or no elements without changing the order of the remaining elements.\nExample 1:\nExample 2:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: nums = [4,3,6,16,8,2]\nOutput: 3\nExplanation: Choose the subsequence [4,16,2]. After sorting it, it becomes [2,4,16].\n- 4 = 2 * 2.\n- 16 = 4 * 4.\nTherefore, [4,16,2] is a square streak.\nIt can be shown that every subsequence of length 4 is not a square streak.",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input: nums = [2,3,5,6,7]\nOutput: -1\nExplanation: There is no square streak in nums so return -1.",
      "images": []
    }
  ],
  "constraints": [
    "2 <= nums.length <= 105",
    "2 <= nums[i] <= 105"
  ],
  "follow_ups": [],
  "hints": [
    "With the constraints, the length of the longest square streak possible is 5.",
    "Store the elements of nums in a set to quickly check if it exists."
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    int longestSquareStreak(vector<int>& nums) {\n        \n    }\n};",
    "java": "class Solution {\n    public int longestSquareStreak(int[] nums) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def longestSquareStreak(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def longestSquareStreak(self, nums: List[int]) -> int:\n        ",
    "c": "int longestSquareStreak(int* nums, int numsSize) {\n    \n}",
    "csharp": "public class Solution {\n    public int LongestSquareStreak(int[] nums) {\n        \n    }\n}",
    "javascript": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar longestSquareStreak = function(nums) {\n    \n};",
    "typescript": "function longestSquareStreak(nums: number[]): number {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @return Integer\n     */\n    function longestSquareStreak($nums) {\n        \n    }\n}",
    "swift": "class Solution {\n    func longestSquareStreak(_ nums: [Int]) -> Int {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun longestSquareStreak(nums: IntArray): Int {\n        \n    }\n}",
    "dart": "class Solution {\n  int longestSquareStreak(List<int> nums) {\n    \n  }\n}",
    "golang": "func longestSquareStreak(nums []int) int {\n    \n}",
    "ruby": "# @param {Integer[]} nums\n# @return {Integer}\ndef longest_square_streak(nums)\n    \nend",
    "scala": "object Solution {\n    def longestSquareStreak(nums: Array[Int]): Int = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn longest_square_streak(nums: Vec<i32>) -> i32 {\n        \n    }\n}",
    "racket": "(define/contract (longest-square-streak nums)\n  (-> (listof exact-integer?) exact-integer?)\n  )",
    "erlang": "-spec longest_square_streak(Nums :: [integer()]) -> integer().\nlongest_square_streak(Nums) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec longest_square_streak(nums :: [integer]) :: integer\n  def longest_square_streak(nums) do\n    \n  end\nend"
  },
  "solution": "[TOC]\n\n## Solution\n    \n---\n\n### Approach 1: Binary Search\n\n#### Intuition\n\nOur task is to form a progression where each number is the square of the previous one. A basic but inefficient method would be to loop through the array and, for each number, search for its square in the rest of the array. The longest chain of such squares would represent our desired square streak.\n\nHowever, a linear search across the entire array is too slow. To optimize, we can use binary search to find the square of a given number. \n\nTo apply binary search, we first sort the array. Then, we attempt to form a streak for each number by repeatedly finding its square using binary search. The number of successful squares found determines the length of the streak, and we keep track of the longest streak.\n\nFurther optimization is possible. Once a number has been part of a streak, it doesnâ€™t need to be considered again as a starting point for another streak, as any new streak starting from that number would be shorter. To handle this, we can use a set to track numbers already processed as part of a streak, excluding them from being reconsidered.\n\n#### Algorithm\n\n- Sort `nums` in ascending order.\n- Initialize a variable `longestStreak` to 0 to store the length of the longest square streak.\n- Create a set `processedNumbers` to keep track of numbers already processed.\n- Iterate through each number `current` in the sorted array:\n  - If `current` is in `processedNumbers`, skip to the next iteration.\n  - Initialize `streak` to `current` and `streakLength` to 1.\n  - Enter a loop:\n    - If the square of `streak` is greater than $10^5$, break the loop.\n    - If the square of `streak` exists in the array (using binary search):\n      - Update `streak` to its square.\n      - Add `streak` to `processedNumbers`.\n      - Increment `streakLength`.\n    - Else, break the loop.\n  - Update `longestStreak` to the maximum of `longestStreak` and `streakLength`.\n- Return -1 if `longestStreak` is less than 2, otherwise return `longestStreak`.\n\nImplement a binary search helper function:\n  - If the target is negative, return false.\n  - Initialize `left` to 0 and `right` to the last index of the array.\n  - While `left` is less than or equal to `right`:\n    - Calculate the middle index `mid`.\n      - If the element at `mid` equals the target, return true.\n      - If the element at `mid` is greater than the target, update `right` to `mid - 1`.\n      - Otherwise, update `left` to `mid + 1`.\n  - If the target is not found, return false.\n\n#### Implementation#### Complexity Analysis\n\nLet $n$ be the length of the input array `nums`. \n\n- Time complexity: $O(n \\cdot \\log n)$\n\n    The first step is sorting the input array, which takes $O(n \\cdot \\log n)$ time. Then, for each element, it performs a series of binary searches. The number of binary searches for each element is limited by the double logarithm of the maximum possible value ($10^5$ in this case), as each step squares the current number. Each binary search takes $O(\\log n)$ time. Thus, the time complexity for processing each element is $O(\\log n \\cdot \\log \\log (10^5))$, which simplifies to $O(\\log n)$ since $\\log 10^5$ is a constant. \n\n    Considering all steps, the overall time complexity is $O(n \\cdot \\log n)$.\n\n    > Note: For a number x, the series of squares would be $x$, $x^2$, $x^4$, $x^8$, and so on. The length of this sequence for each number would be $\\log(\\log(M))$ where $M$ is the maximum possible value that can be reached. Since M here is constant, the Big-O complexity of this value is $O(1)$.\n\n- Space complexity: $O(n)$\n\n    The algorithm uses a set to store processed numbers, which in the worst case could contain all unique elements from the input array, leading to $O(n)$ space.  \n\n    The space taken by the sorting algorithm ($S$) depends on the language of implementation:\n    - In Java, `Arrays.sort()` is implemented using a variant of the Quick Sort algorithm which has a space complexity of $O( \\log n)$.\n    - In C++, the `sort()` function is implemented as a hybrid of Quick Sort, Heap Sort, and Insertion Sort, with a worst-case space complexity of $O(\\log n)$.\n    - In Python, the `sort()` method sorts a list using the Timsort algorithm which is a combination of Merge Sort and Insertion Sort and has a space complexity of $O(n)$.\n  \n    Thus, the space complexity is $O(n + S) = O(n)$.\n\n---\n\n### Approach 2: Set\n\n#### Intuition\n\nInstead of using binary search to check if a number exists in the array, we can leverage a set. This approach eliminates the need for sorting and allows us to check for a number in constant time rather than logarithmic time.\n\nWe start by initializing a set `uniqueNumbers` to store all the numbers from the array. As before, we loop through the array and treat each number as the starting point of a streak. Inside this loop, we continue searching for the square of the previous number in the sequence using the set. The longest streak we find by counting how many times the inner loop runs gives us the desired result.\n\n#### Algorithm\n\n- Initialize a variable `longestStreak` to 0 to store the length of the longest square streak.\n- Create a set `uniqueNumbers` to store all unique numbers from the input array.\n- Iterate through each number in the input array, adding it to `uniqueNumbers`.\n- Iterate through each number `startNumber` in the input array:\n  - Initialize : \n    - `currentStreak` to 0 to track the length of the current streak.\n    - `current` as a long integer with the value of `startNumber`.\n    - Enter a loop that continues while `current` exists in `uniqueNumbers`:\n      - Increment `currentStreak`.\n      - If the square of `current` is greater than $10^5$, break the loop.\n      - Update `current` to its square.\n  - Update `longestStreak` to the maximum of `longestStreak` and `currentStreak`.\n- Return -1 if `longestStreak` is less than 2, otherwise return `longestStreak`.\n\n#### Implementation#### Complexity Analysis\n\nLet $n$ be the length of the input array `nums`. \n\n* Time complexity: $O(n \\log n)$\n\n    The algorithm iterates through each element in `nums` to fill `uniqueNumbers`, which takes $O(n)$ time.\n\n    For each number in `nums`, the algorithm checks a sequence of squares until the square exceeds the value of the element or is not found in the set. \n\n    Given that we are considering values up to the largest element in `nums` (bounded by $n$ in this analysis, as $n \\leq 10^5$), each check involves up to $O(\\log n)$ operations, as each number may involve verifying a logarithmic number of squares.\n\n    Consequently, the time complexity for processing each element becomes $O(\\log n)$, resulting in an overall complexity of $O(n) + O(n \\cdot \\log n) = O(n \\log n)$ for the entire algorithm.\n\n* Space complexity: $O(n)$\n\n    The hash set can store $n$ elements in the worst case, where all elements are unique. This takes $O(n)$ space. No other significant extra space is used that scales with the input size.\n\n    Thus, the space complexity of the algorithm is $O(n)$.\n\n---\n\n### Approach 3: Map\n\n#### Intuition\n\nTo track the length of a streak, we only need two key pieces of information: the last number in the current streak and the streak's length. When we find the square of the last number, we update both: the square becomes the new last number, and the streak length is incremented by one.\n\nWe can store this relationship using a map, where the key is the last number and the value is the streak length. For each number in the array, our first step is to check if it's a perfect square. This can be done by taking the square root of the number and squaring it again. If the result matches the original number, it's a perfect square. If not, it means the square root was decimal, and rounding down results in a smaller value when squared.\n\nOnce we find a perfect square, we check if its square root exists in the map. If it does, we can extend the existing sequence by updating the map with the current number as the new key and increasing the streak length by one.\n\nFinally, we iterate over all the values in the map and return the largest one as our answer.\n\nThe algorithm is visualized in the slideshow below:\n\n!?!../Documents/2501/slideshow.json:954,742!?!\n\n#### Algorithm\n\n- Initialize a map `streakLengths` to store the length of a square streak for each number.\n- Sort the input array in ascending order.\n- Iterate through each `number` in the sorted array:\n  - Calculate the integer square root of `number` and store it in `root`.\n  - Check if `number` is a perfect square and its square root exists in `streakLengths`:\n    - If true, extend the streak by setting the streak length for `number` to the streak length of its root plus one.\n    - If false, start a new streak by setting the streak length for `number` to 1.\n- Initialize `longestStreak` to 0 to store the maximum streak length.\n- Iterate through all streak lengths in `streakLengths`:\n  - Update `longestStreak` to the maximum of itself and the current streak length.\n- Return -1 if `longestStreak` is 1 (no valid streak), otherwise return `longestStreak`.\n\n#### Implementation#### Complexity Analysis\n\nLet $n$ be the length of the input array `nums`. \n\n* Time complexity: $O(n \\cdot \\log n)$\n\n    The algorithm begins by sorting `nums`, which takes $O(n \\cdot \\log n)$. It then iterates through each number in the sorted array once, taking linear time. For each number, it performs constant time operations: calculating the square root, checking if it's a perfect square, and either extending or starting a new streak in the map.\n\n    Finally, the algorithm iterates through the values in the `streakLengths` map to find the maximum streak length. In the worst case, this could be another $O(n)$ operation if all numbers in the input array are unique.\n\n    Thus, the time complexity is dominated by the $O(n \\cdot \\log n)$ sorting step.\n\n* Space complexity: $O(n)$\n\n    The algorithm uses a map `streakLengths` to store the streak length for each number. In the worst case, if all numbers in the input array are unique, this map could contain all $n$ elements, leading to $O(n)$ space.\n\n    The space taken by the sorting algorithm ($S$) can be $O(n)$ or $O(\\log n)$ depending on the language of implementation.\n\n    Thus, the overall space complexity is $O(n + S) = O(n)$.\n\n---"
}