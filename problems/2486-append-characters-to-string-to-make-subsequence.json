{
  "title": "Append Characters to String to Make Subsequence",
  "problem_id": "2572",
  "frontend_id": "2486",
  "difficulty": "Medium",
  "problem_slug": "append-characters-to-string-to-make-subsequence",
  "topics": [
    "Two Pointers",
    "String",
    "Greedy"
  ],
  "description": "You are given two strings s and t consisting of only lowercase English letters.\nReturn the minimum number of characters that need to be appended to the end of s so that t becomes a subsequence of s.\nA subsequence is a string that can be derived from another string by deleting some or no characters without changing the order of the remaining characters.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: s = \"coaching\", t = \"coding\"\nOutput: 4\nExplanation: Append the characters \"ding\" to the end of s so that s = \"coachingding\".\nNow, t is a subsequence of s (\"coachingding\").\nIt can be shown that appending any 3 characters to the end of s will never make t a subsequence.",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input: s = \"abcde\", t = \"a\"\nOutput: 0\nExplanation: t is already a subsequence of s (\"abcde\").",
      "images": []
    },
    {
      "example_num": 3,
      "example_text": "Input: s = \"z\", t = \"abcde\"\nOutput: 5\nExplanation: Append the characters \"abcde\" to the end of s so that s = \"zabcde\".\nNow, t is a subsequence of s (\"zabcde\").\nIt can be shown that appending any 4 characters to the end of s will never make t a subsequence.",
      "images": []
    }
  ],
  "constraints": [
    "1 <= s.length, t.length <= 105",
    "s and t consist only of lowercase English letters."
  ],
  "follow_ups": [],
  "hints": [
    "Find the longest prefix of t that is a subsequence of s.",
    "Use two variables to keep track of your location in s and t. If the characters match, increment both variables. Otherwise, only increment the variable for s.",
    "The remaining characters in t must be appended to the end of s."
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    int appendCharacters(string s, string t) {\n        \n    }\n};",
    "java": "class Solution {\n    public int appendCharacters(String s, String t) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def appendCharacters(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: int\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def appendCharacters(self, s: str, t: str) -> int:\n        ",
    "c": "int appendCharacters(char* s, char* t) {\n    \n}",
    "csharp": "public class Solution {\n    public int AppendCharacters(string s, string t) {\n        \n    }\n}",
    "javascript": "/**\n * @param {string} s\n * @param {string} t\n * @return {number}\n */\nvar appendCharacters = function(s, t) {\n    \n};",
    "typescript": "function appendCharacters(s: string, t: string): number {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param String $s\n     * @param String $t\n     * @return Integer\n     */\n    function appendCharacters($s, $t) {\n        \n    }\n}",
    "swift": "class Solution {\n    func appendCharacters(_ s: String, _ t: String) -> Int {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun appendCharacters(s: String, t: String): Int {\n        \n    }\n}",
    "dart": "class Solution {\n  int appendCharacters(String s, String t) {\n    \n  }\n}",
    "golang": "func appendCharacters(s string, t string) int {\n    \n}",
    "ruby": "# @param {String} s\n# @param {String} t\n# @return {Integer}\ndef append_characters(s, t)\n    \nend",
    "scala": "object Solution {\n    def appendCharacters(s: String, t: String): Int = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn append_characters(s: String, t: String) -> i32 {\n        \n    }\n}",
    "racket": "(define/contract (append-characters s t)\n  (-> string? string? exact-integer?)\n  )",
    "erlang": "-spec append_characters(S :: unicode:unicode_binary(), T :: unicode:unicode_binary()) -> integer().\nappend_characters(S, T) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec append_characters(s :: String.t, t :: String.t) :: integer\n  def append_characters(s, t) do\n    \n  end\nend"
  },
  "solution": "[TOC]\n\n## Solution\n\n---\n\n### Overview\n\nThis problem asks us to find the number of letters we would need to add to the end of `s` so that `s` contains every letter in `t`, in the same order it occurs in `t`. \n\nFrom Examples 1 and 3 in the problem, you can see it's necessary for the letters in `t` to occur in `s` in the same order as they are in `t`. This ordering is what will make `t` a subsequence of `s`. From Example 2, you can see that we won't need to add any letters to `s` if `t` is already a subsequence of it. \n\n**Key Observations:**\n1. Both `s` and `t` consist of only lowercase letters.\n2. The constraints of the problem indicate that we need to think of a solution with linear or log-linear time complexity, in terms of the length of given strings. \n\n---\n\n### Approach 1: Greedy (Two Pointers)\n\n#### Intuition\n\nWe want to start by identifying all of the characters in `t` that are already a subsequence of `s`. These characters would occur as a prefix in `t`. After finding the longest such prefix of `t`, we can append the remaining characters at the end of `s`. Of course, if `t` is already a subsequence of `s`, we won't need to add any characters. This would minimize the number of characters that are appended to the string `s` for it to contain `t` as a subsequence. This idea can be explained using the image given below:\n\n![img](../Figures/2486/Slide1.png)\n\nAlthough the first character in `t` could appear at various positions throughout `s`, we want to pick the first time it appears in `s` as the start of the subsequence. If we determine that the first character of `t` is in `s`, we will start looking for the second character. We will pick the first occurrence of the second character of `t` after the first character. We will repeat this process till we can no longer find a character that can be picked in the string `s`.\n\nWe can accomplish this using a two-pointer approach to iterate through each string, counting the number of characters in `t` that appear in the same order in `s`. When we reach the end of `s`, we know that the number of uncounted characters in `t` need to be added to the end of `s`.\n\nThe first pointer,`first`, will iterate through `s`, one character at a time. The second pointer,`longestPrefix`, will be initially placed at the first character of the string `t`. When the first pointer reaches the end of string `s`, the `longestPrefix` will store the length of the longest prefix of `t` which is a subsequence of `s`. We can now subtract `longestPrefix` from the length of `t` to find the number of characters that need to be added to `s`.\n\nWe can prove the optimality of the algorithm using contradiction. Let's say that the greedy approach returns the minimum number of characters as `c`. By contradiction, assume that there exists a better solution where the number of characters that need to be appended is `c-1`.\n\nThis would mean that the first character appended in the greedy solution is part of a subsequence of `s` in the assumed optimal solution. However, this cannot be true since we have selected the characters of `t` in the order in which they appear in `s` (i.e., we have picked the first occurrences). Therefore, the assumption is incorrect, and the greedy approach gives the most optimal solution here.\n\n#### Algorithm\n\n1. Initialise two pointers `first` and `longestPrefix` with 0. \n2. Iterate while `first` is less than `s.length` and `longestPrefix` is less than `t.length`:\n   - If the `s[first]` is equal to `t[longestPrefix]`:\n     - Increment `longestPrefix` by 1. \n   - Increment `first` by 1.\n3. Return the difference of `t.length` and `longestPrefix`.\n\n!?!../Documents/2486/slideshow1.json:960,540!?!\n\n#### Implementation#### Complexity Analysis\n\nLet $n$ be the length of `s` and $m$ be the length of `t`.\n\n- Time complexity: $O(n)$\n\n  Since we iterate through the string `s` exactly once, the time complexity can be stated as $O(n)$.\n\n- Space complexity: $O(1)$\n\n  We do not allocate any additional auxiliary memory proportional to the size of the given strings. Therefore, overall space complexity is given by $O(1)$.\n\n---"
}