{
  "title": "Largest Plus Sign",
  "problem_id": "769",
  "frontend_id": "764",
  "difficulty": "Medium",
  "problem_slug": "largest-plus-sign",
  "topics": [
    "Array",
    "Dynamic Programming"
  ],
  "description": "You are given an integer n. You have an n x n binary grid grid with all values initially 1's except for some indices given in the array mines. The ith element of the array mines is defined as mines[i] = [xi, yi] where grid[xi][yi] == 0.\nReturn the order of the largest axis-aligned plus sign of 1's contained in grid. If there is none, return 0.\nAn axis-aligned plus sign of 1's of order k has some center grid[r][c] == 1 along with four arms of length k - 1 going up, down, left, and right, and made of 1's. Note that there could be 0's or 1's beyond the arms of the plus sign, only the relevant area of the plus sign is checked for 1's.\nExample 1:\nExample 2:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: n = 5, mines = [[4,2]]\nOutput: 2\nExplanation: In the above grid, the largest plus sign can only be of order 2. One of them is shown.",
      "images": [
        "https://assets.leetcode.com/uploads/2021/06/13/plus1-grid.jpg"
      ]
    },
    {
      "example_num": 2,
      "example_text": "Input: n = 1, mines = [[0,0]]\nOutput: 0\nExplanation: There is no plus sign, so return 0.",
      "images": [
        "https://assets.leetcode.com/uploads/2021/06/13/plus2-grid.jpg"
      ]
    }
  ],
  "constraints": [
    "1 <= n <= 500",
    "1 <= mines.length <= 5000",
    "0 <= xi, yi < n",
    "All the pairs (xi, yi) are unique."
  ],
  "follow_ups": [],
  "hints": [
    "For each direction such as \"left\", find left[r][c] = the number of 1s you will see before a zero starting at r, c and walking left.  You can find this in N^2 time with a dp.  The largest plus sign at r, c is just the minimum of left[r][c], up[r][c] etc."
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    int orderOfLargestPlusSign(int n, vector<vector<int>>& mines) {\n        \n    }\n};",
    "java": "class Solution {\n    public int orderOfLargestPlusSign(int n, int[][] mines) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def orderOfLargestPlusSign(self, n, mines):\n        \"\"\"\n        :type n: int\n        :type mines: List[List[int]]\n        :rtype: int\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def orderOfLargestPlusSign(self, n: int, mines: List[List[int]]) -> int:\n        ",
    "c": "int orderOfLargestPlusSign(int n, int** mines, int minesSize, int* minesColSize) {\n    \n}",
    "csharp": "public class Solution {\n    public int OrderOfLargestPlusSign(int n, int[][] mines) {\n        \n    }\n}",
    "javascript": "/**\n * @param {number} n\n * @param {number[][]} mines\n * @return {number}\n */\nvar orderOfLargestPlusSign = function(n, mines) {\n    \n};",
    "typescript": "function orderOfLargestPlusSign(n: number, mines: number[][]): number {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param Integer $n\n     * @param Integer[][] $mines\n     * @return Integer\n     */\n    function orderOfLargestPlusSign($n, $mines) {\n        \n    }\n}",
    "swift": "class Solution {\n    func orderOfLargestPlusSign(_ n: Int, _ mines: [[Int]]) -> Int {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun orderOfLargestPlusSign(n: Int, mines: Array<IntArray>): Int {\n        \n    }\n}",
    "dart": "class Solution {\n  int orderOfLargestPlusSign(int n, List<List<int>> mines) {\n    \n  }\n}",
    "golang": "func orderOfLargestPlusSign(n int, mines [][]int) int {\n    \n}",
    "ruby": "# @param {Integer} n\n# @param {Integer[][]} mines\n# @return {Integer}\ndef order_of_largest_plus_sign(n, mines)\n    \nend",
    "scala": "object Solution {\n    def orderOfLargestPlusSign(n: Int, mines: Array[Array[Int]]): Int = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn order_of_largest_plus_sign(n: i32, mines: Vec<Vec<i32>>) -> i32 {\n        \n    }\n}",
    "racket": "(define/contract (order-of-largest-plus-sign n mines)\n  (-> exact-integer? (listof (listof exact-integer?)) exact-integer?)\n  )",
    "erlang": "-spec order_of_largest_plus_sign(N :: integer(), Mines :: [[integer()]]) -> integer().\norder_of_largest_plus_sign(N, Mines) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec order_of_largest_plus_sign(n :: integer, mines :: [[integer]]) :: integer\n  def order_of_largest_plus_sign(n, mines) do\n    \n  end\nend"
  },
  "solution": "[TOC]\n\n### Approach #1: Brute Force [Time Limit Exceeded]\n\n**Intuition and Algorithm**\n\nFor each possible center, find the largest plus sign that could be placed by repeatedly expanding it.\nWe expect this algorithm to be $$O(N^3)$$, and so take roughly $$500^3 = (1.25) * 10^8$$ operations.  This is a little bit too big for us to expect it to run in time.**Complexity Analysis**\n\n* Time Complexity: $$O(N^3)$$, as we perform two outer loops ($$O(N^2)$$), plus the inner loop involving `k` is $$O(N)$$.\n\n* Space Complexity: $$O(\\text{mines.length})$$.\n\n---\n\n### Approach #2: Dynamic Programming [Accepted]\n\n**Intuition**\n\nHow can we improve our bruteforce?  One way is to try to speed up the inner loop involving `k`, the order of the candidate plus sign.\nIf we knew the longest possible arm length $$L_u, L_l, L_d, L_r$$ in each direction from a center, we could know the order $$\\min(L_u, L_l, L_d, L_r)$$ of a plus sign at that center.  We could find these lengths separately using dynamic programming.\n\n**Algorithm**\n\nFor each (cardinal) direction, and for each coordinate `(r, c)` let's compute the `count` of that coordinate: the longest line of `'1'`s starting from `(r, c)` and going in that direction.\nWith dynamic programming, it is either 0 if `grid[r][c]` is zero, else it is `1` plus the count of the coordinate in the same direction.\nFor example, if the direction is left and we have a row like `01110110`, the corresponding count values are `01230120`, and the integers are either 1 more than their successor, or 0.\nFor each square, we want `dp[r][c]` to end up being the minimum of the 4 possible counts.  At the end, we take the maximum value in `dp`.**Complexity Analysis**\n\n* Time Complexity: $$O(N^2)$$, as the work we do under two nested for loops is $$O(1)$$.\n\n* Space Complexity: $$O(N^2)$$, the size of `dp`."
}