{
  "title": "Minimum Swaps to Group All 1's Together II",
  "problem_id": "2255",
  "frontend_id": "2134",
  "difficulty": "Medium",
  "problem_slug": "minimum-swaps-to-group-all-1s-together-ii",
  "topics": [
    "Array",
    "Sliding Window"
  ],
  "description": "A swap is defined as taking two distinct positions in an array and swapping the values in them.\nA circular array is defined as an array where we consider the first element and the last element to be adjacent.\nGiven a binary circular array nums, return the minimum number of swaps required to group all 1's present in the array together at any location.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: nums = [0,1,0,1,1,0,0]\nOutput: 1\nExplanation: Here are a few of the ways to group all the 1's together:\n[0,0,1,1,1,0,0] using 1 swap.\n[0,1,1,1,0,0,0] using 1 swap.\n[1,1,0,0,0,0,1] using 2 swaps (using the circular property of the array).\nThere is no way to group all 1's together with 0 swaps.\nThus, the minimum number of swaps required is 1.",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input: nums = [0,1,1,1,0,0,1,1,0]\nOutput: 2\nExplanation: Here are a few of the ways to group all the 1's together:\n[1,1,1,0,0,0,0,1,1] using 2 swaps (using the circular property of the array).\n[1,1,1,1,1,0,0,0,0] using 2 swaps.\nThere is no way to group all 1's together with 0 or 1 swaps.\nThus, the minimum number of swaps required is 2.",
      "images": []
    },
    {
      "example_num": 3,
      "example_text": "Input: nums = [1,1,0,0,1]\nOutput: 0\nExplanation: All the 1's are already grouped together due to the circular property of the array.\nThus, the minimum number of swaps required is 0.",
      "images": []
    }
  ],
  "constraints": [
    "1 <= nums.length <= 105",
    "nums[i] is either 0 or 1."
  ],
  "follow_ups": [],
  "hints": [
    "Notice that the number of 1’s to be grouped together is fixed. It is the number of 1's the whole array has.",
    "Call this number total. We should then check for every subarray of size total (possibly wrapped around), how many swaps are required to have the subarray be all 1’s.",
    "The number of swaps required is the number of 0’s in the subarray.",
    "To eliminate the circular property of the array, we can append the original array to itself. Then, we check each subarray of length total.",
    "How do we avoid recounting the number of 0’s in the subarray each time? The Sliding Window technique can help."
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    int minSwaps(vector<int>& nums) {\n        \n    }\n};",
    "java": "class Solution {\n    public int minSwaps(int[] nums) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def minSwaps(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def minSwaps(self, nums: List[int]) -> int:\n        ",
    "c": "int minSwaps(int* nums, int numsSize) {\n    \n}",
    "csharp": "public class Solution {\n    public int MinSwaps(int[] nums) {\n        \n    }\n}",
    "javascript": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar minSwaps = function(nums) {\n    \n};",
    "typescript": "function minSwaps(nums: number[]): number {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @return Integer\n     */\n    function minSwaps($nums) {\n        \n    }\n}",
    "swift": "class Solution {\n    func minSwaps(_ nums: [Int]) -> Int {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun minSwaps(nums: IntArray): Int {\n        \n    }\n}",
    "dart": "class Solution {\n  int minSwaps(List<int> nums) {\n    \n  }\n}",
    "golang": "func minSwaps(nums []int) int {\n    \n}",
    "ruby": "# @param {Integer[]} nums\n# @return {Integer}\ndef min_swaps(nums)\n    \nend",
    "scala": "object Solution {\n    def minSwaps(nums: Array[Int]): Int = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn min_swaps(nums: Vec<i32>) -> i32 {\n        \n    }\n}",
    "racket": "(define/contract (min-swaps nums)\n  (-> (listof exact-integer?) exact-integer?)\n  )",
    "erlang": "-spec min_swaps(Nums :: [integer()]) -> integer().\nmin_swaps(Nums) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec min_swaps(nums :: [integer]) :: integer\n  def min_swaps(nums) do\n    \n  end\nend"
  },
  "solution": "[TOC]\n\n## Solution\n\n---\n\n### Overview\n\nIn this problem, we're given a binary circular array where each element is either 0 or 1. The circular nature of the array means that the last element is considered adjacent to the first. Our task is to find the minimum number of swaps needed to group the 1s. A swap involves exchanging values between two distinct positions.\n\nThe circular property of the array opens up more possible groupings to consider compared to a linear array.\n\n> Input: `nums = [0,1,1,1,0,0,1,1,0]`\n> Output: `2`\n\nTwo swaps are required to group all 1s together, either forming `[1,1,1,0,0,0,0,1,1]` or `[1,1,1,1,1,0,0,0,0]`.\n\n---\n\n### Approach 1: Using Suffix Sum\n\n#### Intuition\n\nImagine doing this manually. First, count the total number of 1s that we need to group together. Then, count how many 0s we need to swap out if we grouped that number of 1s at the beginning of the array. Continue doing this for each possible start point in the array. When we are done, we'll have considered every possibility to confidently determine the smallest possible number of swaps needed to form the group.\n\nOne approach to achieve this is by using suffix sums. If you are **not familiar with suffix sums**, consider reviewing the problem **[2574. Left and Right Sum Differences](https://leetcode.com/problems/left-and-right-sum-differences/description/)** to get a better understanding.\n\nUsing a suffix sum will let us find the number of 0s within a given range as we check for the best possible grouping of 1s. We'll use an array `rightSuffixSum` to iterate from the end of the array to the beginning, populating the array with cumulative counts of zeros. When we are finished, `rightSuffixSum[0]` will be the total number of 0s in the array.\n\nLet's say we need to group four 1s. We can use our array `rightSuffixSum` to calculate how many 0s are in the first four positions of the given array. Then, we can check how many zeros are in the four positions starting with the second index of the given array, and so on. When we are finished iterating through the given array, we will know the smallest possible number of swaps.\n\n#### Algorithm\n\n- Define `minSwaps` function that calculates minimum swaps needed by calling `minSwapsHelper` with two different values (0 and 1), returning the minimum result.\n- Define `minSwapsHelper` function:\n  - Initialize `length` as the length of the input array `data`.\n  - Create an array `rightSuffixSum` to store the count of elements equal to `val ^ 1` from the right.\n  - Iterate through the array from right to left, updating `rightSuffixSum`:\n    - If the current element equals `val ^ 1`, increment the corresponding entry in `rightSuffixSum`.\n  - Initialize `totalSwapsNeeded` as `rightSuffixSum[0]` and `currentSwapCount` to 0.\n  - Initialize `minimumSwaps` with the difference between `totalSwapsNeeded` and `rightSuffixSum[length - totalSwapsNeeded]`.\n  - Iterate through the first `totalSwapsNeeded` elements to calculate the required swaps:\n    - If the current element equals `val ^ 1`, increment `currentSwapCount`.\n    - Calculate `remaining` as `totalSwapsNeeded - i - 1`.\n    - Calculate `requiredSwaps` using the current and remaining counts, updating `minimumSwaps` with the minimum value.\n  - Return `minimumSwaps` as the result.\n\n#### Implementation#### Complexity Analysis\n\nLet $n$ be the length of the array.\n\n- Time complexity: $O(n)$\n\n    The main operations (constructing the `rightSuffixSum` and calculating minimum swaps) involve single passes through the array.\n\n- Space complexity: $O(n)$\n\n    $O(n)$, due to the `rightSuffixSum` array, which stores the count for each position in the input array.\n\n---\n\n### Approach 2: Using Sliding Window\n\n#### Intuition\n\nWe can simplify our approach by creating a sliding window equal to the number of 1s in the array and using it to identify the grouping with the highest concentration of 1s. Then, we'll use this to determine how many values need to be swapped to group all 1s in the array together.\n\nWe'll determine the size of our sliding window by counting the number of 1s in the given array. Next, we'll initialize the window to be this size and count the number of 1s within it. This gives us a baseline count, representing how many 1s are already in place within the first possible grouping. This step is important because it sets the stage for comparison as we slide the window across the array.\n\nAs we slide the window, we'll dynamically update our count of 1s by subtracting the value at the window's starting edge and adding the value at the window's new trailing edge. This step is crucial because it allows us to track the number of 1s in each potential group without re-scanning the entire window. The circular nature of the array is naturally handled because the sliding window can wrap around from the end to the beginning of the array.\n\nFinally, we'll find the difference between the total number of 1s in the array and the grouping with the highest concentration of 1s to find the minimum number of swaps required to group the 1s.\n\n#### Algorithm\n\n- Calculate the minimum swaps needed to group all 1s or all 0s together.\n- Use `minSwapsHelper` to determine the number of swaps for grouping all 0s and all 1s.\n- Return the minimum value between the two results from `minSwapsHelper`.\n\n- Define `minSwapsHelper` to calculate the minimum swaps required to group all `val` together:\n  - Initialize `length` as the length of the array and `totalValCount` to count the occurrences of `val`.\n  - Iterate through the array in reverse to count the total number of `val`.\n  - If there is no `val` or the array is full of `val`, return 0.\n  - Initialize `start` and `end` pointers for the sliding window and set `maxValInWindow` and `currentValInWindow` to 0.\n  - Set up the initial window by counting the number of `val` in the first window of size `totalValCount`.\n  - Update `maxValInWindow` with the maximum value found in the initial window.\n  - Slide the window across the array:\n    - Decrease `currentValInWindow` if the value at the `start` pointer equals `val` and increment `start`.\n    - Increase `currentValInWindow` if the value at the `end` pointer equals `val` and increment `end`.\n    - Update `maxValInWindow` with the maximum value found in the sliding window.\n  - Calculate the minimum swaps as `totalValCount` minus `maxValInWindow`.\n  - Return the calculated number of swaps.\n\nThe algorithm is visualized below:\n\n!?!../Documents/2134/approach2.json:885,465!?!\n\n#### Implementation#### Complexity Analysis\n\nLet $n$ be the length of the array.\n\n* Time complexity: $O(n)$\n\n    We perform a single pass to count `val` and then a single pass with the sliding window.\n\n* Space complexity: $O(1)$\n\n    $O(1)$, since we are using a constant amount of extra space, regardless of the input size.\n\n---\n\n### Approach 3: Cleaner and More Intuitive Sliding Window\n\n#### Intuition\n\nCompared to Approach 2, Approach 3 refines the sliding window technique by explicitly addressing the circular nature of the array. Instead of having two different windows work together to find the group of 1s and 0s, we allow the window's `end` index to exceed the array bounds and use the modulus operation to wrap around. This makes our solution more straightforward and cleaner.\n\nFirst, we determine the total number of 1s in the array (`totalOnes`), which sets the size of our sliding window. We start with an initial window that covers the first `totalOnes` elements and count the 1s within this window to establish a baseline.\n\nAs we slide the window across the array, we dynamically adjust the count of 1s by subtracting the value that slides out of the window and adding the value that enters it. This step-by-step adjustment is efficient because it avoids rescanning the entire window each time.\n\nTo handle the circular aspect, we use the modulus operation (`end % len(nums)`). This operation wraps the window's `end` index back to the beginning of the array when it goes out of bounds. This ensures our sliding window considers all possible groupings of 1s, including those spanning the array's `end` and `start`.\n\nThroughout this process, we track the window position with the highest number of 1s. The difference between `totalOnes` and this maximum number gives us the minimum swaps needed to group all 1s together. By continually updating our count and leveraging the circular nature of the array, we achieve an optimal and efficient solution.\n\n#### Algorithm\n\n- Initialize `minimumSwaps` to a large value (`INT_MAX`).\n- Calculate the total number of `1`s in the array using `accumulate`:\n  - `totalOnes` stores the total count of `1`s in `nums`.\n- Initialize `onesCount` to the number of `1`s in the initial window (first element of `nums`).\n- Set `end` to `0`.\n- Slide the window across the array:\n  - For each `start` index from `0` to the size of the array:\n    - Adjust `onesCount` by removing the element that is sliding out of the window (`nums[start - 1]`).\n    - Expand the window to the right until it reaches the size equal to `totalOnes`:\n      - Add elements to `onesCount` from the right end of the window using modular indexing (`nums[end % nums.size()]`).\n    - Update `minimumSwaps` by calculating the difference between `totalOnes` and `onesCount`.\n- Return `minimumSwaps` as the result.\n\n#### Implementation#### Complexity Analysis\n\nLet $n$ be the length of the array.\n\n* Time complexity: $O(n)$\n\n    The algorithm processes each element of the array once while expanding and sliding the window. Therefore, the time complexity is linear with respect to the number of elements in the array.\n\n* Space complexity: $O(1)$\n\n    The algorithm uses a constant amount of extra space for variables regardless of the size of the input array. Therefore, the space complexity is constant.\n\n---"
}