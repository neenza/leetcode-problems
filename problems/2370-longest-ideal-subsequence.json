{
  "title": "Longest Ideal Subsequence",
  "problem_id": "2444",
  "frontend_id": "2370",
  "difficulty": "Medium",
  "problem_slug": "longest-ideal-subsequence",
  "topics": [
    "Hash Table",
    "String",
    "Dynamic Programming"
  ],
  "description": "You are given a string s consisting of lowercase letters and an integer k. We call a string t ideal if the following conditions are satisfied:\nReturn the length of the longest ideal string.\nA subsequence is a string that can be derived from another string by deleting some or no characters without changing the order of the remaining characters.\nNote that the alphabet order is not cyclic. For example, the absolute difference in the alphabet order of 'a' and 'z' is 25, not 1.\nExample 1:\nExample 2:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: s = \"acfgbd\", k = 2\nOutput: 4\nExplanation: The longest ideal string is \"acbd\". The length of this string is 4, so 4 is returned.\nNote that \"acfgbd\" is not ideal because 'c' and 'f' have a difference of 3 in alphabet order.",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input: s = \"abcd\", k = 3\nOutput: 4\nExplanation: The longest ideal string is \"abcd\". The length of this string is 4, so 4 is returned.",
      "images": []
    }
  ],
  "constraints": [
    "1 <= s.length <= 105",
    "0 <= k <= 25",
    "s consists of lowercase English letters."
  ],
  "follow_ups": [],
  "hints": [
    "How can you calculate the longest ideal subsequence that ends at a specific index i?",
    "Can you calculate it for all positions i? How can you use previously calculated answers to calculate the answer for the next position?"
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    int longestIdealString(string s, int k) {\n        \n    }\n};",
    "java": "class Solution {\n    public int longestIdealString(String s, int k) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def longestIdealString(self, s, k):\n        \"\"\"\n        :type s: str\n        :type k: int\n        :rtype: int\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def longestIdealString(self, s: str, k: int) -> int:\n        ",
    "c": "int longestIdealString(char* s, int k) {\n    \n}",
    "csharp": "public class Solution {\n    public int LongestIdealString(string s, int k) {\n        \n    }\n}",
    "javascript": "/**\n * @param {string} s\n * @param {number} k\n * @return {number}\n */\nvar longestIdealString = function(s, k) {\n    \n};",
    "typescript": "function longestIdealString(s: string, k: number): number {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param String $s\n     * @param Integer $k\n     * @return Integer\n     */\n    function longestIdealString($s, $k) {\n        \n    }\n}",
    "swift": "class Solution {\n    func longestIdealString(_ s: String, _ k: Int) -> Int {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun longestIdealString(s: String, k: Int): Int {\n        \n    }\n}",
    "dart": "class Solution {\n  int longestIdealString(String s, int k) {\n    \n  }\n}",
    "golang": "func longestIdealString(s string, k int) int {\n    \n}",
    "ruby": "# @param {String} s\n# @param {Integer} k\n# @return {Integer}\ndef longest_ideal_string(s, k)\n    \nend",
    "scala": "object Solution {\n    def longestIdealString(s: String, k: Int): Int = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn longest_ideal_string(s: String, k: i32) -> i32 {\n        \n    }\n}",
    "racket": "(define/contract (longest-ideal-string s k)\n  (-> string? exact-integer? exact-integer?)\n  )",
    "erlang": "-spec longest_ideal_string(S :: unicode:unicode_binary(), K :: integer()) -> integer().\nlongest_ideal_string(S, K) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec longest_ideal_string(s :: String.t, k :: integer) :: integer\n  def longest_ideal_string(s, k) do\n    \n  end\nend"
  },
  "solution": "[TOC]\n\n## Solution\n\n---\n\n### Approach 1: Recursive Dynamic Programming (Top Down)\n\n#### Intuition\n\nDue to the large length of `s`, checking every subsequence is not a feasible option. Instead, we should find some property that simplifies the construction of an ideal subsequence.\n\nConsider building an ideal string as a subsequence of `s` by checking each letter from left to right. To keep track of what letters could be appended to some ideal string, we only need to access the last letter of the current ideal string. \n\nFor example, the same set of letters can be appended to the two strings \"acdba\" and \"abbca\" because both strings end with the letter \"a\". Any characters before the last letter won't affect future letter choices.\n\nTherefore, we can maintain the longest possible subsequence of `s` created from the first `i` letters of `s`. Among all of these subsequences, we only need to track the last letter `c` of any ideal subsequence.\n\nThis motivates a dynamic programming (DP) approach. We can define `dp[i][c]` as the longest ideal subsequence ending with the letter `c` when considering only the first `i` letters in the input string `s`. \n\nSince we need to perform difference calculations between characters, we will represent `c` as an integer from $0$ to $25$ that corresponds to each letter of the alphabet.\n\nThere are two types of transitions when calculating `dp[i][c]`:\n\n1. Do not include $s_i$ in an ideal subsequence. The length of the current longest subsequence stays the same, so `dp[i][c] = dp[i - 1][c]`\n2. Include $s_i$ in an ideal subsequence. Let $c = s_i-{'a'}$. This subsequence becomes one letter longer, so `dp[i][c] = max(dp[i - 1][p]) + 1` for all characters `p` such that $|c-p| \\leq K$. This simulates adding a new character to the longest previous subsequences that allow appending `c`.\n\nFor the base case of $i = 0$ (the first letter), if `c` matches the first letter, then we can create an ideal sequence of length $1$. Otherwise, $c \\neq s_0$, so it's impossible to create a non-empty ideal sequence with the first letter. We set `dp[0][c]` to $0$ to indicate an empty sequence.\n\nTo retrieve the answer, we should consider the longest subsequences that consider all $N$ letters and all $26$ possible ending letters. These quantities are stored in the row `dp[N - 1][c]`. We calculate the possible ideal substring lengths for each `c` value, and the maximum is the result.\n\n#### Algorithm\n\n1. Initialize a `dp` table with $N$ rows and $26$ columns, and set the default values to $-1$.\n2. Create the `dfs` method that passes `i`, `c`, `dp`, `s`, and `k` as parameters. Note that `dp` and `s` should be passed by reference. Steps 3-7 describe the implementation of the `dfs` method.\n3. If `dp[i][c]` is not equal to $-1$, return the memoized value stored in `dp[i][c]`.\n4. Otherwise, set `dp[i][c]` to $1$ if `c == (s[i] - 'a')`, and $0$ otherwise.\n5. If the current state is not a base case ($i > 0$), check the option of not including $s_i$ in this ideal subsequence.\n6. If `c == (s[i] - 'a')`, check all transistions to previous letters $p$ such that $|c - p| \\leq k$.\n7. Return `dp[i][c]` to end the recursive call.\n8. Find the maximum of `dp[N-1][c]` for all `c` from $0$ to $25$, and return this value as the answer.\n\n#### Implementation#### Complexity Analysis\n\nLet $N$ be the length of `s` and $L$ be the number of letters in the English alphabet, which is $26$.\n\n* Time complexity: $O(NL)$.\n\n    In the main function, we check each possible ending letter of some subsequence, calling `dfs()` $L$ times. The `dfs()` function recursively calls itself, and the total number of `dfs()` calls that run prior to memoizing is bounded by $N \\cdot L$, so this step takes $O(NL + L)$, which is essentially $O(NL)$.\n    \n    The loop inside the `dfs()` function makes up to $26$ iterations. This loop is executed only if  `match` is true, which is the case if `c` corresponds to the same ASCII value as the character `s[i]`. There is only one instance of `c` that fits this description for each distinct `i`, so this loop is executed at most once for each character in `s`. In other words, $L$ transitions are executed only for $N$ total states. Over the course of the whole search process, this loop executes up to $O(NL)$ times. \n    \n    Therefore, the total time complexity is $O(NL + NL)$, or $O(2NL)$, which we can simplify to $O(NL)$. Note that $L$ is $26$, which is a constant, so we could simplify the time complexity to $O(N)$.\n    \n* Space complexity: $O(NL)$.\n\n    The additional space complexity is $O(NL)$, since the two-dimensional `dp` grid needs to be initialized for memoization. $L$ is $26$, which is a constant, so we could simplify the time complexity to $O(N)$.\n\n--- \n\n### Approach 2: Iterative Dynamic Programming (Bottom Up, Space Optimized)\n\n#### Intuition\n\nPlease read the above approach first, as this approach builds off of the previous approach. Top-down dynamic programming requires overhead for the call stack; let's use bottom-up dynamic programming to develop a more efficient solution.\n\nIf we examine the above approach, we can observe that `dp[i]` depends only on the previous row `dp[i - 1]` in the DP grid. When we transition to DP states ending at index $i$, we only need to check DP states ending at $i-1$.\n\nBy implementing this approach iteratively, we can store `dp` as an array that tracks only the previous row of DP values. We no longer need to memoize all DP states, so we can reduce the additional space complexity by a factor of $N$.\n    \nWe can use two nested `for` loops to iterate through the `dp` values in order. The outer loop iterates over the current index `i` of `s`, and the inner loop iterates over every choice `prev.` Variable `prev` indicates the previous last letter of the subsequence. `curr`, which corresponds to the character `s[i]`, is used to check if appending `s[i]` is valid.\n\n#### Algorithm\n\n1. Initialize the `dp` array of length $26$ with all $0$'s.\n2. Iterate through each letter in input string `s` and repeat steps 3-6 $N$ times where $N$ is the length of `s`.\n3. Initialize a variable `curr` to the ASCII representation of $s_i$, and a variable `best` to `0`.\n4. Iterate through the possible candidates for the previous ending letter of some ideal subsequence, which are the letters in the alphabet that are at most $K$ apart from $s_i$. Use `best` to track the maximum `dp[prev]`.\n5. Set `dp[curr] = best + 1` to simulate appending letter $curr = s_i-{'a'}$ to an ideal subsequence.\n6. Update the result to the maximum between `res` and `dp[curr]`.\n7. Return the result.\n\n\n#### Implementation#### Complexity Analysis\n\nLet $N$ be the length of `s` and $L$ be the number of letters in the English alphabet, which is $26$.\n\n* Time complexity: $O(NL)$.\n\n    The outer loop iterates through the characters in `s`, so it runs $N$ times. The inner loop iterates up to $L$ times for each character in `s`. Therefore, the time complexity is $O(NL)$. Note that $L$ is $26$, which is a constant, so we could simplify the time complexity to $O(N)$.\n    \n* Space complexity: $O(L)$\n\n    We use a DP array of size $L$. $L$ is $26$, which is a constant, so we could simplify the time complexity to $O(1)$."
}