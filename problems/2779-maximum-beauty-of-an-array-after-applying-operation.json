{
  "title": "Maximum Beauty of an Array After Applying Operation",
  "problem_id": "2891",
  "frontend_id": "2779",
  "difficulty": "Medium",
  "problem_slug": "maximum-beauty-of-an-array-after-applying-operation",
  "topics": [
    "Array",
    "Binary Search",
    "Sliding Window",
    "Sorting"
  ],
  "description": "You are given a 0-indexed array nums and a non-negative integer k.\nIn one operation, you can do the following:\nThe beauty of the array is the length of the longest subsequence consisting of equal elements.\nReturn the maximum possible beauty of the array nums after applying the operation any number of times.\nNote that you can apply the operation to each index only once.\nAÂ subsequence of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the order of the remaining elements.\nExample 1:\nExample 2:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: nums = [4,6,1,2], k = 2\nOutput: 3\nExplanation: In this example, we apply the following operations:\n- Choose index 1, replace it with 4 (from range [4,8]), nums = [4,4,1,2].\n- Choose index 3, replace it with 4 (from range [0,4]), nums = [4,4,1,4].\nAfter the applied operations, the beauty of the array nums is 3 (subsequence consisting of indices 0, 1, and 3).\nIt can be proven that 3 is the maximum possible length we can achieve.",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input: nums = [1,1,1,1], k = 10\nOutput: 4\nExplanation: In this example we don't have to apply any operations.\nThe beauty of the array nums is 4 (whole array).",
      "images": []
    }
  ],
  "constraints": [
    "1 <= nums.length <= 105",
    "0 <= nums[i], k <= 105"
  ],
  "follow_ups": [],
  "hints": [
    "Sort the array.",
    "The problem becomes the following: find maximum subarray A[i â€¦ j] such that A[j] - A[i] â‰¤ 2 * k."
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    int maximumBeauty(vector<int>& nums, int k) {\n        \n    }\n};",
    "java": "class Solution {\n    public int maximumBeauty(int[] nums, int k) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def maximumBeauty(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def maximumBeauty(self, nums: List[int], k: int) -> int:\n        ",
    "c": "int maximumBeauty(int* nums, int numsSize, int k) {\n    \n}",
    "csharp": "public class Solution {\n    public int MaximumBeauty(int[] nums, int k) {\n        \n    }\n}",
    "javascript": "/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number}\n */\nvar maximumBeauty = function(nums, k) {\n    \n};",
    "typescript": "function maximumBeauty(nums: number[], k: number): number {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @param Integer $k\n     * @return Integer\n     */\n    function maximumBeauty($nums, $k) {\n        \n    }\n}",
    "swift": "class Solution {\n    func maximumBeauty(_ nums: [Int], _ k: Int) -> Int {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun maximumBeauty(nums: IntArray, k: Int): Int {\n        \n    }\n}",
    "dart": "class Solution {\n  int maximumBeauty(List<int> nums, int k) {\n    \n  }\n}",
    "golang": "func maximumBeauty(nums []int, k int) int {\n    \n}",
    "ruby": "# @param {Integer[]} nums\n# @param {Integer} k\n# @return {Integer}\ndef maximum_beauty(nums, k)\n    \nend",
    "scala": "object Solution {\n    def maximumBeauty(nums: Array[Int], k: Int): Int = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn maximum_beauty(nums: Vec<i32>, k: i32) -> i32 {\n        \n    }\n}",
    "racket": "(define/contract (maximum-beauty nums k)\n  (-> (listof exact-integer?) exact-integer? exact-integer?)\n  )",
    "erlang": "-spec maximum_beauty(Nums :: [integer()], K :: integer()) -> integer().\nmaximum_beauty(Nums, K) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec maximum_beauty(nums :: [integer], k :: integer) :: integer\n  def maximum_beauty(nums, k) do\n    \n  end\nend"
  },
  "solution": "[TOC]\n\n## Solution\n    \n---\n\n### Approach 1: Binary Search\n\n#### Intuition\n\nConsider an element $x$. Using the given operation, $x$ can be transformed into any integer within the range $[x - k, x + k]$. To find the longest subsequence where all elements are identical, our objective is to apply the operation to each element in a manner that maximizes the number of equal elements.\n\nLet's consider each number in the array as a range of possible values it can become. We'll illustrate this concept using Example 1 from the problem description.\n\n![](../Figures/2779/ranges.png)\n\nNotice that we can make two elements equal if their possible value ranges overlap. For instance, when `k = 2` and we have the numbers 1 and 4, we can change them both to 3. This is possible because 1 can become any number from -1 to 3, and 4 can become any number from 2 to 6. Since these ranges overlap, we can select a number from that overlapping section.\n\nThus, we can conclude that in our collection of ranges, all those that overlap can be changed to have equal values. Therefore, the highest number of equal values will be equal to the largest collection of overlapping ranges.\n\nTo efficiently count overlapping ranges, consider two numbers $x$ and $y$, where $x \\leq y$. Now, $x$ and $y$ can be converted to the same number as long as the maximum possible value of the changed $x$ is greater than or equal to the minimum possible value of the changed $y$, i.e.:\n\n$$\n\\begin{aligned}\n &x + k \\geq y - k  \\\\ \n\\implies& y - x \\leq 2 \\cdot k \\\\\n\\implies& y \\leq x + 2 \\cdot k \n\\end{aligned}\n$$\n\nIn simpler terms, for any number $x$, it can form a subsequence with all numbers that fall within the range from $x$ to $x + 2k$. To efficiently find these numbers, we can use [Binary Search ðŸ”—](https://leetcode.com/explore/learn/card/binary-search/), but first, we need to sort the array.\n\nAfter sorting, we use binary search for each number in the array to identify the largest value that does not exceed $x + 2k$. If we find such a value at index $j$, and our current number is at index $i$, then $j - i + 1$ represents the length of the possible subsequence. The maximum length found among all numbers in the array is our answer.\n\n#### Algorithm\n\n> Note: While most programming languages provide built-in methods for finding the upper bound in a sorted list, we have implemented our own method here for clarity and completeness.\n\n- Initialize a variable `maxBeauty` to `0` to track the maximum beauty possible.\n- Sort the input array `nums` in ascending order to enable efficient range-based searching.\n- For each index `i` from 0 to the length of `nums`:\n  - Calculate the target value as `nums[i] + 2*k`, which represents the maximum possible equal value achievable for any element in the range.\n  - Find the `upperBound` index where `nums[upperBound]` is the largest element less than or equal to the target value.\n  - Update `maxBeauty` to be the maximum of current `maxBeauty` and `(upperBound - i + 1)`.\n- Return `maxBeauty` as the final answer.\n\nIn the `findUpperBound(arr, val)` helper function:\n- Initialize variables `low` to 0 and `high` to the length of the array minus 1.\n- Initialize a `result` variable to 0 to store the latest valid index.\n- While `low` is less than or equal to `high`:\n  - Calculate `mid` as the average of `low` and `high`.\n  - If the element at the `mid` index is less than or equal to the target `val`:\n    - Update `result` to `mid`.\n    - Update `low` to `mid + 1` to search in the right half.\n  - Else:\n    - Update `high` to `mid - 1` to search in the left half.\n- Return the final `result` index.\n\n#### Implementation#### Complexity Analysis\n\nLet $n$ be the length of the input array `nums`.\n\n- Time complexity: $O(n \\cdot \\log n)$\n\n    The time complexity is dominated by two major operations. First, sorting the input array takes $O(n \\cdot \\log n)$ time. Second, for each element in the array, we perform a binary search, which takes $O(\\log n)$ time. Since this binary search is performed $n$ times, the total time complexity is $O(n \\cdot \\log n)$.\n\n    Therefore, the overall time complexity is $2 \\cdot O(n \\cdot \\log n) = O(n \\cdot \\log n)$.\n\n- Space complexity: $O(S)$\n\n    The space taken by the sorting algorithm ($S$) depends on the language of implementation:\n    - In Java, `Arrays.sort()` is implemented using a variant of the Quick Sort algorithm which has a space complexity of $O(\\log n)$.\n    - In C++, the `sort()` function is implemented as a hybrid of Quick Sort, Heap Sort, and Insertion Sort, with a worst-case space complexity of $O(\\log n)$.\n    - In Python, the `sort()` method sorts a list using the Timsort algorithm which is a combination of Merge Sort and Insertion Sort and has a space complexity of $O(n)$.\n\n    All other variables used by the algorithm take constant space. Thus, the space complexity is $O(S)$.\n\n---\n\n### Approach 2: Sliding Window\n\n#### Intuition\n\nWhen we look for the longest subsequence each number can form, we're essentially looking for a window of consecutive numbers. Instead of repeatedly searching for where each window ends, we can be more efficient by using a technique called the sliding window approach.\n\nThis involves maintaining a range with a left and a right boundary that dynamically adjusts as we move through the sorted array. Starting with both boundaries at the beginning of the array, we extend the right boundary to include as many numbers as possible while ensuring the condition holds â€” specifically, that the difference between the largest and smallest numbers in the range does not exceed $2 \\cdot k$. If the condition is violated, we adjust the left boundary to restore the range. The maximum length of this range across all positions gives us the desired result. \n\n> For a more comprehensive understanding of the sliding window technique, check out the [Sliding Window Explore Card ðŸ”—](https://leetcode.com/explore/learn/card/array-and-string/204/sliding-window/). This resource provides an in-depth look at the sliding window approach, explaining its key concepts and applications with a variety of problems to solidify understanding of the pattern.\n\n#### Algorithm\n\n- Initialize a variable `maxBeauty` to `0` to track the maximum beauty possible.\n- Sort the input array `nums` in ascending order.\n- Initialize a variable `right` to `0` to serve as the right pointer of our window.\n- For each index `left` from `0` to length of `nums`:\n  - While `right` is less than the length of `nums` and the difference between elements at `right` and `left` indices is $\\leq$ `2*k`:\n    - Increment `right` pointer by 1.\n  - Update `maxBeauty` to be the maximum of current `maxBeauty` and `(right - left)`.\n- Return `maxBeauty` as our answer.\n\n#### Implementation#### Complexity Analysis\n\nLet $n$ be the length of the input array `nums`.\n\n- Time complexity: $O(n \\cdot \\log n)$\n\n    The time complexity is dominated by the initial sorting operation which takes $O(n \\cdot \\log n)$ time. The subsequent two-pointer traversal, while appearing to be nested loops, actually has linear complexity because the right pointer never resets - it only moves forward. This means each element is visited at most twice (once by the `left` pointer and once by the `right` pointer), contributing $O(n)$ to the time complexity. \n    \n    Thus, the overall time complexity remains $O(n \\cdot \\log n)$.\n\n- Space complexity: $O(S)$\n\n    The space complexity of the sorting algorithm ($S$) depends on the language of implementation:\n    - In Java, `Arrays.sort()` is implemented using a variant of the Quick Sort algorithm which has a space complexity of $O(\\log n)$.\n    - In C++, the `sort()` function is implemented as a hybrid of Quick Sort, Heap Sort, and Insertion Sort, with a worst-case space complexity of $O(\\log n)$.\n    - In Python, the `sort()` method sorts a list using the Timsort algorithm which is a combination of Merge Sort and Insertion Sort and has a space complexity of $O(n)$.\n    \n    The algorithm does not use any additional space aside from that used by the sorting.\n\n    Thus, the overall space complexity is $O(S)$.\n\n---\n\n### Approach 3: Line Sweep\n\n#### Intuition\n\nWe need to find the maximum overlap across all ranges defined by the numbers. Visualize this as laying pieces of cloth on a number line to represent the range of values each number can span. When ranges overlap, the cloths stack on top of each other. Our objective is to identify the point with the most layers of cloth and count those layers.\n\nTo implement this concept, we'll create an array `count` to represent the entire possible range of values (our number line). This array will have a size of `maxValue + 1` to accommodate the maximum possible range. We'll then iterate over the `nums` array, marking the ranges in `count` by incrementing the indices within each range by 1. The highest value in `count` will indicate the point of maximum overlap, which is our answer.\n\n![](../Figures/2779/count.png)\n\nHowever, repeatedly looping over the ranges to populate `count` is inefficient. Instead, we'll mark the start and end positions of each range with `+1` and `-1`, respectively. This allows us to fill the ranges later by calculating the prefix sum of the array. When we encounter the start of a range, our running total increases by 1, and it remains elevated until we reach the end of that range, where it decreases by 1.\n\nWe'll maintain a variable `maxBeauty` to track the maximum value encountered while filling the `count` array. This value, stored in `maxBeauty`, will be returned as the maximum beauty of the array.\n\n#### Algorithm\n\n- Initialize a variable `maxBeauty` to `0` to track the maximum subsequence length.\n- If array length is 1, return `1` as the answer since a single element forms a subsequence of length 1.\n- Find the maximum element in the array and store it in a variable `maxValue`.\n- Create a `count` array of size `maxValue + 1` initialized with zeros to track range overlaps.\n- For each number `num` in the input array:\n  - At index `max(num - k, 0)`, increment count by 1 to mark the start of the range.\n  - At index `min(num + k + 1, maxValue)`, decrement count by 1 to mark the end of the range.\n- Initialize `currentSum` to `0` to track the running sum of overlapping ranges.\n- Iterate through the `count` array:\n  - Add current `count` value to `currentSum`.\n  - Update `maxBeauty` to the maximum of the current `maxBeauty` and `currentSum`.\n- Return `maxBeauty` as the final answer.\n\n#### Implementation#### Complexity Analysis\n\nLet $n$ be the length of the input array `nums` and $\\text{maxValue}$ be the maximum value in the array.\n\n- Time complexity: $O(n + \\text{maxValue})$\n\n    The time complexity has multiple components. First, finding the maximum value requires one pass through `nums` taking $O(n)$ time. Then, we make another pass through the array to update the `count` array, taking $O(n)$ time. Finally, we iterate through the `count` array of size $(\\text{maxValue}+1)$ taking $O(\\text{maxValue})$ time. \n    \n    Thus, the overall time complexity is $2 \\cdot O(n) + O(\\text{maxValue}) = O(n + \\text{maxValue})$.\n\n- Space complexity: $O(\\text{maxValue})$\n\n    The space complexity is dominated by the `count` array which has a size of $\\text{maxValue}+1$. We only use a constant number of additional variables, so they don't affect the asymptotic space complexity. So, the overall space complexity is $O(\\text{maxValue})$.\n\n---"
}