{
  "title": "Shortest Subarray to be Removed to Make Array Sorted",
  "problem_id": "1679",
  "frontend_id": "1574",
  "difficulty": "Medium",
  "problem_slug": "shortest-subarray-to-be-removed-to-make-array-sorted",
  "topics": [
    "Array",
    "Two Pointers",
    "Binary Search",
    "Stack",
    "Monotonic Stack"
  ],
  "description": "Given an integer array arr, remove a subarray (can be empty) from arr such that the remaining elements in arr are non-decreasing.\nReturn the length of the shortest subarray to remove.\nA subarray is a contiguous subsequence of the array.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: arr = [1,2,3,10,4,2,3,5]\nOutput: 3\nExplanation: The shortest subarray we can remove is [10,4,2] of length 3. The remaining elements after that will be [1,2,3,3,5] which are sorted.\nAnother correct solution is to remove the subarray [3,10,4].",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input: arr = [5,4,3,2,1]\nOutput: 4\nExplanation: Since the array is strictly decreasing, we can only keep a single element. Therefore we need to remove a subarray of length 4, either [5,4,3,2] or [4,3,2,1].",
      "images": []
    },
    {
      "example_num": 3,
      "example_text": "Input: arr = [1,2,3]\nOutput: 0\nExplanation: The array is already non-decreasing. We do not need to remove any elements.",
      "images": []
    }
  ],
  "constraints": [
    "1 <= arr.length <= 105",
    "0 <= arr[i] <= 109"
  ],
  "follow_ups": [],
  "hints": [
    "The key is to find the longest non-decreasing subarray starting with the first element or ending with the last element, respectively.",
    "After removing some subarray, the result is the concatenation of a sorted prefix and a sorted suffix, where the last element of the prefix is smaller than the first element of the suffix."
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    int findLengthOfShortestSubarray(vector<int>& arr) {\n        \n    }\n};",
    "java": "class Solution {\n    public int findLengthOfShortestSubarray(int[] arr) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def findLengthOfShortestSubarray(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: int\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def findLengthOfShortestSubarray(self, arr: List[int]) -> int:\n        ",
    "c": "int findLengthOfShortestSubarray(int* arr, int arrSize) {\n    \n}",
    "csharp": "public class Solution {\n    public int FindLengthOfShortestSubarray(int[] arr) {\n        \n    }\n}",
    "javascript": "/**\n * @param {number[]} arr\n * @return {number}\n */\nvar findLengthOfShortestSubarray = function(arr) {\n    \n};",
    "typescript": "function findLengthOfShortestSubarray(arr: number[]): number {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param Integer[] $arr\n     * @return Integer\n     */\n    function findLengthOfShortestSubarray($arr) {\n        \n    }\n}",
    "swift": "class Solution {\n    func findLengthOfShortestSubarray(_ arr: [Int]) -> Int {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun findLengthOfShortestSubarray(arr: IntArray): Int {\n        \n    }\n}",
    "dart": "class Solution {\n  int findLengthOfShortestSubarray(List<int> arr) {\n    \n  }\n}",
    "golang": "func findLengthOfShortestSubarray(arr []int) int {\n    \n}",
    "ruby": "# @param {Integer[]} arr\n# @return {Integer}\ndef find_length_of_shortest_subarray(arr)\n    \nend",
    "scala": "object Solution {\n    def findLengthOfShortestSubarray(arr: Array[Int]): Int = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn find_length_of_shortest_subarray(arr: Vec<i32>) -> i32 {\n        \n    }\n}",
    "racket": "(define/contract (find-length-of-shortest-subarray arr)\n  (-> (listof exact-integer?) exact-integer?)\n  )",
    "erlang": "-spec find_length_of_shortest_subarray(Arr :: [integer()]) -> integer().\nfind_length_of_shortest_subarray(Arr) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec find_length_of_shortest_subarray(arr :: [integer]) :: integer\n  def find_length_of_shortest_subarray(arr) do\n    \n  end\nend"
  },
  "solution": "[TOC]\n\n## Solution\n\n---\n\n### Overview\n\nGiven an array `arr`, we want to return the size of the smallest possible subarray we can remove to make the remaining elements sorted in non-decreasing order. It's acceptable to return an empty subarray if the elements are already sorted correctly.  \n\n![Test cases split into 3 parts](../Figures/1574/shortest_subarray_to_be_removed.png)\n\nWe can think of `arr` as being composed of 3 parts. The first part is a block of numbers in sorted order (blue region in the image above), followed by a block of numbers that breaks the sorted order (yellow region), and then finally another block of numbers in sorted order (green region).\n\nFor the nontrivial cases depicted above, we know that the subarray to remove resides somewhere in the middle of the array. Here, there can be multiple possibilities for what the middle elements can be. For the first example in the image, one option is to remove the block `[2, 3, 10, 4]`, leaving the remaining sorted sequence `[1, 2, 3, 5]`. Another option is to remove the block `[10, 4, 2]`, leaving another valid sequence `[1, 2, 3, 3, 5]`. The question then boils down to how we can find the smallest middle block of numbers to remove.\n\n---\n\n### Approach 1: Binary Search\n\n#### Intuition\n\nWe need to find the shortest subarray that, if removed, would make the array sorted. To do this, we must understand the problem from a few perspectives and break it down logically.\n\n##### 1. Identifying the Longest Non-Decreasing Subarrays\n\nThe first thing to consider is that the array might already be mostly sorted, but just have a small portion that disrupts the order. This means that if we could find the longest part of the array that is already non-decreasing from the left and from the right, we would be left with just a small part in the middle that needs to be removed to make the entire array sorted.\n\nThe concept is to iterate through the array, looking for the longest continuous subarray that follows the non-decreasing order. We start from the left and move right, stopping when we hit a decrease. This is the first natural choice because if we can identify the longest subarray from the left, we know the part from the right must complement it or be the part we need to focus on.\n\nSimilarly, we do the same thing from the right side. This parallelism helps us understand both ends of the array and figure out where the sorting breaks down. These steps build on each other, showing us the boundaries within which we need to find the subarray to remove.\n\n##### 2. The Case Where the Array is Already Sorted\n\nNow that we know how to find the longest non-decreasing subarrays from both ends, we need to think about the case where the array is already sorted. In this case, there’s no need to remove anything. So, we check if the left and right pointers (or indices) overlap or meet. If they do, the entire array is already sorted, and our work is done. This is an important insight because it helps us immediately return 0 when there’s no need to remove any subarray, avoiding unnecessary work.\n\n##### 3. The Core Problem: What to Remove?\n\nIf the array is not sorted, we are left with the task of determining the shortest subarray that can be removed to make the array sorted. We could remove just the left part, just the right part, or try merging the two non-decreasing sections.\n\nNow, this might seem a bit tricky at first, but if we look closely, we can use the fact that if a section on the left is non-decreasing and a section on the right is also non-decreasing, there may still be a possibility of merging these sections by removing the middle. The relationship between the two sections plays a critical role. Specifically, we want to find a point where elements in the right section are greater than or equal to elements in the left section after considering the removal of the middle portion.\n\n##### 4. The Final Search\n\nThis leads us to the next part on how do we efficiently find where the two sections can merge? A naive approach might involve checking all pairs of elements, but that could be inefficient. Instead, we use binary search to find the smallest index in the right part of the array where the element is greater than or equal to the last element of the left part. By doing this, we can quickly pinpoint where the array can be \"joined\" back together, minimizing the subarray to remove.\n\nThis binary search approach leverages the sorted nature of the two subarrays. Since we know both the left and right subarrays are sorted, binary search allows us to find this boundary in logarithmic time, which is much more efficient than checking each element.\n\nFinally, the solution is to take the minimum length of the subarrays that can be removed, whether that’s the left part, the right part, or the middle part (which we find through binary search).\n\n#### Algorithm\n\n- Initialize `n` as the size of `arr`, `left` as 0, and `right` as `n - 1`.\n\n- Find the longest non-decreasing subarray starting from the left:\n  - While `left + 1 < n` and `arr[left] <= arr[left + 1]`, increment `left` to expand the left subarray.\n\n- Find the longest non-decreasing subarray starting from the right:\n  - While `right - 1 >= 0` and `arr[right] >= arr[right - 1]`, decrement `right` to expand the right subarray.\n\n- If the entire array is already sorted (i.e., `left >= right`), return `0` as no subarray removal is needed.\n\n- Initialize `ans` to the smaller of removing the left or right part completely:\n  - `ans = min(n - (left + 1), right)`\n\n- Try to merge the left and right parts:\n  - For each index `i` from 0 to `left`, use binary search (`helperBinarySearch`) to find the smallest index `j` where `arr[j] >= arr[i]`.\n  - Update `ans` as the minimum of `ans` and the difference `j - (i + 1)`.\n\n- Return `ans`, the length of the shortest subarray that can be removed to make the array sorted.\n\n#### Implementation#### Complexity Analysis\n\nLet `N` be the size of `arr`.\n\n* Time Complexity: $O(N \\log N)$\n\n  The first two `while` loops each run in $O(N)$ time to find the longest non-decreasing subarrays from the left and right. \n  \n  After that, the `for` loop iterates up to `N` times, where for each iteration, a binary search is performed. Since binary search runs in $O(\\log N)$ time, the total time complexity for the loop is $O(N \\log N)$. \n  \n  Therefore, the overall time complexity is dominated by the $O(N \\log N)$ component.\n\n* Space Complexity: $O(N)$\n\n  The space complexity is mainly determined by the space required to store the input array `arr`, which takes $O(N)$ space.\n\n---\n\n### Approach 2: Two Pointers\n\n#### Intuition\n\nWe can optimize the solution further by replacing binary search ($O(N \\log N)$) with a more efficient two-pointer approach, reducing the complexity to $O(N)$.\n\nA key insight in the diagram below is that the unsorted yellow region must always be part of the removed subarray, as it breaks the sorted order. In other words, the remaining sorted array will always consist of a prefix of the blue subarray (from the first element up to some index), followed by a suffix of the green subarray (from the last element down to some index).\n\n![2 pointers](../Figures/1574/two_pointers.png)\n\nTo consider all possibilities, use two pointers, `left` and `right`. The pointers represent the prefix blue array `arr[0:left]` and suffix green array `arr[right:]` consisting of the remaining sorted array we are considering. Initially, `left` is set to 0, meaning we’re considering keeping the first element of the blue array. `Right` is set to the index of the start of the green subarray, meaning we consider keeping the entirety of the green subarray.\n\nUsing this two-pointer method, for each position of `left`, we search for the smallest `right` where `arr[left] <= arr[right]`. If this condition holds, then we have found a valid subarray candidate to remove—the subarray between `arr[left]` and `arr[right]`, which has a length of `right - left - 1`. If `arr[left] > arr[right]`, we increment `right` to find the next possible match. Once a valid `right` is found, we advance `left` to the next element, repeating the process.Whyarr[left] <= arr[right]is Important (Click Here!)Sorted Left Portion:The elements before left (i.e.,arr[0:left]) are already sorted. Therefore,arr[left-1]is the largest element in this prefix.Sorted Right Portion:The elements from right onwards (i.e.,arr[right:]) are sorted as well. Thus,arr[right]is the smallest element in the suffix.For the two sorted sections to form one valid sorted sequence when combined, we need the largest element in the left portion (arr[left-1]) to be less than or equal to the smallest element in the right portion (arr[right]), because:Ifarr[left-1]is greater thanarr[right], it means that after removing the unsorted middle section, the combined array would not be sorted.Ifarr[left-1] <= arr[right], it guarantees that the largest element from the left side is smaller than or equal to the smallest element from the right side, ensuring the merged sequence is still sorted.#### Algorithm\n\n1. Initialize our `right` pointer to the last index of `arr`.\n2. We want to start our two-pointer process with `right` pointing to the start of the green sorted subarray. So we want to update `right` to the right index:\n    * While `right > 0` and `arr[right] >= arr[right - 1]`, decrement `right`\n3. We initialize our `ans = right`. We note that the biggest subarray that can be removed is the entire subarray preceding `right`. Thus, the maximum size subarray to be removed is `right`. \n4. We initialize our `left` pointer to `0`, the start of the blue sorted subarray.\n5. While `left < right` and `left` is still in the blue region: `left == 0 || arr[left - 1] <= arr[left]`:\n    * Find the right number after arr[left]:\n        * While `right < arr.length` and `arr[left] > arr[right]`, increment `right`\n    * Save length of the removed subarray: `ans = min(ans, right - left - 1)`\n    * Increment `left`\n6. Return `ans` \n\n#### Implementation#### Complexity Analysis\n\nLet `N` be the size of `arr`.\n\n* Time Complexity: $O(N)$\n\n    In the worst case for our two pointer algorithm, `left` will traverse through the entire blue sorted region once, and `right` will traverse through the entire `green` sorted region once. Thus, the time complexity grows linearly with the size of `arr`: $O(N)$\n\n* Space Complexity: $O(1)$\n\n    We only use two pointers to store indices and do not have any auxiliary data structures, so the space complexity is $O(1)$.\n    \n---"
}