{
  "title": "Coloring A Border",
  "problem_id": "1104",
  "frontend_id": "1034",
  "difficulty": "Medium",
  "problem_slug": "coloring-a-border",
  "topics": [
    "Array",
    "Depth-First Search",
    "Breadth-First Search",
    "Matrix"
  ],
  "description": "You are given an m x n integer matrix grid, and three integers row, col, and color. Each value in the grid represents the color of the grid square at that location.\nTwo squares are called adjacent if they are next to each other in any of the 4 directions.\nTwo squares belong to the same connected component if they have the same color and they are adjacent.\nThe border of a connected component is all the squares in the connected component that are either adjacent to (at least) a square not in the component, or on the boundary of the grid (the first or last row or column).\nYou should color the border of the connected component that contains the square grid[row][col] with color.\nReturn the final grid.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: grid = [[1,1],[1,2]], row = 0, col = 0, color = 3\nOutput: [[3,3],[3,2]]",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input: grid = [[1,2,2],[2,3,2]], row = 0, col = 1, color = 3\nOutput: [[1,3,3],[2,3,3]]",
      "images": []
    },
    {
      "example_num": 3,
      "example_text": "Input: grid = [[1,1,1],[1,1,1],[1,1,1]], row = 1, col = 1, color = 2\nOutput: [[2,2,2],[2,1,2],[2,2,2]]",
      "images": []
    }
  ],
  "constraints": [
    "m == grid.length",
    "n == grid[i].length",
    "1 <= m, n <= 50",
    "1 <= grid[i][j], color <= 1000",
    "0 <= row < m",
    "0 <= col < n"
  ],
  "follow_ups": [],
  "hints": [
    "Use a DFS to find every square in the component.  Then for each square, color it if it has a neighbor that is outside the grid or a different color."
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\n        \n    }\n};",
    "java": "class Solution {\n    public int[][] colorBorder(int[][] grid, int row, int col, int color) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def colorBorder(self, grid, row, col, color):\n        \"\"\"\n        :type grid: List[List[int]]\n        :type row: int\n        :type col: int\n        :type color: int\n        :rtype: List[List[int]]\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def colorBorder(self, grid: List[List[int]], row: int, col: int, color: int) -> List[List[int]]:\n        ",
    "c": "/**\n * Return an array of arrays of size *returnSize.\n * The sizes of the arrays are returned as *returnColumnSizes array.\n * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().\n */\nint** colorBorder(int** grid, int gridSize, int* gridColSize, int row, int col, int color, int* returnSize, int** returnColumnSizes) {\n    \n}",
    "csharp": "public class Solution {\n    public int[][] ColorBorder(int[][] grid, int row, int col, int color) {\n        \n    }\n}",
    "javascript": "/**\n * @param {number[][]} grid\n * @param {number} row\n * @param {number} col\n * @param {number} color\n * @return {number[][]}\n */\nvar colorBorder = function(grid, row, col, color) {\n    \n};",
    "typescript": "function colorBorder(grid: number[][], row: number, col: number, color: number): number[][] {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param Integer[][] $grid\n     * @param Integer $row\n     * @param Integer $col\n     * @param Integer $color\n     * @return Integer[][]\n     */\n    function colorBorder($grid, $row, $col, $color) {\n        \n    }\n}",
    "swift": "class Solution {\n    func colorBorder(_ grid: [[Int]], _ row: Int, _ col: Int, _ color: Int) -> [[Int]] {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun colorBorder(grid: Array<IntArray>, row: Int, col: Int, color: Int): Array<IntArray> {\n        \n    }\n}",
    "dart": "class Solution {\n  List<List<int>> colorBorder(List<List<int>> grid, int row, int col, int color) {\n    \n  }\n}",
    "golang": "func colorBorder(grid [][]int, row int, col int, color int) [][]int {\n    \n}",
    "ruby": "# @param {Integer[][]} grid\n# @param {Integer} row\n# @param {Integer} col\n# @param {Integer} color\n# @return {Integer[][]}\ndef color_border(grid, row, col, color)\n    \nend",
    "scala": "object Solution {\n    def colorBorder(grid: Array[Array[Int]], row: Int, col: Int, color: Int): Array[Array[Int]] = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn color_border(grid: Vec<Vec<i32>>, row: i32, col: i32, color: i32) -> Vec<Vec<i32>> {\n        \n    }\n}",
    "racket": "(define/contract (color-border grid row col color)\n  (-> (listof (listof exact-integer?)) exact-integer? exact-integer? exact-integer? (listof (listof exact-integer?)))\n  )",
    "erlang": "-spec color_border(Grid :: [[integer()]], Row :: integer(), Col :: integer(), Color :: integer()) -> [[integer()]].\ncolor_border(Grid, Row, Col, Color) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec color_border(grid :: [[integer]], row :: integer, col :: integer, color :: integer) :: [[integer]]\n  def color_border(grid, row, col, color) do\n    \n  end\nend"
  }
}