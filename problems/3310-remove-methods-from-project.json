{
  "title": "Remove Methods From Project",
  "problem_id": "3561",
  "frontend_id": "3310",
  "difficulty": "Medium",
  "problem_slug": "remove-methods-from-project",
  "topics": [
    "Depth-First Search",
    "Breadth-First Search",
    "Graph"
  ],
  "description": "You are maintaining a project that has n methods numbered from 0 to n - 1.\nYou are given two integers n and k, and a 2D integer array invocations, where invocations[i] = [ai, bi] indicates that method ai invokes method bi.\nThere is a known bug in method k. Method k, along with any method invoked by it, either directly or indirectly, are considered suspicious and we aim to remove them.\nA group of methods can only be removed if no method outside the group invokes any methods within it.\nReturn an array containing all the remaining methods after removing all the suspicious methods. You may return the answer in any order. If it is not possible to remove all the suspicious methods, none should be removed.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: n = 4, k = 1, invocations = [[1,2],[0,1],[3,2]]\nOutput: [0,1,2,3]\nExplanation:\n\nMethod 2 and method 1 are suspicious, but they are directly invoked by methods 3 and 0, which are not suspicious. We return all elements without removing anything.",
      "images": [
        "https://assets.leetcode.com/uploads/2024/07/18/graph-2.png"
      ]
    },
    {
      "example_num": 2,
      "example_text": "Input: n = 5, k = 0, invocations = [[1,2],[0,2],[0,1],[3,4]]\nOutput: [3,4]\nExplanation:\n\nMethods 0, 1, and 2 are suspicious and they are not directly invoked by any other method. We can remove them.",
      "images": [
        "https://assets.leetcode.com/uploads/2024/07/18/graph-3.png"
      ]
    },
    {
      "example_num": 3,
      "example_text": "Input: n = 3, k = 2, invocations = [[1,2],[0,1],[2,0]]\nOutput: []\nExplanation:\n\nAll methods are suspicious. We can remove them.",
      "images": [
        "https://assets.leetcode.com/uploads/2024/07/20/graph.png"
      ]
    }
  ],
  "constraints": [
    "1 <= n <= 105",
    "0 <= k <= n - 1",
    "0 <= invocations.length <= 2 * 105",
    "invocations[i] == [ai, bi]",
    "0 <= ai, bi <= n - 1",
    "ai != bi",
    "invocations[i] != invocations[j]"
  ],
  "follow_ups": [],
  "hints": [
    "Use DFS from node <code>k</code>.",
    "Mark all the nodes visited from node <code>k</code>, and then check if they can be visited from the other nodes."
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    vector<int> remainingMethods(int n, int k, vector<vector<int>>& invocations) {\n        \n    }\n};",
    "java": "class Solution {\n    public List<Integer> remainingMethods(int n, int k, int[][] invocations) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def remainingMethods(self, n, k, invocations):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :type invocations: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def remainingMethods(self, n: int, k: int, invocations: List[List[int]]) -> List[int]:\n        ",
    "c": "/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nint* remainingMethods(int n, int k, int** invocations, int invocationsSize, int* invocationsColSize, int* returnSize) {\n    \n}",
    "csharp": "public class Solution {\n    public IList<int> RemainingMethods(int n, int k, int[][] invocations) {\n        \n    }\n}",
    "javascript": "/**\n * @param {number} n\n * @param {number} k\n * @param {number[][]} invocations\n * @return {number[]}\n */\nvar remainingMethods = function(n, k, invocations) {\n    \n};",
    "typescript": "function remainingMethods(n: number, k: number, invocations: number[][]): number[] {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param Integer $n\n     * @param Integer $k\n     * @param Integer[][] $invocations\n     * @return Integer[]\n     */\n    function remainingMethods($n, $k, $invocations) {\n        \n    }\n}",
    "swift": "class Solution {\n    func remainingMethods(_ n: Int, _ k: Int, _ invocations: [[Int]]) -> [Int] {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun remainingMethods(n: Int, k: Int, invocations: Array<IntArray>): List<Int> {\n        \n    }\n}",
    "dart": "class Solution {\n  List<int> remainingMethods(int n, int k, List<List<int>> invocations) {\n    \n  }\n}",
    "golang": "func remainingMethods(n int, k int, invocations [][]int) []int {\n    \n}",
    "ruby": "# @param {Integer} n\n# @param {Integer} k\n# @param {Integer[][]} invocations\n# @return {Integer[]}\ndef remaining_methods(n, k, invocations)\n    \nend",
    "scala": "object Solution {\n    def remainingMethods(n: Int, k: Int, invocations: Array[Array[Int]]): List[Int] = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn remaining_methods(n: i32, k: i32, invocations: Vec<Vec<i32>>) -> Vec<i32> {\n        \n    }\n}",
    "racket": "(define/contract (remaining-methods n k invocations)\n  (-> exact-integer? exact-integer? (listof (listof exact-integer?)) (listof exact-integer?))\n  )",
    "erlang": "-spec remaining_methods(N :: integer(), K :: integer(), Invocations :: [[integer()]]) -> [integer()].\nremaining_methods(N, K, Invocations) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec remaining_methods(n :: integer, k :: integer, invocations :: [[integer]]) :: [integer]\n  def remaining_methods(n, k, invocations) do\n    \n  end\nend"
  }
}