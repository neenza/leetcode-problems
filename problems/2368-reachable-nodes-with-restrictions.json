{
  "title": "Reachable Nodes With Restrictions",
  "problem_id": "2445",
  "frontend_id": "2368",
  "difficulty": "Medium",
  "problem_slug": "reachable-nodes-with-restrictions",
  "topics": [
    "Array",
    "Hash Table",
    "Tree",
    "Depth-First Search",
    "Breadth-First Search",
    "Union Find",
    "Graph"
  ],
  "description": "There is an undirected tree with n nodes labeled from 0 to n - 1 and n - 1 edges.\nYou are given a 2D integer array edges of length n - 1 where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the tree. You are also given an integer array restricted which represents restricted nodes.\nReturn the maximum number of nodes you can reach from node 0 without visiting a restricted node.\nNote that node 0 will not be a restricted node.\nExample 1:\nExample 2:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: n = 7, edges = [[0,1],[1,2],[3,1],[4,0],[0,5],[5,6]], restricted = [4,5]\nOutput: 4\nExplanation: The diagram above shows the tree.\nWe have that [0,1,2,3] are the only nodes that can be reached from node 0 without visiting a restricted node.",
      "images": [
        "https://assets.leetcode.com/uploads/2022/06/15/ex1drawio.png"
      ]
    },
    {
      "example_num": 2,
      "example_text": "Input: n = 7, edges = [[0,1],[0,2],[0,5],[0,4],[3,2],[6,5]], restricted = [4,2,1]\nOutput: 3\nExplanation: The diagram above shows the tree.\nWe have that [0,5,6] are the only nodes that can be reached from node 0 without visiting a restricted node.",
      "images": [
        "https://assets.leetcode.com/uploads/2022/06/15/ex2drawio.png"
      ]
    }
  ],
  "constraints": [
    "2 <= n <= 105",
    "edges.length == n - 1",
    "edges[i].length == 2",
    "0 <= ai, bi < n",
    "ai != bi",
    "edges represents a valid tree.",
    "1 <= restricted.length < n",
    "1 <= restricted[i] < n",
    "All the values of restricted are unique."
  ],
  "follow_ups": [],
  "hints": [
    "Can we find all the reachable nodes in a single traversal?",
    "Traverse the graph from node 0 while avoiding the nodes in restricted and do not revisit nodes that have been visited.",
    "Keep count of how many nodes are visited in total."
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    int reachableNodes(int n, vector<vector<int>>& edges, vector<int>& restricted) {\n        \n    }\n};",
    "java": "class Solution {\n    public int reachableNodes(int n, int[][] edges, int[] restricted) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def reachableNodes(self, n, edges, restricted):\n        \"\"\"\n        :type n: int\n        :type edges: List[List[int]]\n        :type restricted: List[int]\n        :rtype: int\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def reachableNodes(self, n: int, edges: List[List[int]], restricted: List[int]) -> int:\n        ",
    "c": "int reachableNodes(int n, int** edges, int edgesSize, int* edgesColSize, int* restricted, int restrictedSize) {\n    \n}",
    "csharp": "public class Solution {\n    public int ReachableNodes(int n, int[][] edges, int[] restricted) {\n        \n    }\n}",
    "javascript": "/**\n * @param {number} n\n * @param {number[][]} edges\n * @param {number[]} restricted\n * @return {number}\n */\nvar reachableNodes = function(n, edges, restricted) {\n    \n};",
    "typescript": "function reachableNodes(n: number, edges: number[][], restricted: number[]): number {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param Integer $n\n     * @param Integer[][] $edges\n     * @param Integer[] $restricted\n     * @return Integer\n     */\n    function reachableNodes($n, $edges, $restricted) {\n        \n    }\n}",
    "swift": "class Solution {\n    func reachableNodes(_ n: Int, _ edges: [[Int]], _ restricted: [Int]) -> Int {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun reachableNodes(n: Int, edges: Array<IntArray>, restricted: IntArray): Int {\n        \n    }\n}",
    "dart": "class Solution {\n  int reachableNodes(int n, List<List<int>> edges, List<int> restricted) {\n    \n  }\n}",
    "golang": "func reachableNodes(n int, edges [][]int, restricted []int) int {\n    \n}",
    "ruby": "# @param {Integer} n\n# @param {Integer[][]} edges\n# @param {Integer[]} restricted\n# @return {Integer}\ndef reachable_nodes(n, edges, restricted)\n    \nend",
    "scala": "object Solution {\n    def reachableNodes(n: Int, edges: Array[Array[Int]], restricted: Array[Int]): Int = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn reachable_nodes(n: i32, edges: Vec<Vec<i32>>, restricted: Vec<i32>) -> i32 {\n        \n    }\n}",
    "racket": "(define/contract (reachable-nodes n edges restricted)\n  (-> exact-integer? (listof (listof exact-integer?)) (listof exact-integer?) exact-integer?)\n  )",
    "erlang": "-spec reachable_nodes(N :: integer(), Edges :: [[integer()]], Restricted :: [integer()]) -> integer().\nreachable_nodes(N, Edges, Restricted) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec reachable_nodes(n :: integer, edges :: [[integer]], restricted :: [integer]) :: integer\n  def reachable_nodes(n, edges, restricted) do\n    \n  end\nend"
  }
}