{
  "title": "Find Minimum Diameter After Merging Two Trees",
  "problem_id": "3439",
  "frontend_id": "3203",
  "difficulty": "Hard",
  "problem_slug": "find-minimum-diameter-after-merging-two-trees",
  "topics": [
    "Tree",
    "Depth-First Search",
    "Breadth-First Search",
    "Graph"
  ],
  "description": "There exist two undirected trees with n and m nodes, numbered from 0 to n - 1 and from 0 to m - 1, respectively. You are given two 2D integer arrays edges1 and edges2 of lengths n - 1 and m - 1, respectively, where edges1[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the first tree and edges2[i] = [ui, vi] indicates that there is an edge between nodes ui and vi in the second tree.\nYou must connect one node from the first tree with another node from the second tree with an edge.\nReturn the minimum possible diameter of the resulting tree.\nThe diameter of a tree is the length of the longest path between any two nodes in the tree.\nExample 1:\nExample 2:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: edges1 = [[0,1],[0,2],[0,3]], edges2 = [[0,1]]\nOutput: 3\nExplanation:\nWe can obtain a tree of diameter 3 by connecting node 0 from the first tree with any node from the second tree.",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input: edges1 = [[0,1],[0,2],[0,3],[2,4],[2,5],[3,6],[2,7]], edges2 = [[0,1],[0,2],[0,3],[2,4],[2,5],[3,6],[2,7]]\nOutput: 5\nExplanation:\nWe can obtain a tree of diameter 5 by connecting node 0 from the first tree with node 0 from the second tree.",
      "images": []
    }
  ],
  "constraints": [
    "1 <= n, m <= 105",
    "edges1.length == n - 1",
    "edges2.length == m - 1",
    "edges1[i].length == edges2[i].length == 2",
    "edges1[i] = [ai, bi]",
    "0 <= ai, bi < n",
    "edges2[i] = [ui, vi]",
    "0 <= ui, vi < m",
    "The input is generated such that edges1 and edges2 represent valid trees."
  ],
  "follow_ups": [],
  "hints": [
    "Suppose that we connected node <code>a</code> in tree1 with node <code>b</code> in tree2. The diameter length of the resulting tree will be the largest of the following 3 values: \r\n<ol>\r\n<li>The diameter of tree 1.</li>\r\n<li>The diameter of tree 2.</li>\r\n<li>The length of the longest path that starts at node <code>a</code> and that is completely within Tree 1 + The length of the longest path that starts at node <code>b</code> and that is completely within Tree 2 + 1.</li>\r\n</ol> \r\nThe added one in the third value is due to the additional edge that we have added between trees 1 and 2.",
    "Values 1 and 2 are constant regardless of our choice of <code>a</code> and <code>b</code>. Therefore, we need to pick <code>a</code> and <code>b</code> in such a way that minimizes value 3.",
    "If we pick <code>a</code> and <code>b</code> optimally, they will be in the diameters of Tree 1 and Tree 2, respectively. Exactly which nodes of the diameter should we pick?",
    "<code>a</code> is the center of the diameter of tree 1, and <code>b</code> is the center of the diameter of tree 2."
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        \n    }\n};",
    "java": "class Solution {\n    public int minimumDiameterAfterMerge(int[][] edges1, int[][] edges2) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def minimumDiameterAfterMerge(self, edges1, edges2):\n        \"\"\"\n        :type edges1: List[List[int]]\n        :type edges2: List[List[int]]\n        :rtype: int\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def minimumDiameterAfterMerge(self, edges1: List[List[int]], edges2: List[List[int]]) -> int:\n        ",
    "c": "int minimumDiameterAfterMerge(int** edges1, int edges1Size, int* edges1ColSize, int** edges2, int edges2Size, int* edges2ColSize) {\n    \n}",
    "csharp": "public class Solution {\n    public int MinimumDiameterAfterMerge(int[][] edges1, int[][] edges2) {\n        \n    }\n}",
    "javascript": "/**\n * @param {number[][]} edges1\n * @param {number[][]} edges2\n * @return {number}\n */\nvar minimumDiameterAfterMerge = function(edges1, edges2) {\n    \n};",
    "typescript": "function minimumDiameterAfterMerge(edges1: number[][], edges2: number[][]): number {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param Integer[][] $edges1\n     * @param Integer[][] $edges2\n     * @return Integer\n     */\n    function minimumDiameterAfterMerge($edges1, $edges2) {\n        \n    }\n}",
    "swift": "class Solution {\n    func minimumDiameterAfterMerge(_ edges1: [[Int]], _ edges2: [[Int]]) -> Int {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun minimumDiameterAfterMerge(edges1: Array<IntArray>, edges2: Array<IntArray>): Int {\n        \n    }\n}",
    "dart": "class Solution {\n  int minimumDiameterAfterMerge(List<List<int>> edges1, List<List<int>> edges2) {\n    \n  }\n}",
    "golang": "func minimumDiameterAfterMerge(edges1 [][]int, edges2 [][]int) int {\n    \n}",
    "ruby": "# @param {Integer[][]} edges1\n# @param {Integer[][]} edges2\n# @return {Integer}\ndef minimum_diameter_after_merge(edges1, edges2)\n    \nend",
    "scala": "object Solution {\n    def minimumDiameterAfterMerge(edges1: Array[Array[Int]], edges2: Array[Array[Int]]): Int = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn minimum_diameter_after_merge(edges1: Vec<Vec<i32>>, edges2: Vec<Vec<i32>>) -> i32 {\n        \n    }\n}",
    "racket": "(define/contract (minimum-diameter-after-merge edges1 edges2)\n  (-> (listof (listof exact-integer?)) (listof (listof exact-integer?)) exact-integer?)\n  )",
    "erlang": "-spec minimum_diameter_after_merge(Edges1 :: [[integer()]], Edges2 :: [[integer()]]) -> integer().\nminimum_diameter_after_merge(Edges1, Edges2) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec minimum_diameter_after_merge(edges1 :: [[integer]], edges2 :: [[integer]]) :: integer\n  def minimum_diameter_after_merge(edges1, edges2) do\n    \n  end\nend"
  },
  "solution": "[TOC]\n\n## Solution\n\n---\n\n### Overview\n\nWe are given two trees: one with `n` nodes and the other with `m` nodes. Our goal is to add an edge between a node from the first tree and a node from the second tree, in such a way that the *diameter* of the resulting tree is minimized. \n\n> The *diameter* of a tree is the longest path between any two nodes in the tree.\n\nLet us consider the two ways that the longest path can be formed:\n\n1. The path starts and ends at nodes within the same tree.In this case, the problem reduces to finding the maximum diameter of the two original trees.\n\n2. The path starts at a node in the first tree and ends at a node in the second.In this case, the selection of the nodes to connect is crucial for minimizing the overall diameter. Intuitively, we aim to select these nodes so that, if chosen as roots, the heights of their respective trees are minimized. In practice, this often involves selecting nodes near the \"center\" of each tree, ensuring their subtrees are as balanced as possible.Click here for a formal proofSpecifically, for the node that is in the middle of the diameter, the following holds:\n\n    1. Its maximum distance to any node of the tree is equal to $\\lceil \\frac{\\text{diameter}}{2} \\rceil$. \n    This is because its maximum distance is determined by the farthest endpoint of the diameter. We can prove this by contradiction. Suppose the maximum distance were to some other node outside the diameter path. This would require the existence of a longer path than the diameter, contradicting the definition of the diameter as the longest path in the tree. Therefore:\n        -   If the $\\text{diameter}$ is even, the middle node is equidistant from both endpoints of the diameter, with a distance of $\\frac{\\text{diameter}}{2}$ to each.\n        -   If the $\\text{diameter}$ is odd, each of the two middle nodes has distances $\\frac{\\text{diameter} - 1}{2}$ to one endpoint and $\\frac{\\text{diameter} + 1}{2}$ to the other. In this case, the maximum distance is $\\frac{\\text{diameter} + 1}{2}$ = $\\lceil \\frac{\\text{diameter}}{2} \\rceil$.\n    2. For any other node in the tree, its maximum distance to another node is greater than or equal to $\\lceil \\frac{\\text{diameter}}{2} \\rceil$.\n    Again, the maximum distance for any node is towards one of the endpoints of the diameter, denoted as $a$ and $b$. Consider a node $u$, and assume $u$ is closer to $a$ than $b$. The distance of $u$ to $b$ can be lower-bounded as follows:\n    -   Let $m$ be the midpoint of the diameter, located at a distance of at least $\\lfloor \\frac{\\text{diameter}}{2} \\rfloor$ to $b$.\n    -   Since $u$ is closer to $a$, it lies either on the path between $a$ and $m$, or off the diameter in a subtree connected to this path.\n    -   In either case, the shortest path from $u$ to $b$ must pass through $m$ or a point even farther from $b$. Thus, the distance from $u$ to $b$ is at least the distance from $m$ to $b$ plus 1, or $\\lceil \\frac{\\text{diameter}}{2} \\rceil$.By adding an edge between the two centers of the trees, the maximum distance between each of them and a node within the same tree is at most $\\lceil \\frac{\\text{diameter}}{2} \\rceil$. Thus, the combined diameter of the tree is the sum of the halves of the original diameters plus one for the extra edge:\n\n    $$\n    \\begin{aligned}\n        \\lceil \\frac{\\text{diameter}_1}{2} \\rceil + \\lceil \\frac{\\text{diameter}_2}{2} \\rceil + 1.\n    \\end{aligned}\n    $$\n\n    Therefore, the problem simplifies to returning the maximum among the diameter of each tree and the above value.\n\nFeel free to try solving these problems first as great prerequisites to this one: \n    1. [Minimum Height Trees](https://leetcode.com/problems/minimum-height-trees/description/).\n    2. [Tree Diameter](https://leetcode.com/problems/tree-diameter/description/)\n\n---\n\n### Approach 1: Farthest of Farthest (BFS)\n\n#### Intuition\n\nLet's break down the problem of calculating the diameter of a tree. First of all, we observe that any tree can be seen as:\n\n-   The sequence of nodes on the diameter itself, plus\n-   Additional subtrees branching out from nodes along the diameter.For any node in the tree, its minimum distance to one of the diameter's endpoints (say $a$ and $b$) is always less than or equal to the diameter. This can be proven via contradiction. If one endpoint of the diameter ($a$) is known, the other endpoint ($b$) is simply the farthest node from $a$.\n\nBased on that, one naive way to find the diameter is:\n1. Assume each node is one endpoint of the diameter.\n2. Calculate the farthest node from it.\n3. Record the longest path found.\n\nHowever, this approach involves computing the farthest node for all nodes, leading to a time complexity of $O(n^2)$, which will result in a TLE (Time Limit Exceeded) for the given constraints.\n\nFor the optimized approach, we observe that we only need to find the farthest node of a single arbitrary node $u$ and that node would be one of the endpoints of the diameter. Why does this work? Let's consider the following cases:\n\n- Case 1: $u$ lies on the diameter\nRunning a BFS for the longest path from $u$ will find an endpoint of the diameter.Click here for a formal proofWe will prove this statement by contradiction. Let $v$ ($v \\neq a, b$) be the farthest node from $u$, implying $\\text{dist}(u, b) < \\text{dist}(u, v)$. Assume $u$ is closer to $a$ than $b$, so $\\text{dist}(u, a) \\leq \\text{dist}(u, b)$. Combining these inequalities gives us:\n\n    $$\n    \\begin{aligned}\n    \\text{dist}(u, b) + \\text{dist}(u, a) &< \\text{dist}(u, v) + \\text{dist}(u, b)  \\\\\n    \\text{dist}(a, b) &< \\text{dist}(v, b),\n    \\end{aligned}\n    $$ \n\n    which is a contradiction, since the diameter ($a \\rightarrow b$) is the longest path in the tree.- Case 2: $u$ does not lie on the diameter\nThe path from $u$ to the farthest node passes through the diameter so the problem reduces to Case 1.Click here for a formal proofLet $v$ ($v \\neq a, b$) be the farthest node from $u$, and $u^*$ the root of $u$'s subtree. The path $u \\to v$ avoids the diameter only if $u$ and $v$ are within the same subtree. In this case:  \n\n    $$\n    \\begin{aligned}\n    \\text{dist}(u, v) &> \\text{dist}(u, b) \\\\\n    \\text{dist}(u, u^*) + \\text{dist}(u^*, v) \\geq \\text{dist}(u, v) &> \\text{dist}(u, u^*) + \\text{dist}(u^*, b) \\\\\n    \\text{dist}(u^*, v) &> \\text{dist}(u^*, b) \\\\\n    \\text{dist}(a, u^*) + \\text{dist}(u^*, v) &> \\text{dist}(a, u^*) + \\text{dist}(u^*, b) \\\\\n    \\text{dist}(a, v) &> \\text{dist}(a, b) \\\\\n    \\end{aligned}\n    $$ \n    which is a contradiction, since the diameter ($a \\rightarrow b$) is the longest path in the tree.Therefore, to calculate the diameter of a tree, only two BFS calls are needed:\n\n1. First BFS starting from any arbitrary node to find the *farthest* node from it, which is also an endpoint of the diameter.\n2. Second BFS starting from this *farthest* node to find the *farthest node* from it, which is equal to the second endpoint of the diameter.\n\n> **Breadth-First Search (BFS)**: For a more comprehensive understanding of breadth-first search, check out the [BFS Explore Card](https://leetcode.com/explore/featured/card/graph/620/breadth-first-search-in-graph/). This resource provides an in-depth look at BFS, explaining its key concepts and applications with a variety of problems to solidify understanding of the pattern.\n\n#### Algorithm\n\n##### Main Function: `minimumDiameterAfterMerge`\n- Calculate the number of nodes for each tree:\n  - `n` is the number of nodes in Tree 1.\n  - `m` is the number of nodes in Tree 2.\n\n- Build adjacency lists for both trees:\n  - Call `buildAdjList(n, edges1)` to construct the adjacency list for the first tree.\n  - Call `buildAdjList(m, edges2)` to construct the adjacency list for the second tree.\n\n- Calculate the diameters of both trees:\n  - Call `findDiameter(n, adjList1)` to find the diameter of the first tree.\n  - Call `findDiameter(m, adjList2)` to find the diameter of the second tree.\n\n- Calculate the longest path that spans across both trees:\n  - Calculate `combinedDiameter` as the sum of half the diameters of both trees, plus 1 (rounded up).\n\n- Return the maximum of the three possibilities:\n  - Return the maximum of `diameter1`, `diameter2`, and `combinedDiameter`.\n\n##### `buildAdjList` function:\n  - Create an adjacency list of size `size`.\n  - For each edge in `edges`, add the nodes to each other's adjacency list.\n\n##### `findDiameter` function:\n  - Call `findFarthestNode(n, adjList, 0)` to find the farthest node from an arbitrary starting node (e.g., node 0).\n  - Call `findFarthestNode(n, adjList, farthestNode)` from the previously found farthest node to determine the tree diameter.\n\n##### `findFarthestNode` function:\n  - Initialize a queue and a visited array to perform BFS starting from `sourceNode`.\n  - Traverse the graph, updating the farthest node each time a node is dequeued.\n  - Return the farthest node and the distance (diameter).\n\n#### Implementation#### Complexity Analysis\n\nLet $n$ be the number of nodes in the first tree and $m$ the number of nodes in the second tree.\n\n-   Time complexity: $O(n + m)$\n\n    To calculate the diameter of a tree, we perform two BFS calls using the `findFarthestNode` function. Each BFS visits every node and edge exactly once, and since the number of edges is $k - 1 = O(k)$ for a tree of size $k$, the time complexity of one BFS is $O(k)$. Thus, finding the diameter of the first tree takes $O(n)$, and for the second tree, it takes $O(m)$, as each involves two BFS calls.\n\n    The combined diameter of the tree is calculated using constant-time operations like addition and comparison, contributing $O(1)$ to the overall time complexity of $O(n + m)$.\n\n-   Space complexity: $O(n + m)$\n\n    All the data structures used in the algorithm, including the adjacency lists, the `visited` array, and the `nodesQueue`, have linear space complexity in terms of the size of the tree being processed. Therefore, the total space complexity is $O(n + m)$.\n\n### Approach 2: Depth First Search\n\n#### Intuition\n\nLet’s start with a simple observation based on the definition of the diameter: \n\n-   For each node in the tree, we calculate the length of the longest path passing through it. The longest of these paths represents the diameter of the tree.\n\nTo determine the longest path that passes through a node $u$, we perform a DFS to calculate the two longest distances from $u$ to any leaf nodes in the tree. The sum of these two distances gives the length of the longest path through $u$.\n\nDuring the recursive calls, each node returns two values: \n\n1. The diameter of its subtree.\n2. The longest path to a leaf in its subtree, or its *depth*. This avoids redundant calculations, reusing previously computed values.\n\n> **Depth-First Search (DFS)**: For a more comprehensive understanding of depth-first search, check out the [DFS Explore Card](https://leetcode.com/explore/learn/card/graph/619/depth-first-search-in-graph/). This resource provides an in-depth look at DFS, explaining its key concepts and applications with a variety of problems to solidify understanding of the pattern.\n\n\n#### Algorithm\n\n##### Main Function: `minimumDiameterAfterMerge`\n\n- Calculate the number of nodes for each tree:\n  - `n` is the number of nodes in Tree 1.\n  - `m` is the number of nodes in Tree 2.\n\n- Build adjacency lists for both trees:\n  - Use the `buildAdjList` function to construct the adjacency list for both trees (`adjList1` and `adjList2`).\n\n- Find the diameter of Tree 1:\n  - Call `findDiameter(adjList1, 0, -1)` to start a DFS from node 0 in Tree 1.\n  - Store the diameter of Tree 1 in `diameter1`.\n\n- Find the diameter of Tree 2:\n  - Call `findDiameter(adjList2, 0, -1)` to start a DFS from node 0 in Tree 2.\n  - Store the diameter of Tree 2 in `diameter2`.\n\n- Calculate the diameter of the combined tree:\n  - The combined diameter accounts for the longest path spanning both trees.\n  - It is calculated as `ceil(diameter1 / 2.0) + ceil(diameter2 / 2.0) + 1`.\n\n- Return the maximum diameter:\n  - Return the maximum of the three values: `diameter1`, `diameter2`, and `combinedDiameter`.\n\n##### Helper Function: `buildAdjList`\n- Given the number of nodes `size` and an edge list `edges`, build an adjacency list (`adjList`):\n  - Iterate through each edge and add the corresponding nodes to the adjacency list.\n\n##### Helper Function: `findDiameter`\n- Given the adjacency list `adjList`, the current `node`, and its `parent`, calculate the diameter of the tree:\n  - Initialize two variables `maxDepth1` and `maxDepth2` to track the two largest depths from the current node.\n  - Initialize `diameter` to track the diameter of the subtree.\n\n- For each neighbor of the current node:\n  - Skip the parent node to avoid cycles.\n  - Recursively calculate the diameter and depth of the neighbor’s subtree.\n  - Update `diameter` with the maximum of the current diameter and the child’s diameter.\n  - Increment the depth and update the two largest depths (`maxDepth1` and `maxDepth2`).\n\n- The diameter of the current node is updated as `maxDepth1 + maxDepth2`.\n\n- Return the `diameter` and `maxDepth1` (to be used by the parent).\n\n#### Implementation#### Complexity Analysis\n\nLet $n$ be the number of nodes in the first tree and $m$ the number of nodes in the second tree.\n\n-   Time complexity: $O(n + m)$\n\n    The `findDiameter` function uses Depth-First Search (DFS) on the tree, with a time complexity of $O(k)$, where $k$ is the tree's size. The diameter calculation itself takes $O(n + m)$ time. Since combining the diameters involves only constant-time operations, the overall time complexity is $O(n + m)$.\n\n-   Space complexity: $O(n + m)$\n\n    The space complexity depends on the size of the data structures and the recursion depth. Using an adjacency list representation of the trees requires $O(n + m)$ space. Additionally, the recursion depth can reach $O(k)$, where $k$ is the number of nodes in the processed tree. Thus, the total space complexity is $O(n + m)$.\n\n### Approach 3: Topological Sorting\n\n#### Intuition\n\nIn this approach, we will again calculate the diameter of each tree separately and then apply the method described in [the overview section](#overview) to determine the diameter of the resulting tree.\n\nFirst, observe that the diameter endpoints must be leaves, as any non-leaf endpoints would allow the diameter to extend further in the opposite direction, contradicting the definition of the diameter.\n\nTherefore, removing all leaves reduces the diameter by 2, and the remaining diameter becomes the diameter of the reduced tree. As a result, the remaining part of the diameter will still be the diameter of the reduced tree.\n\nIf we continue removing the leaves, the remaining diameter will get progressively smaller until only one or two nodes are left.\n\n- If one node is left, the diameter equals the number of nodes removed during the reduction.\n- If two nodes remain, we count the edge connecting them as part of the diameter.\n\nTo track the current leaves of the reduced tree, we will update the counters of their neighboring nodes, also known as the *degree* of each node. Once a node's degree reaches 1, we will enqueue that node in the `nodesQueue` for further processing.\n\n#### Algorithm\n\n##### Main Function: `minimumDiameterAfterMerge`\n\n- Calculate the number of nodes for each tree:\n  - `n` is the number of nodes in Tree 1.\n  - `m` is the number of nodes in Tree 2.\n\n- Build adjacency lists for both trees:\n  - Use the `buildAdjList` function to construct the adjacency list for each tree (`adjList1` for Tree 1 and `adjList2` for Tree 2).\n\n- Calculate the diameters of both trees:\n  - Call `findDiameter(n, adjList1)` to find the diameter of Tree 1 (`diameter1`).\n  - Call `findDiameter(m, adjList2)` to find the diameter of Tree 2 (`diameter2`).\n\n- Calculate the longest path that spans both trees:\n  - Compute `combinedDiameter` as the sum of half of `diameter1`, half of `diameter2`, and an additional 1 to account for the merging edge.\n  - The formula is: `combinedDiameter = ceil(diameter1 / 2.0) + ceil(diameter2 / 2.0) + 1`.\n\n- Return the maximum value among `diameter1`, `diameter2`, and `combinedDiameter`.\n\n##### `buildAdjList` function:\n  - Initialize an empty adjacency list `adjList` of the given size (`size`).\n  - Iterate through the edges and populate the adjacency list by adding neighbors for each node.\n\n##### `findDiameter` function:\n  - Initialize a queue `leavesQueue` to hold leaves (nodes with degree 1) and a `degrees` vector to track the degree (number of neighbors) of each node.\n  - Add all leaves (nodes with degree 1) to the `leavesQueue`.\n  - Process the leaves iteratively, removing them and updating the degrees of their neighbors.\n  - Continue until only 2 or fewer nodes remain:\n    - For each leaf, reduce the degree of its neighbors, and if a neighbor becomes a leaf, add it to the queue.\n  - If exactly two nodes remain, return the diameter as twice the number of layers of leaves removed + 1 (final connecting edge).\n  - If only one node remains, return twice the number of layers of leaves removed.\n\n#### Implementation#### Complexity Analysis\n\nLet $n$ be the number of nodes in the first tree and $m$ the number of nodes in the second tree.\n\n-   Time complexity: $O(n + m)$\n\n    In the `findDiameter` function, each node is added and removed from the `leavesQueue` once. Each edge is processed once when updating the degrees of neighboring nodes. Therefore, the time complexity is $O(k)$, where $k$ is the size of the input tree. Consequently, calculating the diameter for both trees takes $O(n + m)$ time.\n\n    The calculation of the diameter of the combined tree involves only a few constant-time operations, such as adding and comparing values. This step contributes $O(1)$ to the total time complexity, which is still $O(n + m)$.\n\n-   Space complexity: $O(n + m)$\n\n    Similar to the first approach, all the data structures used (adjacency lists, `leavesQueue` and,the `degrees` array), have a linear space complexity in terms of the size of the tree being processed. Therefore, the total space complexity is $O(n + m)$.\n\n---"
}