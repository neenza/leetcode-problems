{
  "title": "Count the Number of Good Partitions",
  "problem_id": "3212",
  "frontend_id": "2963",
  "difficulty": "Hard",
  "problem_slug": "count-the-number-of-good-partitions",
  "topics": [
    "Array",
    "Hash Table",
    "Math",
    "Combinatorics"
  ],
  "description": "You are given a 0-indexed array nums consisting of positive integers.\nA partition of an array into one or more contiguous subarrays is called good if no two subarrays contain the same number.\nReturn the total number of good partitions of nums.\nSince the answer may be large, return it modulo 109 + 7.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: nums = [1,2,3,4]\nOutput: 8\nExplanation: The 8 possible good partitions are: ([1], [2], [3], [4]), ([1], [2], [3,4]), ([1], [2,3], [4]), ([1], [2,3,4]), ([1,2], [3], [4]), ([1,2], [3,4]), ([1,2,3], [4]), and ([1,2,3,4]).",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input: nums = [1,1,1,1]\nOutput: 1\nExplanation: The only possible good partition is: ([1,1,1,1]).",
      "images": []
    },
    {
      "example_num": 3,
      "example_text": "Input: nums = [1,2,1,3]\nOutput: 2\nExplanation: The 2 possible good partitions are: ([1,2,1], [3]) and ([1,2,1,3]).",
      "images": []
    }
  ],
  "constraints": [
    "1 <= nums.length <= 105",
    "1 <= nums[i] <= 109"
  ],
  "follow_ups": [],
  "hints": [
    "If a segment contains a value, it must contain all occurrences of the same value.",
    "Partition the array into segments making each one as short as possible. This can be achieved by two-pointers or using a Set.",
    "If we have <code>m</code> segments, we can arbitrarily group the neighboring segments. How many ways are there to group these <code>m</code> segments?"
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    int numberOfGoodPartitions(vector<int>& nums) {\n        \n    }\n};",
    "java": "class Solution {\n    public int numberOfGoodPartitions(int[] nums) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def numberOfGoodPartitions(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def numberOfGoodPartitions(self, nums: List[int]) -> int:\n        ",
    "c": "int numberOfGoodPartitions(int* nums, int numsSize) {\n    \n}",
    "csharp": "public class Solution {\n    public int NumberOfGoodPartitions(int[] nums) {\n        \n    }\n}",
    "javascript": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar numberOfGoodPartitions = function(nums) {\n    \n};",
    "typescript": "function numberOfGoodPartitions(nums: number[]): number {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @return Integer\n     */\n    function numberOfGoodPartitions($nums) {\n        \n    }\n}",
    "swift": "class Solution {\n    func numberOfGoodPartitions(_ nums: [Int]) -> Int {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun numberOfGoodPartitions(nums: IntArray): Int {\n        \n    }\n}",
    "dart": "class Solution {\n  int numberOfGoodPartitions(List<int> nums) {\n    \n  }\n}",
    "golang": "func numberOfGoodPartitions(nums []int) int {\n    \n}",
    "ruby": "# @param {Integer[]} nums\n# @return {Integer}\ndef number_of_good_partitions(nums)\n    \nend",
    "scala": "object Solution {\n    def numberOfGoodPartitions(nums: Array[Int]): Int = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn number_of_good_partitions(nums: Vec<i32>) -> i32 {\n        \n    }\n}",
    "racket": "(define/contract (number-of-good-partitions nums)\n  (-> (listof exact-integer?) exact-integer?)\n  )",
    "erlang": "-spec number_of_good_partitions(Nums :: [integer()]) -> integer().\nnumber_of_good_partitions(Nums) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec number_of_good_partitions(nums :: [integer]) :: integer\n  def number_of_good_partitions(nums) do\n    \n  end\nend"
  }
}