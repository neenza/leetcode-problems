{
  "title": "Meeting Rooms III",
  "problem_id": "2479",
  "frontend_id": "2402",
  "difficulty": "Hard",
  "problem_slug": "meeting-rooms-iii",
  "topics": [
    "Array",
    "Hash Table",
    "Sorting",
    "Heap (Priority Queue)",
    "Simulation"
  ],
  "description": "You are given an integer n. There are n rooms numbered from 0 to n - 1.\nYou are given a 2D integer array meetings where meetings[i] = [starti, endi] means that a meeting will be held during the half-closed time interval [starti, endi). All the values of starti are unique.\nMeetings are allocated to rooms in the following manner:\nReturn the number of the room that held the most meetings. If there are multiple rooms, return the room with the lowest number.\nA half-closed interval [a, b) is the interval between a and b including a and not including b.\nExample 1:\nExample 2:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: n = 2, meetings = [[0,10],[1,5],[2,7],[3,4]]\nOutput: 0\nExplanation:\n- At time 0, both rooms are not being used. The first meeting starts in room 0.\n- At time 1, only room 1 is not being used. The second meeting starts in room 1.\n- At time 2, both rooms are being used. The third meeting is delayed.\n- At time 3, both rooms are being used. The fourth meeting is delayed.\n- At time 5, the meeting in room 1 finishes. The third meeting starts in room 1 for the time period [5,10).\n- At time 10, the meetings in both rooms finish. The fourth meeting starts in room 0 for the time period [10,11).\nBoth rooms 0 and 1 held 2 meetings, so we return 0.",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input: n = 3, meetings = [[1,20],[2,10],[3,5],[4,9],[6,8]]\nOutput: 1\nExplanation:\n- At time 1, all three rooms are not being used. The first meeting starts in room 0.\n- At time 2, rooms 1 and 2 are not being used. The second meeting starts in room 1.\n- At time 3, only room 2 is not being used. The third meeting starts in room 2.\n- At time 4, all three rooms are being used. The fourth meeting is delayed.\n- At time 5, the meeting in room 2 finishes. The fourth meeting starts in room 2 for the time period [5,10).\n- At time 6, all three rooms are being used. The fifth meeting is delayed.\n- At time 10, the meetings in rooms 1 and 2 finish. The fifth meeting starts in room 1 for the time period [10,12).\nRoom 0 held 1 meeting while rooms 1 and 2 each held 2 meetings, so we return 1.",
      "images": []
    }
  ],
  "constraints": [
    "1 <= n <= 100",
    "1 <= meetings.length <= 105",
    "meetings[i].length == 2",
    "0 <= starti < endi <= 5 * 105",
    "All the values of starti are unique."
  ],
  "follow_ups": [],
  "hints": [
    "Sort meetings based on start times.",
    "Use two min heaps, the first one keeps track of the numbers of all the rooms that are free. The second heap keeps track of the end times of all the meetings that are happening and the room that they are in.",
    "Keep track of the number of times each room is used in an array.",
    "With each meeting, check if there are any free rooms. If there are, then use the room with the smallest number. Otherwise, assign the meeting to the room whose meeting will end the soonest."
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    int mostBooked(int n, vector<vector<int>>& meetings) {\n        \n    }\n};",
    "java": "class Solution {\n    public int mostBooked(int n, int[][] meetings) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def mostBooked(self, n, meetings):\n        \"\"\"\n        :type n: int\n        :type meetings: List[List[int]]\n        :rtype: int\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def mostBooked(self, n: int, meetings: List[List[int]]) -> int:\n        ",
    "c": "int mostBooked(int n, int** meetings, int meetingsSize, int* meetingsColSize) {\n    \n}",
    "csharp": "public class Solution {\n    public int MostBooked(int n, int[][] meetings) {\n        \n    }\n}",
    "javascript": "/**\n * @param {number} n\n * @param {number[][]} meetings\n * @return {number}\n */\nvar mostBooked = function(n, meetings) {\n    \n};",
    "typescript": "function mostBooked(n: number, meetings: number[][]): number {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param Integer $n\n     * @param Integer[][] $meetings\n     * @return Integer\n     */\n    function mostBooked($n, $meetings) {\n        \n    }\n}",
    "swift": "class Solution {\n    func mostBooked(_ n: Int, _ meetings: [[Int]]) -> Int {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun mostBooked(n: Int, meetings: Array<IntArray>): Int {\n        \n    }\n}",
    "dart": "class Solution {\n  int mostBooked(int n, List<List<int>> meetings) {\n    \n  }\n}",
    "golang": "func mostBooked(n int, meetings [][]int) int {\n    \n}",
    "ruby": "# @param {Integer} n\n# @param {Integer[][]} meetings\n# @return {Integer}\ndef most_booked(n, meetings)\n    \nend",
    "scala": "object Solution {\n    def mostBooked(n: Int, meetings: Array[Array[Int]]): Int = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn most_booked(n: i32, meetings: Vec<Vec<i32>>) -> i32 {\n        \n    }\n}",
    "racket": "(define/contract (most-booked n meetings)\n  (-> exact-integer? (listof (listof exact-integer?)) exact-integer?)\n  )",
    "erlang": "-spec most_booked(N :: integer(), Meetings :: [[integer()]]) -> integer().\nmost_booked(N, Meetings) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec most_booked(n :: integer, meetings :: [[integer]]) :: integer\n  def most_booked(n, meetings) do\n    \n  end\nend"
  },
  "solution": "[TOC]\n\n## Solution\n\n--- \n\n### Overview\n\nThis problem involves the efficient allocation of meeting rooms to a set of scheduled meetings, each defined by a start and end time. The goal is to determine the room number that hosts the maximum number of meetings. If multiple rooms hold the same maximum number of meetings, the solution should return the room with the lowest number. By addressing this problem, algorithms developed for this type of scheduling challenge can be adapted to improve efficiency in real-world scenarios where resource allocation and scheduling are essential components.\n\n---\n\n### Approach 1: Sorting and Counting\n\n#### Intuition\n\nTo tackle this problem, we first observe that the meetings are allocated to rooms based on two primary rules. The first rule dictates that each meeting is assigned to the unused room with the lowest number. This implies a sequential allocation strategy, ensuring that meetings are placed in rooms in ascending order. The second rule comes into play when there are no available rooms; in such cases, the meeting is delayed until a room becomes free, and when a room becomes unused, meetings with earlier original start times take precedence.\n\nWe can employ a systematic approach to implement these rules efficiently. We initialize two arrays: `room_availability_time` and `meeting_count`. The former tracks the availability time of each room, while the latter records the number of meetings held in each room.\n\nWe iterate through the sorted meetings(sorted by start time), adhering to the rule that meetings should be allocated based on their start times. Sorting the meetings based on their start times is crucial to effectively implement Rule 3, which states that when a room becomes unused, meetings with an earlier original start time should be given priority for that room. Consider a situation where meetings are not sorted, and the algorithm encounters a scenario where a room becomes available after hosting a meeting. Without the sorting, the algorithm might select the next meeting arbitrarily, possibly one with a later original start time, thus violating Rule 3.\n\nFor each meeting, we identify the room with the earliest availability using a nested loop. \n * If we find an available room: The currently selected meeting is allocated to that room, and the room's availability time is updated. Since we iterate over the $N$ rooms in sequential order, we are guaranteed to identify the available room with the lowest index first. This update involves assigning the end time of the currently selected meeting as the new availability time for the room. This adjustment is made because the room can only be utilized for the next meeting after the currently assigned meeting is finished. \n * If we *don't* find an available room: we must search for the room that will become available soonest. Therefore, we are seeking the room with the earliest available time. The duration of the currently selected meeting is then added to the availability time of this identified room. This ensures that the delayed meeting has the same duration as the original meeting and updates the room's availability time accordingly.\n\nThroughout the process, we keep track of meeting counts in each room. Finally, we identify the room that held the most meetings and, in the case of a tie, select the room with the lowest number.\n\n!?!../Documents/2402/meeting_rooms_iii-1.json:3000,1687!?!\n\n#### Algorithm\n\n1. Initialize two arrays, `room_availability_time` and `meeting_count`, both of size `n`, to keep track of the availability time for each room and the count of meetings held in each room, respectively.\n2. Iterate through each meeting in the sorted order based on their start times.\n3. For each meeting, find the earliest available room by iterating through the `room_availability_time` array. If a room is available (its availability time is less than or equal to the current meeting's start time), allocate the meeting to that room, update the meeting count for that room, and set the room's availability time to the meeting's end time. Break out of the loop.\n4. If no available room is found (i.e., `found_unused_room` is False), find the room with the earliest availability time (`min_room_availability_time`). Update the availability time for that room to accommodate the delayed meeting, and increment the meeting count for that room.\n5. After processing all meetings, return the index of the room with the maximum meeting count using. If there are multiple rooms with the same maximum meeting count, return the room with the lowest index.\n\n\n#### Implementation#### Complexity Analysis\n\nLet $N$ be the number of rooms.\nLet $M$ be the number of meetings.\n\n* Time complexity: $O(M\\cdot logM + M\\cdot N)$. \n\n    Sorting `meetings` will incur a time complexity of $O(M\\cdot logM)$. Iterating over `meetings` will incur a time complexity of $O(M)$. The inner for loop within the iterations over `meetings` has a worst-case time complexity of $O(N)$. To illustrate this, envision a scenario where all rooms are initially occupied and remain so throughout the process. In such a case, there is no possibility of breaking out of the loop prematurely.\n\n    For example: `n = 3, meetings = [[1, 10001], [2, 10001], [3, 10001], [4, 10001], [5, 10001], [6, 10001],... [1000, 10001]]`. In this case, after the first three meetings are assigned to the three rooms, their availability times will be `[10001, 10001, 10001]`. In this scenario, breaking out of the inner loop early for the remaining meetings becomes unattainable, compelling the algorithm to search for the room that becomes unused earliest. Consequently, the inner loop incurs a worst-case time complexity of $O(N)$. \n    \n    Thus the overall time complexity for iterating over `meetings` is $O(M\\cdot N)$. The overall time complexity of the algorithm is $O(M\\cdot logM + M\\cdot N)$.\n\n* Space complexity: $O(N + sort)$. \n  \n    Initializing `room_availability_time` and `meeting_count` will incur a space complexity of $O(N)$. Some extra space is used when we sort an array of size $N$ in place. The space complexity of the sorting algorithm depends on the programming language.\n    - In Python, the `sort` method sorts a list using the Timsort algorithm which is a combination of Merge Sort and Insertion Sort and has a space complexity of $$O(N)$$.\n    - In C++, the sort() function is implemented as a hybrid of Quick Sort, Heap Sort, and Insertion Sort, with a worst-case space complexity of $$O(\\log N)$$.\n    - In Java, Arrays.sort() is implemented using a variant of the Quick Sort algorithm which has a space complexity of $$O(\\log N)$$.\n\n---\n\n### Approach 2: Sorting, Counting using Priority Queues\n\n#### Intuition\n\nIn the preceding solution, the iteration over all $N$ rooms occurs within the nested loop, resulting in an overall time complexity of $O(M \\cdot N)$ for the `for` loop. To enhance efficiency we must explore avenues for optimization. We need to devise a method to obtain the next available room without the necessity of iterating over all $N$ rooms. To do this we can maintain two crucial structures: `unused_rooms` and `used_rooms.` These structures are essentially priority queues or heaps, with `unused_rooms` representing available rooms sorted by room number, and `used_rooms` storing rooms in use along with the time they become available again.\n\nWe start by initialization of `unused_rooms` as a priority queue containing all room numbers and `used_rooms` as an empty priority queue. \n\n`unused_rooms` is ordered in ascending order according to room numbers. This arrangement guarantees that when an element is popped from this, it returns the unused room with the lowest number. This is important to follow rule 1, which states that each meeting will take place in the unused room with the lowest number. \n\n`used_rooms` is a priority queue that contains elements in the form of `{room_availability_time, room_number}`. Here, `room_availability_time` signifies the time at which this room becomes unused. This priority queue is ordered in ascending order based on both `room_availability_time` and `room_number`. This ensures that when an element is popped from it, the room returned is the one that becomes unused earliest. This assists in adhering to rules 2 and 3 while allocating a meeting to the room that becomes unused earliest when all rooms are currently in use.\n\nThen we proceed to iterate through the meetings after sorting them based on their start times, adhering to the rule that meetings should be allocated based on their start times. Within this loop, a cascading series of decisions unfolds to handle various scenarios.\n\nWhen iterating through meetings we first manage the release of rooms that have become unused. We iterate through `used_rooms`, popping rooms from the heap if their availability time is earlier than or equal to the start time of the current meeting. Released rooms are then pushed into `unused_rooms`.\n\nSubsequently, we check if there are available rooms in `unused_rooms`. If so, the room with the lowest number is assigned to the current meeting. This follows the principle of allocating meetings to the unused room with the lowest number.\n\nIn the event that no rooms are available in `unused_rooms`, we resort to delaying the current meeting. We find the room with the earliest availability time (derived from the first item in `used_rooms`.) We then adjust the availability time of this room based on the duration of the delayed meeting, and push the room back into `used_rooms`. This ensures that meetings with earlier original start times are given priority when rooms become available and delayed meetings have the same duration as the original meeting.\n\nThroughout this process, a crucial aspect is tracking of the count of meetings held in each room using the `meeting_count` array. This array is instrumental in determining the room that hosted the most meetings. After we have selected the room that hosts the meeting, we increment the count of meetings that occurred in that room.\n\nFinally, we identify the room that held the most meetings and, in the case of a tie, select the room with the lowest number.\n\n#### Algorithm\n\n1. Create two priority queues, `unused_rooms` and `used_rooms`, representing the available and currently used rooms, respectively. Create an array `meeting_count` of size `n` to keep track of the number of meetings held in each room. \n2. Use the `heapify` function to convert `unused_rooms` into a min heap, ensuring the room with the lowest number is at the top.\n3. Iterate through the meetings sorted by start times.\n4. While there are used rooms (`used_rooms`) and the first room's meeting has already concluded (meeting end time <= current meeting start time), remove the room from `used_rooms` and add it back to `unused_rooms`.\n5. Check if there are available rooms (`unused_rooms`). If available, pop the room with the lowest number from `unused_rooms` and allocate the meeting to that room. Update `used_rooms` with the meeting end time and the room number.\n6. If no available rooms, pop the room with the earliest availability time from `used_rooms`. Adjust the availability time for the room to accommodate the delayed meeting. Update `used_rooms` with the adjusted availability time and room number.\n7. Increment the meeting count for the allocated room.\n8. After processing all meetings, return the index of the room with the maximum meeting count using. If there are multiple rooms with the same maximum meeting count, return the room with the lowest index.\n\n\n#### Implementation#### Complexity Analysis\n\nLet $N$ be the number of rooms.\nLet $M$ be the number of meetings.\n\n* Time complexity: $O(M \\cdot \\log M + M \\cdot \\log N + N \\cdot \\log N)$\n    \n    Sorting `meetings` will incur a time complexity of $O(M \\cdot \\log M)$.\n    \n    Popping and pushing into the priority queue will each cost $O(\\log N)$. These priority queue operations run inside a for loop that runs at most $M$ times, leading to a time complexity of $O(M \\cdot \\log N)$.\n    \n    The inner nested loop will incur a time complexity of $O(\\log N)$. Additionally, initializing the heap of unused rooms takes $O(N \\cdot \\log N)$ time in languages like C++ and Java.\n    \n    The combined time complexity is $O(M \\cdot \\log M + M \\cdot \\log N + N \\cdot \\log N)$. As per the constraints, $N$ is small, so the term $O(M \\cdot \\log M)$ will typically dominate.\n\n* Space complexity: $O(N + sort)$. \n    \n    Initializing `unused_rooms` and `meeting_count` will incur a space complexity of $O(N)$. Some extra space is used when we sort an array of size $N$ in place. The space complexity of the sorting algorithm depends on the programming language.\n    \n    - In Python, the `sort` method sorts a list using the Timsort algorithm which is a combination of Merge Sort and Insertion Sort and has a space complexity of $$O(N)$$.\n    \n    - In C++, the sort() function is implemented as a hybrid of Quick Sort, Heap Sort, and Insertion Sort, with a worst-case space complexity of $$O(\\log N)$$.\n    \n    - In Java, Arrays.sort() is implemented using a variant of the Quick Sort algorithm which has a space complexity of $$O(\\log N)$$.\n\n---"
}