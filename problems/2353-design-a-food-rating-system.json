{
  "title": "Design a Food Rating System",
  "problem_id": "2429",
  "frontend_id": "2353",
  "difficulty": "Medium",
  "problem_slug": "design-a-food-rating-system",
  "topics": [
    "Array",
    "Hash Table",
    "String",
    "Design",
    "Heap (Priority Queue)",
    "Ordered Set"
  ],
  "description": "Design a food rating system that can do the following:\nImplement the FoodRatings class:\nNote that a string x is lexicographically smaller than string y if x comes before y in dictionary order, that is, either x is a prefix of y, or if i is the first position such that x[i] != y[i], then x[i] comes before y[i] in alphabetic order.\nExample 1:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input\n[\"FoodRatings\", \"highestRated\", \"highestRated\", \"changeRating\", \"highestRated\", \"changeRating\", \"highestRated\"]\n[[[\"kimchi\", \"miso\", \"sushi\", \"moussaka\", \"ramen\", \"bulgogi\"], [\"korean\", \"japanese\", \"japanese\", \"greek\", \"japanese\", \"korean\"], [9, 12, 8, 15, 14, 7]], [\"korean\"], [\"japanese\"], [\"sushi\", 16], [\"japanese\"], [\"ramen\", 16], [\"japanese\"]]\nOutput\n[null, \"kimchi\", \"ramen\", null, \"sushi\", null, \"ramen\"]\n\nExplanation\nFoodRatings foodRatings = new FoodRatings([\"kimchi\", \"miso\", \"sushi\", \"moussaka\", \"ramen\", \"bulgogi\"], [\"korean\", \"japanese\", \"japanese\", \"greek\", \"japanese\", \"korean\"], [9, 12, 8, 15, 14, 7]);\nfoodRatings.highestRated(\"korean\"); // return \"kimchi\"\n                                    // \"kimchi\" is the highest rated korean food with a rating of 9.\nfoodRatings.highestRated(\"japanese\"); // return \"ramen\"\n                                      // \"ramen\" is the highest rated japanese food with a rating of 14.\nfoodRatings.changeRating(\"sushi\", 16); // \"sushi\" now has a rating of 16.\nfoodRatings.highestRated(\"japanese\"); // return \"sushi\"\n                                      // \"sushi\" is the highest rated japanese food with a rating of 16.\nfoodRatings.changeRating(\"ramen\", 16); // \"ramen\" now has a rating of 16.\nfoodRatings.highestRated(\"japanese\"); // return \"ramen\"\n                                      // Both \"sushi\" and \"ramen\" have a rating of 16.\n                                      // However, \"ramen\" is lexicographically smaller than \"sushi\".",
      "images": []
    }
  ],
  "constraints": [
    "1 <= n <= 2 * 104",
    "n == foods.length == cuisines.length == ratings.length",
    "1 <= foods[i].length, cuisines[i].length <= 10",
    "foods[i], cuisines[i] consist of lowercase English letters.",
    "1 <= ratings[i] <= 108",
    "All the strings in foods are distinct.",
    "food will be the name of a food item in the system across all calls to changeRating.",
    "cuisine will be a type of cuisine of at least one food item in the system across all calls to highestRated.",
    "At most 2 * 104 calls in total will be made to changeRating and highestRated."
  ],
  "follow_ups": [],
  "hints": [
    "The key to solving this problem is to properly store the data using the right data structures.",
    "Firstly, a hash table is needed to efficiently map each food item to its cuisine and current rating.",
    "In addition, another hash table is needed to map cuisines to foods within each cuisine stored in an ordered set according to their ratings."
  ],
  "code_snippets": {
    "cpp": "class FoodRatings {\npublic:\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\n        \n    }\n    \n    void changeRating(string food, int newRating) {\n        \n    }\n    \n    string highestRated(string cuisine) {\n        \n    }\n};\n\n/**\n * Your FoodRatings object will be instantiated and called as such:\n * FoodRatings* obj = new FoodRatings(foods, cuisines, ratings);\n * obj->changeRating(food,newRating);\n * string param_2 = obj->highestRated(cuisine);\n */",
    "java": "class FoodRatings {\n\n    public FoodRatings(String[] foods, String[] cuisines, int[] ratings) {\n        \n    }\n    \n    public void changeRating(String food, int newRating) {\n        \n    }\n    \n    public String highestRated(String cuisine) {\n        \n    }\n}\n\n/**\n * Your FoodRatings object will be instantiated and called as such:\n * FoodRatings obj = new FoodRatings(foods, cuisines, ratings);\n * obj.changeRating(food,newRating);\n * String param_2 = obj.highestRated(cuisine);\n */",
    "python": "class FoodRatings(object):\n\n    def __init__(self, foods, cuisines, ratings):\n        \"\"\"\n        :type foods: List[str]\n        :type cuisines: List[str]\n        :type ratings: List[int]\n        \"\"\"\n        \n\n    def changeRating(self, food, newRating):\n        \"\"\"\n        :type food: str\n        :type newRating: int\n        :rtype: None\n        \"\"\"\n        \n\n    def highestRated(self, cuisine):\n        \"\"\"\n        :type cuisine: str\n        :rtype: str\n        \"\"\"\n        \n\n\n# Your FoodRatings object will be instantiated and called as such:\n# obj = FoodRatings(foods, cuisines, ratings)\n# obj.changeRating(food,newRating)\n# param_2 = obj.highestRated(cuisine)",
    "python3": "class FoodRatings:\n\n    def __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):\n        \n\n    def changeRating(self, food: str, newRating: int) -> None:\n        \n\n    def highestRated(self, cuisine: str) -> str:\n        \n\n\n# Your FoodRatings object will be instantiated and called as such:\n# obj = FoodRatings(foods, cuisines, ratings)\n# obj.changeRating(food,newRating)\n# param_2 = obj.highestRated(cuisine)",
    "c": "\n\n\ntypedef struct {\n    \n} FoodRatings;\n\n\nFoodRatings* foodRatingsCreate(char** foods, int foodsSize, char** cuisines, int cuisinesSize, int* ratings, int ratingsSize) {\n    \n}\n\nvoid foodRatingsChangeRating(FoodRatings* obj, char* food, int newRating) {\n    \n}\n\nchar* foodRatingsHighestRated(FoodRatings* obj, char* cuisine) {\n    \n}\n\nvoid foodRatingsFree(FoodRatings* obj) {\n    \n}\n\n/**\n * Your FoodRatings struct will be instantiated and called as such:\n * FoodRatings* obj = foodRatingsCreate(foods, foodsSize, cuisines, cuisinesSize, ratings, ratingsSize);\n * foodRatingsChangeRating(obj, food, newRating);\n \n * char* param_2 = foodRatingsHighestRated(obj, cuisine);\n \n * foodRatingsFree(obj);\n*/",
    "csharp": "public class FoodRatings {\n\n    public FoodRatings(string[] foods, string[] cuisines, int[] ratings) {\n        \n    }\n    \n    public void ChangeRating(string food, int newRating) {\n        \n    }\n    \n    public string HighestRated(string cuisine) {\n        \n    }\n}\n\n/**\n * Your FoodRatings object will be instantiated and called as such:\n * FoodRatings obj = new FoodRatings(foods, cuisines, ratings);\n * obj.ChangeRating(food,newRating);\n * string param_2 = obj.HighestRated(cuisine);\n */",
    "javascript": "/**\n * @param {string[]} foods\n * @param {string[]} cuisines\n * @param {number[]} ratings\n */\nvar FoodRatings = function(foods, cuisines, ratings) {\n    \n};\n\n/** \n * @param {string} food \n * @param {number} newRating\n * @return {void}\n */\nFoodRatings.prototype.changeRating = function(food, newRating) {\n    \n};\n\n/** \n * @param {string} cuisine\n * @return {string}\n */\nFoodRatings.prototype.highestRated = function(cuisine) {\n    \n};\n\n/** \n * Your FoodRatings object will be instantiated and called as such:\n * var obj = new FoodRatings(foods, cuisines, ratings)\n * obj.changeRating(food,newRating)\n * var param_2 = obj.highestRated(cuisine)\n */",
    "typescript": "class FoodRatings {\n    constructor(foods: string[], cuisines: string[], ratings: number[]) {\n        \n    }\n\n    changeRating(food: string, newRating: number): void {\n        \n    }\n\n    highestRated(cuisine: string): string {\n        \n    }\n}\n\n/**\n * Your FoodRatings object will be instantiated and called as such:\n * var obj = new FoodRatings(foods, cuisines, ratings)\n * obj.changeRating(food,newRating)\n * var param_2 = obj.highestRated(cuisine)\n */",
    "php": "class FoodRatings {\n    /**\n     * @param String[] $foods\n     * @param String[] $cuisines\n     * @param Integer[] $ratings\n     */\n    function __construct($foods, $cuisines, $ratings) {\n        \n    }\n  \n    /**\n     * @param String $food\n     * @param Integer $newRating\n     * @return NULL\n     */\n    function changeRating($food, $newRating) {\n        \n    }\n  \n    /**\n     * @param String $cuisine\n     * @return String\n     */\n    function highestRated($cuisine) {\n        \n    }\n}\n\n/**\n * Your FoodRatings object will be instantiated and called as such:\n * $obj = FoodRatings($foods, $cuisines, $ratings);\n * $obj->changeRating($food, $newRating);\n * $ret_2 = $obj->highestRated($cuisine);\n */",
    "swift": "\nclass FoodRatings {\n\n    init(_ foods: [String], _ cuisines: [String], _ ratings: [Int]) {\n        \n    }\n    \n    func changeRating(_ food: String, _ newRating: Int) {\n        \n    }\n    \n    func highestRated(_ cuisine: String) -> String {\n        \n    }\n}\n\n/**\n * Your FoodRatings object will be instantiated and called as such:\n * let obj = FoodRatings(foods, cuisines, ratings)\n * obj.changeRating(food, newRating)\n * let ret_2: String = obj.highestRated(cuisine)\n */",
    "kotlin": "class FoodRatings(foods: Array<String>, cuisines: Array<String>, ratings: IntArray) {\n\n    fun changeRating(food: String, newRating: Int) {\n        \n    }\n\n    fun highestRated(cuisine: String): String {\n        \n    }\n\n}\n\n/**\n * Your FoodRatings object will be instantiated and called as such:\n * var obj = FoodRatings(foods, cuisines, ratings)\n * obj.changeRating(food,newRating)\n * var param_2 = obj.highestRated(cuisine)\n */",
    "dart": "class FoodRatings {\n\n  FoodRatings(List<String> foods, List<String> cuisines, List<int> ratings) {\n    \n  }\n  \n  void changeRating(String food, int newRating) {\n    \n  }\n  \n  String highestRated(String cuisine) {\n    \n  }\n}\n\n/**\n * Your FoodRatings object will be instantiated and called as such:\n * FoodRatings obj = FoodRatings(foods, cuisines, ratings);\n * obj.changeRating(food,newRating);\n * String param2 = obj.highestRated(cuisine);\n */",
    "golang": "type FoodRatings struct {\n    \n}\n\n\nfunc Constructor(foods []string, cuisines []string, ratings []int) FoodRatings {\n    \n}\n\n\nfunc (this *FoodRatings) ChangeRating(food string, newRating int)  {\n    \n}\n\n\nfunc (this *FoodRatings) HighestRated(cuisine string) string {\n    \n}\n\n\n/**\n * Your FoodRatings object will be instantiated and called as such:\n * obj := Constructor(foods, cuisines, ratings);\n * obj.ChangeRating(food,newRating);\n * param_2 := obj.HighestRated(cuisine);\n */",
    "ruby": "class FoodRatings\n\n=begin\n    :type foods: String[]\n    :type cuisines: String[]\n    :type ratings: Integer[]\n=end\n    def initialize(foods, cuisines, ratings)\n        \n    end\n\n\n=begin\n    :type food: String\n    :type new_rating: Integer\n    :rtype: Void\n=end\n    def change_rating(food, new_rating)\n        \n    end\n\n\n=begin\n    :type cuisine: String\n    :rtype: String\n=end\n    def highest_rated(cuisine)\n        \n    end\n\n\nend\n\n# Your FoodRatings object will be instantiated and called as such:\n# obj = FoodRatings.new(foods, cuisines, ratings)\n# obj.change_rating(food, new_rating)\n# param_2 = obj.highest_rated(cuisine)",
    "scala": "class FoodRatings(_foods: Array[String], _cuisines: Array[String], _ratings: Array[Int]) {\n\n    def changeRating(food: String, newRating: Int): Unit = {\n        \n    }\n\n    def highestRated(cuisine: String): String = {\n        \n    }\n\n}\n\n/**\n * Your FoodRatings object will be instantiated and called as such:\n * val obj = new FoodRatings(foods, cuisines, ratings)\n * obj.changeRating(food,newRating)\n * val param_2 = obj.highestRated(cuisine)\n */",
    "rust": "struct FoodRatings {\n\n}\n\n\n/** \n * `&self` means the method takes an immutable reference.\n * If you need a mutable reference, change it to `&mut self` instead.\n */\nimpl FoodRatings {\n\n    fn new(foods: Vec<String>, cuisines: Vec<String>, ratings: Vec<i32>) -> Self {\n        \n    }\n    \n    fn change_rating(&self, food: String, new_rating: i32) {\n        \n    }\n    \n    fn highest_rated(&self, cuisine: String) -> String {\n        \n    }\n}\n\n/**\n * Your FoodRatings object will be instantiated and called as such:\n * let obj = FoodRatings::new(foods, cuisines, ratings);\n * obj.change_rating(food, newRating);\n * let ret_2: String = obj.highest_rated(cuisine);\n */",
    "racket": "(define food-ratings%\n  (class object%\n    (super-new)\n    \n    ; foods : (listof string?)\n    ; cuisines : (listof string?)\n    ; ratings : (listof exact-integer?)\n    (init-field\n      foods\n      cuisines\n      ratings)\n    \n    ; change-rating : string? exact-integer? -> void?\n    (define/public (change-rating food new-rating)\n      )\n    ; highest-rated : string? -> string?\n    (define/public (highest-rated cuisine)\n      )))\n\n;; Your food-ratings% object will be instantiated and called as such:\n;; (define obj (new food-ratings% [foods foods] [cuisines cuisines] [ratings ratings]))\n;; (send obj change-rating food new-rating)\n;; (define param_2 (send obj highest-rated cuisine))",
    "erlang": "-spec food_ratings_init_(Foods :: [unicode:unicode_binary()], Cuisines :: [unicode:unicode_binary()], Ratings :: [integer()]) -> any().\nfood_ratings_init_(Foods, Cuisines, Ratings) ->\n  .\n\n-spec food_ratings_change_rating(Food :: unicode:unicode_binary(), NewRating :: integer()) -> any().\nfood_ratings_change_rating(Food, NewRating) ->\n  .\n\n-spec food_ratings_highest_rated(Cuisine :: unicode:unicode_binary()) -> unicode:unicode_binary().\nfood_ratings_highest_rated(Cuisine) ->\n  .\n\n\n%% Your functions will be called as such:\n%% food_ratings_init_(Foods, Cuisines, Ratings),\n%% food_ratings_change_rating(Food, NewRating),\n%% Param_2 = food_ratings_highest_rated(Cuisine),\n\n%% food_ratings_init_ will be called before every test case, in which you can do some necessary initializations.",
    "elixir": "defmodule FoodRatings do\n  @spec init_(foods :: [String.t], cuisines :: [String.t], ratings :: [integer]) :: any\n  def init_(foods, cuisines, ratings) do\n    \n  end\n\n  @spec change_rating(food :: String.t, new_rating :: integer) :: any\n  def change_rating(food, new_rating) do\n    \n  end\n\n  @spec highest_rated(cuisine :: String.t) :: String.t\n  def highest_rated(cuisine) do\n    \n  end\nend\n\n# Your functions will be called as such:\n# FoodRatings.init_(foods, cuisines, ratings)\n# FoodRatings.change_rating(food, new_rating)\n# param_2 = FoodRatings.highest_rated(cuisine)\n\n# FoodRatings.init_ will be called before every test case, in which you can do some necessary initializations."
  },
  "solution": "[TOC]\n\n## Solution \n\n---\n\n\n### Approach 1: Hash Maps and Priority Queue\n\n#### Intuition  \n\nWe are given three arrays:     \n`foods`, containing food's names,     \n`cuisines`, containing the name of the cuisine of the food at the respective index in the `foods` array, and      \n`ratings`, containing the rating of the food at respective index in the `foods` array.We have to update the food's ratings in the method `changeRating(food, newRating)`.  \n\nOne way is to search for the `food` in the `foods` array and then update the rating at the respective index in the `ratings` array. However, searching for `food` in the `foods` array for every update will not be efficient.    \nInstead, we should keep the food names mapped with their ratings, we can use a hash map (named `foodRatingMap`) and this hash map will enable quick retrieval and modification of the respective food's rating.\n\nTo change the rating of any `food`, we simply update the rating stored in this `foodRatingMap`.\n\n![foodRatingsMap](../Figures/2353/Slide1a.jpg)\n\nAnother requirement is to return the highest-rated food of a particular cuisine in the method `highestRated(cuisine)`. We are given `cuisines` and `foods` arrays, we can group and store all foods belonging to one cuisine together beforehand, this will help prevent iterating on foods that don't belong to the given cuisine.\n\nFor grouping, we can again use a hash map (named `cuisineFoodMap`) that maps cuisine names and arrays of foods belonging to that particular cuisine. This hash map will enable quick retrieval of all foods belonging to a particular cuisine.\n\n![cuisineFoodMap](../Figures/2353/Slide1b.jpg)\n\n\nHowever, retrieving the highest-rated food would require iterating over all the foods of that particular cuisine each time. If we could maintain the food in `cuisineFoodMap` arrays in a sorted order (sorted according to ratings) then it might save us some time. \n\nYou might be thinking of sorting the array using the in-built `sort()` method, but if any element of the array changes (i.e. rating of any food changes) we will have to again sort the whole array using the `sort()` method, this will make the algorithm inefficient.**This hints that we should store the foods of a particular cuisine in a max-heap instead of an array.** \n\n> Max-heap data structure is a complete binary tree, where the parent nodes are always bigger than the corresponding child nodes, in order to keep the maximum-valued element at the root node of the tree. Here, pushing and popping an element are both logarithmic time operations, but getting the maximum-valued element is a constant time operation.\n\nIf you are new to this data structure we recommend that you read [Leetcode's Heap Explore Card](https://leetcode.com/explore/learn/card/heap/).We will use priority queues which are internally implemented using a heap. Each element of the priority queue will be an object of `class Food(integer foodRating, string foodName)`. To keep the appropriate element on the top of the priority queue we will use a custom comparator to define the logic for comparing two elements.\n\nSince the priority queue will keep the elements sorted based on their ratings, you might be thinking: when we modify the rating of food, do we need to remove this food with the old rating from the priority queue to ensure accuracy and then add the food with the new rating?\n\nFor example, if we change the rating of food `X` from `10` to `1`, the old data `(10, X)` in the queue might become the highest-rated food, which it shouldn't be. Should we remove it in this case?\n\n![change_rating](../Figures/2353/Slide2.jpg)\n\nFirst of all, searching for elements in the priority queue is a time-consuming task as in the worst case we would have to iterate over all elements stored in the priority queue.   \n\nSecondly, we can avoid the deletion of old rating elements.    \n\nIf we fetch any element `(foodRating, foodName)` from the priority queue then there are only two cases: either the element has the correct `foodRating` or an old rating.       \nOne food can only have one rating, we can verify the fetched element's `foodRating` with the rating stored in `foodRatingMap` against the key `foodName`. If the values don't match, it means the rating for `foodName` was changed and we can safely discard this fetched element of the priority queue and move on to the next highest rating in the priority queue.\n\n![remove_pq_element](../Figures/2353/Slide3.jpg)\n\nAlso remember that while changing the rating, it is necessary to get the cuisine name of that corresponding food to push the new rating element into the appropriate priority queue. To obtain the cuisine name, we must map the food name to its respective cuisine name as well using another hash map (say `foodCuisineMap`).\n\n\n![figure2](../Figures/2353/Slide4.jpg)\n\n\n![figure3](../Figures/2353/Slide5.jpg)\n\n\n\n#### Algorithm\n\n1. Create a class `Food` containing `foodRating` and `foodName` properties, and overload less than operator method to keep the highest rated or lexicographically smaller named element on the top in the priority queue.\n\n2. Create three hash maps:\n    - `foodRatingMap`, to store ratings associated with the respective food.\n    - `foodCuisineMap`, to store the cuisine name of the respective food.\n    - `cuisineFoodMap`, to store `Food(foodRating, foodName)` elements in a priority queue associated with the respective cuisine.\n\n3. Initialization. Iterate on all indices of the `foods` array, and for each index `i`:\n    - Store `(foods[i], ratings[i])` and `(foods[i], cuisines[i])` key-value pairs in `foodRatingMap` and `foodCuisineMap` respectively.\n    - Insert `Food(ratings[i], foods[i])` element in the priority queue of `cuisines[i]` key of `cuisineFoodMap`.\n\n4. Implementing `changeRating(food, newRating)` method:\n    - Update new rating in `foodRatingMap`.\n    - Fetch the cuisine name for `food` from `foodCuisineMap`.\n    - Insert the `Food(newRating, food)` element in the priority queue of the cuisine name in `cuisineFoodMap`.\n\n5. Implementing `highestRated(cuisine)` method:\n    - Get the top element `(i.e. highestRated)` from the priority queue of `cuisine` in `cuisineFoodMap`.\n    - If the rating of the top element and the rating of the corresponding food in `foodRatingMap` are not the same, i.e. `highestRated.foodRating != foodRatingMap[highestRated.foodName]`, then we discard and remove the current top element and fetch the next top element from the priority queue. Repeat this step until ratings are the same.\n    - Return the food name of the top element, i.e. `highestRated.foodName`.\n\n\n#### Implementation#### Complexity Analysis\n\nHere, $n$ is the initial size of the `foods` array, and let, $m$ be the number of calls made to `changeRating` and `highestRated` methods.\n\n* Time complexity:  $O(n \\log n +  m \\log (n + m))$\n    - **Initialization:**     \n        - We iterate over all `foods` elements and insert them into appropriate hash maps and priority queues. Inserting a value into the hash map takes constant time, but, inserting a value into the priority queue will take logarithmic time.      \n         - Thus, for $n$ elements, the total time taken will be $O(n \\log n)$ time.\n\n    - **changeRating(food, newRating)** method: \n        - Updating the rating in the hash map will take constant time.   \n        - But, in the worst case, the priority queue can contain $(n + m)$ elements, and inserting an element into the priority queue will take $O(\\log (n + m))$ time.   \n        - Thus, for $m$ insertions, the total time taken will be $O(m \\log (n + m))$ time.\n\n    - **highestRated(cuisine)** method:   \n        - Getting the cuisine name from the hash map and the top element of the priority queue are both constant time operations.     \n        - But, we might also remove some elements from the priority queue. Each removal operation will take $O(\\log (n + m))$ time. \n        - Each element is permanently unused after it is removed, i.e. they are removed at most once, so, for all `highestRated` method calls we may remove at most $m$ elements.      \n        - Thus, the total time taken for all calls will be $O(m \\log (n + m))$ time. \n\n* Space complexity: $O(n + m)$\n    - In `foodRatingMap`, and `foodCuisineMap` we will store all $n$ elements, thus, they both will take $O(n)$ space.\n    - In `cuisineFoodMap` we might insert $(n + m)$ elements, thus, it will take $O(n + m)$ space.---\n\n\n\n### Approach 2: Hash Maps and Sorted Set\n\n#### Intuition  \n\nUnlike in the previous approach, we can also use the built-in advanced data structure sorted/ordered set instead of max-heap.\n\n> This data structure internally uses a height-balanced binary search tree (like, a red-black tree, AVL tree, etc.) to keep the data sorted. Thus, pushing an element, popping an element, and getting the minimum-valued element are all logarithmic time operations because the tree balances itself after each operation.\n\nYou can read more about [Height-Balanced BST](https://leetcode.com/explore/learn/card/introduction-to-data-structure-binary-search-tree/143/appendix-height-balanced-bst/1021/) in our explore card. \n\nIn Python, we will use `SortedSet`, which is internally implemented as a sorted list that maintains its elements in sorted order. Here insertion and deletion algorithms often use binary search related techniques to achieve $O(\\log n)$ time complexity.\n\n> Note: This sorted set approach is not expected during the interview, but we are including it here for the completeness of the article and to familiarize you with a built-in advanced data structure.In this approach, we will show the implementation without defining an additional class and its custom comparator.     \nWe will use the `Pair` (another in-built data structure) to store the food's rating and food name elements in the sorted set. \n\nBy default, the sorted set sorts the elements in increasing order.     \nWe want to store the elements in decreasing order of food ratings, so we will store the food ratings by their negative values (because, if $ratingA > ratingB$ then $-ratingA < -ratingB$, so $-ratingA$ will be kept before $-ratingB$ in the sorted set).\n\nAlso, in the previous approach, we never deleted the old rating element from the priority queue as searching was a costly operation, however, in a sorted set, searching for an element also takes logarithmic time, so we will search and delete the old element and then insert the new element in the sorted set. Hence, sorted sets will not contain old rating elements, unlike priority queues in the previous approach.\n\n\n\n#### Algorithm\n\n1. Create three hash maps:\n    - `foodRatingMap`, to store ratings associated with the respective food.\n    - `foodCuisineMap`, to store the cuisine name of the respective food.\n    - `cuisineFoodMap`, to store `(-1 * foodRating, foodName)` pair elements in a sorted set associated with the respective cuisine.\n\n2. Initialization. Iterate on all indices of the `foods` array, and for each index `i`:\n    - Store `(foods[i], ratings[i])` and `(foods[i], cuisines[i])` key-value pairs in `foodRatingMap` and `foodCuisineMap` respectively.\n    - Insert `(-1 * ratings[i], foods[i])` pair element in the sorted set of `cuisines[i]` key of `cuisineFoodMap`.\n\n3. Implementing `changeRating(food, newRating)` method:\n    - Fetch the cuisine name for `food` from `foodRatingMap`.\n    - Delete the `(-1 * oldRating, food)` pair element from the sorted set of the cuisine name in `cuisineFoodMap`.\n    - Update new rating in `foodRatingMap`.\n    - Insert the `(-1 * newRating, food)` pair element in the sorted set of the cuisine name in `cuisineFoodMap`.\n\n4. Implementing `highestRated(cuisine)` method:\n    - Get the top element `(i.e. highestRated)` from the sorted set of `cuisine` in `cuisineFoodMap`.\n    - Return the food name of the top element, i.e. `highestRated.second`.\n\n\n\n#### Implementation#### Complexity Analysis\n\nHere, $n$ is the initial size of the `foods` array, and let, $m$ be the number of calls made to `changeRating` and `highestRated` methods.\n\n* Time complexity:  $O((n + m) \\log n)$\n    - **Initialization:**     \n        - We iterate over all `foods` elements and insert them into appropriate hash maps and sorted sets. Inserting a value into the hash map takes constant time, but, inserting a value into the sorted set will take logarithmic time.      \n         - Thus, for $n$ elements, the total time taken will be $O(n \\log n)$ time.\n\n    - **changeRating(food, newRating)** method: \n        - Updating the rating in the hash map will take constant time.   \n        - But, the sorted set will have $n$ elements, and inserting and deleting an element in it will take $O(\\log n)$ time.   \n        - Thus, for $m$ insertions, the total time taken will be $O(m \\log n)$ time.\n\n    - **highestRated(cuisine)** method:   \n        - Getting the cuisine name from the hash map is a constant time operation. \n        - The sorted set will have $n$ elements, in C++ and Java, getting the min element will take $\\log n$ time but in Python, it will take $O(1)$ time.   \n        - Thus, the total time taken for $m$ calls in C++ and Java will be $O(m \\log n)$ and in Python will be $O(m)$. \n\n* Space complexity: $O(n)$\n    - In `foodRatingMap`, `foodCuisineMap`, and `cuisineFoodMap` we will store $n$ elements.\n    - Thus, overall it will take $O(n)$ space."
}