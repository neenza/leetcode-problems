{
  "title": "Count Valid Paths in a Tree",
  "problem_id": "3112",
  "frontend_id": "2867",
  "difficulty": "Hard",
  "problem_slug": "count-valid-paths-in-a-tree",
  "topics": [
    "Math",
    "Dynamic Programming",
    "Tree",
    "Depth-First Search",
    "Number Theory"
  ],
  "description": "There is an undirected tree with n nodes labeled from 1 to n. You are given the integer n and a 2D integer array edges of length n - 1, where edges[i] = [ui, vi] indicates that there is an edge between nodes ui and vi in the tree.\nReturn the number of valid paths in the tree.\nA path (a, b) is valid if there exists exactly one prime number among the node labels in the path from a to b.\nNote that:\nExample 1:\nExample 2:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: n = 5, edges = [[1,2],[1,3],[2,4],[2,5]]\nOutput: 4\nExplanation: The pairs with exactly one prime number on the path between them are: \n- (1, 2) since the path from 1 to 2 contains prime number 2. \n- (1, 3) since the path from 1 to 3 contains prime number 3.\n- (1, 4) since the path from 1 to 4 contains prime number 2.\n- (2, 4) since the path from 2 to 4 contains prime number 2.\nIt can be shown that there are only 4 valid paths.",
      "images": [
        "https://assets.leetcode.com/uploads/2023/08/27/example1.png"
      ]
    },
    {
      "example_num": 2,
      "example_text": "Input: n = 6, edges = [[1,2],[1,3],[2,4],[3,5],[3,6]]\nOutput: 6\nExplanation: The pairs with exactly one prime number on the path between them are: \n- (1, 2) since the path from 1 to 2 contains prime number 2.\n- (1, 3) since the path from 1 to 3 contains prime number 3.\n- (1, 4) since the path from 1 to 4 contains prime number 2.\n- (1, 6) since the path from 1 to 6 contains prime number 3.\n- (2, 4) since the path from 2 to 4 contains prime number 2.\n- (3, 6) since the path from 3 to 6 contains prime number 3.\nIt can be shown that there are only 6 valid paths.",
      "images": [
        "https://assets.leetcode.com/uploads/2023/08/27/example2.png"
      ]
    }
  ],
  "constraints": [
    "1 <= n <= 105",
    "edges.length == n - 1",
    "edges[i].length == 2",
    "1 <= ui, vi <= n",
    "The input is generated such that edges represent a valid tree."
  ],
  "follow_ups": [],
  "hints": [
    "Use the sieve of Eratosthenes to find all prime numbers in the range <code>[1, n]</code>.****",
    "Root the tree at any node.",
    "Let <code>dp[i][0] = the number of vertical paths starting from i containing no prime nodes </code>, and <code>dp[i][1] = the number of vertical paths starting from i containing one prime node </code>.",
    "If <code>i</code> is not prime, <code>dp[i][0] = sum(dp[child][0]) + 1</code>, and <code>dp[i][1] = sum(dp[child][1])</code> for each <code>child</code> of <code>i</code> in the rooted tree.",
    "If <code>i</code> is prime, <code>dp[i][0] = 0</code>, and <code>dp[i][1] = sum(dp[child][0]) + 1</code> for each <code>child</code> of <code>i</code> in the rooted tree.",
    "For each node <code>i</code>, and using the computed <code>dp</code> matrix, count the number of unordered pairs <code>(a,b)</code> such that <code>lca(a,b) = i</code>, and there exists exactly one prime number on the path from <code>a</code> to <code>b</code>."
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    long long countPaths(int n, vector<vector<int>>& edges) {\n        \n    }\n};",
    "java": "class Solution {\n    public long countPaths(int n, int[][] edges) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def countPaths(self, n, edges):\n        \"\"\"\n        :type n: int\n        :type edges: List[List[int]]\n        :rtype: int\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def countPaths(self, n: int, edges: List[List[int]]) -> int:\n        ",
    "c": "long long countPaths(int n, int** edges, int edgesSize, int* edgesColSize) {\n    \n}",
    "csharp": "public class Solution {\n    public long CountPaths(int n, int[][] edges) {\n        \n    }\n}",
    "javascript": "/**\n * @param {number} n\n * @param {number[][]} edges\n * @return {number}\n */\nvar countPaths = function(n, edges) {\n    \n};",
    "typescript": "function countPaths(n: number, edges: number[][]): number {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param Integer $n\n     * @param Integer[][] $edges\n     * @return Integer\n     */\n    function countPaths($n, $edges) {\n        \n    }\n}",
    "swift": "class Solution {\n    func countPaths(_ n: Int, _ edges: [[Int]]) -> Int {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun countPaths(n: Int, edges: Array<IntArray>): Long {\n        \n    }\n}",
    "dart": "class Solution {\n  int countPaths(int n, List<List<int>> edges) {\n    \n  }\n}",
    "golang": "func countPaths(n int, edges [][]int) int64 {\n    \n}",
    "ruby": "# @param {Integer} n\n# @param {Integer[][]} edges\n# @return {Integer}\ndef count_paths(n, edges)\n    \nend",
    "scala": "object Solution {\n    def countPaths(n: Int, edges: Array[Array[Int]]): Long = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn count_paths(n: i32, edges: Vec<Vec<i32>>) -> i64 {\n        \n    }\n}",
    "racket": "(define/contract (count-paths n edges)\n  (-> exact-integer? (listof (listof exact-integer?)) exact-integer?)\n  )",
    "erlang": "-spec count_paths(N :: integer(), Edges :: [[integer()]]) -> integer().\ncount_paths(N, Edges) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec count_paths(n :: integer, edges :: [[integer]]) :: integer\n  def count_paths(n, edges) do\n    \n  end\nend"
  }
}