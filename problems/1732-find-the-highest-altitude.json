{
  "title": "Find the Highest Altitude",
  "problem_id": "1833",
  "frontend_id": "1732",
  "difficulty": "Easy",
  "problem_slug": "find-the-highest-altitude",
  "topics": [
    "Array",
    "Prefix Sum"
  ],
  "description": "There is a biker going on a road trip. The road trip consists of n + 1 points at different altitudes. The biker starts his trip on point 0 with altitude equal 0.\nYou are given an integer array gain of length n where gain[i] is the net gain in altitude between points i​​​​​​ and i + 1 for all (0 <= i < n). Return the highest altitude of a point.\nExample 1:\nExample 2:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: gain = [-5,1,5,0,-7]\nOutput: 1\nExplanation: The altitudes are [0,-5,-4,1,1,-6]. The highest is 1.",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input: gain = [-4,-3,-2,-1,4,3,2]\nOutput: 0\nExplanation: The altitudes are [0,-4,-7,-9,-10,-6,-3,-1]. The highest is 0.",
      "images": []
    }
  ],
  "constraints": [
    "n == gain.length",
    "1 <= n <= 100",
    "-100 <= gain[i] <= 100"
  ],
  "follow_ups": [],
  "hints": [
    "Let's note that the altitude of an element is the sum of gains of all the elements behind it",
    "Getting the altitudes can be done by getting the prefix sum array of the given array"
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    int largestAltitude(vector<int>& gain) {\n        \n    }\n};",
    "java": "class Solution {\n    public int largestAltitude(int[] gain) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def largestAltitude(self, gain):\n        \"\"\"\n        :type gain: List[int]\n        :rtype: int\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def largestAltitude(self, gain: List[int]) -> int:\n        ",
    "c": "int largestAltitude(int* gain, int gainSize) {\n    \n}",
    "csharp": "public class Solution {\n    public int LargestAltitude(int[] gain) {\n        \n    }\n}",
    "javascript": "/**\n * @param {number[]} gain\n * @return {number}\n */\nvar largestAltitude = function(gain) {\n    \n};",
    "typescript": "function largestAltitude(gain: number[]): number {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param Integer[] $gain\n     * @return Integer\n     */\n    function largestAltitude($gain) {\n        \n    }\n}",
    "swift": "class Solution {\n    func largestAltitude(_ gain: [Int]) -> Int {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun largestAltitude(gain: IntArray): Int {\n        \n    }\n}",
    "dart": "class Solution {\n  int largestAltitude(List<int> gain) {\n    \n  }\n}",
    "golang": "func largestAltitude(gain []int) int {\n    \n}",
    "ruby": "# @param {Integer[]} gain\n# @return {Integer}\ndef largest_altitude(gain)\n    \nend",
    "scala": "object Solution {\n    def largestAltitude(gain: Array[Int]): Int = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn largest_altitude(gain: Vec<i32>) -> i32 {\n        \n    }\n}",
    "racket": "(define/contract (largest-altitude gain)\n  (-> (listof exact-integer?) exact-integer?)\n  )",
    "erlang": "-spec largest_altitude(Gain :: [integer()]) -> integer().\nlargest_altitude(Gain) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec largest_altitude(gain :: [integer]) :: integer\n  def largest_altitude(gain) do\n    \n  end\nend"
  },
  "solution": "[TOC]\n\n## Solution\n\n--- \n\n### Approach: Prefix Sum\n\n**Intuition**\n\nWe start from the altitude `0` and we have a list of $N$ integers, where each integer represents the gain in altitude at each step (it could be negative as well, which implies a fall in altitude) a biker takes. We need to return the highest altitude of the biker in the complete journey, including the starting point at `0`.\n\nThis can be solved by taking the maximum altitudes at each step in the journey. The altitude at a step can be determined as the altitude at the previous step plus the gain at the current step. Hence, we will start from `0` and keep adding the gain in altitude to it at each step, and after each addition, we will update the maximum altitude we have seen so far.\n\n![fig](../Figures/1732/1732A.png)\n\nIf we observe closely, the altitude at a point is the sum of gains on the left of it, which is nothing but the prefix sum at this index. Therefore, we can find the prefix sum and return the maximum as the highest reached altitude.\n\n**Algorithm**\n\n1. Initialize the variable `currentAltitude` to `0`; this is the current altitude of the biker.\n2. Initialize the variable `highestPoint` to `currentAltitude`, as the highest altitude we have seen is `0`.\n3. Iterate over the gain in altitude in the list `gain` and add the current gain `altitudeGain` to the variable `currentAltitude`.\n4. Update the variable `highestPoint` as necessary.\n5. Return `highestPoint`.\n\n**Implementation****Complexity Analysis**\n\nHere, $N$ is the number of integers in the list `gain`.\n\n* Time complexity: $O(N)$.\n\n  We iterate over every integer in the list `gain` only once, and hence the total time complexity is equal to $O(N)$.\n\n* Space complexity: $O(1)$.\n\n  We only need two variables, `currentAltitude` and`highestPoint`; hence the space complexity is constant.---"
}