{
  "title": "Jump Game IV",
  "problem_id": "1447",
  "frontend_id": "1345",
  "difficulty": "Hard",
  "problem_slug": "jump-game-iv",
  "topics": [
    "Array",
    "Hash Table",
    "Breadth-First Search"
  ],
  "description": "Given an array ofÂ integers arr, you are initially positioned at the first index of the array.\nIn one step you can jump from index i to index:\nReturn the minimum number of steps to reach the last index of the array.\nNotice that you can not jump outside of the array at any time.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: arr = [100,-23,-23,404,100,23,23,23,3,404]\nOutput: 3\nExplanation: You need three jumps from index 0 --> 4 --> 3 --> 9. Note that index 9 is the last index of the array.",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input: arr = [7]\nOutput: 0\nExplanation: Start index is the last index. You do not need to jump.",
      "images": []
    },
    {
      "example_num": 3,
      "example_text": "Input: arr = [7,6,9,6,9,6,9,7]\nOutput: 1\nExplanation: You can jump directly from index 0 to index 7 which is last index of the array.",
      "images": []
    }
  ],
  "constraints": [
    "1 <= arr.length <= 5 * 104",
    "-108 <= arr[i] <= 108"
  ],
  "follow_ups": [],
  "hints": [
    "Build a graph of n nodes where nodes are the indices of the array and edges for node i are nodes i+1, i-1, j where arr[i] == arr[j].",
    "Start bfs from node 0 and keep distance. The answer is the distance when you reach node n-1."
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    int minJumps(vector<int>& arr) {\n        \n    }\n};",
    "java": "class Solution {\n    public int minJumps(int[] arr) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def minJumps(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: int\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def minJumps(self, arr: List[int]) -> int:\n        ",
    "c": "int minJumps(int* arr, int arrSize) {\n    \n}",
    "csharp": "public class Solution {\n    public int MinJumps(int[] arr) {\n        \n    }\n}",
    "javascript": "/**\n * @param {number[]} arr\n * @return {number}\n */\nvar minJumps = function(arr) {\n    \n};",
    "typescript": "function minJumps(arr: number[]): number {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param Integer[] $arr\n     * @return Integer\n     */\n    function minJumps($arr) {\n        \n    }\n}",
    "swift": "class Solution {\n    func minJumps(_ arr: [Int]) -> Int {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun minJumps(arr: IntArray): Int {\n        \n    }\n}",
    "dart": "class Solution {\n  int minJumps(List<int> arr) {\n    \n  }\n}",
    "golang": "func minJumps(arr []int) int {\n    \n}",
    "ruby": "# @param {Integer[]} arr\n# @return {Integer}\ndef min_jumps(arr)\n    \nend",
    "scala": "object Solution {\n    def minJumps(arr: Array[Int]): Int = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn min_jumps(arr: Vec<i32>) -> i32 {\n        \n    }\n}",
    "racket": "(define/contract (min-jumps arr)\n  (-> (listof exact-integer?) exact-integer?)\n  )",
    "erlang": "-spec min_jumps(Arr :: [integer()]) -> integer().\nmin_jumps(Arr) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec min_jumps(arr :: [integer]) :: integer\n  def min_jumps(arr) do\n    \n  end\nend"
  },
  "solution": "[TOC]\n\n## Solution\n\n---\n\n### Overview\n\nYou probably can guess from the problem title, this is the fourth problem in the series of [Jump Game](https://leetcode.com/problems/jump-game/) problems. Those problems are similar, but have considerable differences, making their solutions quite different.\n\nHere, two approaches are introduced: *Breadth-First Search* approach and *Bidirectional BFS* approach.\n\n---\n\n### Approach 1: Breadth-First Search\n\nMost solutions start from a brute force approach and are optimized by removing unnecessary calculations. Same as this one.\n\nA naive brute force approach is to iterate all the possible routes and check if there is one reaches the last index. However, if we already checked one index, we do not need to check it again. We can mark the index as visited by storing them in a `visited` set.\n\nFrom convenience, we can store nodes with the same value together in a `graph` dictionary. With this method, when searching, we do not need to iterate the whole list to find the nodes with the same value as the next steps, but only need to ask the precomputed dictionary. However, to prevent stepping back, we need to clear the dictionary after we get to that value.**Complexity Analysis**\n\nAssume $$N$$ is the length of `arr`.\n\n* Time complexity: $$\\mathcal{O}(N)$$ since we will visit every node at most once.\n\n* Space complexity: $$\\mathcal{O}(N)$$ since it needs `curs` and `nex` to store nodes.\n\n---\n\n### Approach 2: Bidirectional BFS\n\nIn the later part of our original BFS method, the layer may be long and takes a long time to compute the next layer. In this situation, we can compute the layer from the end, which may be short and takes less time.**Complexity Analysis**\n\nAssume $$N$$ is the length of `arr`.\n\n* Time complexity: $$\\mathcal{O}(N)$$ since we will visit every node at most once, but usually faster than approach 1.\n\n* Space complexity: $$\\mathcal{O}(N)$$ since it needs `curs`, `other` and `nex` to store nodes."
}