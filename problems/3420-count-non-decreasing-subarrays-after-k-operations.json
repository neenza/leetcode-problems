{
  "title": "Count Non-Decreasing Subarrays After K Operations",
  "problem_id": "3674",
  "frontend_id": "3420",
  "difficulty": "Hard",
  "problem_slug": "count-non-decreasing-subarrays-after-k-operations",
  "topics": [
    "Array",
    "Stack",
    "Segment Tree",
    "Queue",
    "Sliding Window",
    "Monotonic Stack",
    "Monotonic Queue"
  ],
  "description": "You are given an array nums of n integers and an integer k.\nFor each subarray of nums, you can apply up to k operations on it. In each operation, you increment any element of the subarray by 1.\nNote that each subarray is considered independently, meaning changes made to one subarray do not persist to another.\nReturn the number of subarrays that you can make non-decreasing ​​​​​after performing at most k operations.\nAn array is said to be non-decreasing if each element is greater than or equal to its previous element, if it exists.\nExample 1:\nExample 2:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: nums = [6,3,1,2,4,4], k = 7\nOutput: 17\nExplanation:\nOut of all 21 possible subarrays of nums , only the subarrays [6, 3, 1] , [6, 3, 1, 2] , [6, 3, 1, 2, 4] and [6, 3, 1, 2, 4, 4] cannot be made non-decreasing after applying up to k = 7 operations. Thus, the number of non-decreasing subarrays is 21 - 4 = 17 .",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input: nums = [6,3,1,3,6], k = 4\nOutput: 12\nExplanation:\nThe subarray [3, 1, 3, 6] along with all subarrays of nums with three or fewer elements, except [6, 3, 1] , can be made non-decreasing after k operations. There are 5 subarrays of a single element, 4 subarrays of two elements, and 2 subarrays of three elements except [6, 3, 1] , so there are 1 + 5 + 4 + 2 = 12 subarrays that can be made non-decreasing.",
      "images": []
    }
  ],
  "constraints": [
    "1 <= nums.length <= 105",
    "1 <= nums[i] <= 109",
    "1 <= k <= 109"
  ],
  "follow_ups": [],
  "hints": [
    "Use a sparse table.",
    "Compute <code>sp[e][i] = [lastElement, operations]</code> where <code>operations</code> is the number of <code>operations</code> required to make the subarray <code>nums[i...i + 2^e - 1]</code> non-decreasing, and <code>lastElement</code> be the value of the last element after the operations were applied on it.",
    "How can we combine <code>sp[a][i]</code> with <code>sp[b][i + 2^a]</code> to find the answer for the subarray <code>nums[i...i + 2^a + 2^b - 1]</code>?"
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    long long countNonDecreasingSubarrays(vector<int>& nums, int k) {\n        \n    }\n};",
    "java": "class Solution {\n    public long countNonDecreasingSubarrays(int[] nums, int k) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def countNonDecreasingSubarrays(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def countNonDecreasingSubarrays(self, nums: List[int], k: int) -> int:\n        ",
    "c": "long long countNonDecreasingSubarrays(int* nums, int numsSize, int k) {\n    \n}",
    "csharp": "public class Solution {\n    public long CountNonDecreasingSubarrays(int[] nums, int k) {\n        \n    }\n}",
    "javascript": "/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number}\n */\nvar countNonDecreasingSubarrays = function(nums, k) {\n    \n};",
    "typescript": "function countNonDecreasingSubarrays(nums: number[], k: number): number {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @param Integer $k\n     * @return Integer\n     */\n    function countNonDecreasingSubarrays($nums, $k) {\n        \n    }\n}",
    "swift": "class Solution {\n    func countNonDecreasingSubarrays(_ nums: [Int], _ k: Int) -> Int {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun countNonDecreasingSubarrays(nums: IntArray, k: Int): Long {\n        \n    }\n}",
    "dart": "class Solution {\n  int countNonDecreasingSubarrays(List<int> nums, int k) {\n    \n  }\n}",
    "golang": "func countNonDecreasingSubarrays(nums []int, k int) int64 {\n    \n}",
    "ruby": "# @param {Integer[]} nums\n# @param {Integer} k\n# @return {Integer}\ndef count_non_decreasing_subarrays(nums, k)\n    \nend",
    "scala": "object Solution {\n    def countNonDecreasingSubarrays(nums: Array[Int], k: Int): Long = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn count_non_decreasing_subarrays(nums: Vec<i32>, k: i32) -> i64 {\n        \n    }\n}",
    "racket": "(define/contract (count-non-decreasing-subarrays nums k)\n  (-> (listof exact-integer?) exact-integer? exact-integer?)\n  )",
    "erlang": "-spec count_non_decreasing_subarrays(Nums :: [integer()], K :: integer()) -> integer().\ncount_non_decreasing_subarrays(Nums, K) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec count_non_decreasing_subarrays(nums :: [integer], k :: integer) :: integer\n  def count_non_decreasing_subarrays(nums, k) do\n    \n  end\nend"
  }
}