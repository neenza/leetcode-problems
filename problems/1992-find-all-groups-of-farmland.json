{
  "title": "Find All Groups of Farmland",
  "problem_id": "2103",
  "frontend_id": "1992",
  "difficulty": "Medium",
  "problem_slug": "find-all-groups-of-farmland",
  "topics": [
    "Array",
    "Depth-First Search",
    "Breadth-First Search",
    "Matrix"
  ],
  "description": "You are given a 0-indexed m x n binary matrix land where a 0 represents a hectare of forested land and a 1 represents a hectare of farmland.\nTo keep the land organized, there are designated rectangular areas of hectares that consist entirely of farmland. These rectangular areas are called groups. No two groups are adjacent, meaning farmland in one group is not four-directionally adjacent to another farmland in a different group.\nland can be represented by a coordinate system where the top left corner of land is (0, 0) and the bottom right corner of land is (m-1, n-1). Find the coordinates of the top left and bottom right corner of each group of farmland. A group of farmland with a top left corner at (r1, c1) and a bottom right corner at (r2, c2) is represented by the 4-length array [r1, c1, r2, c2].\nReturn a 2D array containing the 4-length arrays described above for each group of farmland in land. If there are no groups of farmland, return an empty array. You may return the answer in any order.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: land = [[1,0,0],[0,1,1],[0,1,1]]\nOutput: [[0,0,0,0],[1,1,2,2]]\nExplanation:\nThe first group has a top left corner at land[0][0] and a bottom right corner at land[0][0].\nThe second group has a top left corner at land[1][1] and a bottom right corner at land[2][2].",
      "images": [
        "https://assets.leetcode.com/uploads/2021/07/27/screenshot-2021-07-27-at-12-23-15-copy-of-diagram-drawio-diagrams-net.png"
      ]
    },
    {
      "example_num": 2,
      "example_text": "Input: land = [[1,1],[1,1]]\nOutput: [[0,0,1,1]]\nExplanation:\nThe first group has a top left corner at land[0][0] and a bottom right corner at land[1][1].",
      "images": [
        "https://assets.leetcode.com/uploads/2021/07/27/screenshot-2021-07-27-at-12-30-26-copy-of-diagram-drawio-diagrams-net.png"
      ]
    },
    {
      "example_num": 3,
      "example_text": "Input: land = [[0]]\nOutput: []\nExplanation:\nThere are no groups of farmland.",
      "images": [
        "https://assets.leetcode.com/uploads/2021/07/27/screenshot-2021-07-27-at-12-32-24-copy-of-diagram-drawio-diagrams-net.png"
      ]
    }
  ],
  "constraints": [
    "m == land.length",
    "n == land[i].length",
    "1 <= m, n <= 300",
    "land consists of only 0's and 1's.",
    "Groups of farmland are rectangular in shape."
  ],
  "follow_ups": [],
  "hints": [
    "Since every group of farmland is rectangular, the top left corner of each group will have the smallest x-coordinate and y-coordinate of any farmland in the group.",
    "Similarly, the bottom right corner of each group will have the largest x-coordinate and y-coordinate of any farmland in the group.",
    "Use DFS to traverse through different groups of farmlands and keep track of the smallest and largest x-coordinate and y-coordinates you have seen in each group."
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    vector<vector<int>> findFarmland(vector<vector<int>>& land) {\n        \n    }\n};",
    "java": "class Solution {\n    public int[][] findFarmland(int[][] land) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def findFarmland(self, land):\n        \"\"\"\n        :type land: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def findFarmland(self, land: List[List[int]]) -> List[List[int]]:\n        ",
    "c": "/**\n * Return an array of arrays of size *returnSize.\n * The sizes of the arrays are returned as *returnColumnSizes array.\n * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().\n */\nint** findFarmland(int** land, int landSize, int* landColSize, int* returnSize, int** returnColumnSizes) {\n    \n}",
    "csharp": "public class Solution {\n    public int[][] FindFarmland(int[][] land) {\n        \n    }\n}",
    "javascript": "/**\n * @param {number[][]} land\n * @return {number[][]}\n */\nvar findFarmland = function(land) {\n    \n};",
    "typescript": "function findFarmland(land: number[][]): number[][] {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param Integer[][] $land\n     * @return Integer[][]\n     */\n    function findFarmland($land) {\n        \n    }\n}",
    "swift": "class Solution {\n    func findFarmland(_ land: [[Int]]) -> [[Int]] {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun findFarmland(land: Array<IntArray>): Array<IntArray> {\n        \n    }\n}",
    "dart": "class Solution {\n  List<List<int>> findFarmland(List<List<int>> land) {\n    \n  }\n}",
    "golang": "func findFarmland(land [][]int) [][]int {\n    \n}",
    "ruby": "# @param {Integer[][]} land\n# @return {Integer[][]}\ndef find_farmland(land)\n    \nend",
    "scala": "object Solution {\n    def findFarmland(land: Array[Array[Int]]): Array[Array[Int]] = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn find_farmland(land: Vec<Vec<i32>>) -> Vec<Vec<i32>> {\n        \n    }\n}",
    "racket": "(define/contract (find-farmland land)\n  (-> (listof (listof exact-integer?)) (listof (listof exact-integer?)))\n  )",
    "erlang": "-spec find_farmland(Land :: [[integer()]]) -> [[integer()]].\nfind_farmland(Land) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec find_farmland(land :: [[integer]]) :: [[integer]]\n  def find_farmland(land) do\n    \n  end\nend"
  },
  "solution": "## Solution\n\n---\n\n### Overview\n\nWe are given a binary matrix of `0s` and `1s` of size `M x N`. The value `0` represents the forest land and `1` represents the farmland. We need to return a list with the top left and bottom right coordinates of each farmland in the matrix. All farmlands are rectangular. We can leverage this fact to make our search for farmland more efficient. From a given farmland cell, we can determine which of the eight neighboring cells is farmland by checking just four neighbors (left, right, up, and down). We don't need to check the diagonal neighbors because we can infer whether they are farmland. For example, if the cells on the right and below a farmland cell are also farmland, then the diagonal cell, as shown below, will have to be a farmland cell for this farmland to be rectangular.\n\n![fig](../Figures/1992/1992B.png)\n\nTherefore, this problem is similar to this [Number of Islands](https://leetcode.com/problems/number-of-islands/) problem, except the components (islands of farmland) here will always be rectangular. We will use this property in our third greedy approach. The first two approaches, DFS & BFS, are similar to the one applied in [Number of Islands soluton](https://leetcode.com/problems/number-of-islands/solution/).\n\n![fig](../Figures/1992/1992A.png)\n\n\n> Note: In the following two approaches below, we used a separate array to keep track of visited cells; this could be done using the original input matrix. However, in an interview setting, altering the inputs is not recommended. We have applied this input-altering strategy in our last approach to demonstrate how it can be done.\n\n----\n\n### Approach 1: Depth-First Search\n\n#### Intuition\n\nWe need to find all the cells in each farmland. We will apply a depth-first search from each of the cells with the value `1` that has not yet been visited. In the depth-first search process, we will traverse each of the four connected neighbors with the value `1` and apply DFS. This way, we can traverse over all the cells in each farmland.\n\nWe need a way to find the top left and bottom right cell coordinates of each farmland. Since the order of cell traversal in DFS is not fixed, there is no way to find when the last cell will be visited. To solve this, we can keep the maximum `x` and `y` coordinates we have seen so far. This way the maximum `x` and `y` coordinates will refer to the bottom right coordinates, and the coordinate of the cell with which we started the DFS will be the top left coordinate.\n\n#### Algorithm\n\n1. Iterate over each cell in the matrix `land`, and for each cell `(row1, col1)`, do the following:\n\n    - If the cell is a farmland cell, i.e. `land[row1][col1] = 1`, and hasn't been visited yet (`visited[row1][col1] = 0`), start DFS from `(row1, col1)`. Also, keep two variables `row2` and `col2` as the coordinates of the bottom right corner initialized with `0` each.\n    - In the DFS, mark the current coordinates as visited and update the values of `row2` and `col2` to the maximum compared with the current coordinates.\n    - Traverse over the four neighbors and apply DFS if the neighbor is within the matrix boundary, a farmland cell, and hasn't been visited yet.\n    - When the DFS is complete, store the top left coordinate as `(row1, col1)` and the bottom right as `(row2, col2)` in the list `ans`.\n\n2. Return `ans`.\n\n#### Implementation#### Complexity Analysis\n\nHere, $M$ is the number of rows in the matrix and $N$ is the number of columns in the matrix.\n\n* Time complexity: $O(M \\cdot N)$\n\n  We will iterate over each cell in the matrix at most once because we used the `visited` array to prevent re-processing cells. All other helper functions like `isWithinFarm` are $O(1)$. Hence, the total time complexity is $O(M \\cdot N)$.\n\n* Space complexity: $O(M \\cdot N)$\n\n  The array `visited` is of size $M \\cdot N$; also, there will be stack space consumed by DFS that will be equal to the maximum number of active stack calls, which will be equal to $M * N$ if all cells are `1` in the matrix. Apart from this, there is also array `ans`, but the space used to store the result isn't considered part of space complexity. Hence, the total space complexity is $O(M \\cdot N)$.\n\n---\n\n### Approach 2: Breadth-First Search\n\n#### Intuition\n\nSimilarly to the previous approach, we will traverse over each farmland and store the top left and bottom right corner coordinates in our answer. We will use the breadth-first search here to iterate over each cell. Iterating over the matrix, we will enqueue the first cell and mark it visited in the array `visited`. In the BFS, we will pop the cell from the queue, iterate over the four neighbors, and add them to the queue if the farmland cells have not been visited yet.\n\nIn BFS, the cells are visited in fixed order using a queue, and hence, we can identify the last visited cell in this group of farmland. Therefore, we don't need to keep the maximum coordinates we have seen. We can store the last cell we visit from the current group of farmland in the BFS, which would be the coordinates of the current farmland in the bottom right corner.\n\n#### Algorithm\n\n1. Iterate over each cell in the matrix `land` and for each cell `(row1, col1)` do the following:\n\n    - If the cell is a farmland cell, i.e `land[row1][col1] = 1` and isn't visited yet (`visited[row1][col1] = 0`), enqueue it to the queue start BFS from `(row1, col1)`.\n    - Traverse over the four neighbors and add them to the queue for BFS if the neighbor is within the matrix boundary and is a farmland cell and hasn't visited yet. Also, mark these coordinates as visited.\n    - When the BFS completes return the last coordinate that was popped from the queue and store the top left coordinate as `(row1, col1)` and the bottom right as the last visited node in the list `ans`.\n\n2. Return `ans`.\n\n#### Implementation#### Complexity Analysis\n\nHere, $M$ is the number of rows in the matrix and $N$ is the number of columns in the matrix.\n\n* Time complexity: $O(M \\cdot N)$\n\n  We will iterate over each cell in the matrix at most once because of the `visited` array. All other helper functions like `isWithinFarm` are $O(1)$. Hence, the total time complexity is $O(M \\cdot N)$.\n\n* Space complexity: $O(M \\cdot N)$\n\n  The array `visited` is of size $M \\cdot N$, also there will be space consumed by the queue that can be equal to $M * N$ if all cells are `1` in the matrix. Apart from this, there is also array `ans`, but the space used to store the result isn't considered as part of the space complexity. Hence, the total space complexity is $O(M \\cdot N)$.\n\n---\n### Approach 3: Greedy\n\n#### Intuition\n\nWe can solve this problem with a greedy approach because all farmlands will be rectangular. DFS and BFS approaches are able to find irregularly shaped farmland. Since farmlands are rectangular, we can just start from the first farmland cell, the top left corner, and iterate over the cells in the current row until we find a cell with the value `0`. The y-coordinate of this cell will be the `y` coordinate of the bottom right corner. We can then iterate over the cells with this `y` coordinate and increase the `x` coordinate until we find the cell with value `0`, this will be the bottom right corner of the current farmland.\n\nWe will also need to keep track of which cells have already been visited. We could use a separate array `visited` as we did in the last two approaches, but we will use the input matrix here to demonstrate another strategy. We mark all cells with values `1` to `0` in the farmland so that we don't visit them again and consider them as separate farmland. Please note that in an interview setting changing the input is generally discouraged.\n\nThis way, we will start from the first cell with the value `1` and then find the bottom right corner coordinate using the above strategy, then store the resulting coordinates in the list `ans`.\n\n#### Algorithm\n\n- Initialize dimensions `M` and `N` to represent the number of rows and columns in the `land` grid.\n- Create a `res` array to store the top-left and bottom-right coordinates of each farmland plot.\n\n- Iterate through each cell in the grid using nested loops:\n  - For every cell `(row1, col1)`, check if it is part of farmland (`land[row1][col1] == 1`).\n  - If farmland is found, initialize `x` to `row1` and `y` to `col1`.\n\n- Expand the farmland boundaries:\n  - Increment `x` until you find the last row where `land[x][col1] == 1`.\n  - For each row in this range, increment `y` until you find the last column where `land[x][y] == 1`.\n  - Mark all cells in the identified rectangle as `0` to avoid revisiting them.\n\n- Record the top-left `(row1, col1)` and bottom-right `(x - 1, y - 1)` coordinates of the current farmland plot in `res`.\n\n- Return the `res` array containing the coordinates of all identified farmland plots.\n\n#### Implementation#### Complexity Analysis\n\nHere, $M$ is the number of rows in the matrix and $N$ is the number of columns in the matrix.\n\n* Time complexity: $O(M \\cdot N)$\n\n  We will iterate over each cell in the matrix at most once because we mark the visited cells in the `land`  array.  Hence, the total time complexity is $O(M \\cdot N)$.\n\n* Space complexity: $O(1)$\n\n  The only space required is `ans` but the space used to store the result isn't considered as part of space complexity. Hence, the total space complexity is constant.\n\n---"
}