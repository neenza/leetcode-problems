{
  "title": "Game Play Analysis IV",
  "problem_id": "1182",
  "frontend_id": "550",
  "difficulty": "Medium",
  "problem_slug": "game-play-analysis-iv",
  "topics": [
    "Database"
  ],
  "description": "Table: Activity\nWrite a solution to report the fraction of players that logged in again on the day after the day they first logged in, rounded to 2 decimal places. In other words, you need to determine the number of players who logged in on the day immediately following their initial login, and divide it by the number of total players.\nThe result format is in the following example.\nExample 1:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "+--------------+---------+\n| Column Name  | Type    |\n+--------------+---------+\n| player_id    | int     |\n| device_id    | int     |\n| event_date   | date    |\n| games_played | int     |\n+--------------+---------+\n(player_id, event_date) is the primary key (combination of columns with unique values) of this table.\nThis table shows the activity of players of some games.\nEach row is a record of a player who logged in and played a number of games (possibly 0) before logging out on someday using some device.",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input: \nActivity table:\n+-----------+-----------+------------+--------------+\n| player_id | device_id | event_date | games_played |\n+-----------+-----------+------------+--------------+\n| 1         | 2         | 2016-03-01 | 5            |\n| 1         | 2         | 2016-03-02 | 6            |\n| 2         | 3         | 2017-06-25 | 1            |\n| 3         | 1         | 2016-03-02 | 0            |\n| 3         | 4         | 2018-07-03 | 5            |\n+-----------+-----------+------------+--------------+\nOutput: \n+-----------+\n| fraction  |\n+-----------+\n| 0.33      |\n+-----------+\nExplanation: \nOnly the player with id 1 logged back in after the first day he had logged in so the answer is 1/3 = 0.33",
      "images": []
    }
  ],
  "constraints": [],
  "follow_ups": [],
  "hints": [],
  "code_snippets": {
    "mysql": "# Write your MySQL query statement below\n",
    "mssql": "/* Write your T-SQL query statement below */\n",
    "oraclesql": "/* Write your PL/SQL query statement below */\n",
    "pythondata": "import pandas as pd\n\ndef gameplay_analysis(activity: pd.DataFrame) -> pd.DataFrame:\n    ",
    "postgresql": "-- Write your PostgreSQL query statement below\n"
  },
  "solution": "[TOC]\n\n# Solution\n---\n\n### Overview\n\n> **Problem reference:** Write a solution to report the fraction of players that logged in again on the day after the day they first logged in, rounded to 2 decimal places. In other words, you need to count the number of players that logged in for at least two consecutive days starting from their first login date, then divide that number by the total number of players.\n\nThis problem is a natural extension or follow-up to [part\nII](https://leetcode.com/problems/game-play-analysis-ii/) of the five-part Game Play Analysis problem series. Why? Because counting the number of players who logged in for at least two consecutive days starting from their first login date naturally involves starting the problem-solving process by finding out the first login date for each player (which, we should note, actually *is* the solution to [part I](https://leetcode.com/problems/game-play-analysis-i/) in this problem series).\n\n\nBut finding each player's first login date is only a start to solving this\nproblem. We need to somehow use this information to determine whether or not\neach player under consideration logged in the day after their first log in\ndate. How we go about making this determination is the crux of this problem.\n\n---\n\n## pandas\n\n### Approach 1: Date Manipulation and Conditional Aggregation\n\n**Visualization of approach 1**\n\n![fig](../Figures/550/550-1.png)\n\n#### Intuition\n\nLet's breakdown the steps involved in this approach given the followin input DataFrame:player_iddevice_idevent_dategames_played122016-03-015122016-03-026232017-06-251312016-03-020342018-07-035**Step 1: Identifying the First Login Date**\n   - **Objective**: To determine the first date each player logged in.\n   - **Intuition**: By grouping the data by `player_id` and getting the minimum `event_date`, we pinpoint the initial login date for each individual player. This forms our baseline for tracking each player's login activity over time.\n```python\nfirst_login = activity.groupby('player_id')['event_date'].min().reset_index()\n```player_idevent_date12016-03-0122017-06-2532016-03-02**Step 2: Calculating the Day Before Each Event Date**\n   - **Objective**: To facilitate identifying consecutive logins.\n   - **Intuition**: Note that in the question, consecutive dates actually represent two adjacent dates with a one-day difference. Therefore, we create a column that represents the day before each `event_date` to help us identify consecutive logins in the subsequent steps. This column will essentially allow us to match it with the first login date to see if a player logged in consecutively. For instance, if a player first logged in on `2016-03-02` and had consecutive logins on `2016-03-03`, we would add a value of `day_before_event = 2016-03-02` to the second record, which matches the first login date.\n\n```python\nactivity['day_before_event'] = activity['event_date'] - pd.to_timedelta(1, unit='D')\n```player_iddevice_idevent_dategames_playedday_before_event122016-03-0152016-02-29122016-03-0262016-03-01232017-06-2512017-06-24312016-03-0202016-03-01342018-07-0352018-07-02**Step 3: Merging DataFrames to Identify Potential Consecutive Logins**\n   - **Objective**: To align actual login dates with the first login dates of each player.\n   - **Intuition**: We merge the data on 'player_id' to get a combined dataset where we have details of each playerâ€™s first login day along with all other days they logged in. This prepares us to directly compare whether any of the actual login dates align with a day after the first login date, highlighting consecutive logins.\n\n```python\nmerged_df = activity.merge(first_login, on='player_id', suffixes=('_actual', '_first'))\n```player_iddevice_idevent_date_actualgames_playedday_before_eventevent_date_first122016-03-0152016-02-292016-03-01122016-03-0262016-03-012016-03-01232017-06-2512017-06-242017-06-25312016-03-0202016-03-012016-03-02342018-07-0352018-07-022016-03-02**Step 4: Identifying Consecutive Logins**\n   - **Objective**: To pinpoint the exact instances of consecutive logins occurring a day after the first login.\n   - **Intuition**: By filtering the merged dataset for rows where the 'day_before_event' equals the 'event_date_first', we identify the precise moments where a login took place a day after the first login, effectively highlighting consecutive logins.\n\n```python\nconsecutive_login = merged_df[merged_df['day_before_event'] == merged_df['event_date_first']]\n```player_iddevice_idevent_date_actualgames_playedday_before_eventevent_date_first122016-03-0262016-03-012016-03-01**Step 5: Computing the Fraction of Consecutive Logins**\n   - **Objective**: To find the fraction representing players who logged back in the day following their first login.\n   - **Intuition**: Here we find the unique count of players who logged in consecutively and divide it by the total unique count of players in the dataset. This yields the proportion of players who exhibited this behavior, giving us a sense of player retention after the first login.\n\n```python\nfraction = round(consecutive_login['player_id'].nunique() / activity['player_id'].nunique(), 2)\n```\nReturns: `0.33`\n\n**Step 6: Formatting the Output**\n   - **Objective**: To prepare the final output.\n   - **Intuition**: Creating a new DataFrame to hold the calculated fraction ensures that we can return the results in a structured and readable format, fulfilling the requirements of our function's return type.\n\n```python\noutput_df = pd.DataFrame({'fraction': [fraction]})\n```fraction0.33#### Implementation\n\n```python\nimport pandas as pd\n\ndef gameplay_analysis(activity: pd.DataFrame) -> pd.DataFrame:\n    # Step 1: Find the first login date for each player\n    first_login = activity.groupby('player_id')['event_date'].min().reset_index()\n    \n    # Step 2: Create a new column for the day before each event_date in the original DataFrame\n    activity['day_before_event'] = activity['event_date'] - pd.to_timedelta(1, unit='D')\n    \n    # Step 3: Merge the dataframes to find rows where player logged in a day after their first login\n    merged_df = activity.merge(first_login, on='player_id', suffixes=('_actual', '_first'))\n    \n    # Step 4: Find the rows where the actual event date matches the day after the first login date\n    consecutive_login = merged_df[merged_df['day_before_event'] == merged_df['event_date_first']]\n    \n    # Step 5: Calculate the fraction of players that logged in again on the day after their first login\n    fraction = round(consecutive_login['player_id'].nunique() / activity['player_id'].nunique(), 2)\n    \n    # Step 6: Create a dataframe to hold the output\n    output_df = pd.DataFrame({'fraction': [fraction]})\n    \n    return output_df\n```\n\n\n---\n\n## Database\n\n### Approach 1: Subqueries and multi-value use of the `IN` comparison operator\n\n#### Intuition\n\nThe preferred solution approach to [part\nII](https://leetcode.com/problems/game-play-analysis-ii/) in this problem\nseries involved using the `IN` comparison operator in a rather creative or\nnuanced way, namely *using more than a single value* for comparison:\n\n```sql\nSELECT\n  A1.player_id,\n  A1.device_id\nFROM\n  Activity A1\nWHERE\n  (A1.player_id, A1.event_date) IN (\n    SELECT\n      A2.player_id,\n      MIN(A2.event_date)\n    FROM\n      Activity A2\n    GROUP BY\n      A2.player_id\n  );\n```\n\nWe can use a similar idea for this problem, where, again, we rely on our\nability to access the tuples `(player_id, first_login)` in some manner:\n\n```sql\n(val1, val2) IN (\n  SELECT\n    A.player_id,\n    MIN(A.event_date) AS first_login\n  FROM\n    Activity A\n  GROUP BY\n    A.player_id\n)\n```\n\nBut what should `val1` and `val2` be? We must have `player_id` as `val1`, but the choice for `val2` is less apparent. We need, in some form or fashion, to be able to relate `val2` to the first login date corresponding to the `player_id` represented by `val1`; specifically, `val2` needs to be a date that is one day *after* the first login date being referenced. How can we achieve this?\n\n#### Algorithm\n\n1. Find the first login date for each player: `(player_id, first_login)`.\n2. Determine which tuples, if any, exist such that\n\n    ```\n    (player_id, day_after_first_login) = (player_id, first_login)\n    ```\n\n    The existence of such a tuple will confirm that whichever `player_id` is\n    being considered logged in the day after their first login date (i.e.,\n    `day_after_first_login`).\n\n3. Divide the total number of `player_id` values obtained from the process\n   described above by the *total number* of distinct `player_id` values from\n   the entire `Activity` table and round the result to two decimal places.\n\n#### Implementation\n\n##### MySQL\n\n```sql\nSELECT\n  ROUND(\n    COUNT(A1.player_id)\n    / (SELECT COUNT(DISTINCT A3.player_id) FROM Activity A3)\n  , 2) AS fraction\nFROM\n  Activity A1\nWHERE\n  (A1.player_id, DATE_SUB(A1.event_date, INTERVAL 1 DAY)) IN (\n    SELECT\n      A2.player_id,\n      MIN(A2.event_date)\n    FROM\n      Activity A2\n    GROUP BY\n      A2.player_id\n  );\n```\n\n**Note:** We only need to use `COUNT(A1.player_id)` in the `ROUND()` function above as opposed to `COUNT(DISTINCT A1.player_id)` since `(player_id, event_date)` is the primary key of the `Activity` table (i.e., it is not possible for the same player to have duplicated `event_date` entries for the date after the player's initial login date).\n\n---\n\n### Approach 2: CTEs and `INNER JOIN`\n\n#### Intuition\n\nCommon table expressions (CTEs) are powerful not only because of what they\nallow us to *do* but also because of how they allow us to *think*. We can use CTEs to our advantage here so as to approach the problem-solving process in a more or less \"linear\" fashion:\n\n1. Identify the first login date for each player.\n2. Identify the number of players who logged in the day after their first login date.\n3. Divide the number of players identified in step 2 by the number of players identified in step 1 and round the result to two decimal places.\n\n#### Algorithm\n\nSee above.\n\n#### Implementation\n\n##### MySQL\n\n```sql\nWITH first_logins AS (\n  SELECT\n    A.player_id,\n    MIN(A.event_date) AS first_login\n  FROM\n    Activity A\n  GROUP BY\n    A.player_id\n), consec_logins AS (\n  SELECT\n    COUNT(A.player_id) AS num_logins\n  FROM\n    first_logins F\n    INNER JOIN Activity A ON F.player_id = A.player_id\n    AND F.first_login = DATE_SUB(A.event_date, INTERVAL 1 DAY)\n)\nSELECT\n  ROUND(\n    (SELECT C.num_logins FROM consec_logins C)\n    / (SELECT COUNT(F.player_id) FROM first_logins F)\n  , 2) AS fraction;\n```\n\n**Note:** As with Approach 1, observe that `COUNT(A.player_id)` is sufficient in the `consec_logins` CTE since `(player_id, event_date)` is the primary key of the `Activity` table.\n\n---\n\n### Database Conclusion\n\nApproach 1 is beautiful in its own right. It is elegant and builds on work done previously throughout this problem series. But we prefer Approach 2 due to its relative simplicity, performance, and rather principled approach. Specifically, you may be hard-pressed to come up with Approach 1 on the spot in an interview. It should be much more manageable to reproduce a solution akin to Approach 2 in an interview setting."
}