{
  "title": "Find Polygon With the Largest Perimeter",
  "problem_id": "3262",
  "frontend_id": "2971",
  "difficulty": "Medium",
  "problem_slug": "find-polygon-with-the-largest-perimeter",
  "topics": [
    "Array",
    "Greedy",
    "Sorting",
    "Prefix Sum"
  ],
  "description": "You are given an array of positive integers nums of length n.\nA polygon is a closed plane figure that has at least 3 sides. The longest side of a polygon is smaller than the sum of its other sides.\nConversely, if you have k (k >= 3) positive real numbers a1, a2, a3, ..., ak where a1 <= a2 <= a3 <= ... <= ak and a1 + a2 + a3 + ... + ak-1 > ak, then there always exists a polygon with k sides whose lengths are a1, a2, a3, ..., ak.\nThe perimeter of a polygon is the sum of lengths of its sides.\nReturn the largest possible perimeter of a polygon whose sides can be formed from nums, or -1 if it is not possible to create a polygon.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: nums = [5,5,5]\nOutput: 15\nExplanation: The only possible polygon that can be made from nums has 3 sides: 5, 5, and 5. The perimeter is 5 + 5 + 5 = 15.",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input: nums = [1,12,1,2,5,50,3]\nOutput: 12\nExplanation: The polygon with the largest perimeter which can be made from nums has 5 sides: 1, 1, 2, 3, and 5. The perimeter is 1 + 1 + 2 + 3 + 5 = 12.\nWe cannot have a polygon with either 12 or 50 as the longest side because it is not possible to include 2 or more smaller sides that have a greater sum than either of them.\nIt can be shown that the largest possible perimeter is 12.",
      "images": []
    },
    {
      "example_num": 3,
      "example_text": "Input: nums = [5,5,50]\nOutput: -1\nExplanation: There is no possible way to form a polygon from nums, as a polygon has at least 3 sides and 50 > 5 + 5.",
      "images": []
    }
  ],
  "constraints": [
    "3 <= n <= 105",
    "1 <= nums[i] <= 109"
  ],
  "follow_ups": [],
  "hints": [
    "Sort the array.",
    "Use greedy algorithm. If we select an edge as the longest side, it is always better to pick up all the edges with length no longer than this longest edge.",
    "Note that the number of edges should not be less than 3."
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    long long largestPerimeter(vector<int>& nums) {\n        \n    }\n};",
    "java": "class Solution {\n    public long largestPerimeter(int[] nums) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def largestPerimeter(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def largestPerimeter(self, nums: List[int]) -> int:\n        ",
    "c": "long long largestPerimeter(int* nums, int numsSize) {\n    \n}",
    "csharp": "public class Solution {\n    public long LargestPerimeter(int[] nums) {\n        \n    }\n}",
    "javascript": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar largestPerimeter = function(nums) {\n    \n};",
    "typescript": "function largestPerimeter(nums: number[]): number {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @return Integer\n     */\n    function largestPerimeter($nums) {\n        \n    }\n}",
    "swift": "class Solution {\n    func largestPerimeter(_ nums: [Int]) -> Int {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun largestPerimeter(nums: IntArray): Long {\n        \n    }\n}",
    "dart": "class Solution {\n  int largestPerimeter(List<int> nums) {\n    \n  }\n}",
    "golang": "func largestPerimeter(nums []int) int64 {\n    \n}",
    "ruby": "# @param {Integer[]} nums\n# @return {Integer}\ndef largest_perimeter(nums)\n    \nend",
    "scala": "object Solution {\n    def largestPerimeter(nums: Array[Int]): Long = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn largest_perimeter(nums: Vec<i32>) -> i64 {\n        \n    }\n}",
    "racket": "(define/contract (largest-perimeter nums)\n  (-> (listof exact-integer?) exact-integer?)\n  )",
    "erlang": "-spec largest_perimeter(Nums :: [integer()]) -> integer().\nlargest_perimeter(Nums) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec largest_perimeter(nums :: [integer]) :: integer\n  def largest_perimeter(nums) do\n    \n  end\nend"
  },
  "solution": "[TOC]\n\n## Solution\n\n--- \n\n### Overview\n\nThe problem involves finding the largest possible perimeter of a polygon that can be formed using a given array of positive integers, where each integer represents the length of a side of the polygon. The conditions for forming a valid polygon are that it must be a closed plane figure with at least 3 sides, and the length of the longest side must be smaller than the sum of the lengths of the other sides.\n\nIn real-life scenarios, this problem can be related to optimization challenges in fields such as manufacturing or construction. For example, in manufacturing, where materials are limited, the problem can be interpreted as finding the most efficient way to use available resources to create a closed structure with a maximal perimeter. The problem highlights the importance of understanding geometric constraints and optimizing resource utilization.\n\n---\n\n### Approach: Sorting\n\n#### Intuition\n\nThe problem revolves around the construction of polygons from a given array of positive integers. The aim is to determine the largest possible perimeter of a polygon that can be formed using elements from the array and to return -1 if it is not feasible to create a polygon. A polygon, in this context, is defined as a closed plane figure with **at least three sides**, where the length of the longest side is less than the sum of the remaining sides.\n\nTo approach this problem intuitively, let's consider the nature of polygons and their side lengths. According to the problem description, a valid polygon consists of sides where the **longest side** is **smaller** than the sum of its other sides. \n\n> Conversely, if you have `k (k >= 3)` positive real numbers `a1, a2, a3, ..., ak` where `a1 <= a2 <= a3 <= ... <= ak` and `a1 + a2 + a3 + ... + ak-1 > ak`, then there always exists a polygon with `k` sides whose lengths are `a1, a2, a3, ..., ak`.\n\nThis concept provides a key insight into how we might construct a valid polygon from the given array of positive integers. The requirement that the largest side must be smaller than the sum of the remaining sides suggests the need to establish an order among the side lengths. In other words, the challenge is to find a systematic way to consider side lengths such that the largest one is positioned last, allowing us to check if it is smaller than the sum of the others.\n\nWe can begin by sorting the array, which allows us to consider the elements in ascending order, facilitating a systematic examination of possible side lengths. The sorting operation ensures that we iterate through the array in increasing order of side lengths, so we encounter smaller sides first and the longest side last, which is useful because the longest side should be smaller than the sum of the others.\n\nNow, as we traverse the sorted array, we need to maintain a running sum of the previously encountered elements. This sum represents the cumulative length of the sides that we have already considered. As we move through the array, we evaluate each element in relation to the sum of the previously encountered elements.\n\nThe pivotal insight of this algorithm is that if the current element is smaller than the sum of the previous elements, we can form a valid polygon because adding the current element to the sum satisfies the condition that the longest side is smaller than the sum of the others.\n\nTherefore, the algorithm keeps track of the maximum possible perimeter by updating the answer whenever a valid combination of sides is found. This ensures that we always have the largest perimeter encountered so far.\n\nTo handle cases where a valid combination of sides to form a polygon is not found, the algorithm initializes the variable `ans` to -1. The algorithm ensures that if no valid combination is encountered during the iteration through the sorted array, the value of `ans` remains unchanged. Consequently, upon completion of the loop, the algorithm returns -1, indicating the absence of a feasible polygon with the given array of positive integers.\n\nBased on our current intuition, we can formulate the following solution:\n\n```\nlong long largestPerimeter(vector& nums) {\n    sort(nums.begin(), nums.end());\n    long long previousElementsSum = 0;\n    long long ans = -1;\n    for (int i = 0; i < nums.size(); i++) {\n        if (i >= 2 && nums[i] < previousElementsSum) {\n            ans = nums[i] + previousElementsSum;\n        }\n        previousElementsSum += nums[i];\n    }\n    return ans;\n}\n```\n\nThe additional check (`i >= 2`) before updating `ans` to `nums[i]+ previousElementsSum` ensures that the polygon under consideration has at least three sides. A closer examination reveals that this condition is, in fact, unnecessary. \n\nThe absence of a need to include an additional check for `i >= 2` in the for loop can be comprehensively understood by considering the initialization of `previous_elements_sum` and the inherent properties of the sorted array. \n\n1. On the first iteration, when `i = 0`, the initial value of `previous_elements_sum` is set to 0, and the subsequent comparison `num < previous_elements_sum` evaluates to false, as `num` is a positive integer. Consequently, the code block within the if statement is bypassed during this iteration.\n\n2. Moving to the second iteration, `i = 1`, the value of `previous_elements_sum` assumes the first element of the sorted array (`nums[0]`). Given that the array is sorted in ascending order, `previous_elements_sum` is inherently less than or equal to the current element under consideration (`num`), which is `nums[1]`. As a result, the condition `num < previous_elements_sum` remains false during this iteration as well, and the loop proceeds without executing the code block within the if statement.\n\nThe sorting of the array and the careful initialization of `previous_elements_sum` ensure that the condition `num < previous_elements_sum` is systematically false for the initial iterations of the loop (when `i < 2`). Therefore, the absence of an extra check for `i >= 2` is justified, as the logic inherently accounts for the starting points of the loop, streamlining the code without sacrificing correctness.\n\n!?!../Documents/2971/2971-1.json:960,540!?!\n\n#### Algorithm\n\n1. Sort the input array `nums` in ascending order.\n2. Initialize variables `previous_elements_sum` to 0 and `ans` to -1.\n3. Iterate through each element `num` in the sorted array `nums`.\n4. Check if the current element `num` is less than the sum of previous elements. If true, we have encountered a valid combination of sides.\n5. If the current `num` is a valid side, update `ans` to the sum of the current `num` and `previous_elements_sum`.\n6. Update `previous_elements_sum` by adding the current element `num`.\n7. After iterating through all elements, the method returns the largest possible perimeter stored in `ans`.\n\n#### Implementation#### Complexity Analysis\n\nLet $N$ be the length of `nums`.\n\n* Time complexity: $O(N\\cdot logN)$. Sorting `nums` incurs a time complexity of $O(N\\cdot logN)$. Iterating over `nums` incurs a time complexity of $O(N)$ which can be ignored since $O(N\\cdot logN)$ is the dominating term. \n\n* Space complexity: $O(N)$ or $O(\\log N)$. Some extra space is used when we sort an array of size $N$ in place. The space complexity of the sorting algorithm depends on the programming language.\n    - In Python, the `sort` method sorts a list using the Timsort algorithm which is a combination of Merge Sort and Insertion Sort and has a space complexity of $$O(N)$$.\n    - In C++, the sort() function is implemented as a hybrid of Quick Sort, Heap Sort, and Insertion Sort, with a worst-case space complexity of $$O(\\log N)$$.\n    - In Java, Arrays.sort() is implemented using a variant of the Quick Sort algorithm which has a space complexity of $$O(\\log N)$$.\n\n---"
}