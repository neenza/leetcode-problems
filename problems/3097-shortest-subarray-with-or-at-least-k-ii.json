{
  "title": "Shortest Subarray With OR at Least K II",
  "problem_id": "3380",
  "frontend_id": "3097",
  "difficulty": "Medium",
  "problem_slug": "shortest-subarray-with-or-at-least-k-ii",
  "topics": [
    "Array",
    "Bit Manipulation",
    "Sliding Window"
  ],
  "description": "You are given an array nums of non-negative integers and an integer k.\nAn array is called special if the bitwise OR of all of its elements is at least k.\nReturn the length of the shortest special non-empty subarray of nums, or return -1 if no special subarray exists.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: nums = [1,2,3], k = 2\nOutput: 1\nExplanation:\nThe subarray [3] has OR value of 3 . Hence, we return 1 .",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input: nums = [2,1,8], k = 10\nOutput: 3\nExplanation:\nThe subarray [2,1,8] has OR value of 11 . Hence, we return 3 .",
      "images": []
    },
    {
      "example_num": 3,
      "example_text": "Input: nums = [1,2], k = 0\nOutput: 1\nExplanation:\nThe subarray [1] has OR value of 1 . Hence, we return 1 .",
      "images": []
    }
  ],
  "constraints": [
    "1 <= nums.length <= 2 * 105",
    "0 <= nums[i] <= 109",
    "0 <= k <= 109"
  ],
  "follow_ups": [],
  "hints": [
    "For each <code>nums[i]</code>, we can maintain each subarray’s bitwise <code>OR</code> result ending with it.",
    "The property of bitwise <code>OR</code> is that it never unsets any bits and only sets new bits",
    "So the number of different results for each <code>nums[i]</code> is at most the number of bits 32."
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    int minimumSubarrayLength(vector<int>& nums, int k) {\n        \n    }\n};",
    "java": "class Solution {\n    public int minimumSubarrayLength(int[] nums, int k) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def minimumSubarrayLength(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def minimumSubarrayLength(self, nums: List[int], k: int) -> int:\n        ",
    "c": "int minimumSubarrayLength(int* nums, int numsSize, int k) {\n    \n}",
    "csharp": "public class Solution {\n    public int MinimumSubarrayLength(int[] nums, int k) {\n        \n    }\n}",
    "javascript": "/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number}\n */\nvar minimumSubarrayLength = function(nums, k) {\n    \n};",
    "typescript": "function minimumSubarrayLength(nums: number[], k: number): number {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @param Integer $k\n     * @return Integer\n     */\n    function minimumSubarrayLength($nums, $k) {\n        \n    }\n}",
    "swift": "class Solution {\n    func minimumSubarrayLength(_ nums: [Int], _ k: Int) -> Int {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun minimumSubarrayLength(nums: IntArray, k: Int): Int {\n        \n    }\n}",
    "dart": "class Solution {\n  int minimumSubarrayLength(List<int> nums, int k) {\n    \n  }\n}",
    "golang": "func minimumSubarrayLength(nums []int, k int) int {\n    \n}",
    "ruby": "# @param {Integer[]} nums\n# @param {Integer} k\n# @return {Integer}\ndef minimum_subarray_length(nums, k)\n    \nend",
    "scala": "object Solution {\n    def minimumSubarrayLength(nums: Array[Int], k: Int): Int = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn minimum_subarray_length(nums: Vec<i32>, k: i32) -> i32 {\n        \n    }\n}",
    "racket": "(define/contract (minimum-subarray-length nums k)\n  (-> (listof exact-integer?) exact-integer? exact-integer?)\n  )",
    "erlang": "-spec minimum_subarray_length(Nums :: [integer()], K :: integer()) -> integer().\nminimum_subarray_length(Nums, K) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec minimum_subarray_length(nums :: [integer], k :: integer) :: integer\n  def minimum_subarray_length(nums, k) do\n    \n  end\nend"
  },
  "solution": "[TOC]\n\n## Solution\n\n---\n\n### Approach 1: Binary Search\n\n#### Intuition\n\nThe OR operation has a unique property: the result is always greater than or equal to its operands. When we perform the OR operation on a series of numbers, each intermediate result will be greater than or equal to all previous results. This means that if we take two different lengths of subarrays, say $l_1$ and $l_2$, and their highest OR values are $o_1$ and $o_2$ respectively, then $o_2$ will always be greater than or equal to $o_1$ when $l_2$ is greater than or equal to $l_1$.\n\nThis property indicates that the highest OR values of subarray lengths, when arranged from 1 to `n`, form a non-decreasing sequence. This insight lets us use binary search in our solution.\n\nTo find the smallest subarray length that meets our requirement (an OR value greater than or equal to `k`), we can perform a binary search on the possible lengths of subarrays. If we find that no subarray of a certain length satisfies the criteria, we can disregard all shorter lengths because they won’t work either. On the other hand, if we find a valid length, we’ll store it in a variable called `minLength` and keep searching for potentially shorter valid lengths. At the end of our search, the final value of `minLength` will be our answer.\n\nNow, how do we check if a subarray of a given length has an OR value that meets or exceeds `k`? We could loop through the array and check all subarrays of that length. However, repeatedly calculating the OR value for each subarray would take too much time, resulting in quadratic complexity. Instead, we want to achieve this in linear time.\n\nWhen you OR multiple numbers together, a bit in the result will be 1 if any of the numbers have a 1 in that position. To efficiently track this, we can use a 32-bit array where each position corresponds to a bit and stores the count of set bits from the numbers being OR'd. This approach allows us to easily remove a number from our calculation by simply subtracting its set bit counts from the array.\n\nSo, to determine the OR value of a subarray, we’ll use a bit array called `bitCounts` along with a helper method named `updateBitCounts`. We’ll slide a fixed-size window of the given length across the array, adding and removing elements as the window moves using the `updateBitCounts` method. If we find that the OR value of any window is greater than or equal to `k`, we know that length is valid. Our goal is to find the smallest valid window length, which will be our final answer.\n\n#### Algorithm\n\n- Initialize variables `left` to 1 and `right` to the array length to establish binary search boundaries.\n- Initialize `minLength` to -1 to track the shortest valid subarray length.\n- Execute binary search while `left` is less than or equal to `right`:\n  - Calculate the midpoint as `left + (right - left) / 2`.\n  - If a valid subarray of length `mid` exists:\n    - Update `minLength` to current `mid`.\n    - Set `right` to `mid - 1` to search for a smaller length.\n  - Otherwise:\n    - Set `left` to `mid + 1` to search for a larger length.\n- Return `minLength` as the final result.\n\nHelper Method `hasValidSubarray`:\n- Initialize an array `bitCounts` of size 32 filled with zeros to track set bits at each position.\n- Implement sliding window approach from index 0 to array length:\n  - Add bits of the current number at `right` to `bitCounts`.\n  - If the window size exceeds the desired length:\n    - Remove bits of the leftmost number from `bitCounts`.\n  - If the current window has reached the desired size and its OR value exceeds the target:\n    - Return true as valid subarray found.\n- Return false if no valid subarray is found.\n\nHelper Method `updateBitCounts(bitCounts, number, delta)`:\n- For each bit position from 0 to 31:\n  - Check if the bit is set using right shift and AND operation.\n  - If bit is set, update the count at that position by delta.\n\nHelper Method `convertBitCountsToNumber(bitCounts)`:\n- Initialize `number` to 0 to store the final result.\n- For each bit position from 0 to 31:\n  - If the count at the current position is non-zero:\n    - Set the corresponding bit in `number` using OR operation.\n- Return the final computed `number`.\n\n#### Implementation\n\n> Note: While this is a valid approach and makes an excellent interview starting point, the Python3 implementation exceeds time limits on large test cases.#### Complexity Analysis\n\nLet $n$ be the length of the `nums` array.\n\n- Time complexity: $O(n \\cdot \\log n)$\n\n    The algorithm performs a binary search on possible subarray lengths from $1$ to $n$, which takes $O(\\log n)$ iterations. For each iteration, the algorithm calls `hasValidSubarray` which uses a fixed-length sliding window to examine each position in the array once. For each position it performs two operations: `updateBitCounts` and `convertBitCountsToNumber`, each taking $O(32) = O(1)$ time as they iterate through fixed $32$ bit positions. So, `hasValidSubarray` takes $O(n)$ time.\n\n    Thus, the overall time complexity of the algorithm is $O(n \\cdot \\log n)$.\n\n- Space complexity: $O(1)$\n\n    The algorithm uses a fixed-size array `bitCounts` of size $32$ to store the count of set bits at each position and a few other variables for binary search and tracking results. Therefore, the total space complexity is $O(1)$.  \n\n---\n\n### Approach 2: Sliding Window\n\n#### Intuition\n\nIn our previous method, we used binary search to adjust the size of the window to find the smallest possible window size. However, we can simplify things by using a variable-size sliding window instead, which eliminates the $\\log n$ factor from our time complexity.\n\nWe’ll iterate through the `nums` array and add each element to our window one by one. After adding an element, we’ll check if the current OR value of the subarray meets or exceeds the target value `k`. If it does, we’ll keep track of the current size of the window in a variable called `minLength`.\n\nNext, we’ll try to shrink the window from the start by removing elements one at a time. Each time we remove an element, we reduce the window size and update `minLength` accordingly. We keep doing this until the OR value of the window drops below `k`, at which point we stop removing elements and continue with the next element in the array.\n\nOnce we finish looping through the array, `minLength` will contain the length of the smallest valid subarray that meets the condition. We can then return this value as our answer.\n\nThe algorithm is visualized in the slideshow below:\n\n!?!../Documents/3097/slideshow.json:874,672!?!\n\n#### Algorithm\n\n- Initialize:\n  - a variable `minLength` to maximum possible integer value to track the shortest valid subarray length.\n  - two pointers `windowStart` and `windowEnd` to 0 to implement a sliding window.\n  - an array `bitCounts` of size 32 filled with zeros to keep track of set bits at each position.\n- Start expanding the window while `windowEnd` is less than the array length:\n  - Add the bits of current number at `windowEnd` to `bitCounts` by calling `updateBitCounts`.\n  - While the window contains a valid subarray (OR of numbers $\\geq$ k) and `windowStart` $\\leq$ `windowEnd`:\n    - Update `minLength` to minimum of current `minLength` and current window size.\n    - Remove the bits of number at `windowStart` from `bitCounts`.\n    - Increment `windowStart` to shrink window from left.\n  - Increment `windowEnd` to expand window from right.\n- Return -1 if no valid subarray found (`minLength` still maximum), else return `minLength`.\n\nHelper method `updateBitCounts(bitCounts, number, delta)`:\n- For each bit position from 0 to 31:\n  - Check if bit is set in given number using right shift and AND operation.\n  - If bit is set, increment/decrement count at that position by delta.\n\nHelper method `convertBitCountsToNumber(bitCounts)`:\n- Initialize `result` to 0.\n- For each bit position from 0 to 31:\n  - If count at current position is non-zero, set corresponding bit in `result` using OR operation.\n- Return the final `result`.\n\n#### Implementation#### Complexity Analysis\n\nLet $n$ be the length of the `nums` array.\n\n* Time complexity: $O(n)$\n\n    The outer loop runs over the length of the input array. For each iteration, we perform two operations: the first operation updates the bit counts, and the second operation checks if the current window is valid by converting bit counts to numbers. Both these take $O(32) = O(1)$ time. \n    \n    The inner while loop can run at most $n$ times across all iterations of the outer loop, as `windowStart` can only be incremented $n$ times in total. \n    \n    Thus, the total time complexity of our algorithm is $O(n)$. \n\n* Space complexity: $O(1)$\n\n    The algorithm uses a fixed-size array `bitCounts` of size $32$ to store the count of set bits at each position. Besides this, it uses only a few integer variables (`minLength`, `windowStart`, `windowEnd`) for tracking the window and result.\n\n    Therefore, the total space complexity is $O(1)$ as it uses constant extra space independent of input size.\n\n---"
}