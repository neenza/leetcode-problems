{
  "title": "Find the Prefix Common Array of Two Arrays",
  "problem_id": "2766",
  "frontend_id": "2657",
  "difficulty": "Medium",
  "problem_slug": "find-the-prefix-common-array-of-two-arrays",
  "topics": [
    "Array",
    "Hash Table",
    "Bit Manipulation"
  ],
  "description": "You are given two 0-indexed integer permutations A and B of length n.\nA prefix common array of A and B is an array C such that C[i] is equal to the count of numbers that are present at or before the index i in both A and B.\nReturn the prefix common array of A and B.\nA sequence of n integers is called a permutation if it contains all integers from 1 to n exactly once.\nExample 1:\nExample 2:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: A = [1,3,2,4], B = [3,1,2,4]\nOutput: [0,2,3,4]\nExplanation: At i = 0: no number is common, so C[0] = 0.\nAt i = 1: 1 and 3 are common in A and B, so C[1] = 2.\nAt i = 2: 1, 2, and 3 are common in A and B, so C[2] = 3.\nAt i = 3: 1, 2, 3, and 4 are common in A and B, so C[3] = 4.",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input: A = [2,3,1], B = [3,1,2]\nOutput: [0,1,3]\nExplanation: At i = 0: no number is common, so C[0] = 0.\nAt i = 1: only 3 is common in A and B, so C[1] = 1.\nAt i = 2: 1, 2, and 3 are common in A and B, so C[2] = 3.",
      "images": []
    }
  ],
  "constraints": [
    "1 <= A.length == B.length == n <= 50",
    "1 <= A[i], B[i] <= n",
    "It is guaranteed that A and B are both a permutation of n integers."
  ],
  "follow_ups": [],
  "hints": [
    "Consider keeping a frequency array that stores the count of occurrences of each number till index i.",
    "If a number occurred two times, it means it occurred in both A and B since they’re both permutations so add one to the answer."
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\n        \n    }\n};",
    "java": "class Solution {\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def findThePrefixCommonArray(self, A, B):\n        \"\"\"\n        :type A: List[int]\n        :type B: List[int]\n        :rtype: List[int]\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def findThePrefixCommonArray(self, A: List[int], B: List[int]) -> List[int]:\n        ",
    "c": "/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nint* findThePrefixCommonArray(int* A, int ASize, int* B, int BSize, int* returnSize) {\n    \n}",
    "csharp": "public class Solution {\n    public int[] FindThePrefixCommonArray(int[] A, int[] B) {\n        \n    }\n}",
    "javascript": "/**\n * @param {number[]} A\n * @param {number[]} B\n * @return {number[]}\n */\nvar findThePrefixCommonArray = function(A, B) {\n    \n};",
    "typescript": "function findThePrefixCommonArray(A: number[], B: number[]): number[] {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param Integer[] $A\n     * @param Integer[] $B\n     * @return Integer[]\n     */\n    function findThePrefixCommonArray($A, $B) {\n        \n    }\n}",
    "swift": "class Solution {\n    func findThePrefixCommonArray(_ A: [Int], _ B: [Int]) -> [Int] {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun findThePrefixCommonArray(A: IntArray, B: IntArray): IntArray {\n        \n    }\n}",
    "dart": "class Solution {\n  List<int> findThePrefixCommonArray(List<int> A, List<int> B) {\n    \n  }\n}",
    "golang": "func findThePrefixCommonArray(A []int, B []int) []int {\n    \n}",
    "ruby": "# @param {Integer[]} a\n# @param {Integer[]} b\n# @return {Integer[]}\ndef find_the_prefix_common_array(a, b)\n    \nend",
    "scala": "object Solution {\n    def findThePrefixCommonArray(A: Array[Int], B: Array[Int]): Array[Int] = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn find_the_prefix_common_array(a: Vec<i32>, b: Vec<i32>) -> Vec<i32> {\n        \n    }\n}",
    "racket": "(define/contract (find-the-prefix-common-array A B)\n  (-> (listof exact-integer?) (listof exact-integer?) (listof exact-integer?))\n  )",
    "erlang": "-spec find_the_prefix_common_array(A :: [integer()], B :: [integer()]) -> [integer()].\nfind_the_prefix_common_array(A, B) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec find_the_prefix_common_array(a :: [integer], b :: [integer]) :: [integer]\n  def find_the_prefix_common_array(a, b) do\n    \n  end\nend"
  },
  "solution": "[TOC]\n\n## Solution\n\n--- \n\n### Overview\n\nWe are given two arrays, `A` and `B`, each containing a shuffled list of numbers from `1` to `n`. Our task is to construct a new array `C`, where each element `C[i]` represents the count of numbers from `1` to `i + 1` that are present in both `A` and `B` up to that index.\n\nFor example, consider `A = [1, 3, 2, 4]` and `B = [3, 1, 2, 4]`:\n\n- At `i = 0` (first element): No numbers are common between `A` and `B` yet, so `C[0] = 0`.\n- At `i = 1`: The numbers `1` and `3` are common in both arrays, so `C[1] = 2`.\n- At `i = 2`: The numbers `1`, `2`, and `3` are common, so `C[2] = 3`.\n- At `i = 3`: All four numbers, `1`, `2`, `3`, and `4`, are common in both arrays, so `C[3] = 4`.\n\nThus, the resulting array is `C = [0, 2, 3, 4]`.\n\n---\n\n### Approach 1: Brute Force\n\n#### Intuition   \n\nA straightforward and logical approach to finding the prefix common array is to use a brute-force method. The core idea is iterating through each index `currentIndex` of the input arrays `A` and `B` and calculating the number of common elements up to that index.\n\nFor each element in the subarray of `A`, we compare it with each element in the subarray of `B`. If we find a match, we count it as a common element. Since the elements in both arrays are unique, we don't need to worry about counting duplicates. Once we find a match for an element, we can stop further checks for that element, knowing it has already been accounted for.\n\nThis process is repeated for every index in the arrays, and the results are stored in an array, which we will refer to as `prefixCommonArray` (replacing `C` for clarity) to better reflect its purpose as the final output array.\n\n#### Algorithm\n\n- Initialize `n` to the size of array `A` and create an array `prefixCommonArray` of size `n` to store the common count for each prefix.\n\n- Iterate through each index `currentIndex` from `0` to `n-1`:\n  - Initialize `commonCount` to `0`, which will store the number of common elements in the current prefix.\n  \n  - For each `aIndex` from `0` to `currentIndex`:\n    - For each `bIndex` from `0` to `currentIndex`:\n      - If `A[aIndex]` equals `B[bIndex]`, increment `commonCount` and break the inner loop.\n\n  - Store `commonCount` in `prefixCommonArray[currentIndex]` to record the number of common elements for the current prefix.\n\n- Return `prefixCommonArray`, which contains the common count for each prefix of `A` and `B`.\n\n#### Implementation#### Complexity Analysis\n\nLet $n$ be the size of the input arrays `A` and `B`.\n\n- Time complexity: $O(n^3)$\n\n    The outer loop runs $n$ times (from `currentIndex = 0` to `currentIndex = n-1`). For each iteration of the outer loop, the first inner loop runs `currentIndex + 1` times, and the second inner loop also runs `currentIndex + 1` times. \n    \n    Therefore, the total number of iterations is: $\\sum_{currentIndex=0}^{n-1} (currentIndex + 1) \\times (currentIndex + 1) = \\sum_{currentIndex=0}^{n-1} (currentIndex + 1)^2$\n\n    This simplifies to: $\\sum_{k=1}^{n} k^2 = \\frac{n(n + 1)(2n + 1)}{6}$\n\n    Asymptotically, this is $O(n^3)$.\n\n- Space complexity: $O(1)$\n\n    The space complexity is constant because no additional data structures are used apart from the output container (`prefixCommonArray`), which is excluded from the analysis as it’s a requirement from the problem statement. Only a few variables like `currentIndex`, `commonCount`, `aIndex`, and `bIndex` are used, which take $O(1)$ space.\n\n---\n\n### Approach 2: Hash Set\n\n#### Intuition   \n\nWe can improve the brute-force method by using an unordered set to track the elements encountered so far in both arrays `A` and `B`. This is significantly more efficient than the brute-force method, where we had to check every element in both arrays for each index. The key idea is to reduce the time complexity by leveraging efficient element checking, which is done in constant time for an unordered set.\n\nTo implement this, we use two sets: `elementsInA` and `elementsInB`. These sets store the elements encountered up to the current index. For each index `currentIndex`, we insert the current elements of both `A[currentIndex]` and `B[currentIndex]` into their respective sets. Then, we iterate over the elements in `elementsInA` and check if each element exists in `elementsInB`. If it does, it is counted as a common element.\n\n#### Algorithm\n\n- Initialize `n` as the size of array `A`.\n- Create a `prefixCommonArray` array of size `n` to store the result.\n- Initialize two unordered sets `elementsInA` and `elementsInB` to track the elements encountered in arrays `A` and `B` respectively.\n\n- Iterate through each `currentIndex` from `0` to `n-1`:\n  - Add the element `A[currentIndex]` to `elementsInA`.\n  - Add the element `B[currentIndex]` to `elementsInB`.\n  - Initialize `commonCount` to `0`, which will track the number of common elements in `elementsInA` and `elementsInB`.\n\n  - Iterate through each `element` in `elementsInA`:\n    - If the `element` exists in `elementsInB`, increment `commonCount`.\n\n  - Set `prefixCommonArray[currentIndex]` to `commonCount`.\n\n- Return `prefixCommonArray`, which contains the common count for each prefix of `A` and `B`.\n\n#### Implementation#### Complexity Analysis\n\nLet $n$ be the size of the input arrays `A` and `B`.\n\n- Time complexity: $O(n^2)$\n\n    The outer loop runs $n$ times (from `currentIndex = 0` to `currentIndex = n-1`). Inside the loop, the `insert` operation for the set takes $O(1)$ on average. The inner loop iterates over the elements in `elementsInA`, which can have up to `currentIndex + 1` elements (at most $n$ elements). For each element, the `count` operation in `elementsInB` also takes $O(1)$ on average. Therefore, the inner loop contributes $O(n)$ per iteration of the outer loop.\n    \n    Overall, the time complexity is $O(n) \\times O(n) = O(n^2)$.\n\n- Space complexity: $O(n)$\n\n    The space complexity is dominated by the two set objects, `elementsInA` and `elementsInB`, which can each store up to $n$ elements. This results in $O(n)$ space. The output container (`prefixCommonArray`) is excluded from the analysis as it is part of the problem statement, and the remaining variables use $O(1)$ space.\n\n---\n\n### Approach 3: Single Pass with Frequency Array\n\n#### Intuition   \n\nWe can further optimize the approach by using a frequency array to count how many times each number appears in the two arrays, `A` and `B`. The key idea is to avoid unnecessary nested loops or set-based checks by directly counting the occurrences of each number in both arrays up to the current index.\n\nWe maintain a `frequency` array of size `n + 1`. This array is used to store the count of each element's occurrence across both `A` and `B`. Since the elements in `A` and `B` are permutations of numbers from `1` to `n`, the `frequency` array has `n + 1` elements to cover the range from `1` to `n` (ignoring index `0` for simplicity).\n\nAs we process each index `currentIndex` of both arrays, we increment the count of `A[currentIndex]` and `B[currentIndex]` in the `frequency` array. Whenever the count for an element in the `frequency` array reaches `2` (meaning that this number has appeared once in both `A` and `B`), we know that this element is a common element at the current prefix, and we increment the `commonCount`.\n\nFinally, we store the `commonCount` at each index in the `prefixCommonArray`, which will give us the cumulative count of common elements at each position in the arrays. This way we only visit each element a constant number of times, making it more efficient than the two previous approaches.\n\nThe algorithm is visualized below:\n\n!?!../Documents/2657/singlepass.json:765,655!?!\n\n#### Algorithm\n\n- Initialize an integer `n` to store the size of array `A`.\n- Create a `prefixCommonArray` array of size `n` to store the result.\n- Create a `frequency` array of size `n + 1` to keep track of the occurrences of each number.\n- Initialize `commonCount` to `0`, which will store the count of common elements in prefixes of `A` and `B`.\n\n- Iterate through each index `currentIndex` from `0` to `n - 1`:\n  - Increment the frequency of `A[currentIndex]` and check if its count becomes 2, indicating a common element between `A` and `B`. If true, increment `commonCount`.\n  - Similarly, increment the frequency of `B[currentIndex]` and check if its count becomes 2. If true, increment `commonCount`.\n  - Assign the value of `commonCount` to `prefixCommonArray[currentIndex]`.\n\n- Return `prefixCommonArray`, which contains the common count for each prefix of `A` and `B`.\n\n#### Implementation#### Complexity Analysis\n\nLet $n$ be the size of the input arrays `A` and `B`.\n\n- Time complexity: $O(n)$\n\n    The loop runs $n$ times (from `currentIndex = 0` to `currentIndex = n - 1`). Inside the loop, the operations involve incrementing the frequency of elements in `A` and `B` and checking if the frequency equals 2. These operations are $O(1)$ because they involve simple array accesses and comparisons.\n\n    Therefore, the total time complexity is $O(n)$.\n\n- Space complexity: $O(n)$\n\n    The space complexity is dominated by the `frequency` array, which requires $O(n + 1) = O(n)$ space. The output container (`prefixCommonArray`) is excluded from the analysis as it is part of the problem statement, and the remaining variables use $O(1)$ space.\n\n---"
}