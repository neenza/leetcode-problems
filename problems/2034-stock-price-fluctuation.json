{
  "title": "Stock Price Fluctuation ",
  "problem_id": "2161",
  "frontend_id": "2034",
  "difficulty": "Medium",
  "problem_slug": "stock-price-fluctuation",
  "topics": [
    "Hash Table",
    "Design",
    "Heap (Priority Queue)",
    "Data Stream",
    "Ordered Set"
  ],
  "description": "You are given a stream of records about a particular stock. Each record contains a timestamp and the corresponding price of the stock at that timestamp.\nUnfortunately due to the volatile nature of the stock market, the records do not come in order. Even worse, some records may be incorrect. Another record with the same timestamp may appear later in the stream correcting the price of the previous wrong record.\nDesign an algorithm that:\nImplement the StockPrice class:\nExample 1:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input\n[\"StockPrice\", \"update\", \"update\", \"current\", \"maximum\", \"update\", \"maximum\", \"update\", \"minimum\"]\n[[], [1, 10], [2, 5], [], [], [1, 3], [], [4, 2], []]\nOutput\n[null, null, null, 5, 10, null, 5, null, 2]\n\nExplanation\nStockPrice stockPrice = new StockPrice();\nstockPrice.update(1, 10); // Timestamps are [1] with corresponding prices [10].\nstockPrice.update(2, 5);  // Timestamps are [1,2] with corresponding prices [10,5].\nstockPrice.current();     // return 5, the latest timestamp is 2 with the price being 5.\nstockPrice.maximum();     // return 10, the maximum price is 10 at timestamp 1.\nstockPrice.update(1, 3);  // The previous timestamp 1 had the wrong price, so it is updated to 3.\n                          // Timestamps are [1,2] with corresponding prices [3,5].\nstockPrice.maximum();     // return 5, the maximum price is 5 after the correction.\nstockPrice.update(4, 2);  // Timestamps are [1,2,4] with corresponding prices [3,5,2].\nstockPrice.minimum();     // return 2, the minimum price is 2 at timestamp 4.",
      "images": []
    }
  ],
  "constraints": [
    "1 <= timestamp, price <= 109",
    "At most 105 calls will be made in total to update, current, maximum, and minimum.",
    "current, maximum, and minimum will be called only after update has been called at least once."
  ],
  "follow_ups": [],
  "hints": [
    "How would you solve the problem for offline queries (all queries given at once)?",
    "Think about which data structure can help insert and delete the most optimal way."
  ],
  "code_snippets": {
    "cpp": "class StockPrice {\npublic:\n    StockPrice() {\n        \n    }\n    \n    void update(int timestamp, int price) {\n        \n    }\n    \n    int current() {\n        \n    }\n    \n    int maximum() {\n        \n    }\n    \n    int minimum() {\n        \n    }\n};\n\n/**\n * Your StockPrice object will be instantiated and called as such:\n * StockPrice* obj = new StockPrice();\n * obj->update(timestamp,price);\n * int param_2 = obj->current();\n * int param_3 = obj->maximum();\n * int param_4 = obj->minimum();\n */",
    "java": "class StockPrice {\n\n    public StockPrice() {\n        \n    }\n    \n    public void update(int timestamp, int price) {\n        \n    }\n    \n    public int current() {\n        \n    }\n    \n    public int maximum() {\n        \n    }\n    \n    public int minimum() {\n        \n    }\n}\n\n/**\n * Your StockPrice object will be instantiated and called as such:\n * StockPrice obj = new StockPrice();\n * obj.update(timestamp,price);\n * int param_2 = obj.current();\n * int param_3 = obj.maximum();\n * int param_4 = obj.minimum();\n */",
    "python": "class StockPrice(object):\n\n    def __init__(self):\n        \n\n    def update(self, timestamp, price):\n        \"\"\"\n        :type timestamp: int\n        :type price: int\n        :rtype: None\n        \"\"\"\n        \n\n    def current(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        \n\n    def maximum(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        \n\n    def minimum(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        \n\n\n# Your StockPrice object will be instantiated and called as such:\n# obj = StockPrice()\n# obj.update(timestamp,price)\n# param_2 = obj.current()\n# param_3 = obj.maximum()\n# param_4 = obj.minimum()",
    "python3": "class StockPrice:\n\n    def __init__(self):\n        \n\n    def update(self, timestamp: int, price: int) -> None:\n        \n\n    def current(self) -> int:\n        \n\n    def maximum(self) -> int:\n        \n\n    def minimum(self) -> int:\n        \n\n\n# Your StockPrice object will be instantiated and called as such:\n# obj = StockPrice()\n# obj.update(timestamp,price)\n# param_2 = obj.current()\n# param_3 = obj.maximum()\n# param_4 = obj.minimum()",
    "c": "\n\n\ntypedef struct {\n    \n} StockPrice;\n\n\nStockPrice* stockPriceCreate() {\n    \n}\n\nvoid stockPriceUpdate(StockPrice* obj, int timestamp, int price) {\n    \n}\n\nint stockPriceCurrent(StockPrice* obj) {\n    \n}\n\nint stockPriceMaximum(StockPrice* obj) {\n    \n}\n\nint stockPriceMinimum(StockPrice* obj) {\n    \n}\n\nvoid stockPriceFree(StockPrice* obj) {\n    \n}\n\n/**\n * Your StockPrice struct will be instantiated and called as such:\n * StockPrice* obj = stockPriceCreate();\n * stockPriceUpdate(obj, timestamp, price);\n \n * int param_2 = stockPriceCurrent(obj);\n \n * int param_3 = stockPriceMaximum(obj);\n \n * int param_4 = stockPriceMinimum(obj);\n \n * stockPriceFree(obj);\n*/",
    "csharp": "public class StockPrice {\n\n    public StockPrice() {\n        \n    }\n    \n    public void Update(int timestamp, int price) {\n        \n    }\n    \n    public int Current() {\n        \n    }\n    \n    public int Maximum() {\n        \n    }\n    \n    public int Minimum() {\n        \n    }\n}\n\n/**\n * Your StockPrice object will be instantiated and called as such:\n * StockPrice obj = new StockPrice();\n * obj.Update(timestamp,price);\n * int param_2 = obj.Current();\n * int param_3 = obj.Maximum();\n * int param_4 = obj.Minimum();\n */",
    "javascript": "\nvar StockPrice = function() {\n    \n};\n\n/** \n * @param {number} timestamp \n * @param {number} price\n * @return {void}\n */\nStockPrice.prototype.update = function(timestamp, price) {\n    \n};\n\n/**\n * @return {number}\n */\nStockPrice.prototype.current = function() {\n    \n};\n\n/**\n * @return {number}\n */\nStockPrice.prototype.maximum = function() {\n    \n};\n\n/**\n * @return {number}\n */\nStockPrice.prototype.minimum = function() {\n    \n};\n\n/** \n * Your StockPrice object will be instantiated and called as such:\n * var obj = new StockPrice()\n * obj.update(timestamp,price)\n * var param_2 = obj.current()\n * var param_3 = obj.maximum()\n * var param_4 = obj.minimum()\n */",
    "typescript": "class StockPrice {\n    constructor() {\n        \n    }\n\n    update(timestamp: number, price: number): void {\n        \n    }\n\n    current(): number {\n        \n    }\n\n    maximum(): number {\n        \n    }\n\n    minimum(): number {\n        \n    }\n}\n\n/**\n * Your StockPrice object will be instantiated and called as such:\n * var obj = new StockPrice()\n * obj.update(timestamp,price)\n * var param_2 = obj.current()\n * var param_3 = obj.maximum()\n * var param_4 = obj.minimum()\n */",
    "php": "class StockPrice {\n    /**\n     */\n    function __construct() {\n        \n    }\n  \n    /**\n     * @param Integer $timestamp\n     * @param Integer $price\n     * @return NULL\n     */\n    function update($timestamp, $price) {\n        \n    }\n  \n    /**\n     * @return Integer\n     */\n    function current() {\n        \n    }\n  \n    /**\n     * @return Integer\n     */\n    function maximum() {\n        \n    }\n  \n    /**\n     * @return Integer\n     */\n    function minimum() {\n        \n    }\n}\n\n/**\n * Your StockPrice object will be instantiated and called as such:\n * $obj = StockPrice();\n * $obj->update($timestamp, $price);\n * $ret_2 = $obj->current();\n * $ret_3 = $obj->maximum();\n * $ret_4 = $obj->minimum();\n */",
    "swift": "\nclass StockPrice {\n\n    init() {\n        \n    }\n    \n    func update(_ timestamp: Int, _ price: Int) {\n        \n    }\n    \n    func current() -> Int {\n        \n    }\n    \n    func maximum() -> Int {\n        \n    }\n    \n    func minimum() -> Int {\n        \n    }\n}\n\n/**\n * Your StockPrice object will be instantiated and called as such:\n * let obj = StockPrice()\n * obj.update(timestamp, price)\n * let ret_2: Int = obj.current()\n * let ret_3: Int = obj.maximum()\n * let ret_4: Int = obj.minimum()\n */",
    "kotlin": "class StockPrice() {\n\n    fun update(timestamp: Int, price: Int) {\n        \n    }\n\n    fun current(): Int {\n        \n    }\n\n    fun maximum(): Int {\n        \n    }\n\n    fun minimum(): Int {\n        \n    }\n\n}\n\n/**\n * Your StockPrice object will be instantiated and called as such:\n * var obj = StockPrice()\n * obj.update(timestamp,price)\n * var param_2 = obj.current()\n * var param_3 = obj.maximum()\n * var param_4 = obj.minimum()\n */",
    "dart": "class StockPrice {\n\n  StockPrice() {\n    \n  }\n  \n  void update(int timestamp, int price) {\n    \n  }\n  \n  int current() {\n    \n  }\n  \n  int maximum() {\n    \n  }\n  \n  int minimum() {\n    \n  }\n}\n\n/**\n * Your StockPrice object will be instantiated and called as such:\n * StockPrice obj = StockPrice();\n * obj.update(timestamp,price);\n * int param2 = obj.current();\n * int param3 = obj.maximum();\n * int param4 = obj.minimum();\n */",
    "golang": "type StockPrice struct {\n    \n}\n\n\nfunc Constructor() StockPrice {\n    \n}\n\n\nfunc (this *StockPrice) Update(timestamp int, price int)  {\n    \n}\n\n\nfunc (this *StockPrice) Current() int {\n    \n}\n\n\nfunc (this *StockPrice) Maximum() int {\n    \n}\n\n\nfunc (this *StockPrice) Minimum() int {\n    \n}\n\n\n/**\n * Your StockPrice object will be instantiated and called as such:\n * obj := Constructor();\n * obj.Update(timestamp,price);\n * param_2 := obj.Current();\n * param_3 := obj.Maximum();\n * param_4 := obj.Minimum();\n */",
    "ruby": "class StockPrice\n    def initialize()\n        \n    end\n\n\n=begin\n    :type timestamp: Integer\n    :type price: Integer\n    :rtype: Void\n=end\n    def update(timestamp, price)\n        \n    end\n\n\n=begin\n    :rtype: Integer\n=end\n    def current()\n        \n    end\n\n\n=begin\n    :rtype: Integer\n=end\n    def maximum()\n        \n    end\n\n\n=begin\n    :rtype: Integer\n=end\n    def minimum()\n        \n    end\n\n\nend\n\n# Your StockPrice object will be instantiated and called as such:\n# obj = StockPrice.new()\n# obj.update(timestamp, price)\n# param_2 = obj.current()\n# param_3 = obj.maximum()\n# param_4 = obj.minimum()",
    "scala": "class StockPrice() {\n\n    def update(timestamp: Int, price: Int): Unit = {\n        \n    }\n\n    def current(): Int = {\n        \n    }\n\n    def maximum(): Int = {\n        \n    }\n\n    def minimum(): Int = {\n        \n    }\n\n}\n\n/**\n * Your StockPrice object will be instantiated and called as such:\n * val obj = new StockPrice()\n * obj.update(timestamp,price)\n * val param_2 = obj.current()\n * val param_3 = obj.maximum()\n * val param_4 = obj.minimum()\n */",
    "rust": "struct StockPrice {\n\n}\n\n\n/** \n * `&self` means the method takes an immutable reference.\n * If you need a mutable reference, change it to `&mut self` instead.\n */\nimpl StockPrice {\n\n    fn new() -> Self {\n        \n    }\n    \n    fn update(&self, timestamp: i32, price: i32) {\n        \n    }\n    \n    fn current(&self) -> i32 {\n        \n    }\n    \n    fn maximum(&self) -> i32 {\n        \n    }\n    \n    fn minimum(&self) -> i32 {\n        \n    }\n}\n\n/**\n * Your StockPrice object will be instantiated and called as such:\n * let obj = StockPrice::new();\n * obj.update(timestamp, price);\n * let ret_2: i32 = obj.current();\n * let ret_3: i32 = obj.maximum();\n * let ret_4: i32 = obj.minimum();\n */",
    "racket": "(define stock-price%\n  (class object%\n    (super-new)\n    \n    (init-field)\n    \n    ; update : exact-integer? exact-integer? -> void?\n    (define/public (update timestamp price)\n      )\n    ; current : -> exact-integer?\n    (define/public (current)\n      )\n    ; maximum : -> exact-integer?\n    (define/public (maximum)\n      )\n    ; minimum : -> exact-integer?\n    (define/public (minimum)\n      )))\n\n;; Your stock-price% object will be instantiated and called as such:\n;; (define obj (new stock-price%))\n;; (send obj update timestamp price)\n;; (define param_2 (send obj current))\n;; (define param_3 (send obj maximum))\n;; (define param_4 (send obj minimum))",
    "erlang": "-spec stock_price_init_() -> any().\nstock_price_init_() ->\n  .\n\n-spec stock_price_update(Timestamp :: integer(), Price :: integer()) -> any().\nstock_price_update(Timestamp, Price) ->\n  .\n\n-spec stock_price_current() -> integer().\nstock_price_current() ->\n  .\n\n-spec stock_price_maximum() -> integer().\nstock_price_maximum() ->\n  .\n\n-spec stock_price_minimum() -> integer().\nstock_price_minimum() ->\n  .\n\n\n%% Your functions will be called as such:\n%% stock_price_init_(),\n%% stock_price_update(Timestamp, Price),\n%% Param_2 = stock_price_current(),\n%% Param_3 = stock_price_maximum(),\n%% Param_4 = stock_price_minimum(),\n\n%% stock_price_init_ will be called before every test case, in which you can do some necessary initializations.",
    "elixir": "defmodule StockPrice do\n  @spec init_() :: any\n  def init_() do\n    \n  end\n\n  @spec update(timestamp :: integer, price :: integer) :: any\n  def update(timestamp, price) do\n    \n  end\n\n  @spec current() :: integer\n  def current() do\n    \n  end\n\n  @spec maximum() :: integer\n  def maximum() do\n    \n  end\n\n  @spec minimum() :: integer\n  def minimum() do\n    \n  end\nend\n\n# Your functions will be called as such:\n# StockPrice.init_()\n# StockPrice.update(timestamp, price)\n# param_2 = StockPrice.current()\n# param_3 = StockPrice.maximum()\n# param_4 = StockPrice.minimum()\n\n# StockPrice.init_ will be called before every test case, in which you can do some necessary initializations."
  }
}