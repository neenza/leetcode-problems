{
  "title": "Greatest Common Divisor of Strings",
  "problem_id": "1146",
  "frontend_id": "1071",
  "difficulty": "Easy",
  "problem_slug": "greatest-common-divisor-of-strings",
  "topics": [
    "Math",
    "String"
  ],
  "description": "For two strings s and t, we say \"t divides s\" if and only if s = t + t + t + ... + t + t (i.e., t is concatenated with itself one or more times).\nGiven two strings str1 and str2, return the largest string x such that x divides both str1 and str2.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: str1 = \"ABCABC\", str2 = \"ABC\"\nOutput: \"ABC\"",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input: str1 = \"ABABAB\", str2 = \"ABAB\"\nOutput: \"AB\"",
      "images": []
    },
    {
      "example_num": 3,
      "example_text": "Input: str1 = \"LEET\", str2 = \"CODE\"\nOutput: \"\"",
      "images": []
    }
  ],
  "constraints": [
    "1 <= str1.length, str2.length <= 1000",
    "str1 and str2 consist of English uppercase letters."
  ],
  "follow_ups": [],
  "hints": [
    "The greatest common divisor must be a prefix of each string, so we can try all prefixes."
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    string gcdOfStrings(string str1, string str2) {\n        \n    }\n};",
    "java": "class Solution {\n    public String gcdOfStrings(String str1, String str2) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def gcdOfStrings(self, str1, str2):\n        \"\"\"\n        :type str1: str\n        :type str2: str\n        :rtype: str\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def gcdOfStrings(self, str1: str, str2: str) -> str:\n        ",
    "c": "char* gcdOfStrings(char* str1, char* str2) {\n    \n}",
    "csharp": "public class Solution {\n    public string GcdOfStrings(string str1, string str2) {\n        \n    }\n}",
    "javascript": "/**\n * @param {string} str1\n * @param {string} str2\n * @return {string}\n */\nvar gcdOfStrings = function(str1, str2) {\n    \n};",
    "typescript": "function gcdOfStrings(str1: string, str2: string): string {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param String $str1\n     * @param String $str2\n     * @return String\n     */\n    function gcdOfStrings($str1, $str2) {\n        \n    }\n}",
    "swift": "class Solution {\n    func gcdOfStrings(_ str1: String, _ str2: String) -> String {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun gcdOfStrings(str1: String, str2: String): String {\n        \n    }\n}",
    "dart": "class Solution {\n  String gcdOfStrings(String str1, String str2) {\n    \n  }\n}",
    "golang": "func gcdOfStrings(str1 string, str2 string) string {\n    \n}",
    "ruby": "# @param {String} str1\n# @param {String} str2\n# @return {String}\ndef gcd_of_strings(str1, str2)\n    \nend",
    "scala": "object Solution {\n    def gcdOfStrings(str1: String, str2: String): String = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn gcd_of_strings(str1: String, str2: String) -> String {\n        \n    }\n}",
    "racket": "(define/contract (gcd-of-strings str1 str2)\n  (-> string? string? string?)\n  )",
    "erlang": "-spec gcd_of_strings(Str1 :: unicode:unicode_binary(), Str2 :: unicode:unicode_binary()) -> unicode:unicode_binary().\ngcd_of_strings(Str1, Str2) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec gcd_of_strings(str1 :: String.t, str2 :: String.t) :: String.t\n  def gcd_of_strings(str1, str2) do\n    \n  end\nend"
  },
  "solution": "[TOC]\n\n## Solution\n\n--- \n\n### Overview\n\nIn this problem, we are looking for the Greatest Common Divisor of two strings, which for convenience we will consider as the **GCD string**. To remove ambiguity, here we regard:\n\n- all strings that divides both str1 and str2 as **divisible strings**.\n- the longest string among all **divisible strings** as the **GCD string**.\n\n\n---\n\n### Approach 1: Brute Force\n\n#### Intuition   \n\nWe start by introducing a brute force method that checks every possible string until we find the GCD string. Before we do that, let's clarify a few things:\n\n> What are the possible candidate strings?\n\nHere we make use of prefix strings. If a string `base` is the GCD string, it must be a prefix of both `str1` and `str2`. So instead of trying every combination of characters, we instead just take each prefix string of `str1` (or `str2`) and check if it is the GCD string.\n\n\n> What is the order we should check in?\n\n\nAs the problem indicates that we should look for the greatest common divisor string (longest length), we should start with the longest possible prefix string, which is the shorter string between `str1` and `str2` (any longer string is guaranteed not to be a divisible string since it will be longer than at least one string). If the current `base` is not valid, we can check the next shorter prefix by removing the last character from `base`.\n\n\n![img](../Figures/1071/bf1.png)\n\n> How to verify if `base` is the GCD string?\n\nIf `base` is the GCD string, then both `str1` and `str2` are made up of multiples of `base`, so we just need to check if `str1` and `str2` can be made up of multiple `base` concatenations. We first check if the length of `str` is divisible by the length of `base`. If so, we multiply `base` by the number of times the lengths divide and check if the made-up string equals `str`.\n\n\n![img](../Figures/1071/bf2.png)#### Algorithm\n\n1) Find the shorter string among `str1` and `str2`, without loss of generality, let it be `str1`. \n2) Start with `base = str1`, and check if both `str1` and `str2` are made of multiples of `base`.\n\n    - If so, return `base`.\n    - Otherwise, we shall try a shorter string by removing the last character from `base`.\n3) If we have checked all prefix strings without finding the GCD string, return `\"\"`.\n\n#### Implementation#### Complexity Analysis\n\nLet $m, n$ be the lengths of the two input strings `str1` and `str2`.\n\n* Time complexity: $O(\\min(m, n) \\cdot (m + n))$\n    We checked every prefix string `base` of the shorter string among `str1` and `str2`, and verify if both strings are made by multiples of `base`. There are up to $\\min(m, n)$ prefix strings to verify and each check involves iterating over the two input strings to check if the current `base` is the GCD string, which costs $O(m + n)$. Therefore, the overall time complexity is $O(\\min(m, n) \\cdot (m + n))$.\n    \n\n* Space complexity: $O(\\min(m, n))$\n    We need to keep a copy of `base` in each iteration, which takes $O(\\min(m, n))$ space.---\n\n### Approach 2: Greatest Common Divisor\n\n#### Intuition   \n\nHere is a more mathematical approach to the problem. Note that this approach is more advanced/elegant and you should not feel discouraged if you do not come up with it on the spot in an interview.\n\n\n**1. How to verify if there exists any divisible string?**\n\n\nSuppose there exists a divisible string `base`, we can write `str1` and `str2` in the form of multiples of `base`. Take the following picture as an example.\n\n\n\n![img](../Figures/1071/gcd1.png)\n\nSince both strings contains multiples of the identical segment `base`, their concatenation must be consistent, regardless of the order `(str1 + str2 = str2 + str1)`.\n\n\n![img](../Figures/1071/gcd2.png)\n\nTherefore, we need to check if two concatenations made by `str1` and `str2` in both orders are the same. If they are not consistent, it means there is no divisible strings and we should return `\"\"` as required. Otherwise, there exists a GCD string of `str1` and `str2`.\n\n\n\n**2. If there are divisible strings, what is the length of the GCD string?**\n\n \nWe focus on the substring `gcdBase` whose length equals the greatest common divisor of the lengths of `str1` and `str2` (take the above picture as an example, the lengths of `str1` and `str2` are `9` and `6`, so we focus on the substring of length `3`, which is `gcdBase = ABC`). We will show that if there exists divisible strings, then the `gcdBase` must be the GCD string.\n\n\nFor convenience, we refer to the length of `str1`, `str2` and `gcdBase` as `m`, `n`, `gcdLength` respectively.\n\n\n> Is it possible for the GCD string to be shorter than `gcdBase`?\n\n\nNo. We can prove it by contradiction. Assume that a string `shorterBase` is shorter than `gcdBase` (`shorterLength < gcdLength`, and `gcdBase` is not the GCD string). \n\n\n- `shorterBase` is a divisible string, thus `shorterLength` is a divisor of `m` and `n`.\n- Since `gcdLength` is the greatest common divisor of `m` and `n`, `gcdLength` is divisible by `shorterLength`.\n- Both `str1` and `str2` contains multiples of `gcdBase`, so `gcdBase` is also a divisible string, which means that the GCD string is at least as long as `gcdBase`.\n\n- Therefore it is not possible for the GCD string to be shorter than `gcdBase`.\n\n\nLet's look at the following example where `gcdBase = ABCABC`. Note that we are not sure if `gcdBase` is the GCD string yet.\n\n\n![img](../Figures/1071/exp_2.png)\n\nThere exists a shorter substring `shorterBase = ABC` which divides both `str1` and `str2`. Can this divisible string be the GCD of strings? \n\n![img](../Figures/1071/exp_3.png)\n\nBoth `str1` and `str2` contain multiples of `shorterBase`.\n\n\n![img](../Figures/1071/exp_4.png)\n\nRecall that the length of `gcdBase` is the GCD of the lengths of `str1` and `str2`, thus it is divisible by the length of `shorterBase`.\n\n![img](../Figures/1071/exp_5.png)\n\nSince `gcdLength` is a divisor of both `m` and `n`, both `str1` and `str2` contain multiples of `gcdBase`, thus `gcdBase` is also a divisible string.\n\n\n![img](../Figures/1071/exp_6.png)\n\nWe have shown that if there is a shorter string that divides both str1 and str2, then `gcdBase` is also a divisible string, so a divisible string shorter than `gcdBase` can never be the GCD  string.\n\n\n\n\n> Is it possible for the a string longer than `gcdBase` to be divisible, and thus `gcdBase` is not the GCD string?\n\n\nNo. Assume that there exists a string `longerBase` that is a divisible string with length `longerLength > gcdLength`, \n\n\n- Since `longerBase` is a divisible string, its length `longerLength` must be a divisor of `m` and `n`. \n\n- This contradicts the assumption that `gcdLength` is the GCD of `m` and `n`. \n\n- Therefore there doesn't exist a divisible string longer than `gcdBase`.\n\n\n\n**In conclusion, if there exists divisible strings, the GCD string must be `gcdBase`.**#### Algorithm\n\n1) Check if the concatenations of `str1` and `str2` in different orders are the same. \n    - If not, return `\"\"`.\n\n2) Get the GCD `gcdLength` of the two lengths of `str1` and `str2`.\n\n3) Return the prefix string with a length of `gcdLength` of either `str1` or `str2` as the answer.\n\n\n#### Implementation#### Complexity Analysis\n\nLet $m, n$ be the lengthes of the two input strings `str1` and `str2`.\n\n* Time complexity: $O(m + n)$\n    - We need to compare the two concatenations of length $O(m + n)$, it takes $O(m + n)$ time.\n    - We calculate the GCD using binary Euclidean algorithm, it takes $\\log(m \\cdot n)$ time.\n    - To sum up, the overall time complexity is $O(m + n)$.\n    \n\n* Space complexity: $O(m + n)$\n    We need to compare the two concatenations of length $O(m + n)$."
}