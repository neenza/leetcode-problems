{
  "title": "Design an Ordered Stream",
  "problem_id": "1775",
  "frontend_id": "1656",
  "difficulty": "Easy",
  "problem_slug": "design-an-ordered-stream",
  "topics": [
    "Array",
    "Hash Table",
    "Design",
    "Data Stream"
  ],
  "description": "There is a stream of n (idKey, value) pairs arriving in an arbitrary order, where idKey is an integer between 1 and n and value is a string. No two pairs have the same id.\nDesign a stream that returns the values in increasing order of their IDs by returning a chunk (list) of values after each insertion. The concatenation of all the chunks should result in a list of the sorted values.\nImplement the OrderedStream class:\nExample:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input\n[\"OrderedStream\", \"insert\", \"insert\", \"insert\", \"insert\", \"insert\"]\n[[5], [3, \"ccccc\"], [1, \"aaaaa\"], [2, \"bbbbb\"], [5, \"eeeee\"], [4, \"ddddd\"]]\nOutput\n[null, [], [\"aaaaa\"], [\"bbbbb\", \"ccccc\"], [], [\"ddddd\", \"eeeee\"]]\n\nExplanation\n// Note that the values ordered by ID is [\"aaaaa\", \"bbbbb\", \"ccccc\", \"ddddd\", \"eeeee\"].\nOrderedStream os = new OrderedStream(5);\nos.insert(3, \"ccccc\"); // Inserts (3, \"ccccc\"), returns [].\nos.insert(1, \"aaaaa\"); // Inserts (1, \"aaaaa\"), returns [\"aaaaa\"].\nos.insert(2, \"bbbbb\"); // Inserts (2, \"bbbbb\"), returns [\"bbbbb\", \"ccccc\"].\nos.insert(5, \"eeeee\"); // Inserts (5, \"eeeee\"), returns [].\nos.insert(4, \"ddddd\"); // Inserts (4, \"ddddd\"), returns [\"ddddd\", \"eeeee\"].\n// Concatentating all the chunks returned:\n// [] + [\"aaaaa\"] + [\"bbbbb\", \"ccccc\"] + [] + [\"ddddd\", \"eeeee\"] = [\"aaaaa\", \"bbbbb\", \"ccccc\", \"ddddd\", \"eeeee\"]\n// The resulting order is the same as the order above.",
      "images": [
        "https://assets.leetcode.com/uploads/2020/11/10/q1.gif"
      ]
    }
  ],
  "constraints": [
    "1 <= n <= 1000",
    "1 <= id <= n",
    "value.length == 5",
    "value consists only of lowercase letters.",
    "Each call to insert will have a unique id.",
    "Exactly n calls will be made to insert."
  ],
  "follow_ups": [],
  "hints": [
    "Maintain the next id that should be outputted.",
    "Maintain the ids that were inserted in the stream.",
    "Per each insert, make a loop where you check if the id that has the turn has been inserted, and if so increment the id that has the turn and continue the loop, else break."
  ],
  "code_snippets": {
    "cpp": "class OrderedStream {\npublic:\n    OrderedStream(int n) {\n        \n    }\n    \n    vector<string> insert(int idKey, string value) {\n        \n    }\n};\n\n/**\n * Your OrderedStream object will be instantiated and called as such:\n * OrderedStream* obj = new OrderedStream(n);\n * vector<string> param_1 = obj->insert(idKey,value);\n */",
    "java": "class OrderedStream {\n\n    public OrderedStream(int n) {\n        \n    }\n    \n    public List<String> insert(int idKey, String value) {\n        \n    }\n}\n\n/**\n * Your OrderedStream object will be instantiated and called as such:\n * OrderedStream obj = new OrderedStream(n);\n * List<String> param_1 = obj.insert(idKey,value);\n */",
    "python": "class OrderedStream(object):\n\n    def __init__(self, n):\n        \"\"\"\n        :type n: int\n        \"\"\"\n        \n\n    def insert(self, idKey, value):\n        \"\"\"\n        :type idKey: int\n        :type value: str\n        :rtype: List[str]\n        \"\"\"\n        \n\n\n# Your OrderedStream object will be instantiated and called as such:\n# obj = OrderedStream(n)\n# param_1 = obj.insert(idKey,value)",
    "python3": "class OrderedStream:\n\n    def __init__(self, n: int):\n        \n\n    def insert(self, idKey: int, value: str) -> List[str]:\n        \n\n\n# Your OrderedStream object will be instantiated and called as such:\n# obj = OrderedStream(n)\n# param_1 = obj.insert(idKey,value)",
    "c": "\n\n\ntypedef struct {\n    \n} OrderedStream;\n\n\nOrderedStream* orderedStreamCreate(int n) {\n    \n}\n\nchar** orderedStreamInsert(OrderedStream* obj, int idKey, char* value, int* retSize) {\n    \n}\n\nvoid orderedStreamFree(OrderedStream* obj) {\n    \n}\n\n/**\n * Your OrderedStream struct will be instantiated and called as such:\n * OrderedStream* obj = orderedStreamCreate(n);\n * char** param_1 = orderedStreamInsert(obj, idKey, value, retSize);\n \n * orderedStreamFree(obj);\n*/",
    "csharp": "public class OrderedStream {\n\n    public OrderedStream(int n) {\n        \n    }\n    \n    public IList<string> Insert(int idKey, string value) {\n        \n    }\n}\n\n/**\n * Your OrderedStream object will be instantiated and called as such:\n * OrderedStream obj = new OrderedStream(n);\n * IList<string> param_1 = obj.Insert(idKey,value);\n */",
    "javascript": "/**\n * @param {number} n\n */\nvar OrderedStream = function(n) {\n    \n};\n\n/** \n * @param {number} idKey \n * @param {string} value\n * @return {string[]}\n */\nOrderedStream.prototype.insert = function(idKey, value) {\n    \n};\n\n/** \n * Your OrderedStream object will be instantiated and called as such:\n * var obj = new OrderedStream(n)\n * var param_1 = obj.insert(idKey,value)\n */",
    "typescript": "class OrderedStream {\n    constructor(n: number) {\n        \n    }\n\n    insert(idKey: number, value: string): string[] {\n        \n    }\n}\n\n/**\n * Your OrderedStream object will be instantiated and called as such:\n * var obj = new OrderedStream(n)\n * var param_1 = obj.insert(idKey,value)\n */",
    "php": "class OrderedStream {\n    /**\n     * @param Integer $n\n     */\n    function __construct($n) {\n        \n    }\n  \n    /**\n     * @param Integer $idKey\n     * @param String $value\n     * @return String[]\n     */\n    function insert($idKey, $value) {\n        \n    }\n}\n\n/**\n * Your OrderedStream object will be instantiated and called as such:\n * $obj = OrderedStream($n);\n * $ret_1 = $obj->insert($idKey, $value);\n */",
    "swift": "\nclass OrderedStream {\n\n    init(_ n: Int) {\n        \n    }\n    \n    func insert(_ idKey: Int, _ value: String) -> [String] {\n        \n    }\n}\n\n/**\n * Your OrderedStream object will be instantiated and called as such:\n * let obj = OrderedStream(n)\n * let ret_1: [String] = obj.insert(idKey, value)\n */",
    "kotlin": "class OrderedStream(n: Int) {\n\n    fun insert(idKey: Int, value: String): List<String> {\n        \n    }\n\n}\n\n/**\n * Your OrderedStream object will be instantiated and called as such:\n * var obj = OrderedStream(n)\n * var param_1 = obj.insert(idKey,value)\n */",
    "dart": "class OrderedStream {\n\n  OrderedStream(int n) {\n    \n  }\n  \n  List<String> insert(int idKey, String value) {\n    \n  }\n}\n\n/**\n * Your OrderedStream object will be instantiated and called as such:\n * OrderedStream obj = OrderedStream(n);\n * List<String> param1 = obj.insert(idKey,value);\n */",
    "golang": "type OrderedStream struct {\n    \n}\n\n\nfunc Constructor(n int) OrderedStream {\n    \n}\n\n\nfunc (this *OrderedStream) Insert(idKey int, value string) []string {\n    \n}\n\n\n/**\n * Your OrderedStream object will be instantiated and called as such:\n * obj := Constructor(n);\n * param_1 := obj.Insert(idKey,value);\n */",
    "ruby": "class OrderedStream\n\n=begin\n    :type n: Integer\n=end\n    def initialize(n)\n        \n    end\n\n\n=begin\n    :type id_key: Integer\n    :type value: String\n    :rtype: String[]\n=end\n    def insert(id_key, value)\n        \n    end\n\n\nend\n\n# Your OrderedStream object will be instantiated and called as such:\n# obj = OrderedStream.new(n)\n# param_1 = obj.insert(id_key, value)",
    "scala": "class OrderedStream(_n: Int) {\n\n    def insert(idKey: Int, value: String): List[String] = {\n        \n    }\n\n}\n\n/**\n * Your OrderedStream object will be instantiated and called as such:\n * val obj = new OrderedStream(n)\n * val param_1 = obj.insert(idKey,value)\n */",
    "rust": "struct OrderedStream {\n\n}\n\n\n/** \n * `&self` means the method takes an immutable reference.\n * If you need a mutable reference, change it to `&mut self` instead.\n */\nimpl OrderedStream {\n\n    fn new(n: i32) -> Self {\n        \n    }\n    \n    fn insert(&self, id_key: i32, value: String) -> Vec<String> {\n        \n    }\n}\n\n/**\n * Your OrderedStream object will be instantiated and called as such:\n * let obj = OrderedStream::new(n);\n * let ret_1: Vec<String> = obj.insert(idKey, value);\n */",
    "racket": "(define ordered-stream%\n  (class object%\n    (super-new)\n    \n    ; n : exact-integer?\n    (init-field\n      n)\n    \n    ; insert : exact-integer? string? -> (listof string?)\n    (define/public (insert id-key value)\n      )))\n\n;; Your ordered-stream% object will be instantiated and called as such:\n;; (define obj (new ordered-stream% [n n]))\n;; (define param_1 (send obj insert id-key value))",
    "erlang": "-spec ordered_stream_init_(N :: integer()) -> any().\nordered_stream_init_(N) ->\n  .\n\n-spec ordered_stream_insert(IdKey :: integer(), Value :: unicode:unicode_binary()) -> [unicode:unicode_binary()].\nordered_stream_insert(IdKey, Value) ->\n  .\n\n\n%% Your functions will be called as such:\n%% ordered_stream_init_(N),\n%% Param_1 = ordered_stream_insert(IdKey, Value),\n\n%% ordered_stream_init_ will be called before every test case, in which you can do some necessary initializations.",
    "elixir": "defmodule OrderedStream do\n  @spec init_(n :: integer) :: any\n  def init_(n) do\n    \n  end\n\n  @spec insert(id_key :: integer, value :: String.t) :: [String.t]\n  def insert(id_key, value) do\n    \n  end\nend\n\n# Your functions will be called as such:\n# OrderedStream.init_(n)\n# param_1 = OrderedStream.insert(id_key, value)\n\n# OrderedStream.init_ will be called before every test case, in which you can do some necessary initializations."
  }
}