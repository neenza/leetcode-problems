{
  "title": "Prime Arrangements",
  "problem_id": "1279",
  "frontend_id": "1175",
  "difficulty": "Easy",
  "problem_slug": "prime-arrangements",
  "topics": [
    "Math"
  ],
  "description": "Return the number of permutations of 1 to n so that prime numbers are at prime indices (1-indexed.)\n(Recall that an integer is prime if and only if it is greater than 1, and cannot be written as a product of two positive integers both smaller than it.)\nSince the answer may be large, return the answer modulo 10^9 + 7.\nExample 1:\nExample 2:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: n = 5\nOutput: 12\nExplanation: For example [1,2,5,4,3] is a valid permutation, but [5,2,3,4,1] is not because the prime number 5 is at index 1.",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input: n = 100\nOutput: 682289015",
      "images": []
    }
  ],
  "constraints": [
    "1 <= n <= 100"
  ],
  "follow_ups": [],
  "hints": [
    "Solve the problem for prime numbers and composite numbers separately.",
    "Multiply the number of permutations of prime numbers over prime indices with the number of permutations of composite numbers over composite indices.",
    "The number of permutations equals the factorial."
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    int numPrimeArrangements(int n) {\n        \n    }\n};",
    "java": "class Solution {\n    public int numPrimeArrangements(int n) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def numPrimeArrangements(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def numPrimeArrangements(self, n: int) -> int:\n        ",
    "c": "int numPrimeArrangements(int n) {\n    \n}",
    "csharp": "public class Solution {\n    public int NumPrimeArrangements(int n) {\n        \n    }\n}",
    "javascript": "/**\n * @param {number} n\n * @return {number}\n */\nvar numPrimeArrangements = function(n) {\n    \n};",
    "typescript": "function numPrimeArrangements(n: number): number {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param Integer $n\n     * @return Integer\n     */\n    function numPrimeArrangements($n) {\n        \n    }\n}",
    "swift": "class Solution {\n    func numPrimeArrangements(_ n: Int) -> Int {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun numPrimeArrangements(n: Int): Int {\n        \n    }\n}",
    "dart": "class Solution {\n  int numPrimeArrangements(int n) {\n    \n  }\n}",
    "golang": "func numPrimeArrangements(n int) int {\n    \n}",
    "ruby": "# @param {Integer} n\n# @return {Integer}\ndef num_prime_arrangements(n)\n    \nend",
    "scala": "object Solution {\n    def numPrimeArrangements(n: Int): Int = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn num_prime_arrangements(n: i32) -> i32 {\n        \n    }\n}",
    "racket": "(define/contract (num-prime-arrangements n)\n  (-> exact-integer? exact-integer?)\n  )",
    "erlang": "-spec num_prime_arrangements(N :: integer()) -> integer().\nnum_prime_arrangements(N) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec num_prime_arrangements(n :: integer) :: integer\n  def num_prime_arrangements(n) do\n    \n  end\nend"
  }
}