{
  "title": "Minimize Maximum Component Cost",
  "problem_id": "3881",
  "frontend_id": "3613",
  "difficulty": "Medium",
  "problem_slug": "minimize-maximum-component-cost",
  "topics": [
    "Binary Search",
    "Sort",
    "Union Find",
    "Graph"
  ],
  "description": "You are given an undirected connected graph with n nodes labeled from 0 to n - 1 and a 2D integer array edges where edges[i] = [ui, vi, wi] denotes an undirected edge between node ui and node vi with weight wi, and an integer k.\nYou are allowed to remove any number of edges from the graph such that the resulting graph has at most k connected components.\nThe cost of a component is defined as the maximum edge weight in that component. If a component has no edges, its cost is 0.\nReturn the minimum possible value of the maximum cost among all components after such removals.\nExample 1:\nExample 2:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: n = 5, edges = [[0,1,4],[1,2,3],[1,3,2],[3,4,6]], k = 2\nOutput: 4\nExplanation:\n",
      "images": [
        "https://assets.leetcode.com/uploads/2025/04/19/minimizemaximumm.jpg"
      ]
    },
    {
      "example_num": 2,
      "example_text": "Input: n = 4, edges = [[0,1,5],[1,2,5],[2,3,5]], k = 1\nOutput: 5\nExplanation:\n",
      "images": [
        "https://assets.leetcode.com/uploads/2025/04/19/minmax2.jpg"
      ]
    }
  ],
  "constraints": [
    "1 <= n <= 5 * 104",
    "0 <= edges.length <= 105",
    "edges[i].length == 3",
    "0 <= ui, vi < n",
    "1 <= wi <= 106",
    "1 <= k <= n",
    "The input graph is connected."
  ],
  "follow_ups": [],
  "hints": [
    "Sort the <code>edges</code> and do binary search on the candidate maximum weight",
    "Use <code>DFS</code> or <code>DSU</code> to count the number of connected components when keeping only edges with weight <= mid"
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    int minCost(int n, vector<vector<int>>& edges, int k) {\n        \n    }\n};",
    "java": "class Solution {\n    public int minCost(int n, int[][] edges, int k) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def minCost(self, n, edges, k):\n        \"\"\"\n        :type n: int\n        :type edges: List[List[int]]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def minCost(self, n: int, edges: List[List[int]], k: int) -> int:\n        ",
    "c": "int minCost(int n, int** edges, int edgesSize, int* edgesColSize, int k) {\n    \n}",
    "csharp": "public class Solution {\n    public int MinCost(int n, int[][] edges, int k) {\n        \n    }\n}",
    "javascript": "/**\n * @param {number} n\n * @param {number[][]} edges\n * @param {number} k\n * @return {number}\n */\nvar minCost = function(n, edges, k) {\n    \n};",
    "typescript": "function minCost(n: number, edges: number[][], k: number): number {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param Integer $n\n     * @param Integer[][] $edges\n     * @param Integer $k\n     * @return Integer\n     */\n    function minCost($n, $edges, $k) {\n        \n    }\n}",
    "swift": "class Solution {\n    func minCost(_ n: Int, _ edges: [[Int]], _ k: Int) -> Int {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun minCost(n: Int, edges: Array<IntArray>, k: Int): Int {\n        \n    }\n}",
    "dart": "class Solution {\n  int minCost(int n, List<List<int>> edges, int k) {\n    \n  }\n}",
    "golang": "func minCost(n int, edges [][]int, k int) int {\n    \n}",
    "ruby": "# @param {Integer} n\n# @param {Integer[][]} edges\n# @param {Integer} k\n# @return {Integer}\ndef min_cost(n, edges, k)\n    \nend",
    "scala": "object Solution {\n    def minCost(n: Int, edges: Array[Array[Int]], k: Int): Int = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn min_cost(n: i32, edges: Vec<Vec<i32>>, k: i32) -> i32 {\n        \n    }\n}",
    "racket": "(define/contract (min-cost n edges k)\n  (-> exact-integer? (listof (listof exact-integer?)) exact-integer? exact-integer?)\n  )",
    "erlang": "-spec min_cost(N :: integer(), Edges :: [[integer()]], K :: integer()) -> integer().\nmin_cost(N, Edges, K) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec min_cost(n :: integer, edges :: [[integer]], k :: integer) :: integer\n  def min_cost(n, edges, k) do\n    \n  end\nend"
  }
}