{
  "title": "Product Price at a Given Date",
  "problem_id": "1278",
  "frontend_id": "1164",
  "difficulty": "Medium",
  "problem_slug": "product-price-at-a-given-date",
  "topics": [
    "Database"
  ],
  "description": "Table: Products\nInitially, all products have price 10.\nWrite a solution to find the prices of all products on the date 2019-08-16.\nReturn the result table in any order.\nThe result format is in the following example.\nExample 1:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "+---------------+---------+\n| Column Name   | Type    |\n+---------------+---------+\n| product_id    | int     |\n| new_price     | int     |\n| change_date   | date    |\n+---------------+---------+\n(product_id, change_date) is the primary key (combination of columns with unique values) of this table.\nEach row of this table indicates that the price of some product was changed to a new price at some date.",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input: \nProducts table:\n+------------+-----------+-------------+\n| product_id | new_price | change_date |\n+------------+-----------+-------------+\n| 1          | 20        | 2019-08-14  |\n| 2          | 50        | 2019-08-14  |\n| 1          | 30        | 2019-08-15  |\n| 1          | 35        | 2019-08-16  |\n| 2          | 65        | 2019-08-17  |\n| 3          | 20        | 2019-08-18  |\n+------------+-----------+-------------+\nOutput: \n+------------+-------+\n| product_id | price |\n+------------+-------+\n| 2          | 50    |\n| 1          | 35    |\n| 3          | 10    |\n+------------+-------+",
      "images": []
    }
  ],
  "constraints": [],
  "follow_ups": [],
  "hints": [],
  "code_snippets": {
    "mysql": "# Write your MySQL query statement below\n",
    "mssql": "/* Write your T-SQL query statement below */\n",
    "oraclesql": "/* Write your PL/SQL query statement below */\n",
    "pythondata": "import pandas as pd\n\ndef price_at_given_date(products: pd.DataFrame) -> pd.DataFrame:\n    ",
    "postgresql": "-- Write your PostgreSQL query statement below\n"
  },
  "solution": "[TOC]\n\n## Solution\n\n---\n\n### Overview\n\n> **Problem reference:** Find the price of all products on the given date(`2019-08-16`). Assume the price before any change is `10`. Return the result table in any order.\n\nWe need to find the last changed price for each product until the given date (`2019-08-16`). If a product does not have an update before this date, the result for that product will be `NULL`. We need to handle `NULL` values so that the price is `10`.\n\n---\n\n### Approach 1: Divide cases by using `UNION ALL`\n\n#### Intuition\n\nWe can separate the cases by using the `UNION ALL` keyword. If the first changed date (`change_date`) is over the given date (`2019-08-16`), the price wasn't changed in time, so the `new_price` field is the old value `10`. Otherwise, we need to find the last changed date for the other rows by grouping to get the last changed price (`new_price`).\n\nWe know there are no duplicated tuples when we union the two separated tables because we get one field using `GROUP BY` for each query. Thus, it would be better to use `UNION ALL` instead of `UNION` for performance.\n\nAlso, we should be careful with grouping the table to get the last changed price because we cannot get the price directly by using a single `GROUP BY` clause. For example, if we group the example case where the `change_date` field is under `'2019-08-16` inclusive, it looks like the one below.\n\n```\n+------------+-----------+------------------+\n| product_id | new_price | last_change_date |\n+------------+-----------+------------------+\n| 1          | 20        | 2019-08-16       |\n| 1          | 30        | 2019-08-16       |\n| 1          | 35        | 2019-08-16       |\n| 2          | 50        | 2019-08-14       |\n| 2          | 65        | 2019-08-14       |\n+------------+-----------+------------------+\n```\n\nWe could try getting the last changed date by using the aggregate function and the `product_id`, which is the primary key and the grouping target. However, DBMS (Database Management System) does not know what to choose for the `new_price` field after grouping because there are multiple rows to choose from, so we cannot use the aggregate function. The reason why we cannot use the aggregate function is that we need to only get the `new_price` field by the last change date which we can do by comparing the set of the `product_id` and `change_date` fields.\n\n#### Algorithm\n\n1. Group the table with the `product_id` field and find the first changed date over `2019-08-16` by using `MIN` aggregation function on `HAVING` clause.\n2. Set the `price` table as `10`.\n3. Group the table with the `product_id` again, and find the `product_id` field and the last changed date until `2019-08-16`.\n4. Find the last changed `new_price` field with the last changed date.\n5. Union the two tables by using `UNION ALL`.\n\n#### Implementation\n\n##### MySQL\n\n```sql\nSELECT\n  product_id,\n  10 AS price\nFROM\n  Products\nGROUP BY\n  product_id\nHAVING\n  MIN(change_date) > '2019-08-16'\nUNION ALL\nSELECT\n  product_id,\n  new_price AS price\nFROM\n  Products\nWHERE\n  (product_id, change_date) IN (\n    SELECT\n      product_id,\n      MAX(change_date)\n    FROM\n      Products\n    WHERE\n      change_date <= '2019-08-16'\n    GROUP BY\n      product_id\n  )\n```\n\n### Approach 2: Divide cases by using `LEFT JOIN`\n\n#### Intuition\n\nWe can also handle the `NULL` value using the `LEFT JOIN` clause. For example, if there are no changes before the given date, the result field of `LEFT JOIN` is `NULL`. Thus, after we get the last changed date before the given date, we could join that table with the table with a unique `product_id` field and handle the `NULL` value using a condition statement.\n\nWe need to use two kinds of join, the `INNER JOIN` and the `LEFT JOIN`. We use the `INNER JOIN` to get the last changed price until the given date and the `LEFT JOIN` to handle the `NULL` value.\n\n!?!../Documents/1164/01_Slideshow.json:960,540!?!\n\n#### Algorithm\n\n1. Group the table with the `product_id`, and find the `product_id` field and the last changed date until `2019-08-16` using the aggregate function.\n2. Use `INNER JOIN` to join the tables where the set of `product_id` and `change_date` fields is the same.\n3. Get the last changed price and the `product_id` fields from the joined table.\n4. Join by using `LEFT JOIN` where the `product_id` field is the same.\n5. Handle the `NULL` value, which means there are no changes before the given date, using the `IFNULL` function.\n\n#### Implementation\n\n##### MySQL\n\n```sql\nSELECT\n  UniqueProductId.product_id,\n  IFNULL (LastChangedPrice.new_price, 10) AS price\nFROM\n  (\n    SELECT DISTINCT\n      product_id\n    FROM\n      Products\n  ) AS UniqueProductIds\n  LEFT JOIN (\n    SELECT\n      Products.product_id,\n      new_price\n    FROM\n      Products\n      JOIN (\n        SELECT\n          product_id,\n          MAX(change_date) AS change_date\n        FROM\n          Products\n        WHERE\n          change_date <= \"2019-08-16\"\n        GROUP BY\n          product_id\n      ) AS LastChangedDate USING (product_id, change_date)\n    GROUP BY\n      product_id\n  ) AS LastChangedPrice USING (product_id)\n```\n\n### Approach 3: Use the window function\n\n#### Intuition\n\nWe can get the last changed price by using the window function, `FIRST_VALUE`.\n\n#### Window function\n\nIn [MySQL](https://dev.mysql.com/doc/refman/8.0/en/window-functions-usage.html), they say the window function _performs an aggregate-like operation on a set of query rows._ Even though they work almost the same, the aggregate function returns a single row for each target field, but the window function produces a result for each row.\n\nThere are two window function types: the aggregate function and the non-aggregate function. The aggregate function could be the window function with the `OVER` clause, such as `MAX`, `MIN`, and `SUM`. Thus, if we use these aggregate functions **without** the `OVER` clause, it works as the aggregate function; if we use these **with** the `OVER` clause, it works as the window function. However, some window functions, such as `LEAD`, `LAG`, `RANK`, and `FIRST_VALUE` are non-aggregate functions, which means they should be used with the `OVER` clause.\n\nWe define the target field to group or order on the `OVER` clause. Hence, if we use the `FIRST_VALUE` window function, the syntax looks like the image below. (You can get more details if you want to know the specification of the window function in [MySQL reference](https://dev.mysql.com/doc/refman/8.0/en/window-functions-usage.html).)\n\n![Window Function](../Documents/1164/02_Window_Function.png)\n\nThe `PARTITION BY` works the same as `GROUP BY`. The only difference with `GROUP BY` is that it produces the result for each row. Now, we can get the last changed price by this `FIRST_VALUE` instead of using `GROUP BY` and `JOIN`. We can order the `change_date` fields in descending order and get each last changed price by `PARTITION BY` to group the table. You should be careful that we use the window function on the `SELECT` clause. Thus, it executes after the `JOIN`, `WHERE`, and `GROUP BY` clauses.\n\n#### Algorithm\n\n1. Filter the table where the value of the `change_date` field is under the given date (`2019-08-16`).\n2. Get the last changed price using `FIRST_VALUE` for each `product_id`.\n3. The rest of the process is the same as [Approach 2](#approach-2-divide-cases-by-using-the-left-join)\n\n#### Implementation\n\n##### MySQL\n\n```sql\nSELECT\n  product_id,\n  IFNULL (price, 10) AS price\nFROM\n  (\n    SELECT DISTINCT\n      product_id\n    FROM\n      Products\n  ) AS UniqueProducts\n  LEFT JOIN (\n    SELECT DISTINCT\n      product_id,\n      FIRST_VALUE (new_price) OVER (\n        PARTITION BY\n          product_id\n        ORDER BY\n          change_date DESC\n      ) AS price\n    FROM\n      Products\n    WHERE\n      change_date <= '2019-08-16'\n  ) AS LastChangedPrice USING (product_id);\n```\n\n---\n\n### Conclusion\n\nWe recommend [Approach 1](#approach-1-divide-cases-by-using-the-union-all) due to its simplicity and performance. Usually, it takes much more time when we use the `UNION` clause because it orders the table to remove the duplicated fields. However, the `UNION ALL` **does not** order the table because it **does not** remove the duplicated fields. We ensure that there are no duplicated fields because we use `GROUP BY` to get the last changed price for each `product_id`."
}