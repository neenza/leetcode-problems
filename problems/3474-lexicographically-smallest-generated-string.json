{
  "title": "Lexicographically Smallest Generated String",
  "problem_id": "3770",
  "frontend_id": "3474",
  "difficulty": "Hard",
  "problem_slug": "lexicographically-smallest-generated-string",
  "topics": [
    "String",
    "Greedy",
    "String Matching"
  ],
  "description": "You are given two strings, str1 and str2, of lengths n and m, respectively.\nA string word of length n + m - 1 is defined to be generated by str1 and str2 if it satisfies the following conditions for each index 0 <= i <= n - 1:\nReturn the lexicographically smallest possible string that can be generated by str1 and str2. If no string can be generated, return an empty string \"\".\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: str1 = \"TFTF\", str2 = \"ab\"\nOutput: \"ababa\"\nExplanation:\nThe strings \"ababa\" and \"ababb\" can be generated by str1 and str2 .\nReturn \"ababa\" since it is the lexicographically smaller string.",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input: str1 = \"TFTF\", str2 = \"abc\"\nOutput: \"\"\nExplanation:\nNo string that satisfies the conditions can be generated.",
      "images": []
    },
    {
      "example_num": 3,
      "example_text": "Input: str1 = \"F\", str2 = \"d\"\nOutput: \"a\"",
      "images": []
    }
  ],
  "constraints": [
    "1 <= n == str1.length <= 104",
    "1 <= m == str2.length <= 500",
    "str1 consists only of 'T' or 'F'.",
    "str2 consists only of lowercase English characters."
  ],
  "follow_ups": [],
  "hints": [
    "Use dynamic programming.",
    "Fill the fixed part.",
    "Use KMP's next table for DP.",
    "The state is the prefix length and the longest suffix length that matches the pattern.",
    "Each unknown character can be selected from <code>['a', 'b']</code>.",
    "Can you think of a greedy approach?"
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    string generateString(string str1, string str2) {\n        \n    }\n};",
    "java": "class Solution {\n    public String generateString(String str1, String str2) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def generateString(self, str1, str2):\n        \"\"\"\n        :type str1: str\n        :type str2: str\n        :rtype: str\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def generateString(self, str1: str, str2: str) -> str:\n        ",
    "c": "char* generateString(char* str1, char* str2) {\n    \n}",
    "csharp": "public class Solution {\n    public string GenerateString(string str1, string str2) {\n        \n    }\n}",
    "javascript": "/**\n * @param {string} str1\n * @param {string} str2\n * @return {string}\n */\nvar generateString = function(str1, str2) {\n    \n};",
    "typescript": "function generateString(str1: string, str2: string): string {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param String $str1\n     * @param String $str2\n     * @return String\n     */\n    function generateString($str1, $str2) {\n        \n    }\n}",
    "swift": "class Solution {\n    func generateString(_ str1: String, _ str2: String) -> String {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun generateString(str1: String, str2: String): String {\n        \n    }\n}",
    "dart": "class Solution {\n  String generateString(String str1, String str2) {\n    \n  }\n}",
    "golang": "func generateString(str1 string, str2 string) string {\n    \n}",
    "ruby": "# @param {String} str1\n# @param {String} str2\n# @return {String}\ndef generate_string(str1, str2)\n    \nend",
    "scala": "object Solution {\n    def generateString(str1: String, str2: String): String = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn generate_string(str1: String, str2: String) -> String {\n        \n    }\n}",
    "racket": "(define/contract (generate-string str1 str2)\n  (-> string? string? string?)\n  )",
    "erlang": "-spec generate_string(Str1 :: unicode:unicode_binary(), Str2 :: unicode:unicode_binary()) -> unicode:unicode_binary().\ngenerate_string(Str1, Str2) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec generate_string(str1 :: String.t, str2 :: String.t) :: String.t\n  def generate_string(str1, str2) do\n    \n  end\nend"
  }
}