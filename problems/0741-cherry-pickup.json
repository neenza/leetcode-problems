{
  "title": "Cherry Pickup",
  "problem_id": "741",
  "frontend_id": "741",
  "difficulty": "Hard",
  "problem_slug": "cherry-pickup",
  "topics": [
    "Array",
    "Dynamic Programming",
    "Matrix"
  ],
  "description": "You are given an n x n grid representing a field of cherries, each cell is one of three possible integers.\nReturn the maximum number of cherries you can collect by following the rules below:\nExample 1:\nExample 2:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: grid = [[0,1,-1],[1,0,-1],[1,1,1]]\nOutput: 5\nExplanation: The player started at (0, 0) and went down, down, right right to reach (2, 2).\n4 cherries were picked up during this single trip, and the matrix becomes [[0,1,-1],[0,0,-1],[0,0,0]].\nThen, the player went left, up, up, left to return home, picking up one more cherry.\nThe total number of cherries picked up is 5, and this is the maximum possible.",
      "images": [
        "https://assets.leetcode.com/uploads/2020/12/14/grid.jpg"
      ]
    },
    {
      "example_num": 2,
      "example_text": "Input: grid = [[1,1,-1],[1,-1,1],[-1,1,1]]\nOutput: 0",
      "images": [
        "https://assets.leetcode.com/uploads/2020/12/14/grid.jpg"
      ]
    }
  ],
  "constraints": [
    "n == grid.length",
    "n == grid[i].length",
    "1 <= n <= 50",
    "grid[i][j] is -1, 0, or 1.",
    "grid[0][0] != -1",
    "grid[n - 1][n - 1] != -1"
  ],
  "follow_ups": [],
  "hints": [],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    int cherryPickup(vector<vector<int>>& grid) {\n        \n    }\n};",
    "java": "class Solution {\n    public int cherryPickup(int[][] grid) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def cherryPickup(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def cherryPickup(self, grid: List[List[int]]) -> int:\n        ",
    "c": "int cherryPickup(int** grid, int gridSize, int* gridColSize) {\n    \n}",
    "csharp": "public class Solution {\n    public int CherryPickup(int[][] grid) {\n        \n    }\n}",
    "javascript": "/**\n * @param {number[][]} grid\n * @return {number}\n */\nvar cherryPickup = function(grid) {\n    \n};",
    "typescript": "function cherryPickup(grid: number[][]): number {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param Integer[][] $grid\n     * @return Integer\n     */\n    function cherryPickup($grid) {\n        \n    }\n}",
    "swift": "class Solution {\n    func cherryPickup(_ grid: [[Int]]) -> Int {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun cherryPickup(grid: Array<IntArray>): Int {\n        \n    }\n}",
    "dart": "class Solution {\n  int cherryPickup(List<List<int>> grid) {\n    \n  }\n}",
    "golang": "func cherryPickup(grid [][]int) int {\n    \n}",
    "ruby": "# @param {Integer[][]} grid\n# @return {Integer}\ndef cherry_pickup(grid)\n    \nend",
    "scala": "object Solution {\n    def cherryPickup(grid: Array[Array[Int]]): Int = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn cherry_pickup(grid: Vec<Vec<i32>>) -> i32 {\n        \n    }\n}",
    "racket": "(define/contract (cherry-pickup grid)\n  (-> (listof (listof exact-integer?)) exact-integer?)\n  )",
    "erlang": "-spec cherry_pickup(Grid :: [[integer()]]) -> integer().\ncherry_pickup(Grid) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec cherry_pickup(grid :: [[integer]]) :: integer\n  def cherry_pickup(grid) do\n    \n  end\nend"
  },
  "solution": "[TOC]\n\n### Approach #1: Greedy [Wrong Answer]\n\n**Intuition**\n\nLet's find the most cherries we can pick up with one path, pick them up, and then find the most cherries we can pick up with a second path on the remaining field.\n\nThough a counter example might be hard to think of, this approach fails to find the best answer to this case:\n```python\n11100\n00101\n10100\n00100\n00111\n```\n\n**Algorithm**\n\nWe can use dynamic programming to find the most number of cherries `dp[i][j]` that can be picked up from any location `(i, j)` to the bottom right corner. This is a classic question very similar to [Minimum Path Sum](https://leetcode.com/problems/minimum-path-sum/description/), refer to the link if you are not familiar with this type of question.\n\nAfter, we can find a first path that maximizes the number of cherries taken by using our completed `dp` as an oracle for deciding where to move. We'll choose the move that allows us to pick up more cherries (based on comparing `dp[i + 1][j]` and `dp[i][j + 1]`).\n\nAfter taking the cherries from that path (and removing them from the grid), we'll take the cherries again.**Complexity Analysis**\n\n* Time Complexity: $$O(N^2)$$, where $$N$$ is the length of `grid`. Our dynamic programming consists of two for-loops of length `N`.\n\n* Space Complexity: $$O(N^2)$$, the size of `dp`.\n\n---\n### Approach #2: Dynamic Programming (Top Down) [Accepted]\n\n**Intuition**\n\nInstead of walking from end to beginning, let's reverse the second leg of the path, so we are only considering two paths from the beginning to the end.\n\nNotice after `t` steps, each position `(r, c)` we could be, is on the line `r + c = t`. So if we have two people at positions `(r1, c1)` and `(r2, c2)`, then `r2 = r1 + c1 - c2`.  That means the variables `r1, c1, c2` uniquely determine 2 people who have walked the same `r1 + c1` number of steps.  This sets us up for dynamic programming quite nicely.\n\n**Algorithm**\n\nLet `dp[r1][c1][c2]` be the most number of cherries obtained by two people starting at `(r1, c1)` and `(r2, c2)` and walking towards `(N - 1, N - 1)` picking up cherries, where `r2 = r1 + c1 - c2`.\n\nIf `grid[r1][c1]` and `grid[r2][c2]` are not thorns, then the value of `dp[r1][c1][c2]` is `(grid[r1][c1] + grid[r2][c2])`, plus the maximum of `dp[r1 + 1][c1][c2]`, `dp[r1][c1 + 1][c2]`, `dp[r1 + 1][c1][c2 + 1]`, `dp[r1][c1 + 1][c2 + 1]` as appropriate.  We should also be careful to not double count in case `(r1, c1) == (r2, c2)`.\n\nWhy did we say it was the maximum of `dp[r + 1][c1][c2]` etc.?  It corresponds to the 4 possibilities for persons 1 and 2 moving down and right:\n\n* Person 1 down and person 2 down: `dp[r1 + 1][c1][c2]`;\n* Person 1 right and person 2 down: `dp[r1][c1 + 1][c2]`;\n* Person 1 down and person 2 right: `dp[r1 + 1][c1][c2 + 1]`;\n* Person 1 right and person 2 right: `dp[r1][c1 + 1][c2 + 1]`;**Complexity Analysis**\n\n* Time Complexity: $$O(N^3)$$, where $$N$$ is the length of `grid`. Our dynamic programming has $$N^3$$ states, and each state is calculated once.\n\n* Space Complexity: $$O(N^3)$$, the size of `memo`.\n\n---\n### Approach #3: Dynamic Programming (Bottom Up) [Accepted]\n\n**Intuition**\n\nLike in *Approach #2*, we have the idea of dynamic programming.\n\nSay `r1 + c1 = t` is the `t`-th layer.  Since our recursion only references the next layer, we only need to keep two layers in memory at a time.\n\n**Algorithm**\n\nAt time `t`, let `dp[c1][c2]` be the most cherries that we can pick up for two people going from `(0, 0)` to `(r1, c1)` and `(0, 0)` to `(r2, c2)`, where `r1 = t-c1, r2 = t-c2`.  Our dynamic program proceeds similarly to *Approach #2*.**Complexity Analysis**\n\n* Time Complexity: $$O(N^3)$$, where $$N$$ is the length of `grid`. We have three for-loops of size $$N$$.\n\n* Space Complexity: $$O(N^2)$$, the sizes of `dp` and `dp2`."
}