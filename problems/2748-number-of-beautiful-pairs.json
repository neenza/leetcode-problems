{
  "title": "Number of Beautiful Pairs",
  "problem_id": "2831",
  "frontend_id": "2748",
  "difficulty": "Easy",
  "problem_slug": "number-of-beautiful-pairs",
  "topics": [
    "Array",
    "Hash Table",
    "Math",
    "Counting",
    "Number Theory"
  ],
  "description": "You are given a 0-indexed integer array nums. A pair of indices i, j where 0 <=Â i < j < nums.length is called beautiful if the first digit of nums[i] and the last digit of nums[j] are coprime.\nReturn the total number of beautiful pairs in nums.\nTwo integers x and y are coprime if there is no integer greater than 1 that divides both of them. In other words, x and y are coprime if gcd(x, y) == 1, where gcd(x, y) is the greatest common divisor of x and y.\nExample 1:\nExample 2:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: nums = [2,5,1,4]\nOutput: 5\nExplanation: There are 5 beautiful pairs in nums:\nWhen i = 0 and j = 1: the first digit of nums[0] is 2, and the last digit of nums[1] is 5. We can confirm that 2 and 5 are coprime, since gcd(2,5) == 1.\nWhen i = 0 and j = 2: the first digit of nums[0] is 2, and the last digit of nums[2] is 1. Indeed, gcd(2,1) == 1.\nWhen i = 1 and j = 2: the first digit of nums[1] is 5, and the last digit of nums[2] is 1. Indeed, gcd(5,1) == 1.\nWhen i = 1 and j = 3: the first digit of nums[1] is 5, and the last digit of nums[3] is 4. Indeed, gcd(5,4) == 1.\nWhen i = 2 and j = 3: the first digit of nums[2] is 1, and the last digit of nums[3] is 4. Indeed, gcd(1,4) == 1.\nThus, we return 5.",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input: nums = [11,21,12]\nOutput: 2\nExplanation: There are 2 beautiful pairs:\nWhen i = 0 and j = 1: the first digit of nums[0] is 1, and the last digit of nums[1] is 1. Indeed, gcd(1,1) == 1.\nWhen i = 0 and j = 2: the first digit of nums[0] is 1, and the last digit of nums[2] is 2. Indeed, gcd(1,2) == 1.\nThus, we return 2.",
      "images": []
    }
  ],
  "constraints": [
    "2 <= nums.length <= 100",
    "1 <= nums[i] <= 9999",
    "nums[i] % 10 != 0"
  ],
  "follow_ups": [],
  "hints": [
    "Since nums.length is small, you can find all pairs of indices and check if each pair is beautiful.",
    "Use integer to string conversion to get the first and last digit of each number."
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    int countBeautifulPairs(vector<int>& nums) {\n        \n    }\n};",
    "java": "class Solution {\n    public int countBeautifulPairs(int[] nums) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def countBeautifulPairs(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def countBeautifulPairs(self, nums: List[int]) -> int:\n        ",
    "c": "int countBeautifulPairs(int* nums, int numsSize) {\n    \n}",
    "csharp": "public class Solution {\n    public int CountBeautifulPairs(int[] nums) {\n        \n    }\n}",
    "javascript": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar countBeautifulPairs = function(nums) {\n    \n};",
    "typescript": "function countBeautifulPairs(nums: number[]): number {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @return Integer\n     */\n    function countBeautifulPairs($nums) {\n        \n    }\n}",
    "swift": "class Solution {\n    func countBeautifulPairs(_ nums: [Int]) -> Int {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun countBeautifulPairs(nums: IntArray): Int {\n        \n    }\n}",
    "dart": "class Solution {\n  int countBeautifulPairs(List<int> nums) {\n    \n  }\n}",
    "golang": "func countBeautifulPairs(nums []int) int {\n    \n}",
    "ruby": "# @param {Integer[]} nums\n# @return {Integer}\ndef count_beautiful_pairs(nums)\n    \nend",
    "scala": "object Solution {\n    def countBeautifulPairs(nums: Array[Int]): Int = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn count_beautiful_pairs(nums: Vec<i32>) -> i32 {\n        \n    }\n}",
    "racket": "(define/contract (count-beautiful-pairs nums)\n  (-> (listof exact-integer?) exact-integer?)\n  )",
    "erlang": "-spec count_beautiful_pairs(Nums :: [integer()]) -> integer().\ncount_beautiful_pairs(Nums) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec count_beautiful_pairs(nums :: [integer]) :: integer\n  def count_beautiful_pairs(nums) do\n    \n  end\nend"
  }
}