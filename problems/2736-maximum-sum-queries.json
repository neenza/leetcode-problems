{
  "title": "Maximum Sum Queries",
  "problem_id": "2839",
  "frontend_id": "2736",
  "difficulty": "Hard",
  "problem_slug": "maximum-sum-queries",
  "topics": [
    "Array",
    "Binary Search",
    "Stack",
    "Binary Indexed Tree",
    "Segment Tree",
    "Sorting",
    "Monotonic Stack"
  ],
  "description": "You are given two 0-indexed integer arrays nums1 and nums2, each of length n, and a 1-indexed 2D array queries where queries[i] = [xi, yi].\nFor the ith query, find the maximum value of nums1[j] + nums2[j] among all indices j (0 <= j < n), where nums1[j] >= xi and nums2[j] >= yi, or -1 if there is no j satisfying the constraints.\nReturn an array answer where answer[i] is the answer to the ith query.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: nums1 = [4,3,1,2], nums2 = [2,4,9,5], queries = [[4,1],[1,3],[2,5]]\nOutput: [6,10,7]\nExplanation: \nFor the 1st query xi = 4 and yi = 1, we can select index j = 0 since nums1[j] >= 4 and nums2[j] >= 1. The sum nums1[j] + nums2[j] is 6, and we can show that 6 is the maximum we can obtain.\n\nFor the 2nd query xi = 1 and yi = 3, we can select index j = 2 since nums1[j] >= 1 and nums2[j] >= 3. The sum nums1[j] + nums2[j] is 10, and we can show that 10 is the maximum we can obtain. \n\nFor the 3rd query xi = 2 and yi = 5, we can select index j = 3 since nums1[j] >= 2 and nums2[j] >= 5. The sum nums1[j] + nums2[j] is 7, and we can show that 7 is the maximum we can obtain.\n\nTherefore, we return [6,10,7].",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input: nums1 = [3,2,5], nums2 = [2,3,4], queries = [[4,4],[3,2],[1,1]]\nOutput: [9,9,9]\nExplanation: For this example, we can use index j = 2 for all the queries since it satisfies the constraints for each query.",
      "images": []
    },
    {
      "example_num": 3,
      "example_text": "Input: nums1 = [2,1], nums2 = [2,3], queries = [[3,3]]\nOutput: [-1]\nExplanation: There is one query in this example with xi = 3 and yi = 3. For every index, j, either nums1[j] < xi or nums2[j] < yi. Hence, there is no solution.",
      "images": []
    }
  ],
  "constraints": [
    "nums1.length == nums2.length",
    "n == nums1.length",
    "1 <= n <= 105",
    "1 <= nums1[i], nums2[i] <= 109",
    "1 <= queries.length <= 105",
    "queries[i].length == 2",
    "xi == queries[i][1]",
    "yi == queries[i][2]",
    "1 <= xi, yi <= 109"
  ],
  "follow_ups": [],
  "hints": [
    "Sort (x, y) tuples and queries by x-coordinate descending. Don’t forget to index queries before sorting so that you can answer them in the correct order.",
    "Before answering a query (min_x, min_y), add all (x, y) pairs with x >= min_x to some data structure.",
    "Use a monotone descending map to store (y, x + y) pairs. A monotone map has ascending keys and descending values. When inserting a pair (y, x + y), remove all pairs (y', x' + y') with y' < y and x' + y' <= x + y.",
    "To find the insertion position use binary search (built-in in many languages).",
    "When querying for max (x + y) over y >= y', use binary search to find the first pair (y, x + y) with y >= y'. It will have the maximum value of x + y because the map has monotone descending values."
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    vector<int> maximumSumQueries(vector<int>& nums1, vector<int>& nums2, vector<vector<int>>& queries) {\n        \n    }\n};",
    "java": "class Solution {\n    public int[] maximumSumQueries(int[] nums1, int[] nums2, int[][] queries) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def maximumSumQueries(self, nums1, nums2, queries):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :type queries: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def maximumSumQueries(self, nums1: List[int], nums2: List[int], queries: List[List[int]]) -> List[int]:\n        ",
    "c": "/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nint* maximumSumQueries(int* nums1, int nums1Size, int* nums2, int nums2Size, int** queries, int queriesSize, int* queriesColSize, int* returnSize) {\n    \n}",
    "csharp": "public class Solution {\n    public int[] MaximumSumQueries(int[] nums1, int[] nums2, int[][] queries) {\n        \n    }\n}",
    "javascript": "/**\n * @param {number[]} nums1\n * @param {number[]} nums2\n * @param {number[][]} queries\n * @return {number[]}\n */\nvar maximumSumQueries = function(nums1, nums2, queries) {\n    \n};",
    "typescript": "function maximumSumQueries(nums1: number[], nums2: number[], queries: number[][]): number[] {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param Integer[] $nums1\n     * @param Integer[] $nums2\n     * @param Integer[][] $queries\n     * @return Integer[]\n     */\n    function maximumSumQueries($nums1, $nums2, $queries) {\n        \n    }\n}",
    "swift": "class Solution {\n    func maximumSumQueries(_ nums1: [Int], _ nums2: [Int], _ queries: [[Int]]) -> [Int] {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun maximumSumQueries(nums1: IntArray, nums2: IntArray, queries: Array<IntArray>): IntArray {\n        \n    }\n}",
    "dart": "class Solution {\n  List<int> maximumSumQueries(List<int> nums1, List<int> nums2, List<List<int>> queries) {\n    \n  }\n}",
    "golang": "func maximumSumQueries(nums1 []int, nums2 []int, queries [][]int) []int {\n    \n}",
    "ruby": "# @param {Integer[]} nums1\n# @param {Integer[]} nums2\n# @param {Integer[][]} queries\n# @return {Integer[]}\ndef maximum_sum_queries(nums1, nums2, queries)\n    \nend",
    "scala": "object Solution {\n    def maximumSumQueries(nums1: Array[Int], nums2: Array[Int], queries: Array[Array[Int]]): Array[Int] = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn maximum_sum_queries(nums1: Vec<i32>, nums2: Vec<i32>, queries: Vec<Vec<i32>>) -> Vec<i32> {\n        \n    }\n}",
    "racket": "(define/contract (maximum-sum-queries nums1 nums2 queries)\n  (-> (listof exact-integer?) (listof exact-integer?) (listof (listof exact-integer?)) (listof exact-integer?))\n  )",
    "erlang": "-spec maximum_sum_queries(Nums1 :: [integer()], Nums2 :: [integer()], Queries :: [[integer()]]) -> [integer()].\nmaximum_sum_queries(Nums1, Nums2, Queries) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec maximum_sum_queries(nums1 :: [integer], nums2 :: [integer], queries :: [[integer]]) :: [integer]\n  def maximum_sum_queries(nums1, nums2, queries) do\n    \n  end\nend"
  }
}