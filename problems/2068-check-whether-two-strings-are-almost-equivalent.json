{
  "title": "Check Whether Two Strings are Almost Equivalent",
  "problem_id": "2177",
  "frontend_id": "2068",
  "difficulty": "Easy",
  "problem_slug": "check-whether-two-strings-are-almost-equivalent",
  "topics": [
    "Hash Table",
    "String",
    "Counting"
  ],
  "description": "Two strings word1 and word2 are considered almost equivalent if the differences between the frequencies of each letter from 'a' to 'z' between word1 and word2 is at most 3.\nGiven two strings word1 and word2, each of length n, return true if word1 and word2 are almost equivalent, or false otherwise.\nThe frequency of a letter x is the number of times it occurs in the string.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: word1 = \"aaaa\", word2 = \"bccb\"\nOutput: false\nExplanation: There are 4 'a's in \"aaaa\" but 0 'a's in \"bccb\".\nThe difference is 4, which is more than the allowed 3.",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input: word1 = \"abcdeef\", word2 = \"abaaacc\"\nOutput: true\nExplanation: The differences between the frequencies of each letter in word1 and word2 are at most 3:\n- 'a' appears 1 time in word1 and 4 times in word2. The difference is 3.\n- 'b' appears 1 time in word1 and 1 time in word2. The difference is 0.\n- 'c' appears 1 time in word1 and 2 times in word2. The difference is 1.\n- 'd' appears 1 time in word1 and 0 times in word2. The difference is 1.\n- 'e' appears 2 times in word1 and 0 times in word2. The difference is 2.\n- 'f' appears 1 time in word1 and 0 times in word2. The difference is 1.",
      "images": []
    },
    {
      "example_num": 3,
      "example_text": "Input: word1 = \"cccddabba\", word2 = \"babababab\"\nOutput: true\nExplanation: The differences between the frequencies of each letter in word1 and word2 are at most 3:\n- 'a' appears 2 times in word1 and 4 times in word2. The difference is 2.\n- 'b' appears 2 times in word1 and 5 times in word2. The difference is 3.\n- 'c' appears 3 times in word1 and 0 times in word2. The difference is 3.\n- 'd' appears 2 times in word1 and 0 times in word2. The difference is 2.",
      "images": []
    }
  ],
  "constraints": [
    "n == word1.length == word2.length",
    "1 <= n <= 100",
    "word1 and word2 consist only of lowercase English letters."
  ],
  "follow_ups": [],
  "hints": [
    "What data structure can we use to count the frequency of each character?",
    "Are there edge cases where a character is present in one string but not the other?"
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    bool checkAlmostEquivalent(string word1, string word2) {\n        \n    }\n};",
    "java": "class Solution {\n    public boolean checkAlmostEquivalent(String word1, String word2) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def checkAlmostEquivalent(self, word1, word2):\n        \"\"\"\n        :type word1: str\n        :type word2: str\n        :rtype: bool\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def checkAlmostEquivalent(self, word1: str, word2: str) -> bool:\n        ",
    "c": "bool checkAlmostEquivalent(char* word1, char* word2) {\n    \n}",
    "csharp": "public class Solution {\n    public bool CheckAlmostEquivalent(string word1, string word2) {\n        \n    }\n}",
    "javascript": "/**\n * @param {string} word1\n * @param {string} word2\n * @return {boolean}\n */\nvar checkAlmostEquivalent = function(word1, word2) {\n    \n};",
    "typescript": "function checkAlmostEquivalent(word1: string, word2: string): boolean {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param String $word1\n     * @param String $word2\n     * @return Boolean\n     */\n    function checkAlmostEquivalent($word1, $word2) {\n        \n    }\n}",
    "swift": "class Solution {\n    func checkAlmostEquivalent(_ word1: String, _ word2: String) -> Bool {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun checkAlmostEquivalent(word1: String, word2: String): Boolean {\n        \n    }\n}",
    "dart": "class Solution {\n  bool checkAlmostEquivalent(String word1, String word2) {\n    \n  }\n}",
    "golang": "func checkAlmostEquivalent(word1 string, word2 string) bool {\n    \n}",
    "ruby": "# @param {String} word1\n# @param {String} word2\n# @return {Boolean}\ndef check_almost_equivalent(word1, word2)\n    \nend",
    "scala": "object Solution {\n    def checkAlmostEquivalent(word1: String, word2: String): Boolean = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn check_almost_equivalent(word1: String, word2: String) -> bool {\n        \n    }\n}",
    "racket": "(define/contract (check-almost-equivalent word1 word2)\n  (-> string? string? boolean?)\n  )",
    "erlang": "-spec check_almost_equivalent(Word1 :: unicode:unicode_binary(), Word2 :: unicode:unicode_binary()) -> boolean().\ncheck_almost_equivalent(Word1, Word2) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec check_almost_equivalent(word1 :: String.t, word2 :: String.t) :: boolean\n  def check_almost_equivalent(word1, word2) do\n    \n  end\nend"
  },
  "solution": "[TOC]\n\n## Solution\n\n---\n\n### Approach: Array\n\n**Intuition**\n\nWe are given two strings `word1` and `word2`, both having the same length. We should return `true` if for each letter the difference in the frequency between `word1` and `word2` is not greater than `3`.\n\nWe can have an array of size `26` (as the strings can only have lowercase English letters), and store the frequency of the letters in the string `word1`. Then, we do the same with the string `word2` and store its frequencies in another array. We can then iterate over each letter to find the difference and check if any of them exceeds `3`, if yes we will return `false` and `true` otherwise.\n\nSince we don't care about the actual frequencies in each string but rather the difference, we can use the same array for both words. For string `word1` we will increment the count for each letter, and for `word2` letters we will decrement the count. This way we will be able to find the difference between the frequencies on the fly and would only need one array. Also, since the length of both strings is the same, instead of doing it in two iterations, one for `word1` and another for `word2` we can do it in one.\n\n![fig](../Figures/2068/2068A.png)\n\n**Algorithm**\n\n1. Initialise an empty array `cnt` of size `26` to store the difference of frequencies for each letter.\n2. Iterate over the indices and for each index `i`:\n  1. Increment the count of the letter `word1[i]` by 1 and,\n  2. Decrement the count of `word2[i]` by 1.\n3. In the end, iterate over the letters from `0` to `26` for each:\n  1. Check if the absolute value in the `cnt` is more than `3`.\n  2. If yes, return `false`.\n4. Return `true` when the iteration is complete because that means there are no letters with a difference of more than `3`.\n\n**Implementation****Complexity Analysis**\n\nHere, $N$ is the length of the string `word1` and `word2`, and $K$ is the number of unique characters in these strings.\n\n* Time complexity: $O(N)$\n\n  We iterate over each letter in the strings `word1` and `word2` to store the frequency difference, this takes $O(N)$ operations. Then we iterate over each letter to check if the difference is more than `3`, this takes $O(K)$ operations. Hence, the total time complexity is equal to $O(N + K)$. The number of unique characters in the string cannot be more than the string of length itself, hence $K <= N$. Therefore the time complexity can be simplified as $O(N)$\n\n* Space complexity: $O(1)$\n\n  We need an array `cnt` to store the frequency difference for each letter, hence it would take an array of size $K$. In this problem, $K = 26$. Hence, the space complexity is constant.---"
}