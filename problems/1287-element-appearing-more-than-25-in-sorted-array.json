{
  "title": "Element Appearing More Than 25% In Sorted Array",
  "problem_id": "1221",
  "frontend_id": "1287",
  "difficulty": "Easy",
  "problem_slug": "element-appearing-more-than-25-in-sorted-array",
  "topics": [
    "Array"
  ],
  "description": "Given an integer array sorted in non-decreasing order, there is exactly one integer in the array that occurs more than 25% of the time, return that integer.\nExample 1:\nExample 2:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: arr = [1,2,2,6,6,6,6,7,10]\nOutput: 6",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input: arr = [1,1]\nOutput: 1",
      "images": []
    }
  ],
  "constraints": [
    "1 <= arr.length <= 104",
    "0 <= arr[i] <= 105"
  ],
  "follow_ups": [],
  "hints": [
    "Divide the array in four parts [1 - 25%] [25 - 50 %] [50 - 75 %] [75% - 100%]",
    "The answer should be in one of the ends of the intervals.",
    "In order to check which is element is the answer we can count the frequency with binarySearch."
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    int findSpecialInteger(vector<int>& arr) {\n        \n    }\n};",
    "java": "class Solution {\n    public int findSpecialInteger(int[] arr) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def findSpecialInteger(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: int\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def findSpecialInteger(self, arr: List[int]) -> int:\n        ",
    "c": "int findSpecialInteger(int* arr, int arrSize) {\n    \n}",
    "csharp": "public class Solution {\n    public int FindSpecialInteger(int[] arr) {\n        \n    }\n}",
    "javascript": "/**\n * @param {number[]} arr\n * @return {number}\n */\nvar findSpecialInteger = function(arr) {\n    \n};",
    "typescript": "function findSpecialInteger(arr: number[]): number {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param Integer[] $arr\n     * @return Integer\n     */\n    function findSpecialInteger($arr) {\n        \n    }\n}",
    "swift": "class Solution {\n    func findSpecialInteger(_ arr: [Int]) -> Int {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun findSpecialInteger(arr: IntArray): Int {\n        \n    }\n}",
    "dart": "class Solution {\n  int findSpecialInteger(List<int> arr) {\n    \n  }\n}",
    "golang": "func findSpecialInteger(arr []int) int {\n    \n}",
    "ruby": "# @param {Integer[]} arr\n# @return {Integer}\ndef find_special_integer(arr)\n    \nend",
    "scala": "object Solution {\n    def findSpecialInteger(arr: Array[Int]): Int = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn find_special_integer(arr: Vec<i32>) -> i32 {\n        \n    }\n}",
    "racket": "(define/contract (find-special-integer arr)\n  (-> (listof exact-integer?) exact-integer?)\n  )",
    "erlang": "-spec find_special_integer(Arr :: [integer()]) -> integer().\nfind_special_integer(Arr) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec find_special_integer(arr :: [integer]) :: integer\n  def find_special_integer(arr) do\n    \n  end\nend"
  },
  "solution": "[TOC]\n\n## Solution\n\n---\n\n### Approach 1: Count With Hash Map\n\n**Intuition**\n\nIf you are not already familiar with hash maps, please check out our relevant [LeetCode explore card](https://leetcode.com/explore/learn/card/hash-table/).\n\nWe can count the frequency of each `num` in `arr` using a hash map `counts`. Once we have all the frequencies, we can iterate over the keys of `counts` and check which one has a value greater than `n / 4`, where `n` is the length of `arr`.\n\nIf a key in `counts` has a value greater than `n / 4`, it must occupy more than 25% of `arr` and thus would be our answer.\n\n> Note that in languages like Java and C++, integer division of `n / 4` will round the result down. Rounding down does not affect our strategy. The reason that rounding down doesn't change anything is because when we round down, we are removing a decimal. However, this decimal is irrelevant because the next integer will always be larger than the result even if we didn't remove the decimal.\n> \n> For example, let's say we had `n = 10`. `n / 4 = 2.5`. By doing integer division, we remove the `.5`. However, the next integer `3` is larger than `2.5` regardless, so when we evaluate `10 / 4` as `2`, there is no difference between comparing `3 > 2.5` and `3 > 2`. The only scenarios that would be affected would be when a frequency is greater than `2` but less than `2.5`. However, the frequencies must be integers, so this scenario would never happen. \n\n**Algorithm**\n\n1. Initialize a hash map `counts`.\n2. Iterate over each element in `arr`. For each element `num`, increment `counts[num]`.\n3. Set `target = arr.length / 4`.\n4. Iterate over each `key, value` pair in `counts`:\n    - If `value > target`, return `key`.\n5. The code should never reach this point since it's guaranteed an answer exists. Return anything.\n\n**Implementation**Bonus: a small optimization to this approach would be to terminate early as soon as an element's count reaches `target`.**Complexity Analysis**\n\nGiven $$n$$ as the length of `arr`,\n\n* Time complexity: $$O(n)$$\n\n    We iterate over `arr` once to calculate `counts`. This costs $$O(n)$$. Next, we iterate over `counts`, which also costs $$O(n)$$.\n\n* Space complexity: $$O(n)$$\n\n    In the worst-case scenario, `counts` can contain at most $$O(n)$$ keys and thus grow to a size of $$O(n)$$.---\n\n### Approach 2: Check the Element N/4 Ahead\n\n**Intuition**\n\nThe previous approach did not make use of the fact the input is given sorted. By taking advantage of this fact, we can come up with a more efficient algorithm.\n\n![example](../Figures/1287/1.png)Let's call our answer `ans`, where `ans` makes up more than 25% of the array. In the above example, We have `n = 9`, and 25% of `9` is `2.25`. Thus, an element must appear 3 times or more to be the answer. We have `ans = 5` in this example.\n\nIn general, an element must appear **more** than `n / 4` times to be considered the answer.\n\nBecause the array is sorted, all equal elements are adjacent to each other and form a \"block\" in the array. The size of the `ans` block must be greater than `n / 4` by definition.\n\nLet's say the first index of the `ans` block is `i`. As a consequence of the above observation, the final index of the `ans` block must be greater than or equal to `i + (n / 4)` (floor division).\n\n![example](../Figures/1287/2.png)As you can see, the `ans` block here starts at `i = 3` and ends at `i = 6`. This brings us to our solution.\n\nWe first calculate a value `size = n / 4` (floor division). We then iterate `i` over the indices of `arr` until `n - size`. At each index `i`, we check if `arr[i] = arr[i + size]`. If it is, `arr[i]` must be the answer!\n\nWhy is this the case? Because if the elements at `i` and `i + size` are the same, then they are part of the same block. Since the difference between these indices is `size`, the length of the block must be at least `size + 1`.\n\n> The length of the block must be at least `size + 1`, not `size`. This can be verified with a small example. Imagine a block starting at index `2` and ending at index `4`. The difference between the indices is `2`, but the block has a length of `3`: it contains indices `[2, 3, 4]`.\n\nWe established earlier that the answer has a frequency of more than `n / 4`. As we calculated `size = n / 4`, a block having a length of at least `size + 1` must mean it is the answer block.\n\n**Algorithm**\n\n1. Calculate `size = n / 4`.\n2. Iterate `i` from `0` until `arr.length - size`:\n    - If `arr[i] = arr[i + size]`, return `arr[i]`.\n3. The code should never reach this point since it's guaranteed an answer exists. Return anything.\n\n**Implementation****Complexity Analysis**\n\nGiven $$n$$ as the length of `arr`,\n\n* Time complexity: $$O(n)$$\n\n    We iterate over $$\\dfrac{3n}{4}$$ indices, performing $$O(1)$$ work at each iteration.\n\n* Space complexity: $$O(1)$$\n\n    We aren't using any extra space except for the integer `size`.---\n\n### Approach 3: Binary Search\n\n**Intuition**\n\nIf you are not already familiar with binary search, please check out our relevant [LeetCode explore card](https://leetcode.com/explore/learn/card/binary-search/).\n\nWhenever you have a sorted array, you should try to think how binary search could be applied to it. In this approach, we will continue to take advantage of the fact that the input is sorted and use similar ideas from the previous approach.\n\nLet's continue thinking about the array being split into blocks of similar elements. The answer block has a length greater than `n / 4`, and thus it **must** overlap **at least** one of the following positions in the array:\n\n1. A quarter of the way through at index `n / 4`.\n2. Halfway through at index `n / 2`.\n3. Three-quarters of the way through at index `3n / 4`.\n\n![example](../Figures/1287/3.png)We will only consider the elements at each of these indices as **candidates** since one of them must be the answer. For a given `candidate`, we can find its frequency by identifying its block size. To identify its block size, we find the leftmost index in which `candidate` appears as `left` and the rightmost index in which `candidate` appears as `right`. Then, the size of the block is `right - left + 1`. We can calculate `left` and `right` using binary search.\n\nIn Python and C++, we have handy built-in functions that find the leftmost and rightmost indices of elements. In Java, we will implement our own versions of these functions.\n\n**Algorithm**\n\n1. Set `n = arr.length`.\n2. Create the array `candidates` with elements `arr[n / 4], arr[n / 2], arr[3 * n / 4]`.\n3. Set `target = n / 4`.\n4. For each `candidate` in `candidates`:\n    - Calculate the leftmost index of `candidate` as `left` using binary search.\n    - Calculate the rightmost index of `candidate` as `right` using binary search.\n    - If `right - left + 1 > target`, return `candidate`.\n5. The code should never reach this point since it's guaranteed an answer exists. Return anything.\n\n**Implementation****Complexity Analysis**\n\nGiven $$n$$ as the length of `arr`,\n\n* Time complexity: $$O(\\log{}n)$$\n\n    We have three candidates. For each candidate, we perform two binary searches over `arr`, each costing $$O(\\log{}n)$$.\n\n* Space complexity: $$O(1)$$\n\n    We aren't using any extra space except for a few integers.---"
}