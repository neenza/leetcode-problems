{
  "title": "The Number of Employees Which Report to Each Employee",
  "problem_id": "1882",
  "frontend_id": "1731",
  "difficulty": "Easy",
  "problem_slug": "the-number-of-employees-which-report-to-each-employee",
  "topics": [
    "Database"
  ],
  "description": "Table: Employees\nFor this problem, we will consider a manager an employee who has at least 1 other employee reporting to them.\nWrite a solution to report the ids and the names of all managers, the number of employees who report directly to them, and the average age of the reports rounded to the nearest integer.\nReturn the result table ordered by employee_id.\nThe result format is in the following example.\nExample 1:\nExample 2:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "+-------------+----------+\n| Column Name | Type     |\n+-------------+----------+\n| employee_id | int      |\n| name        | varchar  |\n| reports_to  | int      |\n| age         | int      |\n+-------------+----------+\nemployee_id is the column with unique values for this table.\nThis table contains information about the employees and the id of the manager they report to. Some employees do not report to anyone (reports_to is null).",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input: \nEmployees table:\n+-------------+---------+------------+-----+\n| employee_id | name    | reports_to | age |\n+-------------+---------+------------+-----+\n| 9           | Hercy   | null       | 43  |\n| 6           | Alice   | 9          | 41  |\n| 4           | Bob     | 9          | 36  |\n| 2           | Winston | null       | 37  |\n+-------------+---------+------------+-----+\nOutput: \n+-------------+-------+---------------+-------------+\n| employee_id | name  | reports_count | average_age |\n+-------------+-------+---------------+-------------+\n| 9           | Hercy | 2             | 39          |\n+-------------+-------+---------------+-------------+\nExplanation: Hercy has 2 people report directly to him, Alice and Bob. Their average age is (41+36)/2 = 38.5, which is 39 after rounding it to the nearest integer.",
      "images": []
    },
    {
      "example_num": 3,
      "example_text": "Input: \nEmployees table:\n+-------------+---------+------------+-----+ \n| employee_id | name    | reports_to | age |\n|-------------|---------|------------|-----|\n| 1           | Michael | null       | 45  |\n| 2           | Alice   | 1          | 38  |\n| 3           | Bob     | 1          | 42  |\n| 4           | Charlie | 2          | 34  |\n| 5           | David   | 2          | 40  |\n| 6           | Eve     | 3          | 37  |\n| 7           | Frank   | null       | 50  |\n| 8           | Grace   | null       | 48  |\n+-------------+---------+------------+-----+ \nOutput: \n+-------------+---------+---------------+-------------+\n| employee_id | name    | reports_count | average_age |\n| ----------- | ------- | ------------- | ----------- |\n| 1           | Michael | 2             | 40          |\n| 2           | Alice   | 2             | 37          |\n| 3           | Bob     | 1             | 37          |\n+-------------+---------+---------------+-------------+",
      "images": []
    }
  ],
  "constraints": [],
  "follow_ups": [],
  "hints": [],
  "code_snippets": {
    "mysql": "# Write your MySQL query statement below\n",
    "mssql": "/* Write your T-SQL query statement below */\n",
    "oraclesql": "/* Write your PL/SQL query statement below */\n",
    "pythondata": "import pandas as pd\n\ndef count_employees(employees: pd.DataFrame) -> pd.DataFrame:\n    ",
    "postgresql": "-- Write your PostgreSQL query statement below\n"
  },
  "solution": "[TOC]\n\n# Solution\n\n---\n\n## pandas\n\n### Approach: Aggregation-Merge Rounding Strategy\n\nInitially, this approach involves aggregating employee data to identify managerial roles and compute key metrics, such as the count of direct reports and their average age. This aggregation phase allows for the extraction of insightful summaries about the workforce distribution and demographics. Following this, the strategy employs a merge operation to reintegrate these summaries with the broader dataset, thereby appending meaningful context like manager names to the aggregated statistics. A critical aspect of this strategy is the implementation of a custom rounding technique designed to circumvent the limitations of banker's rounding. Banker's rounding, also known as round half to even, is a method where half values (e.g., 0.5) are rounded to the nearest even number to reduce bias in the sum of many rounded numbers. This technique minimizes cumulative rounding errors in statistical operations but may not always align with common rounding expectations, where 0.5 is traditionally rounded up. By adjusting the rounding method, it ensures that the average age calculations align more closely with intuitive expectations.\n\n **Visualization of Approach:**\n\n![fig](../Figures/1731/1731-1.gif)\n\n#### Intuition\n\nLet's review the intuition behind each step given the following input DataFrames:\n\nEmployees DataFrame (`employees`):\n\n| employee_id | name    | reports_to | age |\n| ----------- | ------- | ---------- | --- |\n| 9           | Hercy   | null       | 43  |\n| 6           | Alice   | 9          | 41  |\n| 4           | Bob     | 9          | 36  |\n| 2           | Winston | null       | 37  |1. **Aggregation for Average Age**\n\n- The first step involves grouping the data by the `reports_to` field, which represents the manager each employee reports to. The goal here is to calculate two key metrics for each manager: the total number of direct reports (`reports_count`) and the average age of these reports (`average_age`). This aggregation is crucial for understanding the composition and demographics of teams within the organization.\n\n```python\nby_manager = employees.groupby('reports_to', as_index=False).agg(\n    reports_count=('employee_id', 'size'),\n    average_age=('age', 'mean')\n)\n```\n- This step allows us to identify which employees are managers (those who have others reporting to them) and summarize the average age of their teams, laying the groundwork for further analysis.\n\n`by_manager`:\n\n| reports_to | reports_count | average_age |\n|------------|---------------|-------------|\n| 9          | 2             | 38.5        |2. **Custom Rounding to Overcome Banker's Rounding**\n\n- Banker's rounding can lead to counterintuitive results, especially when the average age is exactly halfway between two integers. To ensure the average age rounds in a way that aligns with common expectations (up from .5), we adjust the rounding process.\n\n```python\nby_manager['average_age'] = (by_manager['average_age'] + 1e-12).round(0)\n```\n- Adding a minuscule value before rounding ensures that values exactly at the half mark are always rounded up, thus addressing the potential issue of banker's rounding where such values might otherwise round to the nearest even number.\n\n`by_manager`:\n\n| reports_to | reports_count | average_age |\n|------------|---------------|-------------|\n| 9          | 2             | 39.0        |3. **Merging Aggregated Data with Manager Names**\n\n- Having aggregated the data, we now need to link each manager's ID back to their name for a more intuitive and informative output. This is achieved by merging the aggregated data with the original dataset based on the `employee_id`.\n\n```python\nmerged = by_manager.merge(\n    employees[['employee_id', 'name']],\n    how='left',\n    left_on='reports_to',\n    right_on='employee_id'\n)\n```\n- This step enriches the average age with human-readable information, specifically the names of the managers, making the final output more accessible and actionable for decision-making or reporting purposes.\n\n`merged`:\n\n| reports_to | reports_count | average_age | employee_id | name  |\n|------------|---------------|-------------|-------------|-------|\n| 9          | 2             | 39.0        | 9           | Hercy |4. **Final Output Preparation**\n\n- Finally, we need to prepare the output in a clear and structured format, selecting only the relevant columns and renaming them as necessary to match the expected output schema.\n\n```python\nmerged.rename(\n    columns={\n        'employee_id_y': 'employee_id',  # This is the actual manager's ID\n    }, \n    inplace=True\n)\nfinal_output = merged[['employee_id', 'name', 'reports_count', 'average_age']]\n```\n- The final step ensures that the output is presented in a user-friendly format, with each column clearly labeled to reflect its content—manager IDs, manager names, counts of direct reports, and their average age. \n\n`merged`:\n\n| employee_id | name  | reports_count | average_age |\n| ----------- | ----- | ------------- | ----------- |\n| 9           | Hercy | 2             | 39          |#### Implementation---\n\n## Database\n\n### Approach 1: Self Join\n\nThis SQL query is designed to identify managers within an organization, count how many employees report directly to each manager, and calculate the average age of these direct reports. The query operates on a single table, `employees`, which contains records of all employees, including their `employee_id`, `name`, age, and the `employee_id` of their manager (`reports_to`). \n\nThe query effectively utilizes SQL's capabilities to perform a self-join on the `employees` table, enabling the identification of managers and the aggregation of direct report counts and average ages.\n\n#### Intuition\n\nLet's break down the SQL query step by step and explain the intuition behind each part:\n\n1. **Join Operation**\n\n- This step creates a self-join on the `employees` table. It essentially pairs each employee (`emp`) with their respective manager (`mgr`) by matching the `emp.reports_to` field with `mgr.employee_id`. This join is necessary because both employee and manager information resides within the same table, and we need to link employees to their managers to compute the required statistics.\n\n```sql\nFROM employees emp JOIN employees mgr ON emp.reports_to = mgr.employee_id\n```\n\n- The self-join enables us to work with employee-manager pairs in the subsequent steps, facilitating the aggregation of data based on manager.\n\n\n2. **Aggregation and Calculation**\n\n- This part of the query selects the manager's `employee_id` and `name`, counts the number of direct reports for each manager (`COUNT(emp.employee_id) AS reports_count`), and calculates the average age of these reports (`ROUND(AVG(emp.age)) AS average_age`).\n\n```sql\nSELECT \n  mgr.employee_id, \n  mgr.name, \n  COUNT(emp.employee_id) AS reports_count, \n  ROUND(AVG(emp.age)) AS average_age\n```\n\n- **Manager Identification**: By selecting `mgr.employee_id` and `mgr.name`, we ensure that the output will list managers, not all employees.\n- **Reports Count**: `COUNT(emp.employee_id)` counts how many times each manager appears in employee-manager pairs, effectively counting the number of direct reports.\n- **Average Age Calculation**: `ROUND(AVG(emp.age))` calculates the average age of the direct reports for each manager, rounding it to the nearest whole number for simplicity and readability.\n\n\n3. **Grouping**\n\n- This clause groups the results by the manager's `employee_id`. It ensures that the aggregation functions (`COUNT` and `AVG`) operate within each group, that is, for each manager, rather than on the entire dataset.\n\n```sql\nGROUP BY employee_id\n```\n\n- Without grouping by `employee_id`, we wouldn't be able to calculate the `reports_count` and `average_age` per manager. This step is crucial for performing the per-manager calculations required by the query.\n\n\n4. **Ordering**\n\n- Orders the final result set by the manager's `employee_id`. This is likely for presentation purposes, to make the data easier to read and to follow a logical sequence (usually ascending order by ID).\n\n```sql\nORDER BY employee_id\n```\n\n- This is required by the problem statement, but also ordering the results makes the output systematic and easier to navigate, especially useful in scenarios where the dataset includes a large number of managers.\n\n\n#### Implementation\n\n\n```mysql []\nSELECT \n  mgr.employee_id, \n  mgr.name, \n  COUNT(emp.employee_id) AS reports_count, \n  ROUND(\n    AVG(emp.age)\n  ) AS average_age \nFROM \n  employees emp \n  JOIN employees mgr ON emp.reports_to = mgr.employee_id \nGROUP BY \n  employee_id \nORDER BY \n  employee_id\n```\n\n### Approach 2: Correlated Sub-Query\n\nThis alternative SQL query also aims to list managers within an organization, the number of employees who report directly to each manager, and the average age of these reports. Unlike the previous approach that used a self-join, this solution employs a correlated subquery to fetch the manager's name and utilizes `GROUP BY` and `HAVING` clauses to aggregate and filter the data. \n\nThis alternative query leverages a mix of grouping, a correlated subquery for enhanced data retrieval, and conditional filtering to achieve its goal. By doing so, it provides a clear and efficient way to identify managers, count their direct reports, and calculate the average age of these reports, all while ensuring the output is neatly organized and focused only on those employees who are indeed managers.\n\n#### Intuition\n\nLet's break down the SQL query step by step and explain the intuition behind each part:\n\n1. **Grouping by Manager**\n\n- The query starts by selecting from the `employees` table (aliased as `e`) and groups the results by the `reports_to` column. This column indicates the manager each employee reports to, effectively grouping employees by their manager.\n\n```sql\nFROM employees e GROUP BY reports_to\n```\n\n- Grouping by `reports_to` is essential for calculating the count of direct reports and their average age for each manager. It organizes the data such that each group corresponds to a manager's direct reports.\n\n\n2. **Selecting Manager ID and Name**\n\n- This part of the query selects two pieces of information for each manager: their `employee_id` (using the `reports_to` column from the grouped data) and their name (using a correlated subquery).\n\n```sql\nSELECT \n  reports_to AS employee_id, \n  (\n    SELECT name FROM employees e1 WHERE e.reports_to = e1.employee_id\n  ) AS name,\n```\n\n- **Manager ID**: The `reports_to` column directly maps to the `employee_id` of the manager, so it's used to identify the manager.\n- **Manager Name**: A correlated subquery fetches the name of each manager from the `employees` table by matching `e.reports_to` with `e1.employee_id`. This approach allows fetching related data without performing a join operation, which can be advantageous in terms of readability or performance.\n\n\n3. **Calculating Reports Count and Average Age**\n\n- For each group (i.e., each manager), this calculates the number of direct reports (`COUNT(reports_to)`) and the average age of these reports (`ROUND(AVG(age))`).\n\n```sql\nCOUNT(reports_to) AS reports_count, \nROUND(AVG(age)) AS average_age\n```\n\n- **Reports Count**: Counting the `reports_to` occurrences within each group gives the number of employees reporting to each manager.\n- **Average Age Calculation**: Calculating the average of `age` and rounding it provides a simple, readable metric of the average age of each manager's direct reports.\n\n\n4. **Calculating Reports Count and Average Age**\n\n- This clause filters the grouped results to include only those entries where the `reports_count` is greater than 0. \n\n```sql\nHAVING reports_count > 0\n```\n\n- This ensures that the query only returns records for actual managers (employees who have at least one direct report), excluding employees who do not manage anyone.\n\n\n5. **Ordering Results**\n\n- Orders the resulting records by `employee_id` (which, in this context, is the `reports_to` field renamed), ensuring a structured and predictable output.\n\n```sql\nORDER BY employee_id\n```\n\n- This is required by the problem statement but also makes the results easier to read and understand, particularly useful when dealing with a large dataset.\n\n\n#### Implementation\n\n\n```mysql []\nSELECT \n  reports_to AS employee_id, \n  (\n    SELECT \n      name \n    FROM \n      employees e1 \n    WHERE \n      e.reports_to = e1.employee_id \n  ) AS name, \n  COUNT(reports_to) AS reports_count, \n  ROUND(\n    AVG(age)\n  ) AS average_age \nFROM \n  employees e \nGROUP BY \n  reports_to \nHAVING \n  reports_count > 0 \nORDER BY \n  employee_id\n```"
}