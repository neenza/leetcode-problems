{
  "title": "Permutation in String",
  "problem_id": "567",
  "frontend_id": "567",
  "difficulty": "Medium",
  "problem_slug": "permutation-in-string",
  "topics": [
    "Hash Table",
    "Two Pointers",
    "String",
    "Sliding Window"
  ],
  "description": "Given two strings s1 and s2, return true if s2 contains a permutation of s1, or false otherwise.\nIn other words, return true if one of s1's permutations is the substring of s2.\nExample 1:\nExample 2:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: s1 = \"ab\", s2 = \"eidbaooo\"\nOutput: true\nExplanation: s2 contains one permutation of s1 (\"ba\").",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input: s1 = \"ab\", s2 = \"eidboaoo\"\nOutput: false",
      "images": []
    }
  ],
  "constraints": [
    "1 <= s1.length, s2.length <= 104",
    "s1 and s2 consist of lowercase English letters."
  ],
  "follow_ups": [],
  "hints": [
    "Obviously, brute force will result in TLE. Think of something else.",
    "How will you check whether one string is a permutation of another string?",
    "One way is to sort the string and then compare. But, Is there a better way?",
    "If one string is a permutation of another string then they must have one common metric. What is that?",
    "Both strings must have same character frequencies, if  one is permutation of another. Which data structure should be used to store frequencies?",
    "What about hash table?  An array of size 26?"
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    bool checkInclusion(string s1, string s2) {\n        \n    }\n};",
    "java": "class Solution {\n    public boolean checkInclusion(String s1, String s2) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def checkInclusion(self, s1, s2):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :rtype: bool\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def checkInclusion(self, s1: str, s2: str) -> bool:\n        ",
    "c": "bool checkInclusion(char* s1, char* s2) {\n    \n}",
    "csharp": "public class Solution {\n    public bool CheckInclusion(string s1, string s2) {\n        \n    }\n}",
    "javascript": "/**\n * @param {string} s1\n * @param {string} s2\n * @return {boolean}\n */\nvar checkInclusion = function(s1, s2) {\n    \n};",
    "typescript": "function checkInclusion(s1: string, s2: string): boolean {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param String $s1\n     * @param String $s2\n     * @return Boolean\n     */\n    function checkInclusion($s1, $s2) {\n        \n    }\n}",
    "swift": "class Solution {\n    func checkInclusion(_ s1: String, _ s2: String) -> Bool {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun checkInclusion(s1: String, s2: String): Boolean {\n        \n    }\n}",
    "dart": "class Solution {\n  bool checkInclusion(String s1, String s2) {\n    \n  }\n}",
    "golang": "func checkInclusion(s1 string, s2 string) bool {\n    \n}",
    "ruby": "# @param {String} s1\n# @param {String} s2\n# @return {Boolean}\ndef check_inclusion(s1, s2)\n    \nend",
    "scala": "object Solution {\n    def checkInclusion(s1: String, s2: String): Boolean = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn check_inclusion(s1: String, s2: String) -> bool {\n        \n    }\n}",
    "racket": "(define/contract (check-inclusion s1 s2)\n  (-> string? string? boolean?)\n  )",
    "erlang": "-spec check_inclusion(S1 :: unicode:unicode_binary(), S2 :: unicode:unicode_binary()) -> boolean().\ncheck_inclusion(S1, S2) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec check_inclusion(s1 :: String.t, s2 :: String.t) :: boolean\n  def check_inclusion(s1, s2) do\n    \n  end\nend"
  },
  "solution": "[TOC]\n\n## Solution\n\n---\n### Approach 1: Brute Force\n\n> Note: This approach is included because it is a logical first step towards building an efficient solution. However, it is a brute-force approach and is not expected to pass all test cases. Readers are still recommended to read it because it helps to understand the following approaches.\n\n**Algorithm**\n\nThe simplest method is to generate all the permutations of the short string  and to check if the generated permutation is a substring of the longer string.\n\nIn order to generate all the possible pairings, we make use of a function `permute(string_1, string_2, current_index)`. This function creates all the possible permutations of the short string $$s1$$.\n\nTo do so, permute takes the index of the current element $$current\\_index$$ as one of the arguments. Then, it swaps the current element with every other element in the array, lying towards its right, so as to generate a new ordering of the array elements. After the swapping has been done, it makes another call to permute but this time with the index of the next element in the array. While returning back, we reverse the swapping done in the current function call.\n\nThus, when we reach the end of the array, a new ordering of the array's elements is generated. The following animation depicts the process of generating the permutations.\n\n!?!../Documents/561_Array.json:1000,563!?!\n\n**Implementation****Complexity Analysis**\n\nLet $$n$$ be the length of $$s1$$\n    \n* Time complexity: $$O(n!)$$. The permute method generates all possible permutations of the string `s1`. In a permutation problem, the number of ways to permute a string of length $n$ is $n!$. Each recursive call swaps characters at different positions to explore every possible permutation at each level of recursion. At the first level, there are $n$ choices for which character to place in the first position. At the second level, there are $nâˆ’1$ choices for which character to place in the second position, and so on, leading to $n!$ total recursive calls.\n\n* Space complexity: $$O(n^2)$$. The depth of the recursion tree is $$n$$($$n$$ refers to the length of the short string `s1`). Every node of the recursion tree contains a string of max. length $$n$$.\n\n---\n\n### Approach 2: Using sorting:\n\n**Algorithm**\n\nThe idea behind this approach is that one string will be a permutation of another string only if both of them contain the same characters the same number of times. One string $$x$$ is a permutation of other string $$y$$ only if $$sorted(x)=sorted(y)$$. \n\nIn order to check this, we can sort the two strings and compare them.  We sort the short string $$s1$$ and all the substrings of $$s2$$, sort them and compare them with the sorted $$s1$$ string. If the two matches completely, $$s1$$'s permutation is a substring of $$s2$$, otherwise not.\n\n**Implementation****Complexity Analysis**\n\nLet $$l_1$$ be the length of string $$s_1$$ and $$l_2$$ be the length of string $$s_2$$.\n    \n* Time complexity: $O((l_2 - l_1) \\cdot l_1 \\log l_1)$.\n  \n  First, we sort $s_1$ which takes $O(l_1 \\log l_1)$. Then, we iterate through a range of $(l_2 - l_1 + 1)$ and within the loop, we sort a substring of length $l_1$. This process takes $O((l_2 - l_1 + 1) \\cdot l_1 \\log l_1)$ time. Overall, we combine both time complexities: $O((l_2 - l_1 + 1 + 1) \\cdot l_1 \\log l_1) \\rightarrow O((l_2 - l_1) \\cdot l_1 \\log l_1)$\n\n* Space complexity: $O(l_1 + S)$. $t$ array is used.\n\n    Some extra space is used when we sort an array of size $n$ in place. The space complexity of the sorting algorithm ($S$) depends on the programming language. The value of $S$ depends on the programming language and the sorting algorithm being used:\n    - In Python, the sort method sorts a list using the Timsort algorithm which is a combination of Merge Sort and Insertion Sort and has a space complexity of $O(n)$\n    - In C++, the `sort()` function is implemented as a hybrid of Quick Sort, Heap Sort, and Insertion Sort, with a worst-case space complexity of $O( \\log n )$\n    - In Java, `Arrays.sort()` is implemented using a variant of the Quick Sort algorithm which has a space complexity of $O( \\log n)$\n\n    Thus, the total space complexity of the algorithm is $O(l_1 + S)$.\n\n---\n\n### Approach 3: Using Hashmap\n\n**Algorithm**\n\nAs discussed above, one string will be a permutation of another string only if both of them contain the same characters with the same frequency. We can consider every possible substring in the long string $$s2$$ of the same length as that of $$s1$$ and check the frequency of occurence of the characters appearing in the two. If the frequencies of every letter match exactly, then only $$s1$$'s permutation can be a substring of $$s2$$. \n\nIn order to implement this approach, instead of sorting and then comparing the elements for equality, we make use of a hashmap $$s1map$$ which stores the frequency of occurence of all the characters in the short string $$s1$$. We consider every possible substring of $$s2$$ of the same length as that of $$s1$$, find its corresponding hashmap as well, namely $$s2map$$. Thus, the substrings considered can be viewed as a window of length as that of $$s1$$ iterating over $$s2$$. If the two hashmaps obtained are identical for any such window, we can conclude that $$s1$$'s permutation is a substring of $$s2$$, otherwise not.\n    \n**Implementation****Complexity Analysis**\n\nLet $$l_1$$ be the length of string $$s_1$$ and $$l_2$$ be the length of string $$s_2$$.\n\n* Time complexity: $O(l_1 + (26 + l_1) \\cdot (l_2 - l_1))$\n  \n  The initialization of the map `s1map` takes $O(l_1)$ since we loop through each character of $s_1$ once and store the counts.\n\n  The outer loop runs $(l_2 - l_1 + 1)$ times, as we need to consider each possible substring of length $l_1$ within $s_2$.\n\n  For each iteration of the outer loop, we build `s2map`, which takes $O(l_1)$ time (since we process $l_1$ characters for each substring in $s_2$).\n\n  In the `matches` function, we iterate through `s1map` to compare it with `s2map`. This takes $O(26) = O(1)$, as the alphabet size is constant (26 characters). Thus, checking equality of the two maps involves a constant-time comparison for each character in the alphabet.\n\n  Thus, the total time complexity becomes: $O(l_1 + (26 + l_1) \\cdot (l_2 - l_1))$.\n\n* Space complexity: $O(l_2 - l_1)$\n  \n  Each substring from $s_2$ of length $l_1$ creates a `HashMap` (`s2map`) to store the character frequencies.\n\n  The size of this `HashMap` is $O(26)$, since there are at most 26 characters in the alphabet.\n  \n  Over $l_2 - l_1 + 1$ iterations of the outer loop, we create one such `HashMap` per iteration, resulting in $O(26 \\cdot (l_2 - l_1 + 1))$ space usage.\n\n  We also create a `HashMap` for $s_1$ (`s1map`), which similarly takes $O(26)$ space.\n  \n  Since we need to store a `HashMap` for each of the $l_2 - l_1 + 1$ substrings in the worst case, the space complexity is proportional to the number of substrings and the size of each `HashMap`. \n  \n  Therefore, the total space complexity is: $O(26 \\cdot (l_2 - l_1 + 1) + 26) = O(26 \\cdot (l_2 - l_1 + 1))$. In simplified terms: $O(l_2 - l_1)$\n\n---\n\n### Approach 4: Using Array [Accepted]\n\n**Algorithm**\n\nInstead of making use of a special HashMap datastructure just to store the frequency of occurence of characters, we can use a simpler array data structure to store the frequencies. Given strings contains only lowercase alphabets ('a' to 'z'). So we need to take an array of size 26.The rest of the process remains the same as the last approach.\n\n**Implementation****Complexity Analysis**\n\nLet $$l_1$$ be the length of string $$s_1$$ and $$l_2$$ be the length of string $$s_2$$.\n\n* Time complexity: $O(l_1 + (26 + l_1) \\cdot (l_2 - l_1))$\n  \n  The initialization of the array `s1arr` takes $O(l_1)$ since we loop through each character of $s_1$ once and store the counts.\n\n  The outer loop runs $(l_2 - l_1 + 1)$ times, as we need to consider each possible substring of length $l_1$ within $s_2$.\n\n  For each iteration of the outer loop, we build `s2arr`, which takes $O(l_1)$ time (since we process $l_1$ characters for each substring in $s_2$).\n\n  In the `matches` function, we iterate through `s1arr` to compare it with `s2arr`. This takes $O(26) = O(1)$, as the alphabet size is constant (26 characters). Thus, checking equality of the two maps involves a constant-time comparison for each character in the alphabet.\n\n  Thus, the total time complexity becomes: $O(l_1 + (26 + l_1) \\cdot (l_2 - l_1))$.\n\n* Space complexity: $O(l_2 - l_1)$\n  \n  Each substring from $s_2$ of length $l_1$ creates a array (`s2arr`) to store the character frequencies.\n\n  The size of this array is $O(26)$, since there are at most 26 characters in the alphabet.\n  \n  Over $l_2 - l_1 + 1$ iterations of the outer loop, we create one such array per iteration, resulting in $O(26 \\cdot (l_2 - l_1 + 1))$ space usage.\n\n  We also create a array for $s_1$ (`s1arr`), which similarly takes $O(26)$ space.\n  \n  Since we need to store a array for each of the $l_2 - l_1 + 1$ substrings in the worst case, the space complexity is proportional to the number of substrings and the size of each array. \n  \n  Therefore, the total space complexity is: $O(26 \\cdot (l_2 - l_1 + 1) + 26) = O(26 \\cdot (l_2 - l_1 + 1))$. In simplified terms: $O(l_2 - l_1)$\n\n---\n### Approach 5: Sliding Window  [Accepted]:\n\n**Algorithm**\n\nInstead of building a new hashmap from scratch for every window we check in $$s2$$, we can just set up a fixed-size array of length 26 once for the first window in $$s2$$. Then, as we slide the window over, we can simply update it. Basically, weâ€™ll remove the character that's no longer in the window and add the new one thatâ€™s now part of it. So, the array gets tweaked only at the two spots related to those two characters. Each time we update the array, we just compare all the elements to check if everything matches up for the result we want.\n\n**Implementation****Complexity Analysis**\n   \nLet $$l_1$$ be the length of string $$s_1$$ and $$l_2$$ be the length of string $$s_2$$.\n\n* Time complexity: $O(l_1 + 26 \\cdot (l_2 - l_1)) = O(l_1 + (l_2 - l_1)) = O(l_2)$\n\n  The loop that populates two frequency arrays runs for $l_1$ iterations, as it processes all characters in $s_1$ and the first $l_1$ characters in $s_2$. This step takes $O(l_1)$ time.\n\n  The outer loop runs $l_2 - l_1$ times, sliding the window of size $l_1$ across $s_2$. For each iteration, two operations are performed:\n     - Increment the count of the new character added to the window (`s2arr[s2.charAt(i + l_1) - 'a']++`).\n     - Decrement the count of the character leaving the window (`s2arr[s2.charAt(i) - 'a']--`).\n  Both of these operations are constant-time, $O(1)$, for each iteration since the arrays are of fixed size (26). Thus, the time complexity for this part is $O(l_2 - l_1)$.\n\n  The `matches` function compares the two arrays element by element, which takes $O(26) = O(1)$ time because the arrays have a fixed size of 26.\n \n  Combining the preprocessing and sliding window steps, the total time complexity is: $O(l_1 + 26 \\cdot (l_2 - l_1))$\n\n  Since $26$ is a constant, this simplifies to: $O(l_1 + (l_2 - l_1)) = O(l_2)$\n\n* Space complexity: $O(26 + 26) = O(1)$\n  \n  Two arrays, `s1arr` and `s2arr`, are used to store character frequencies. Each array has a fixed size of 26, regardless of the lengths of $s_1$ and $s_2$. Therefore, the space used for these arrays is $O(26 + 26) = O(52) = O(1)$.\n\n  No other data structures that depend on the size of $s_1$ or $s_2$ are used. The space required is constant, independent of the input size.\n\n  Thus, the total space complexity is: $O(1)$\n\n---\n### Approach 6: Optimized Sliding Window [Accepted]:\n\n**Algorithm**\n\nThe last approach can be optimized, if instead of comparing all the elements of the `s1arr` for every updated `s2arr` corresponding to every window of $$s2$$ considered, we keep a track of the number of elements which were already matching in the `s1arr` and update just the count of matching elements when we shift the window towards the right.\n\nTo do so, we maintain a `count` variable, which stores the number of characters(out of the 26 alphabets), which have the same frequency of occurence in $$s1$$ and the current window in $$s2$$. When we slide the window, if the deduction of the last element and the addition of the new element leads to a new frequency match of any of the characters, we increment the `count` by 1. If not, we keep the `count` intact. But, if a character whose frequency was the same earlier(prior to addition and removal) is added, it now leads to a frequency mismatch which is taken into account by decrementing the same `count` variable. If, after the shifting of the window, the `count` evaluates to 26, it means all the characters match in frequency totally. So, we return a True in that case immediately.\n\n**Implementation****Complexity Analysis**\n\nLet $$l_1$$ be the length of string $$s_1$$ and $$l_2$$ be the length of string $$s_2$$.\n\n* Time complexity: $O(l_1 + (l_2 - l_1)) \\approx O(l_2)$\n\n  Populating `s1arr` and `s2arr` takes $O(l_1)$ time since we iterate over the first $l_1$ characters of both strings.\n\n  The outer loop runs $l_2 - l_1$ times. In each iteration, we update two characters (one entering and one leaving the window) in constant time $O(1)$, and we maintain a count of matches. This step takes $O(l_2 - l_1)$.\n\n  Checking if `count == 26` also happens in $O(1)$, since it's a constant comparison.\n\n  Thus, the total time complexity is: $O(l_1 + (l_2 - l_1)) \\approx O(l_2)$\n\n* Space complexity: $$O(1)$$\n  \n  Two fixed-size arrays (`s1arr` and `s2arr`) of size 26 are used for counting character frequencies. No additional space that grows with the input size is used."
}