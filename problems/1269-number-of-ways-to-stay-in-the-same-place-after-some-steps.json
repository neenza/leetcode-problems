{
  "title": "Number of Ways to Stay in the Same Place After Some Steps",
  "problem_id": "1398",
  "frontend_id": "1269",
  "difficulty": "Hard",
  "problem_slug": "number-of-ways-to-stay-in-the-same-place-after-some-steps",
  "topics": [
    "Dynamic Programming"
  ],
  "description": "You have a pointer at index 0 in an array of size arrLen. At each step, you can move 1 position to the left, 1 position to the right in the array, or stay in the same place (The pointer should not be placed outside the array at any time).\nGiven two integers steps and arrLen, return the number of ways such that your pointer is still at index 0 after exactly steps steps. Since the answer may be too large, return it modulo 109 + 7.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: steps = 3, arrLen = 2\nOutput: 4\nExplanation: There are 4 differents ways to stay at index 0 after 3 steps.\nRight, Left, Stay\nStay, Right, Left\nRight, Stay, Left\nStay, Stay, Stay",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input: steps = 2, arrLen = 4\nOutput: 2\nExplanation: There are 2 differents ways to stay at index 0 after 2 steps\nRight, Left\nStay, Stay",
      "images": []
    },
    {
      "example_num": 3,
      "example_text": "Input: steps = 4, arrLen = 2\nOutput: 8",
      "images": []
    }
  ],
  "constraints": [
    "1 <= steps <= 500",
    "1 <= arrLen <= 106"
  ],
  "follow_ups": [],
  "hints": [
    "Try with Dynamic programming, dp(pos,steps): number of ways to back pos = 0 using exactly \"steps\" moves.",
    "Notice that the computational complexity does not depend of \"arrlen\"."
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    int numWays(int steps, int arrLen) {\n        \n    }\n};",
    "java": "class Solution {\n    public int numWays(int steps, int arrLen) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def numWays(self, steps, arrLen):\n        \"\"\"\n        :type steps: int\n        :type arrLen: int\n        :rtype: int\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def numWays(self, steps: int, arrLen: int) -> int:\n        ",
    "c": "int numWays(int steps, int arrLen) {\n    \n}",
    "csharp": "public class Solution {\n    public int NumWays(int steps, int arrLen) {\n        \n    }\n}",
    "javascript": "/**\n * @param {number} steps\n * @param {number} arrLen\n * @return {number}\n */\nvar numWays = function(steps, arrLen) {\n    \n};",
    "typescript": "function numWays(steps: number, arrLen: number): number {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param Integer $steps\n     * @param Integer $arrLen\n     * @return Integer\n     */\n    function numWays($steps, $arrLen) {\n        \n    }\n}",
    "swift": "class Solution {\n    func numWays(_ steps: Int, _ arrLen: Int) -> Int {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun numWays(steps: Int, arrLen: Int): Int {\n        \n    }\n}",
    "dart": "class Solution {\n  int numWays(int steps, int arrLen) {\n    \n  }\n}",
    "golang": "func numWays(steps int, arrLen int) int {\n    \n}",
    "ruby": "# @param {Integer} steps\n# @param {Integer} arr_len\n# @return {Integer}\ndef num_ways(steps, arr_len)\n    \nend",
    "scala": "object Solution {\n    def numWays(steps: Int, arrLen: Int): Int = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn num_ways(steps: i32, arr_len: i32) -> i32 {\n        \n    }\n}",
    "racket": "(define/contract (num-ways steps arrLen)\n  (-> exact-integer? exact-integer? exact-integer?)\n  )",
    "erlang": "-spec num_ways(Steps :: integer(), ArrLen :: integer()) -> integer().\nnum_ways(Steps, ArrLen) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec num_ways(steps :: integer, arr_len :: integer) :: integer\n  def num_ways(steps, arr_len) do\n    \n  end\nend"
  },
  "solution": "[TOC]\n\n## Solution\n\n---\n\n### Approach 1: Top-Down Dynamic Programming\n\n**Intuition**\n\n> **Note.** For this approach, we assume that you already know the fundamentals of dynamic programming and are figuring out how to apply it to a wide range of problems, such as this one. If you are not yet at this stage, we recommend checking out our relevant [Explore Card content on dynamic programming](https://leetcode.com/explore/featured/card/dynamic-programming/) before coming back to this problem.\n\nLet's imagine that we are positioned on a number line. This number line starts at `0` and ends at `arrLen - 1` (since `arrLen` is 0-indexed). We start at `0` on this number line, and on each move we are allowed to move left, right, or stay.\n\nWe start at `0`, need to make `steps` moves, and want to end up back at `0`. Without loss of generality, let's say we are currently at `curr` on the number line and need to make `remain` more moves. We have three options:\n\n1. Don't move. We will stay at `curr` and need to make `remain - 1` more moves.\n2. Move left. We can only do this if `curr > 0`. We move to `curr - 1` and need to make `remain - 1` more moves.\n3. Move right. We can only do this if `curr < arrLen - 1`. We move to `curr + 1` and need to make `remain - 1` more moves.\n\nLet's define a function `dp(curr, remain)` that returns the number of ways we can arrive at `0` from `curr` after `remain` moves. If we want to go back to `0`, we can only do so through one of these three options. In other words, the number of ways to return to `0` from the current state is equivalent to the sum of the number of ways to return to `0` in the next three options. We have the following transitions:\n\n1. `dp(curr, remain) += dp(curr, remain - 1)`\n2. `dp(curr, remain) += dp(curr - 1, remain - 1) if curr > 0`\n3. `dp(curr, remain) += dp(curr + 1, remain - 1) if curr < arrLen - 1>`\n\nWhat will be the base case of this function? If `remain = 0`, we have no more moves to make. If `curr = 0`, then we have found a way to accomplish our task, so we `return 1`. Otherwise, we return `0`.\n\nThis recursive approach will solve the problem, but will have an exponential time complexity as each call to `dp` creates three more calls. Many states of `curr, remain` will be repeated. In the below tree, each node represents a call to `dp` with the first number being `curr` and the second one being `steps`. Nodes with the same color represent the same arguments. With larger values of `steps` and `arrLen`, the tree will quickly grow beyond what we can compute.\n\n![img](../Figures/1269/1.png)To prevent repeated computation, we will memoize the `dp` function. Using a data structure `memo`, the first time we find the answer for a state `curr, remain`, we will save it in `memo`. In the future when we see the same `curr, remain` state again, we can refer to `memo` instead of having to re-calculate. With memoization, the tree now looks like this:\n\n![img](../Figures/1269/2.png)If we want to use a 2D array to implement `memo`, we must be careful with the sizing. Notice in the constraints that while `steps` can be up to `500`, `arrLen` can be up to $$10^6$$. However, it is impossible for any call to have a value of `curr` greater than `steps`. The furthest we can go is by only making moves to the right, but we would run out of moves after `steps` moves. Thus, we can safely perform `arrLen = min(arrLen, steps)` before starting the algorithm.\n\nThe answer to the original problem is `dp(0, steps)`. We start at `0` and need to make `steps` moves.\n \n**Algorithm**\n\nAll arithmetic operations should be done mod $$10^9 + 7$$.\n\n1. Create a memoized function `dp(curr, remain)`:\n    - If `remain == 0`:\n        - Return `1` if `curr == 0`, and `0` otherwise.\n    - Initialize `ans = dp(curr, remain - 1)`.\n    - If `curr > 0`, add `dp(curr - 1, remain - 1)` to `ans`.\n    - If `curr < arrLen - 1`, add `dp(curr + 1, remain - 1)` to `ans`.\n    - Return `ans`.\n2. Set `arrLen = min(arrLen, steps)`.\n3. Return `dp(0, steps)`.\n\nTo memoize `dp`:\n\n1. After the base case, check if `curr, remain` has already been calculated using a data structure `memo`.\n    - If it has already been calculated, return the saved result.\n2. Before returning `ans`, store `ans` in `memo` while associating it with `curr, remain`.\n\n**Implementation**\n\n> In Python, we use [@functools.cache](https://docs.python.org/3/library/functools.html#functools.cache) to memoize our function.**Complexity Analysis**\n\nGiven $$n$$ as `steps` and $$m$$ as `arrLen`,\n\n* Time complexity: $$O(n \\cdot \\min{(n, m)})$$\n\n    There can be `steps` values of `remain` and `min(steps, arrLen)` values of `curr`. The reason `curr` is limited by `steps` is because if we were to only move right, we would eventually run out of moves. Thus, there are $$O(n \\cdot \\min{(n, m)})$$ states of `curr, remain`. Due to memoization, we never calculate a state more than once. To calculate a given state costs $$O(1)$$ as we are simply adding up three options.\n\n* Space complexity: $$O(n \\cdot \\min{(n, m)})$$\n\n    The recursion call stack uses up to $$O(n)$$ space, but this is dominated by `memo` which has a size of $$O(n \\cdot \\min{(n, m)})$$.---\n\n### Approach 2: Bottom-Up Dynamic Programming\n\n**Intuition**\n\nThe \"answer state\" is `curr = 0, remain = steps`. In the previous approach, we started by making a call to `dp(0, steps)` and made function calls down to the base case. In this approach, we will start at the base case and iterate toward the answer state.\n\nTo implement this iterative algorithm, we will convert `dp` from a function to an array. Here, `dp[curr][remain]` is analogous to `dp(curr, remain)` from the previous approach.\n\nFirst, we need to size `dp`. The first dimension needs to be the range of `curr`. As the number line has a limit of `arrLen - 1`, the first dimension of `dp` should have a size of `arrLen`. As we mentioned briefly in the previous approach, the value of `arrLen` can be reduced to `min(arrLen, steps)`. Larger values of `arrLen` (greater than `steps`) are pointless because we could not reach those states due to running out of `steps`. The second dimension of `dp` needs to be the range of `remain`. As the maximum value of `remain` is `steps`, the second dimension of `dp` should have a size of `steps + 1`. Thus, dp will have a size of `arrLen * (steps + 1)` (after we update `arrLen = min(arrLen, steps)`).\n\nSecond, we need to initialize the base case. Assuming `dp` is initialized with values of `0`, the only non-zero base case is when `curr = 0, remain = 0`, the answer is `1`. Thus, we will set `dp[0][0] = 1`.\n\nThird, we need to configure our for-loops. We will use nested for-loops to iterate over all states of `curr, remain`. We must iterate starting from the base case. Thus, our first loop will be over `remain` starting at `1` and ending at `steps`. Our second loop will be over `curr` starting at `arrLen - 1` and ending at `0`.\n\n> Generally, you want the final loop iteration to calculate the final answer. As our answer state is `curr = 0, remain = steps`, we have the loop for `remain` end at `steps` and the loop for `curr` end at `0`.\n\nFinally, each inner loop iteration represents a state `curr, remain`. We will calculate its value `dp[curr][remain]` just like we did in the previous approach by considering the three options:\n\n1. Don't move. Add `dp[curr][remain - 1]`.\n2. Move left. We can only do this if `curr > 0`. Add `dp[curr - 1][remain - 1]`.\n3. Move right. We can only do this if `curr < arrLen - 1`. Add `dp[curr + 1][remain - 1]`.\n\nThe answer to the original problem is `dp[0][steps]`. We return this value at the end.\n\n**Algorithm**\n\nAll arithmetic operations should be done mod $$10^9 + 7$$.\n\n1. Set `arrLen = min(arrLen, steps)`.\n2. Create an array `dp[arrLen][steps + 1]`.\n3. Set `dp[0][0] = 1`, the base case.\n4. Iterate `remain` from `1` to `steps`:\n    - Iterate `curr` from `arrLen - 1` to `0`:\n        - Initialize `ans = dp[curr][remain - 1]`.\n        - If `curr > 0`, add `dp[curr - 1][remain - 1]` to `ans`.\n        - If `curr < arrLen - 1`, add `dp[curr + 1][remain - 1]` to `ans`.\n        - Set `dp[curr][remain] = ans`.\n5. Return `dp[0][steps]`.\n\n**Implementation****Complexity Analysis**\n\nGiven $$n$$ as `steps` and $$m$$ as `arrLen`,\n\n* Time complexity: $$O(n \\cdot \\min{(n, m)})$$\n\n    Our nested for-loops iterate over $$O(n \\cdot \\min{(n, m)})$$ states of `curr, remain`. Calculating each state is done in $$O(1)$$.\n\n* Space complexity: $$O(n \\cdot \\min{(n, m)})$$\n\n    `dp` has a size of $$O(n \\cdot \\min{(n, m)})$$.---\n\n### Approach 3: Space-Optimized Dynamic Programming\n\n**Intuition**\n\nYou may notice that in the previous two approaches, to calculate a state `curr, remain`, we only needed states involving `remain - 1`. For example, if we wanted to calculate `dp[4][6]`, we only needed values of `dp[...][5]`. Values stored in `dp[...][4], dp[...][3], dp[...][2]`, etc. are no longer required.\n\nAs we iterate over `remain` using the outer for-loop, we only need to store values of `dp` for the current value of `remain` and the previous value `remain - 1`. We will use two arrays of size `arrLen` to do this: `dp` and `prevDp`.\n\nHere, `dp[curr]` is analogous to `dp[curr][remain]` from the previous approach. `prevDp[curr]` is analogous to `dp[curr][remain - 1]` from the previous approach.\n\nAs the first value of `remain = 1`, this means initially, `prevDp` represents values for `remain = 0`. This means we must initialize `prevDp[0]`, as this is our base case `curr = 0, remain = 0`.\n\nAt the beginning of each outer for-loop iteration, we will reset `dp`. We will then calculate `dp` using values from `prevDp`. Once we have finished calculating `dp`, we will update `prevDp = dp`, so that in the next iteration, `prevDp` will represent the correct values.\n\nFor example, when `remain = 5`:\n\n1. `dp[curr]` represents `dp[curr][5]` from the previous approach. We calculate it using `prevDp`, where `prevDp[curr]` represents `prevDp[curr][4]` from the previous approach.\n2. Once we finish calculating `dp`, the next for-loop iteration has `remain = 6`, and now `prevDp` must represent values of `remain = 5`.\n3. This is why we update `prevDp = dp`, since we just calculated `dp` to have the values for `remain = 5`.\n\nThe final value we have in our for-loop over `remain` is `steps`. Thus, the final calculated `dp` will represent values for `remain = steps`. We can simply return `dp[0]`, which represents `dp[0][steps]` from the previous approach, our answer state.\n\n**Algorithm**\n\nAll arithmetic operations should be done mod $$10^9 + 7$$.\n\n1. Set `arrLen = min(arrLen, steps)`.\n2. Create an array `dp[arrLen]` and an array `prevDp[arrLen]`.\n3. Set `prevDp[0] = 1`, the base case.\n4. Iterate `remain` from `1` to `steps`:\n    - Reset `dp`.\n    - Iterate `curr` from `arrLen - 1` to `0`:\n        - Initialize `ans = prevDp[curr]`.\n        - If `curr > 0`, add `prevDp[curr - 1]` to `ans`.\n        - If `curr < arrLen - 1`, add `prevDp[curr + 1]` to `ans`.\n        - Set `dp[curr] = ans`.\n    - Update `prevDp = dp`.\n5. Return `dp[0]`.\n\n**Implementation****Complexity Analysis**\n\nGiven $$n$$ as `steps` and $$m$$ as `arrLen`,\n\n* Time complexity: $$O(n \\cdot \\min{(n, m)})$$\n\n    Our nested for-loops iterate over $$O(n \\cdot \\min{(n, m)})$$ states of `curr, remain`. Calculating each state is done in $$O(1)$$.\n\n* Space complexity: $$O(\\min{(n, m)})$$\n\n    `dp` and `prevDp` have a size of $$O(\\min{(n, m)})$$.---"
}